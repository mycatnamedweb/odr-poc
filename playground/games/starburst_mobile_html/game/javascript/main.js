Sys.ns("Core");
Core.StateHandler = {
    constructor: function() {
        var a = this;
        Core.StateHandler.superclass.constructor.apply(a, arguments);
        a.useLogging = false;
        a.states = window.GenericStates || {};
        a.stateStack = [];
        a.runningStateMachine = false
    },
    registerEvents: function(c) {
        var d = this,
            b = c.length,
            a;
        if (Sys.isArray(c)) {
            for (a = -1; ++a < b;) {
                d.addListener(c[a], d.onDefaultEventHandler.bind(d, c[a]))
            }
        } else {
            if (typeof c === "string") {
                d.addListener(c, d.onDefaultEventHandler.bind(d, c))
            }
        }
    },
    onDefaultEventHandler: function(a) {
        this.dispatchEvent(a);
        this.activateStateMachine()
    },
    initStateHandler: function() {
        var b = this,
            a;
        Sys.iterate(window.GenericStates || {}, function(c, d) {
            b._registerTrigger(d)
        });
        EventHandler.sortEventListeners(this);
        a = Resources.readData("gameServerInitResponse");
        if (a.restore !== true) {
            this.pushState(this.states.idle)
        }
        this.pushState(this.states.beforeLoaderClose);
        this.pushState(this.states.setupGame);
        this.activateStateMachine()
    },
    activateStateMachine: function() {
        var a = this,
            b;
        if (a.runningStateMachine) {
            return
        }
        a.runningStateMachine = true;
        while (a.hasStatesInStack()) {
            if (!Sys.isEmpty(a.currentState)) {
                for (b in a.currentState.waitEvents) {
                    if (a.currentState.waitEvents.hasOwnProperty(b) && !a.currentState.waitEvents[b]) {
                        a.runningStateMachine = false;
                        return
                    }
                }
                setTimeout(a.leaveCurrentState.bind(a), 1);
                return
            }
            a.currentState = a.stateStack.pop();
            a.currentState.execute({
                stateHandler: a,
                states: a.states
            });
            a.processModuleQueue();
            if (Sys.isDefined(a.currentState.executeLast)) {
                a.currentState.executeLast({
                    stateHandler: a,
                    states: a.states
                })
            }
            a.fireEvent("notify:stateHandler.entering" + a.currentState.name + "State")
        }
        a.runningStateMachine = false
    },
    leaveCurrentState: function() {
        var a = this;
        a.fireEvent("notify:stateHandler.leaving" + a.currentState.name + "State");
        a.currentState = undefined;
        a.runningStateMachine = false;
        a.activateStateMachine()
    },
    processModuleQueue: function() {
        var c = this,
            a = Game.moduleLoader.getModuleQueueForState(c.currentState.name),
            d = a.length,
            b;
        for (b = 0; b < d; b++) {
            a[b]({
                stateHandler: c,
                states: c.states
            })
        }
    },
    addState: function(a, b) {
        if (!Sys.isDefined(this.states[a])) {
            this.states[a] = b;
            this._registerTrigger(b)
        }
    },
    _registerTrigger: function(a) {
        if (Sys.isDefined(Services.trigger)) {
            Services.trigger.registerTrigger("notify:stateHandler.entering" + a.name + "State", this, "When entering the state " + a.name);
            Services.trigger.registerTrigger("notify:stateHandler.leaving" + a.name + "State", this, "When leaving the state " + a.name)
        }
    },
    pushState: function(a) {
        var b;
        if (this.stateStack.indexOf(a) > -1) {
            return
        }
        for (b in a.waitEvents) {
            if (a.waitEvents.hasOwnProperty(b)) {
                a.waitEvents[b] = false
            }
        }
        this.stateStack.push(a)
    },
    dispatchEvent: function(b) {
        var a = this;
        if (!Sys.isEmpty(a.currentState) && !Sys.isEmpty(a.currentState.waitEvents[b])) {
            a.currentState.waitEvents[b] = true
        }
        Sys.each(a.stateStack, function(c) {
            if (!Sys.isEmpty(c.waitEvents[b])) {
                c.waitEvents[b] = true
            }
        })
    },
    dumpStack: function(d) {
        var c = this,
            f = "",
            e, a, b;
        if (c.useLogging) {
            if (!this.currentState) {} else {
                e = d;
                Sys.each(Object.getOwnPropertyNames(this.currentState.waitEvents), function(g) {
                    a = c.currentState.waitEvents[g] ? "*" : " ";
                    f += "\n\t\t(" + a + ") " + g.replace(/\s/g, "")
                });
                e += "\nCurrent state:\t" + this.currentState.name + f;
                for (b = this.stateStack.length - 1; b >= 0; b--) {
                    e += "\n\t" + this.stateStack[b].name
                }
            }
        }
    },
    hasStates: function() {
        return Object.keys(this.states).length > 0
    },
    hasStatesInStack: function() {
        return this.stateStack.length > 0
    },
    isRunning: function() {
        return this.runningStateMachine
    }
};
Core.StateHandler = Sys.extend(Sys.Observable, Core.StateHandler, "Core.StateHandler");
window.GenericStates = {
    beforeLoaderClose: {
        name: "BeforeLoaderClose",
        execute: function() {},
        waitEvents: {}
    },
    setupGame: {
        name: "SetupGame",
        execute: function() {},
        waitEvents: {}
    },
    idle: {
        name: "Idle",
        execute: function(a) {},
        waitEvents: {}
    }
};
Sys.ns("Core");
Core.ModuleLoader = {
    constructor: function(a) {
        Core.ModuleLoader.superclass.constructor.apply(this, arguments);
        this.init(a)
    },
    getModuleQueueForState: function(b) {
        var a = this.stateOrder[b];
        if (Sys.isDefined(a)) {
            return a
        }
        return []
    },
    init: function(a) {
        var c = this,
            b = Resources.readData("modules");
        c.stateHandler = a.stateHandler;
        c.stateOrder = c.getCommonStateOrder();
        c.addGameSpecificStateOrder();
        c.loadModules(b);
        c.updateStates();
        c.cleanStateQueue();
        c.fireEvent("notify:moduleLoader.finishedLoadingModules")
    },
    loadModules: function(d) {
        var c = this,
            e = Environment.getCurrentPlatform(),
            b, a;
        c.modules = {};
        Sys.iterate(d, function(g, f) {
            b = (Sys.isArray(f.platforms) && f.platforms.indexOf(e) === -1);
            if (!Sys.isDefined(c.modules[g]) && !b) {
                a = c.getClassFromString(f.module);
                if (!Sys.isDefined(a) && f.optional === true) {
                    return
                }
                c.modules[g] = new a({
                    name: g,
                    model: c.getPlatformSpecificClass(f.model),
                    view: c.getPlatformSpecificClass(f.view),
                    controller: c.getClassFromString(f.controller)
                });
                if (typeof f.global === "string") {
                    if (!Sys.isDefined(window[f.global])) {
                        window[f.global] = {}
                    }
                    window[f.global][g] = c.modules[g].controller
                }
                c.applyMixins(c.modules[g], c.combineMixins(c.modules[g].getMixinDependencies(), f.mixins))
            }
        })
    },
    combineMixins: function(b, g) {
        var f = {},
            j, a, h, d, e, c, k = Environment.getCurrentPlatform();
        if (Sys.isArray(b)) {
            e = b;
            c = b.length
        } else {
            e = (b.hasOwnProperty(k)) ? b[k] : b.fallback;
            c = (e && e.length) || 0
        }
        for (d = -1; ++d < c;) {
            j = e[d];
            if (Sys.isObj(j)) {
                h = Object.keys(j)[0];
                a = j[h];
                f[h] = a
            } else {
                if (typeof j === "string") {
                    f[j] = undefined
                }
            }
        }
        if (Sys.isArray(g)) {
            c = g.length;
            for (d = -1; ++d < c;) {
                j = g[d];
                if (!Sys.isDefined(f[j])) {
                    f[j] = undefined
                }
            }
        }
        return f
    },
    applyMixins: function(a, h) {
        var d = ["controller", "model", "view"],
            n = Object.keys(h),
            g = n.length,
            c = d.length,
            m, k, b, l, f, e;
        for (f = -1; ++f < g;) {
            l = n[f];
            b = h[l] || {};
            m = Mixins[l];
            if (Sys.isDefined(m)) {
                for (e = -1; ++e < c;) {
                    k = d[e];
                    if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].methods)) {
                        this.applyMixinProperties(a[k], m[k].methods)
                    }
                }
                for (e = -1; ++e < c;) {
                    k = d[e];
                    if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].executeOnInstantiation)) {
                        this.executeMixinProperties(a[k], m[k].executeOnInstantiation, b)
                    }
                }
            }
        }
    },
    applyMixinProperties: function(f, a) {
        var d = Object.keys(a),
            e = d.length,
            c, b = 0;
        while (b < e) {
            c = d[b];
            if (!Sys.isDefined(f[c])) {
                f[c] = a[c]
            }++b
        }
    },
    executeMixinProperties: function(f, c, d) {
        var b = Object.keys(c),
            a = b.length,
            e = 0;
        while (e < a) {
            c[b[e]].call(f, d);
            ++e
        }
    },
    updateStates: function() {
        var b = this,
            a = b.modules,
            c = b.stateHandler.states;
        b.moduleQueues = {};
        Sys.iterate(a, function(d, f) {
            var e = f.getStateChanges();
            Sys.iterate(e, function(i, h) {
                var g = [];
                if (Sys.isDefined(h.state)) {
                    b.stateHandler.addState(i, h.state);
                    Sys.iterate(h.state.waitEvents, function(j) {
                        g.push(j)
                    });
                    if (g.length > 0) {
                        b.registerListenersOnStateHandler(f.controller, g)
                    }
                }
            })
        });
        Sys.iterate(a, function(d, f) {
            var e = f.getStateChanges();
            Sys.iterate(e, function(h, g) {
                if (!Sys.isDefined(g.state) && Sys.isDefined(c[h])) {
                    if (Sys.isArray(g.waitEvents)) {
                        Sys.each(g.waitEvents, function(i) {
                            c[h].waitEvents[i] = false
                        });
                        b.registerListenersOnStateHandler(f.controller, g.waitEvents)
                    }
                    if (Sys.isArray(g.queue)) {
                        b.updateModuleQueue(d, c[h].name, g.queue)
                    }
                }
            })
        })
    },
    registerListenersOnStateHandler: function(d, c) {
        var b = c.length,
            a;
        for (a = -1; ++a < b;) {
            if (!this.stateHandler.hasListener(c[a])) {
                this.stateHandler.registerEvents(c[a])
            }
        }
    },
    updateModuleQueue: function(c, e, a) {
        var d = this.stateOrder[e],
            b;
        if (Sys.isDefined(d)) {
            b = d.indexOf(c);
            if (b >= 0) {
                d.splice.apply(d, [b, 1].concat(a));
                this.stateOrder[e] = d
            } else {}
        } else {}
    },
    cleanStateQueue: function() {
        var a = this;
        Sys.iterate(a.stateOrder, function(d, b) {
            var c;
            for (c = 0; c < b.length; c++) {
                if (typeof b[c] === "string" || !Sys.isDefined(b[c])) {
                    b.splice(c, 1);
                    c--
                }
            }
        })
    },
    addGameSpecificStateOrder: function() {
        var d = this,
            c = d.stateOrder,
            b = Resources.readData("config"),
            a = b.stateOrder;
        if (Sys.isDefined(a)) {
            Sys.iterate(a, function(f, e) {
                Sys.each(e, function(h) {
                    var g;
                    if (!Sys.isDefined(c[f])) {
                        c[f] = h.modules
                    } else {
                        if (Sys.isDefined(h.insertBefore)) {
                            g = c[f].indexOf(h.insertBefore) + 1;
                            if (g < 0) {
                                c[f] = h.modules.concat(c[f])
                            } else {
                                c[f].splice.apply(c[f], [g, 0].concat(h.modules))
                            }
                        } else {
                            c[f].push.apply(c[f], h.modules)
                        }
                    }
                })
            })
        }
    },
    getClassFromString: function(c) {
        var d, b, a, e;
        if (typeof c === "string") {
            d = c.split(".");
            b = window;
            e = d.length;
            for (a = 0; a < e; a++) {
                if (Sys.isDefined(b)) {
                    b = b[d[a]]
                }
            }
            return b
        } else {
            if (typeof c === "function") {
                return c
            }
        }
        return undefined
    },
    getPlatformSpecificClass: function(c) {
        var b = this,
            a = c;
        if (Sys.isObj(a)) {
            if (b.isMVCSupported(a)) {
                a = b.getPlatformView(a)
            } else {}
        }
        return b.getClassFromString(a)
    },
    isMVCSupported: function(b) {
        var c = ["mobile", "mobileLow", "tablet", "tabletLow", "desktop"],
            a = true;
        Sys.iterate(b, function(e, d) {
            if (c.indexOf(e) < 0) {
                a = false
            }
        });
        return a
    },
    getPlatformView: function(a) {
        var b = Environment.getCurrentPlatform();
        if (b === "desktop" && !Sys.isDefined(a[b])) {
            b = "tablet"
        }
        if (b === "tablet" && !Sys.isDefined(a[b])) {
            b = "mobile"
        }
        if (b === "tabletLow" && !Sys.isDefined(a[b])) {
            b = "mobileLow"
        }
        if (b === "mobileLow" && !Sys.isDefined(a[b])) {
            b = "mobile"
        }
        return a[b]
    },
    getCommonStateOrder: function() {
        return {
            BeforeLoaderClose: ["stage"],
            Idle: ["playForRealPromo"]
        }
    }
};
Core.ModuleLoader = Sys.extend(Sys.Observable, Core.ModuleLoader, "Core.ModuleLoader");
Sys.ns("Core.Slots");
Core.Slots.ModuleLoader = {
    constructor: function(a) {
        Core.Slots.ModuleLoader.superclass.constructor.apply(this, arguments)
    },
    getCommonStateOrder: function() {
        return {
            SetupGame: ["blurredSymbols"],
            BeforeLoaderClose: ["freeSpinOutro", "spinTypeFreespin", "spinTypeRespin", "countDownFreespins", "freeSpinIntro", "bonusProgramWidget", "freeRounds", "disclaimer", "introMovie", "stage"],
            Idle: ["spin", "playForRealPromo", "customMessages"],
            Spinning: ["serverManager"],
            ProcessServerResponse: [],
            BeforeStopping: ["customMessages"],
            Stopping: ["spin"],
            Stopped: ["spinTypeRespin", "spinTypeBasic", "freeRounds", "realityCheck", "autoPlayer", "freeSpinOutro", "spinTypeFreespin", "g4", "freeSpinIntro", "freeSpinIntroMovie", "countDownFreespins", "additionalFreespins", "standardWin", "bigWin", "freeSpinSymbolAttentionAnimation", "stickySymbols", "spreadingWild"],
            FreeSpinIntro: ["freeRounds"],
            spinTypeRespinRestore: ["freeRounds"],
            NoWinPresentation: ["customMessages"]
        }
    }
};
Core.Slots.ModuleLoader = Sys.extend(Core.ModuleLoader, Core.Slots.ModuleLoader, "Core.Slots.ModuleLoader");
Sys.ns("Core");
Core.Heart = {
    constructor: function(a) {
        var b = this;
        Core.Heart.superclass.constructor.apply(b, arguments);
        b.pulse = 5000;
        b.pulseDelay = 1000;
        b.timeOutDelay = 2000;
        if (Sys.isDefined(a)) {
            b.pulse = a.pulse || b.pulse;
            b.pulseDelay = a.pulseDelay || b.pulseDelay
        }
        b.lastBeat = 0;
        b.flatlined = false;
        b.on({
            scope: b,
            "notify:loader.closed": b.init
        })
    },
    init: function() {
        this.revive()
    },
    flatline: function() {
        this.flatlined = true;
        clearTimeout(this.currentBeatTimeout)
    },
    revive: function() {
        this.flatlined = false;
        this.lastBeat = Date.now();
        this.beat()
    },
    beat: function() {
        var b = this,
            a = Date.now();
        if ((a - b.lastBeat) >= (b.pulse + b.pulseDelay)) {
            b.fireEvent("request:errorManager.handleGameInactive");
            this.flatline()
        }
        b.lastBeat = a;
        if (!b.flatlined) {
            clearTimeout(b.currentBeatTimeout);
            b.currentBeatTimeout = setTimeout(function() {
                b.beat()
            }, b.timeOutDelay)
        }
    }
};
Core.Heart = Sys.extend(Sys.Observable, Core.Heart, "Core.Heart");
Sys.ns("Mixins");
Mixins.orientation = {
    controller: {
        methods: {
            onPortrait: function() {
                this.view.onPortrait()
            },
            onLandscape: function() {
                this.view.onLandscape()
            }
        },
        executeOnInstantiation: {
            setupEvents: function() {
                this.on({
                    "notify:viewport.PORTRAIT": this.onPortrait,
                    "notify:viewport.LANDSCAPE": this.onLandscape
                })
            }
        }
    },
    view: {
        methods: {
            onPortrait: function() {
                this.adaptToOrientation("PORTRAIT");
                this.currentOrientation = "PORTRAIT"
            },
            onLandscape: function() {
                this.adaptToOrientation("LANDSCAPE");
                this.currentOrientation = "LANDSCAPE"
            },
            adaptToOrientation: function(a) {
                this.setSize(a);
                this.setPosition(a);
                this.setStyle(a)
            },
            setSize: function(c) {
                var f = this,
                    a = f.container,
                    g = Sys.isDefined(a) ? a.el.style : undefined,
                    j = f[c + "_SIZE"],
                    d, h, k = 0,
                    e = 0,
                    i, b;
                if (!Sys.isDefined(j) || !Sys.isDefined(a)) {
                    return
                }
                d = j.RELATIVE_SCREEN ? Utils.Platform.getViewportInnerSize() : Environment.determineResolution().resolution;
                h = j.RELATIVE_SCREEN ? 1 / Services.scaling.getScale() : 1;
                if (Sys.isDefined(j.HEIGHT)) {
                    i = Math.round(d.height * j.HEIGHT * h);
                    b = Sys.isDefined(j.WIDTH) ? Math.round(d.width * j.WIDTH * h) : Math.round(i * j.ASPECT_RATIO)
                } else {
                    b = Math.round(d.width * j.WIDTH * h);
                    i = Math.round(b / j.ASPECT_RATIO)
                }
                if (j.VERTICAL_OFFSET === "bottom") {
                    k = "-" + i + "px"
                } else {
                    if (j.VERTICAL_OFFSET === "center") {
                        k = "-" + Math.round(i / 2) + "px"
                    }
                }
                if (j.HORIZONTAL_OFFSET === "right") {
                    e = "-" + b + "px"
                } else {
                    if (j.HORIZONTAL_OFFSET === "center") {
                        e = "-" + Math.round(b / 2) + "px"
                    }
                }
                g.width = b + "px";
                g.height = i + "px";
                g.backgroundSize = b + "px " + i + "px";
                g.margin = k + " 0 0 " + e
            },
            setPosition: function(c) {
                var h = this,
                    e = h[c + "_POSITION"],
                    j, i, f, b, g, d, a;
                if (!Sys.isDefined(e) || !Sys.isDefined(h.container)) {
                    return
                }
                j = h.container.el.style;
                if (Sys.isDefined(e.BOTTOM)) {
                    f = "BOTTOM";
                    b = "top";
                    a = "getBottom"
                } else {
                    f = "TOP";
                    b = "bottom";
                    a = "getTop"
                }
                if (Sys.isDefined(e.RIGHT)) {
                    g = "RIGHT";
                    d = "left"
                } else {
                    g = "LEFT";
                    d = "right"
                }
                if (e.BELOW_GAME) {
                    i = Environment[a + "BelowGame"](e[f])
                } else {
                    if (e.ABOVE_GAME) {
                        i = Environment[a + "AboveGame"](e[f])
                    } else {
                        i = Environment[a + "InGame"](e[f])
                    }
                }
                if (e["MIN_" + f]) {
                    i = Math.max(e["MIN_" + f], i)
                }
                j[f.toLowerCase()] = i + "px";
                j[b] = "auto";
                j[g.toLowerCase()] = (100 * e[g]) + "%";
                j[d] = "auto"
            },
            setStyle: function(a) {
                var c = this,
                    d = a + "_CSS",
                    b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
                if (c.container && c[d]) {
                    c.container.removeCls(c[b]);
                    c.container.addCls(c[d])
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.userInput = {
    controller: {
        methods: {
            startListeningToUserInput: function() {
                this.on(this.USED_INPUT_HANDLERS);
                this.isListeningToUserInput = true
            },
            stopListeningToUserInput: function() {
                var a = this;
                Sys.iterate(a.USED_INPUT_HANDLERS, a.removeListener.bind(a));
                a.isListeningToUserInput = false
            },
            onUserInputStart: function() {},
            onUserInputEnd: function() {},
            onUserInputMove: function() {},
            onUserInputHover: function() {},
            onUserInputCanceled: function() {},
            onUserInputScroll: function() {},
            onUserInputKeyUp: function() {},
            onUserInputKeyDown: function() {},
            isUserInputInSegment: function(b, a) {
                Sys.UserInputUtils.isUserInputInSegment(b, a)
            }
        },
        executeOnInstantiation: {
            init: function(c) {
                var d = this,
                    e = Sys.isDefined(c.inputEvents) ? c.inputEvents : ["start", "end", "cancel", "move"],
                    a = {},
                    b;
                for (b = 0; b < e.length; b++) {
                    switch (e[b]) {
                        case "start":
                            a["notify:userInputManager.userInputStarted"] = d.onUserInputStart;
                            break;
                        case "end":
                            a["notify:userInputManager.userInputEnded"] = d.onUserInputEnd;
                            break;
                        case "move":
                            a["notify:userInputManager.userInputMove"] = d.onUserInputMove;
                            break;
                        case "hover":
                            a["notify:userInputManager.userInputHover"] = d.onUserInputHover;
                            break;
                        case "cancel":
                            a["notify:userInputManager.userInputCanceled"] = d.onUserInputCanceled;
                            break;
                        case "scroll":
                            a["notify:userInputManager.userInputScroll"] = d.onUserInputScroll;
                            break;
                        case "keyUp":
                            a["notify:userInputManager.userInputKeyUp"] = d.onUserInputKeyUp;
                            break;
                        case "keyDown":
                            a["notify:userInputManager.userInputKeyDown"] = d.onUserInputKeyDown;
                            break;
                        default:
                    }
                }
                d.USED_INPUT_HANDLERS = a;
                if (c.listenToUserInput) {
                    d.startListeningToUserInput()
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.waitSequence = {
    controller: {
        methods: {
            initializeWaitSequence: function(c, a) {
                var b = this;
                b.clearWaitSequence();
                b.waiting = true;
                if (Sys.isDefined(c)) {
                    b.fireEvent(c, a);
                    b.checkForCompletion()
                }
            },
            clearWaitSequence: function() {
                var a = this;
                Sys.each(a.eventsToWaitFor, a.removeWaitEventListener.bind(a));
                a.eventsToWaitFor.length = 0;
                a.waiting = false
            },
            removeWaitEventListener: function(a) {
                if (Sys.isDefined(this.customListeners[a])) {
                    this.removeListener(a);
                    delete this.customListeners[a]
                }
            },
            checkForCompletion: function() {
                if (this.eventsToWaitFor.length === 0) {
                    this.onWaitIsComplete();
                    this.waiting = false
                }
            },
            onWaitRequested: function(a) {
                var b = this,
                    c;
                if (b.waiting && !b.eventsToWaitFor.contains(a)) {
                    if (!Sys.isDefined(b.events[a]) && !Sys.isDefined(b.handlers[a])) {
                        c = b.onWaitEventReceived.bind(b, a);
                        b.addListener(a, c, b);
                        b.customListeners[a] = c
                    }
                    b.eventsToWaitFor.push(a)
                }
            },
            onWaitEventReceived: function(a) {
                var c = this,
                    b = c.eventsToWaitFor.indexOf(a);
                if (b >= 0) {
                    c.eventsToWaitFor.splice(b, 1);
                    c.removeWaitEventListener(a)
                }
                c.checkForCompletion()
            },
            onWaitIsComplete: function() {}
        },
        executeOnInstantiation: {
            initialize: function() {
                var a = this;
                a.eventsToWaitFor = [];
                a.waiting = false;
                a.customListeners = {};
                if (!Sys.isDefined(a.events)) {
                    a.events = {}
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.properties = {
    model: {
        methods: {
            hasProperty: function(b) {
                var a = this.readData("properties")[b];
                return Sys.isDefined(a) && a.length > 0
            },
            addProperty: function(c, b) {
                var a = this.readData("properties");
                if (!Sys.isDefined(a[c])) {
                    a[c] = [b]
                } else {
                    if (!a[c].contains(b)) {
                        a[c].push(b)
                    }
                }
                this.storeData("properties", a)
            },
            removeProperty: function(c, b) {
                var a = this.readData("properties")[c];
                if (Sys.isDefined(a) && a.contains(b)) {
                    a.splice(a.indexOf(b), 1)
                }
            }
        }
    },
    controller: {
        executeOnInstantiation: {
            setupEvents: function(a) {
                var c = this,
                    b = this.model.PROPERTIES || {},
                    d = {
                        "view:addProperty": c.addProperty,
                        "view:removeProperty": c.removeProperty
                    };
                c.model.storeData("properties", b);
                d["request:" + c.MODULE_NAME + ".addProperty"] = c.addProperty;
                d["request:" + c.MODULE_NAME + ".removeProperty"] = c.removeProperty;
                c.on(d);
                if (Sys.isDefined(a) && a.updateOnStartup === true) {
                    c.updateAppearance()
                }
            }
        },
        methods: {
            addProperty: function(c, b) {
                var a = !this.model.hasProperty(c);
                this.model.addProperty(c, b);
                if (a) {
                    this.updateAppearance()
                }
            },
            updateAppearance: function() {},
            removeProperty: function(c, b) {
                var a = this;
                if (a.model.hasProperty(c)) {
                    a.model.removeProperty(c, b);
                    if (!a.model.hasProperty(c)) {
                        a.updateAppearance()
                    }
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.trigger = {
    controller: {
        methods: {
            registerTriggers: function(a) {
                throw new Error("Abstract method! Must be implemented!")
            },
            onTriggerReady: function() {
                this.registerTriggers(Services.trigger)
            }
        },
        executeOnInstantiation: {
            setupEvents: function() {
                this.on({
                    "notify:trigger.ready": this.onTriggerReady
                })
            }
        }
    }
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseGetter = {
    platforms: ["desktop", "mobile"],
    isAvailable: function() {
        return true
    },
    validateNumArguments: function() {
        return arguments.length === 3
    },
    validateArguments: function() {
        return true
    },
    func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseSetter = {
    platforms: ["desktop", "mobile"],
    isAvailable: function(a) {
        return this.model.readData("inIdleState") && Services.settingsManager.isSettable(a)
    },
    validateNumArguments: function() {
        return arguments.length === 4
    },
    validateArguments: function() {
        return true
    },
    func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseCall = {
    platforms: ["desktop", "mobile"],
    isAvailable: function() {
        return this.model.readData("inIdleState") && !Services.storage.readData("dialog.showing")
    },
    validateNumArguments: function() {
        return arguments.length === 3
    },
    validateArguments: function() {
        return true
    },
    func: function() {}
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Getters = {
    balanceInCurrency: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                b = Services.moneyManager,
                a = b.getBalanceCents(),
                e = b.formatMoneyCurrencySign(a),
                c = Array.prototype.slice.call(arguments),
                f = d.addParamsToArgument(c, e);
            d.success.apply(d, f)
        }
    }, NetEntExtend.API.BaseGetter),
    betInCurrency: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                a = Services.moneyManager,
                c = a.getBetCents(),
                e = a.formatMoneyCurrencySign(c),
                b = Array.prototype.slice.call(arguments),
                f = d.addParamsToArgument(b, e);
            d.success.apply(d, f)
        }
    }, NetEntExtend.API.BaseGetter),
    winInCurrency: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                a = Services.storage.readData("cashField.winInCents"),
                b = Services.moneyManager.formatMoneyCurrencySign(a),
                c = Array.prototype.slice.call(arguments),
                e = d.addParamsToArgument(c, b);
            d.success.apply(d, e)
        }
    }, NetEntExtend.API.BaseGetter),
    audio: Sys.applyPropertiesIf({
        func: function() {
            var b = this,
                d = Services.settingsManager.getSetting("volume") > 0,
                a = Array.prototype.slice.call(arguments),
                c = b.addParamsToArgument(a, d);
            b.success.apply(b, c)
        }
    }, NetEntExtend.API.BaseGetter),
    currentPlayMode: Sys.applyPropertiesIf({
        func: function() {
            var b = Services.storage.readData("playModeManager.modes"),
                a = Array.prototype.slice.call(arguments),
                c = this.addParamsToArgument(a, b);
            this.success.apply(this, c)
        }
    }, NetEntExtend.API.BaseGetter),
    autoplayNumberOfRoundsAvailable: Sys.applyPropertiesIf({
        func: function() {
            var c = this,
                a = c.autoplayNumberOfRoundsAvailable(),
                b = Array.prototype.slice.call(arguments),
                d = c.addParamsToArgument(b, a);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter),
    autoplayCurrentRoundsLeft: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                b = Services.storage.readData("autoPlayer.roundsLeft"),
                a = Sys.isDefined(b) && b > 0 ? b : null,
                c = Array.prototype.slice.call(arguments),
                e = d.addParamsToArgument(c, a);
            d.success.apply(d, e)
        }
    }, NetEntExtend.API.BaseGetter),
    paytableCount: Sys.applyPropertiesIf({
        func: function() {
            var a = Services.storage.readData("paytable.numberOfPages"),
                b = Array.prototype.slice.call(arguments),
                c = this.addParamsToArgument(b, a);
            this.success.apply(this, c)
        }
    }, NetEntExtend.API.BaseGetter),
    paytablePage: Sys.applyPropertiesIf({
        func: function() {
            var b = null,
                a = Array.prototype.slice.call(arguments);
            if (Services.storage.readData("paytable.showing")) {
                b = Services.storage.readData("paytable.currentPage")
            }
            this.success.apply(this, this.addParamsToArgument(a, b))
        }
    }, NetEntExtend.API.BaseGetter),
    volumeLevel: Sys.applyPropertiesIf({
        func: function() {
            var c = this,
                b = Sys.utils.toInt(Services.settingsManager.getSetting("volume") * 100),
                a = Array.prototype.slice.call(arguments),
                d = c.addParamsToArgument(a, b);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter),
    debugMode: Sys.applyPropertiesIf({
        func: function() {
            var c = this,
                a = false,
                b = Array.prototype.slice.call(arguments),
                d;
            d = c.addParamsToArgument(b, a);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Setters = {
    volumeLevel: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return true
        },
        validateArguments: function() {
            return Sys.isNumber(arguments[3]) && 0 <= arguments[3] && arguments[3] <= 100
        },
        func: function() {
            var b = this,
                c = arguments[3] / 100,
                a = Array.prototype.slice.call(arguments);
            b.updateSetting("volume", c, a)
        }
    }, NetEntExtend.API.BaseSetter),
    audio: Sys.applyPropertiesIf({
        isAvailable: function() {
            return true
        },
        validateArguments: function() {
            return typeof arguments[3] === "boolean"
        },
        func: function() {
            var c = this,
                a = arguments[3] ? 1 : 0,
                b = Array.prototype.slice.call(arguments);
            c.updateSetting("volume", a, b)
        }
    }, NetEntExtend.API.BaseSetter),
    inGameMessage: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        validateArguments: function() {
            var a = arguments[3],
                b;
            if (Sys.isArray(a) && a.length > 0) {
                b = Sys.find(a, function(c) {
                    if (Sys.isObj(c) && typeof c.text === "string") {
                        if (Sys.isDefined(c.type)) {
                            if (c.type !== "link" && c.type !== "text") {
                                return true
                            }
                            if (c.type === "link" && Sys.isDefined(c.url) && typeof c.url !== "string") {
                                return true
                            }
                        }
                        return false
                    }
                    return true
                });
                return !Sys.isDefined(b)
            }
            return false
        },
        func: function() {
            var f = this,
                g = arguments[3],
                e = [],
                c = 60,
                d, h = "",
                a = 0,
                b = Array.prototype.slice.call(arguments);
            g.forEach(function(i) {
                a++;
                h += i.text;
                if (h.length > c) {
                    i.text = i.text.substring(0, i.text.length - h.length + c)
                }
                if (i.text.length > 0) {
                    if (Sys.isDefined(i.type) && i.type === "link") {
                        d = new Interface.utils.Button({
                            id: "ticker_lnk_" + a,
                            label: i.text,
                            clickCallback: function() {
                                Sys.utils.openURL(i.url)
                            }
                        });
                        d.enable();
                        window.linkContainer = d.getContainer();
                        window.linkContainer.addCSSClass("netEntExtend_button");
                        e.push(window.linkContainer)
                    } else {
                        e.push(new Sys.Element({
                            tag: "span",
                            textContent: i.text
                        }))
                    }
                }
            });
            f.fireEvent("request:ticker.enable", "netEntExtend");
            f.fireEvent("request:ticker.setText", e);
            f.success.apply(f, b)
        }
    }, NetEntExtend.API.BaseSetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Calls = {
    stopAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"],
        isAvailable: function() {
            var b = Services.storage.readData("dialog.showing"),
                a = Services.storage.readData("autoPlayer.roundsLeft");
            return !b && a > 0
        },
        func: function() {
            var b = this,
                a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:autoPlayer.stop");
            b.success.apply(b, a)
        }
    }, NetEntExtend.API.BaseCall),
    pauseAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"],
        isAvailable: function() {
            var b = Services.storage.readData("dialog.showing"),
                a = Services.storage.readData("autoPlayer.roundsLeft");
            return !b && a > 0
        },
        func: function() {
            this.fireEvent("request:autoPlayer.pause");
            this.success.apply(this, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    resumeAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"],
        isAvailable: function() {
            var b = Services.storage.readData("dialog.showing"),
                a = Services.storage.readData("autoPlayer.roundsLeft");
            return !b && a > 0
        },
        func: function() {
            this.fireEvent("request:autoPlayer.resume");
            this.success.apply(this, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    reloadBalance: Sys.applyPropertiesIf({
        func: function() {
            var b = this,
                a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceResponseParsed", "notify:serverManager.reloadBalanceFailed");
            b.model.storeData("reloadBalanceArguments", a);
            b.model.storeData("reloadBalanceSpin", false)
        }
    }, NetEntExtend.API.BaseCall),
    createDialogbox: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            var c = false,
                b = arguments[6],
                a = Resources.readData("pluginMenuOpen") || Services.storage.readData("dialog.showing");
            Object.keys(b).forEach(function(e) {
                var d = (typeof b[e].action !== "undefined") ? b[e].action.toLowerCase() : "";
                if (d === "showplugin") {
                    c = true
                }
            });
            if (c && a) {
                return false
            }
            return true
        },
        validateNumArguments: function() {
            return arguments.length === 7
        },
        validateArguments: function() {
            var f = arguments[3],
                e = arguments[4],
                d = arguments[5],
                c = arguments[6],
                a = false,
                b = ["gotolobby", "reload", "showplugin", ""];
            Object.keys(c).forEach(function(h) {
                var g = (typeof c[h].action !== "undefined") ? c[h].action.toLowerCase() : "";
                if (b.indexOf(g) !== -1) {
                    a = true
                }
            });
            return a && Sys.isString(f) && Sys.isString(e) && Sys.isString(d) && Sys.isArray(c) && c.length > 0 && c.length <= 2 && typeof Sys.find(c, function(g) {
                return !(typeof g.buttonid === "string" && typeof g.buttontext === "string")
            }) === "undefined"
        },
        func: function() {
            var d = this,
                g = arguments[3],
                f = arguments[4].substring(0, 20),
                e = arguments[5],
                c = arguments[6],
                b = {
                    id: "netEntExtend_" + g,
                    title: f,
                    text: e,
                    buttons: [],
                    stopAutoplay: true
                },
                a = Array.prototype.slice.call(arguments);
            Object.keys(c).forEach(function(i) {
                var h = (typeof c[i].action !== "undefined") ? c[i].action.toLowerCase() : "";
                if (h === "showplugin") {
                    d.fireEvent("request:customMessages.removeDialog", "netEntExtend_" + g)
                }
            });
            Sys.each(c, function(h) {
                var i = {};
                i.action = function() {
                    var j = Sys.isDefined(this.buttontype) ? this.buttontype.toLowerCase() : "";
                    d.fireEvent("notify:dialogBoxClosed", this.dialogid, this.buttonid, {
                        name: this.dialogid,
                        button: this.buttonid
                    });
                    switch (j) {
                        case "gotolobby":
                            d.fireEvent("request:disableBasicGamePanel", "prevent_panel_work_before_go_to_lobby");
                            Sys.utils.goToLobby(this.reason);
                            break;
                        case "reload":
                            Sys.utils.reload();
                            break;
                        case "showplugin":
                            d.fireEvent("request:pluginMenu.activate");
                            break;
                        default:
                            break
                    }
                };
                i.scope = {
                    dialogid: g,
                    buttonid: h.buttonid,
                    buttontype: h.action,
                    reason: h.reason
                };
                i.text = h.buttontext;
                i.buttonid = h.buttonid;
                b.buttons.push(i)
            });
            d.fireEvent("request:customMessages.showDialog", b);
            d.success.apply(d, a)
        }
    }, NetEntExtend.API.BaseCall),
    removeDialogbox: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            return typeof arguments[3] === "string"
        },
        func: function() {
            var b = this,
                a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:customMessages.removeDialog", "netEntExtend_" + arguments[3]);
            b.success.apply(b, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginError: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:errorManager.handleError");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    deactivatePluginMenu: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.deactivate");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    activatePluginMenu: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            var c = this.model.readData("inIdleState") === true,
                a = Resources.readData("pluginMenuOpen") !== true,
                b = Resources.readData("overlayVisible") !== true;
            return c && a && b
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.activate");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginNotification: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            return typeof arguments[3] === "string"
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.notification", arguments[3]);
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginChangeMenuHeight: Sys.applyPropertiesIf({
        platforms: ["mobile"],
        isAvailable: function() {
            return true
        },
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            return Sys.isNumber(arguments[3]) || Sys.isObj(arguments[3])
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.changeMenuHeight", arguments[3]);
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    showSystemClock: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"],
        isAvailable: function() {
            return true
        },
        func: function() {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:systemClock.show");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    addButton: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"],
        isAvailable: function() {
            return true
        },
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            return Sys.isObj(arguments[3])
        },
        func: function() {
            var h = this,
                g = Array.prototype.slice.call(arguments),
                c = g[3],
                d, a = "injected-btn",
                b, f, i, e;
            if (c.image) {
                d = document.createElement("img");
                d.src = c.image;
                d.alt = c.text
            } else {
                d = document.createElement("input");
                d.type = "button";
                d.value = c.text
            }
            d.name = c.name;
            d.id = c.id;
            d.className = a;
            f = document.createElement("style");
            f.type = "text/css";
            e = function(j) {
                return ".mobile_landscape #" + j.id + " { z-index: 1000;position: fixed;background: " + j.landscape.color + ";top:" + j.landscape.top + ";left:" + j.landscape.left + ";width:" + j.landscape.width + ";height:" + j.landscape.height + ";" + j.landscape.style + ";}.mobile_portrait #" + j.id + " { z-index: 1000;position: fixed;background: " + j.portrait.color + ";top:" + j.portrait.top + ";left:" + j.portrait.left + ";width:" + j.portrait.width + ";height:" + j.portrait.height + ";" + j.portrait.style + ";}.tablet_landscape #" + j.id + " { z-index: 1000;position: fixed;background: " + j.tablet.color + ";top:" + j.tablet.top + ";left:" + j.tablet.left + ";width:" + j.tablet.width + ";height:" + j.tablet.height + ";" + j.tablet.style + ";}"
            };
            i = e(c);
            if (f.styleSheet) {
                f.styleSheet.cssText = i
            } else {
                f.appendChild(document.createTextNode(i))
            }
            document.getElementsByTagName("head")[0].appendChild(f);
            b = function(k, j) {
                if (!j.target || j.target.className !== a) {
                    return
                }
                h.fireEvent("request:postman.sendMessage", ["event", j.target.id + "_click", j.target.id])
            };
            h.on({
                "notify:userInputManager.userInputEnded": b
            });
            document.body.appendChild(d);
            h.success.apply(this, g)
        }
    }, NetEntExtend.API.BaseCall)
};
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Getters, {
    balanceInCoins: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                b = Services.moneyManager,
                a = b.getBalanceCoins(),
                c = d.addParamsToArgument(arguments, a);
            d.success.apply(d, c)
        }
    }, NetEntExtend.API.BaseGetter),
    betInCoins: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                a = Services.moneyManager,
                c = a.getBetCoins(),
                b = d.addParamsToArgument(arguments, c);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter),
    availableCoins: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                c = Resources.readData("gameServerInitResponse"),
                a = c["denomination.all"],
                b = d.addParamsToArgument(arguments, a);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter),
    selectedCoinValue: Sys.applyPropertiesIf({
        func: function() {
            var c = this,
                a = Services.moneyManager,
                d = a.model.readData("denomination"),
                b = c.addParamsToArgument(arguments, d);
            c.success.apply(c, b)
        }
    }, NetEntExtend.API.BaseGetter),
    winInCoins: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                b = Services.storage.readData("cashField.winInCents"),
                e = Services.moneyManager.model.readData("denomination"),
                a = Math.floor(b / e),
                c = d.addParamsToArgument(arguments, a);
            d.success.apply(d, c)
        }
    }, NetEntExtend.API.BaseGetter),
    freeRoundsLeft: Sys.applyPropertiesIf({
        func: function() {
            var d = this,
                c = Services.storage.readData("freeRounds.roundsLeft"),
                a = Sys.isDefined(c) && c > 0 ? c : null,
                b = d.addParamsToArgument(arguments, a);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter),
    freeSpinsLeft: Sys.applyPropertiesIf({
        func: function() {
            var c = this,
                b = Services.storage.readData("freespin.freespinsLeft"),
                a = Sys.isDefined(b) && b >= 0 && ["FREESPIN", "SUPERSPIN"].contains(c.model.readData("gameMode")) ? b : null;
            c.success.apply(c, c.addParamsToArgument(arguments, a))
        }
    }, NetEntExtend.API.BaseGetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Setters, {});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Calls, {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Getters = Sys.apply(Sys.clone(NetEntExtend.API.Getters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Setters = Sys.apply(Sys.clone(NetEntExtend.API.Setters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Calls = Sys.apply(Sys.clone(NetEntExtend.API.Calls), {
    startAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            var c = this,
                b = c.autoplayNumberOfRoundsAvailable(),
                d = b === null ? [] : b.split(","),
                a = arguments[3];
            return typeof a === "string" && d.contains(a)
        },
        func: function() {
            var b = this,
                a = arguments[3];
            Services.settingsManager.storeSetting("autoPlayNrSpins", Number(a), false);
            b.fireEvent("request:autoPlayer.start");
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    showAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            var d = Services.storage.readData("autoplaySettings.showing"),
                c = Services.storage.readData("spinSettings.showing"),
                e = Services.storage.readData("dialog.showing"),
                b = Services.storage.readData("IntroMovie.showing"),
                a = this.model.readData("featureSplash.showing");
            return !(d || c || e || b || a)
        },
        func: function() {
            var a = this;
            a.fireEvent("request:autoplaySettings.show");
            a.fireEvent("request:spinSettings.show");
            if (!(Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))) {
                a.error(arguments, a.model.ERROR_CODES.UNKNOWN_ERROR)
            } else {
                a.success.apply(a, arguments)
            }
        }
    }, NetEntExtend.API.BaseCall),
    hideAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && (Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))
        },
        func: function() {
            var a = this;
            a.fireEvent("request:autoplaySettings.hide");
            a.fireEvent("request:spinSettings.hide");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    showPaytable: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing")
        },
        validateNumArguments: function() {
            return arguments.length === 4
        },
        validateArguments: function() {
            var b = arguments[3],
                a = Services.storage.readData("paytable.numberOfPages");
            return Sys.isNumber(b) && (1 <= b && b <= a)
        },
        func: function() {
            var a = this,
                b = arguments[3];
            a.fireEvent("request:paytable.show", b);
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    hidePaytable: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:paytable.hide");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    paytableForward: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:paytable.forward");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    paytableBackward: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:paytable.backward");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    closeSplash: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            var a = this;
            return !Services.storage.readData("dialog.showing") && a.model.readData("featureSplash.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:featureSplash.close");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    startFreespins: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("freeSpins.canStart")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:freeSpins.start");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    openHelp: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            var a = this;
            return !Services.storage.readData("dialog.showing") && a.model.readData("inIdleState") && !Services.storage.readData("gameRules.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:gameRules.show");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    skipIntro: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("IntroMovie.showing")
        },
        func: function() {
            var a = this;
            a.fireEvent("request:introMovie.close");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Setters, {
    betLevel: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return NetEntExtend.API.BaseSetter.isAvailable.call(this, "betLevel")
        },
        validateArguments: function() {
            var c = arguments[3],
                a = Resources.readData("gameServerInitResponse"),
                b = a["betlevel.all"].split(",");
            return Sys.isNumber(c) && b.contains(String(c))
        },
        func: function() {
            var a = this;
            a.updateSetting("betLevel", arguments[3], arguments)
        }
    }, NetEntExtend.API.BaseSetter),
    coinValue: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return NetEntExtend.API.BaseSetter.isAvailable.call(this, "denomination")
        },
        validateArguments: function() {
            var b = arguments[3],
                c = Resources.readData("gameServerInitResponse"),
                a = c["denomination.all"].split(",");
            return Sys.isNumber(b) && a.contains(String(b))
        },
        func: function() {
            var a = this;
            a.updateSetting("denomination", arguments[3], arguments)
        }
    }, NetEntExtend.API.BaseSetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Calls, {
    startSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.moneyManager.canPlaceAnotherBet()
        },
        func: function() {
            var a = this;
            a.fireEvent("request:spin.startNewRound");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    startQuickSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function() {
            return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.settingsManager.isSettable("quickSpin") && Services.moneyManager.canPlaceAnotherBet()
        },
        func: function() {
            var b = this,
                a = Services.settingsManager.getSetting("quickSpin");
            b.fireEvent("request:settingsManager.storeData", "quickSpin", true);
            b.fireEvent("request:spin.startNewRound");
            b.onEnteringIdleState.push(function() {
                b.fireEvent("request:settingsManager.storeData", "quickSpin", a)
            });
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    maxBetSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        func: function() {
            var b = this,
                c = Resources.readData("gameServerInitResponseObject").betlevel.all,
                a = Math.max.apply(null, c);
            b.fireEvent("request:settingsManager.storeData", "betLevel", a);
            b.startRound();
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    featurePreview: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        func: function() {
            var a = this;
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall)
});
Sys.ns("Core.NetEntExtend");
Core.NetEntExtend = {
    constructor: function() {
        Core.NetEntExtend.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.NetEntExtendModel,
            controller: Core.NetEntExtendController
        }
    }
};
Core.NetEntExtend = Sys.extend(Core.Module, Core.NetEntExtend, "Core.NetEntExtend");
Sys.ns("Core");
Core.NetEntExtendController = {
    USE_LOGGING: false,
    ROUND_START_EVENT: "request:spin.startNewRound",
    constructor: function() {
        Core.NetEntExtendController.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Core.NetEntExtendController.superclass.init.apply(a, arguments);
        a.onEnteringIdleState = [];
        a.setupAPI()
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.enteringIdleState": a.enteringIdleState,
            "notify:stateHandler.leavingIdleState": a.leavingIdleState,
            "notify:netEntExtendEvents.eventTriggered": a.sendMessage,
            "notify:responseParser.reloadBalanceResponseParsed": a.onReloadBalanceResponse,
            "notify:serverManager.reloadBalanceFailed": a.onReloadBalanceFailed,
            "notify:featureSplash.showing": a.onFeatureSplashShowing,
            "notify:featureSplash.closed": a.onFeatureSplashClosed,
            "notify:gameModeChanged": a.onGameModeChanged,
            "request:NetEntExtend.newMessage": a.handleIncomingMessage
        })
    },
    setupAPI: function() {
        var b = this,
            c = b.model.readData("useRestricted"),
            a = (c === true) ? NetEntExtend.API.Restricted : NetEntExtend.API;
        b.API = {
            get: a.Getters,
            set: a.Setters,
            call: a.Calls
        }
    },
    enteringIdleState: function() {
        var a = this;
        a.onEnteringIdleState.forEach(function(b) {
            b.apply(a, arguments)
        });
        a.onEnteringIdleState = [];
        a.model.storeData("inIdleState", true)
    },
    leavingIdleState: function() {
        var a = this;
        a.model.storeData("inIdleState", false);
        a.model.storeData("reloadBalanceSpin", true)
    },
    handleIncomingMessage: function() {
        var d = this,
            b = arguments[0],
            c = arguments[1],
            a = arguments[2],
            f;
        if (arguments.length < 3 || typeof b !== "string" || !Sys.isNumber(c) || typeof a !== "string") {
            d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
        } else {
            if (!Sys.isDefined(d.API[b]) || !Sys.isDefined(d.API[b][a])) {
                d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
            } else {
                f = d.API[b][a];
                if ((Platform.isDesktopDevice && f.platforms.indexOf("desktop") === -1) || ((Platform.isMobileDevice || Platform.isTabletDevice) && f.platforms.indexOf("mobile") === -1)) {
                    d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
                } else {
                    if (!f.isAvailable.apply(d, arguments)) {
                        d.error(arguments, d.model.ERROR_CODES.NOT_AVAILABLE_IN_CURRENT_STATE)
                    } else {
                        if (!f.validateNumArguments.apply(d, arguments)) {
                            d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
                        } else {
                            if (!f.validateArguments.apply(d, arguments)) {
                                d.error(arguments, d.model.ERROR_CODES.ILLEGAL_ARGUMENT)
                            } else {
                                try {
                                    f.func.apply(d, arguments)
                                } catch (g) {
                                    d.error(arguments, d.model.ERROR_CODES.UNKNOWN_ERROR)
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    success: function() {
        var b = this,
            a = b.getResponseArguments.apply(b, arguments);
        b.sendMessage(["success", a.callId].concat(a.rest))
    },
    error: function(c, a, e) {
        var d = this,
            b = d.getResponseArguments.apply(d, c);
        d.sendMessage(["error", b.callId, a, e])
    },
    sendMessage: function(a) {
        var b = "";
        this.fireEvent("request:postman.sendMessage", a)
    },
    getResponseArguments: function() {
        var a = Array.prototype.slice.call(arguments),
            c = a[1],
            b = a.splice(3);
        return {
            callId: c,
            rest: b
        }
    },
    addParamsToArgument: function(c, b) {
        var a = Array.prototype.slice.call(c);
        if (Sys.isArray(b)) {
            b.forEach(function(d) {
                a.push(d)
            })
        } else {
            a.push(b)
        }
        return a
    },
    updateSetting: function(c, f, b) {
        var e = this,
            a = Services.settingsManager,
            d = this.model.ERROR_CODES;
        a.storeSetting(c, f, false);
        if (a.getSetting(c) === f) {
            e.success.apply(e, b)
        } else {
            e.error(b, d.UNKNOWN_ERROR)
        }
    },
    autoplayNumberOfRoundsAvailable: function() {
        var a = Services.storage.readData("spinSettings.autoplayRoundsAvailable");
        return Sys.isDefined(a) ? a.toString() : null
    },
    onReloadBalanceResponse: function(a) {
        var c = this,
            b = c.model.readData("reloadBalanceArguments"),
            d = c.model.readData("reloadBalanceSpin"),
            e = a.credit;
        if (d) {
            c.success.apply(c, c.addParamsToArgument(b, "busy"))
        } else {
            if (Sys.isNumber(e)) {
                Services.moneyManager.setBalance(e);
                c.success.apply(c, c.addParamsToArgument(b, e))
            }
        }
    },
    onReloadBalanceFailed: function() {
        var b = this,
            a = b.model.readData("reloadBalanceArguments");
        b.error(a, b.model.UNKNOWN_ERROR)
    },
    onFeatureSplashShowing: function() {
        this.model.storeData("featureSplash.showing", true)
    },
    onFeatureSplashClosed: function() {
        this.model.storeData("featureSplash.showing", false)
    },
    startRound: function() {
        var a = this;
        a.fireEvent(a.ROUND_START_EVENT)
    },
    onGameModeChanged: function(a) {
        this.model.storeData("gameMode", a)
    }
};
Core.NetEntExtendController = Sys.extend(Core.Controller, Core.NetEntExtendController, "Core.NetEntExtendController");
Sys.ns("Core");
Core.NetEntExtendModel = {
    ERROR_CODES: {
        UNKNOWN_ERROR: 0,
        ILLEGAL_ARGUMENT: 1,
        EVENTS_NOT_AVAILABLE_IN_GAME: 7,
        CALLBACK_NOT_PROVIDED: 8,
        FUNCTIONALITY_NOT_AVAILABLE: 9,
        WRONG_NUMBER_OF_ARGUMENTS: 10,
        NO_RESPONSE_FROM_GAME: 11,
        NOT_AVAILABLE_IN_CURRENT_STATE: 12,
        HTML_GAME_LAUNCH_FAILED: 18
    },
    constructor: function() {
        Core.NetEntExtendModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var d = this,
            c = Resources.readData("gameServerInitResponse"),
            b = (Sys.isDefined(c)) ? c["gameEventSetters.enabled"] : false,
            a = false;
        if (Sys.isDefined(b) && b === true) {
            a = true
        }
        d.storeData("useRestricted", a);
        d.storeData("locked", true);
        d.storeData("inIdleState", false);
        d.storeData("featureSplash.showing", false)
    }
};
Core.NetEntExtendModel = Sys.extend(Core.Model, Core.NetEntExtendModel, "Core.NetEntExtendModel");
Sys.ns("Core.NetEntExtendEvents");
Core.NetEntExtendEvents = {
    constructor: function() {
        Core.NetEntExtendEvents.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.NetEntExtendEventsModel,
            controller: Core.NetEntExtendEventsController
        }
    }
};
Core.NetEntExtendEvents = Sys.extend(Core.Module, Core.NetEntExtendEvents, "Core.NetEntExtendEvents");
Sys.ns("Core");
Core.NetEntExtendEventsController = {
    USE_LOGGING: false,
    constructor: function() {
        Core.NetEntExtendEventsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var b = this,
            a = {
                "notify:autoPlayer.starting": b.onAutoplayStarting,
                "notify:autoPlayer.startRound": b.onAutoplayStartRound,
                "notify:settingsManager.settingChanged": b.onSettingsChanged,
                "notify:spin.spinAnimationStarted": b.onSpinStart,
                "notify:spin.spinAnimationComplete": b.onSpinEnded,
                "notify:stateHandler.enteringStandardWinPresentationState": b.onWinPresentationStarted,
                "notify:responseParser.responseParsed": b.onServerResponseParsed,
                "notify:standardWin.presentationComplete": b.onWinPresentationComplete,
                "notify:paytable.shown": b.sendEvent.bind(b, "paytableToggle", true),
                "notify:paytable.hidden": b.sendEvent.bind(b, "paytableToggle", false),
                "notify:bonusGameIntro.bonusGameStarted": b.onBonusGameStarted,
                "notify:bonusGameOutro.bonusGameEnded": b.onBonusGameEnded,
                "notify:gameModeChanged": b.onGameModeChanged,
                "notify:stateHandler.enteringIdleState": b.onEnteringIdleState,
                "notify:stateHandler.leavingIdleState": b.onLeavingIdleState,
                "notify:cashField.update": b.onCashFieldUpdate,
                "notify:freeRounds.started": b.onFreeRoundsStarted,
                "notify:freeRounds.ended": b.onFreeRoundsEnded,
                "notify:freeRounds.nextRound": b.onFreeRoundsNextRound,
                "notify:pluginMenu.activated": b.onPluginMenuActivated,
                "notify:pluginMenu.deactivated": b.onPluginMenuDeactivated,
                "notify:viewport.PORTRAIT": b.onPortrait,
                "notify:viewport.LANDSCAPE": b.onLandscape,
                "notify:loader.closed": b.onLoaderClosed,
                "notify:customMessages.fatalMessageShowing": b.onFatalCustomMessage,
                "notify:action.goToLobby": b.onGoToLobby,
                "notify:dialogBoxClosed": b.onDialogBoxClosed
            };
        Sys.iterate(b.model.EVENT_MAP, function(c, d) {
            a[c] = b.sendEvent.bind(b, d)
        });
        b.on(a)
    },
    onLoaderClosed: function() {
        if (this.model.readData("isRestore") === true) {
            this.sendEvent("gameRoundStarted")
        }
    },
    onFatalCustomMessage: function(b, a) {
        if (b === 990 || b === 992) {
            this.sendEvent("gameError", 18, a)
        }
    },
    onFreeRoundsStarted: function(a) {
        this.sendEvent("freeRoundsStarted", a)
    },
    onFreeRoundsEnded: function() {
        this.sendEvent("freeRoundsEnded")
    },
    onFreeRoundsNextRound: function(a, b) {
        this.sendEvent("freeRoundsNextRound", a, b)
    },
    sendEvent: function() {
        var a = Array.prototype.slice.call(arguments),
            b = "";
        this.fireEvent("notify:netEntExtendEvents.eventTriggered", ["event"].concat(a))
    },
    onSpinStart: function() {
        var a = Services.storage.readData("playModeManager.modes");
        this.model.storeData("spinStarted", true);
        this.sendEvent("spinStarted", a)
    },
    onSpinEnded: function() {
        this.model.storeData("spinStarted", false);
        this.sendEvent("spinEnded")
    },
    onWinPresentationStarted: function() {
        this.sendEvent("spinProgress", "initialWinPresentationStarted")
    },
    onServerResponseParsed: function(c) {
        var a = this,
            b;
        if (a.model.readData("spinStarted")) {
            b = Sys.isDefined(c.gameroundid) ? c.gameroundid : 0;
            a.sendEvent("spinProgress", "outcomeReceived", b)
        }
        if ((c.restore === true)) {
            a.model.storeData("isRestore", true)
        }
    },
    onWinPresentationComplete: function(b) {
        var a;
        if (Sys.isDefined(b)) {
            a = (b === true) ? "initialWinPresentationAborted" : "initialWinPresentationEnded"
        }
        if (a) {
            this.sendEvent("spinProgress", a)
        }
    },
    onSettingsChanged: function(a, c) {
        var b = this;
        if (a === "volume") {
            b.volumeChange(c)
        }
    },
    onAutoplayStarting: function() {
        var a = this,
            b = Services.settingsManager.getSetting("autoPlayNrSpins");
        a.model.storeData("autoplayRoundsSelected", b);
        a.sendEvent("autoplayStarted", b)
    },
    onAutoplayStartRound: function(a) {
        var c = this,
            b = c.model.readData("autoplayRoundsSelected");
        c.sendEvent("autoplayNextRound", b, a)
    },
    volumeChange: function(d) {
        var c = this,
            b = Math.floor(d * 100),
            e = d > 0,
            a = c.model.readData("lastVolume") > 0;
        c.model.storeData("lastVolume", d);
        c.sendEvent("volumeChange", b);
        if (e !== a) {
            c.sendEvent("audioToggle", e)
        }
    },
    onCashFieldUpdate: function(d) {
        var b = this,
            a = b.model,
            c = a.readData("balance");
        if (Sys.isDefined(c)) {
            if (d !== c) {
                b.sendEvent("balanceChanged");
                a.storeData("balance", d)
            }
        } else {
            a.storeData("balance", d)
        }
    },
    onGameModeChanged: function(a) {
        this.model.storeData("gameMode", a.toLowerCase())
    },
    onBonusGameStarted: function(a) {
        this.sendEvent("bonusGameStarted", a)
    },
    onBonusGameEnded: function(a) {
        this.sendEvent("bonusGameEnded", a)
    },
    onEnteringIdleState: function() {
        var b = this,
            a = b.model.readData("leftIdleState"),
            c = b.model.readData("isRestore");
        if (a || c) {
            b.sendEvent("gameRoundEnded");
            b.model.storeData("isRestore", false)
        }
        b.model.storeData("leftIdleState", false)
    },
    onLeavingIdleState: function() {
        var a = this;
        a.sendEvent("gameRoundStarted");
        a.model.storeData("leftIdleState", true)
    },
    onPluginMenuActivated: function() {
        this.sendEvent("pluginMenuActivated")
    },
    onPluginMenuDeactivated: function() {
        this.sendEvent("pluginMenuDeactivated")
    },
    onPortrait: function() {
        this.sendEvent("rotate", {
            orientation: "portrait"
        })
    },
    onLandscape: function() {
        this.sendEvent("rotate", {
            orientation: "landscape"
        })
    },
    onGoToLobby: function(a) {
        this.sendEvent("goToLobby", a)
    },
    onDialogBoxClosed: function(a, c, b) {
        if (typeof arguments[0] === "object") {
            this.sendEvent("dialogBoxClosed", "", "", arguments[0])
        } else {
            this.sendEvent("dialogBoxClosed", a, c, b)
        }
    }
};
Core.NetEntExtendEventsController = Sys.extend(Core.Controller, Core.NetEntExtendEventsController, "Core.NetEntExtendEventsController");
Sys.ns("Core");
Core.NetEntExtendEventsModel = {
    EVENT_MAP: {
        "notify:stateHandler.leavingBeforeLoaderCloseState": "gameReady",
        "notify:errorManager.error": "gameError",
        "notify:errorManager.errorDialogClosed": "gameErrorClose",
        "notify:paytable.pageSwitched": "paytablePageSwitch",
        "notify:autoPlayer.stopped": "autoplayStopped"
    },
    constructor: function() {
        Core.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("autoplay", false);
        this.storeData("gameMode", "basic")
    },
    getCurrentGameMode: function() {
        var b = this,
            a = b.readData("gameMode");
        if (b.readData("autoplay")) {
            a += ", autoplay"
        }
        return a
    }
};
Core.NetEntExtendEventsModel = Sys.extend(Core.Model, Core.NetEntExtendEventsModel, "Core.NetEntExtendEventsModel");
Sys.ns("Core.Slots");
Core.Slots.NetEntExtendEventsModel = {
    SLOTS_EVENT_MAP: {
        "notify:stateHandler.enteringBigWinState": "bigWinStarted",
        "notify:stateHandler.leavingBigWinState": "bigWinEnded",
        "notify:freeSpinIntro.closed": "freeSpinStarted",
        "notify:freeSpinOutro.closed": "freeSpinEnded"
    },
    constructor: function() {
        Core.Slots.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        Core.Slots.NetEntExtendEventsModel.superclass.setupData.apply(this, arguments);
        Sys.apply(this.EVENT_MAP, this.SLOTS_EVENT_MAP)
    }
};
Core.Slots.NetEntExtendEventsModel = Sys.extend(Core.NetEntExtendEventsModel, Core.Slots.NetEntExtendEventsModel, "Core.Slots.NetEntExtendEventsModel");
Sys.ns("Core");
Core.Postman = {
    constructor: function() {
        Core.Postman.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            setupGame: {
                waitEvents: ["notify:postman.ready"]
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Core.PostmanController
        }
    }
};
Core.Postman = Sys.extend(Core.Module, Core.Postman, "Core.Postman");
Sys.ns("Core");
Core.PostmanController = {
    IS_READY: false,
    PLUGIN_TIMEOUT: 30000,
    constructor: function() {
        Core.PostmanController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        this.pluginURL = Resources.readData("pluginURL");
        this.enableSwedenPlugin = Resources.readData("queryData") ? Resources.readData("queryData").enableDefaultSwedenButtons : false;
        this.swedenButtonPluginHost = Resources.readData("queryData") ? Resources.readData("queryData").swedenButtonPluginHost : undefined;
        this.hiddenIframeForSweden = null;
        this.iframe = null;
        this.on({
            "request:postman.sendMessage": this.sendMessage,
            "notify:stateHandler.enteringSetupGameState": this.setupPlugin
        });
        window.addEventListener("message", function(b) {
            a.onMessage(b)
        })
    },
    onMessage: function(a) {
        if (a.data.moduleId) {
            this.fireEvent("notify:" + a.data.moduleId + ".notification", a.data)
        } else {
            this.handleIncomingMessage(a.data)
        }
    },
    setupPlugin: function() {
        var b = this,
            a;
        if (this.pluginURL) {
            if (this.enableSwedenPlugin) {
                this.loadPluginForSwedenIntegration()
            }
            this.iframe = document.createElement("iframe");
            this.iframe.setAttribute("id", "netEntExtendPlugin");
            this.iframe.setAttribute("sandbox", "allow-scripts allow-popups allow-popups-to-escape-sandbox allow-top-navigation allow-top-navigation-by-user-activation allow-same-origin allow-forms allow-pointer-lock");
            this.iframe.setAttribute("frameborder", 0);
            this.iframe.setAttribute("width", "100%");
            this.iframe.setAttribute("height", 0);
            this.iframe.src = this.pluginURL;
            a = document.getElementById("viewport");
            a.insertBefore(this.iframe, a.firstChild);
            this.timeout = setTimeout(function() {
                b.fireEvent("request:loaderErrorHandler.handlePluginTimeoutError")
            }, this.PLUGIN_TIMEOUT)
        } else {
            this.fireEvent("notify:postman.ready");
            this.IS_READY = true
        }
    },
    handlePluginReadyCall: function(c) {
        var b = c[3],
            d = c[4],
            a = c[5];
        if (c[0] === "call" && c[2] === "pluginReady") {
            clearTimeout(this.timeout);
            this.IS_READY = true;
            this.fireEvent("notify:postman.ready");
            if (Sys.isDefined(b) && Sys.isDefined(d)) {
                this.fireEvent("request:pluginMenu.init", b, d, a)
            }
            this.sendMessage(["success", c[1]])
        }
    },
    handleIncomingMessage: function(a) {
        if (this.pluginURL && !this.IS_READY) {
            this.handlePluginReadyCall(a)
        } else {
            this.fireEvent.apply(this, ["request:NetEntExtend.newMessage"].concat(a))
        }
    },
    sendMessage: function(a) {
        if (Utils.Platform.inIframe()) {
            window.parent.postMessage(a, "*")
        }
        if (this.iframe && this.pluginURL) {
            this.iframe.contentWindow.postMessage(a, "*");
            if (this.hiddenIframeForSweden) {
                this.hiddenIframeForSweden.contentWindow.postMessage(a, "*")
            }
        }
    },
    loadPluginForSwedenIntegration: function() {
        var b = document.createElement("link"),
            a = Resources.readData("queryData").gameId;
        this.hiddenIframeForSweden = document.createElement("iframe");
        this.hiddenIframeForSweden.setAttribute("frameborder", 0);
        this.hiddenIframeForSweden.setAttribute("style", "width: 100%;height: 0px;z-index: -1;position: absolute;");
        this.hiddenIframeForSweden.src = (this.swedenButtonPluginHost ? this.swedenButtonPluginHost : "https://static-shared.casinomodule.com") + "/sweden-plugin/sweden_buttons.html?gameid=" + a;
        this.cssPath = (this.swedenButtonPluginHost ? this.swedenButtonPluginHost : "https://static-shared.casinomodule.com") + "/sweden-plugin/origin.css";
        document.body.insertBefore(this.hiddenIframeForSweden, document.body.firstChild);
        b.href = this.cssPath;
        b.type = "text/css";
        b.rel = "stylesheet";
        Sys.utils.addCSSClass(document.body, "sweden-regulation");
        Sys.utils.addCSSClass(document.body, a);
        document.getElementsByTagName("head")[0].appendChild(b)
    }
};
Core.PostmanController = Sys.extend(Core.Controller, Core.PostmanController, "Core.PostmanController");
Sys.ns("Core");
Core.CustomMessages = {
    constructor: function() {
        Core.CustomMessages.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            showingCustomMessages: {
                state: {
                    name: "ShowingCustomMessages",
                    execute: function() {},
                    waitEvents: {
                        "notify:customMessages.messagesClosed": false
                    }
                }
            },
            delayBeforeShowingMessages: {
                state: {
                    name: "DelayBeforeShowingMessages",
                    execute: function() {},
                    waitEvents: {
                        "notify:customMessages.delayComplete": false
                    }
                }
            },
            idle: {
                waitEvents: ["notify:customMessages.messagesClosed"]
            },
            beforeStopping: {
                queue: [function(b) {
                    if (a.hasImmediate() || !a.readData("shouldShowDialogs")) {
                        b.stateHandler.pushState(b.states.showingCustomMessages)
                    }
                }]
            },
            setupGame: {
                waitEvents: ["notify:customMessages.ready"]
            },
            noWinPresentation: {
                queue: [function(b) {
                    if (a.hasDialogs() || !a.readData("shouldShowDialogs")) {
                        b.stateHandler.pushState(b.states.delayBeforeShowingMessages)
                    }
                }]
            }
        }
    },
    getMixinDependencies: function() {
        return ["userInput"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Core.CustomMessagesController,
            model: Core.CustomMessagesModel
        }
    }
};
Core.CustomMessages = Sys.extend(Core.Module, Core.CustomMessages, "Core.CustomMessages");
Sys.ns("Core");
Core.CustomMessagesController = {
    DIALOG_DELAY: 3000,
    ERRORS: {
        DISPLAY_IMMEDIATELY_CLOSE: 990,
        DISPLAY_IMMEDIATELY_CONTINUE: 991,
        DISPLAY_ON_IDLE_CLOSE: 992,
        DISPLAY_ON_IDLE_CONTINUE: 993
    },
    constructor: function() {
        Core.CustomMessagesController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:customMessages.showDialog": this.onShowDialogRequest,
            "request:customMessages.removeDialog": this.onRemoveDialogRequest,
            "notify:serverManager.serverResponseReceived": this.onServerResponseReceived,
            "notify:serverManager.serverErrorReceived": this.onServerErrorReceived,
            "notify:stateHandler.enteringSetupGameState": this.onEnteringSetupGameState,
            "notify:stateHandler.enteringIdleState": this.onEnteringIdleState,
            "notify:stateHandler.leavingIdleState": this.onLeavingIdleState,
            "notify:stateHandler.enteringShowingCustomMessagesState": this.onEnteringShowingCustomMessagesState,
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.onLoaderClose,
            "notify:stateHandler.enteringDelayBeforeShowingMessagesState": this.onEnteringDelayBeforeShowingMessagesState,
            "notify:stateHandler.leavingDelayBeforeShowingMessagesState": this.onLeavingDelayBeforeShowingMessagesState,
            "notify:dialogWindow.dialogShown": this.onDialogShown
        })
    },
    onLoaderClose: function() {
        this.model.storeData("showingLoader", false);
        this.model.storeData("shouldShowDialogs", true)
    },
    onShowDialogRequest: function(b) {
        var a;
        try {
            a = this.prepareDialogConfig(b)
        } catch (c) {
            this.showTechnicalError();
            this.model.storeData("shouldShowDialogs", false);
            return
        }
        delete a.immediate;
        if (this.model.readData("isIdle")) {
            if (this.model.hasDialogsToWaitFor()) {
                this.model.addDialogToWaitFor(a.id)
            }
            this.fireEvent("request:dialogWindow.showDialog", a)
        } else {
            this.model.addDialog(a)
        }
    },
    onRemoveDialogRequest: function(a) {
        this.model.removeDialogToWaitFor(a);
        this.model.removeDialog(a);
        this.fireEvent("request:dialogWindow.removeDialog", a)
    },
    onServerResponseReceived: function(a) {
        var b = Sys.utils.queryStringToObject(a.responseText, true),
            c = Object.keys(b).length;
        if (Sys.isDefined(b.messages)) {
            this.handleMessagesFromServerRequest(b.messages, c === 1)
        }
    },
    onServerErrorReceived: function(a) {
        var b = Sys.utils.qsToObj(a.responseText, true);
        if (Sys.isDefined(b.messages)) {
            this.handleMessagesFromServerRequest(b.messages, true)
        }
    },
    handleMessagesFromServerRequest: function(f, c) {
        var g, b, d, a;
        try {
            g = JSON.parse(f);
            if (Sys.isArray(g)) {
                b = g.pop();
                if (Sys.isDefined(b)) {
                    d = this.createConfigFromMessage(b);
                    a = this.prepareDialogConfig(d);
                    this.model.addDialog(a)
                }
                if (c) {
                    this.showImmediateMessages()
                }
            }
        } catch (h) {
            this.showTechnicalError();
            this.model.storeData("shouldShowDialogs", false)
        }
    },
    onEnteringSetupGameState: function() {
        if (!this.model.readData("showingError")) {
            this.fireEvent("notify:customMessages.ready")
        }
    },
    onEnteringIdleState: function() {
        this.model.storeData("isIdle", true);
        if (!this.model.readData("shouldShowDialogs")) {
            return
        }
        this.showDialogs(this.model.popAll())
    },
    onLeavingIdleState: function() {
        this.model.storeData("isIdle", false)
    },
    onEnteringShowingCustomMessagesState: function() {
        this.showImmediateMessages()
    },
    onEnteringDelayBeforeShowingMessagesState: function() {
        var a = this;
        clearTimeout(this.delayTimeout);
        this.startListeningToUserInput();
        this.delayTimeout = setTimeout(function() {
            a.fireEvent("notify:customMessages.delayComplete")
        }, this.DIALOG_DELAY)
    },
    onLeavingDelayBeforeShowingMessagesState: function() {
        this.stopListeningToUserInput()
    },
    onUserInputEnd: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            clearTimeout(this.delayTimeout);
            this.fireEvent("notify:customMessages.delayComplete")
        }
    },
    showImmediateMessages: function() {
        if (!this.model.readData("shouldShowDialogs")) {
            return
        }
        this.showDialogs(this.model.popAllImmediate())
    },
    onDialogShown: function(a) {
        if (!Sys.isDefined(a)) {
            return
        }
        this.model.removeDialogToWaitFor(a);
        if (!this.model.hasDialogsToWaitFor()) {
            this.fireEvent("notify:customMessages.messagesClosed")
        }
    },
    showDialogs: function(b) {
        var a = this;
        if (b.length > 0) {
            b.forEach(function(c) {
                a.model.addDialogToWaitFor(c.id);
                if (Services.settingsManager.getSetting("autoPlayNrSpins") > 0 && (a.isErrorMessage(c.messageCode) || c.stopAutoplay)) {
                    a.fireEvent("request:autoPlayer.stop")
                }
                a.fireEvent("request:dialogWindow.showDialog", c);
                if (c.messageCode === a.ERRORS.DISPLAY_IMMEDIATELY_CLOSE || c.messageCode === a.ERRORS.DISPLAY_ON_IDLE_CLOSE) {
                    a.fireEvent("notify:customMessages.fatalMessageShowing", c.messageCode, c.text)
                }
            })
        } else {
            this.fireEvent("notify:customMessages.messagesClosed")
        }
    },
    isErrorMessage: function(b) {
        var c = this,
            a;
        for (a in c.ERRORS) {
            if (c.ERRORS.hasOwnProperty(a) && b === c.ERRORS[a]) {
                return true
            }
        }
        return false
    },
    createConfigFromMessage: function(c) {
        var a = {
                title: Services.languageManager.getText(Language.Keys.messageCaption),
                text: c.message,
                buttons: [],
                immediate: true,
                id: c.code,
                messageCode: c.code
            },
            b;
        switch (c.code) {
            case this.ERRORS.DISPLAY_IMMEDIATELY_CLOSE:
                b = this.model.getCloseButtonConfig(this);
                a.hideGame = true;
                break;
            case this.ERRORS.DISPLAY_IMMEDIATELY_CONTINUE:
                b = this.model.getContinueButtonConfig(this, true);
                break;
            case this.ERRORS.DISPLAY_ON_IDLE_CLOSE:
                b = this.model.getCloseButtonConfig(this);
                a.hideGame = true;
                a.immediate = false;
                break;
            case this.ERRORS.DISPLAY_ON_IDLE_CONTINUE:
                b = this.model.getContinueButtonConfig(this);
                a.immediate = false;
                break;
            default:
                throw new Error("Technical Error")
        }
        if (Sys.isDefined(b)) {
            a.buttons.push(b)
        }
        return a
    },
    prepareDialogConfig: function(a) {
        a.text = this.scrubMessageString(a.text);
        return a
    },
    scrubMessageString: function(c) {
        var a = (c.match(/<\/?\w+((\s+\w+(\s*=\s*(?:\".*?\"|'.*?'|[^'\">\s]+))?)+\s*|\s*)\/?>/g) || []).length > 0,
            b = document.createElement("div");
        if (a) {
            throw new Error("Technical Error")
        }
        try {
            b.textContent = c
        } catch (d) {
            throw new Error("Technical Error")
        }
        return c
    },
    showTechnicalError: function() {
        this.model.storeData("showingError", true);
        if (this.model.readData("showingLoader")) {
            this.fireEvent("request:loaderErrorHandler.showTechnicalError")
        } else {
            this.fireEvent("request:errorManager.handleError")
        }
    },
    revertSpin: function() {
        this.fireEvent("request:moneyManager.revertBet");
        this.fireEvent("request:spin.cancelSpin")
    }
};
Core.CustomMessagesController = Sys.extend(Core.Controller, Core.CustomMessagesController, "Core.CustomMessagesController");
Sys.ns("Core");
Core.CustomMessagesModel = {
    constructor: function() {
        Core.CustomMessagesModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.roundEndQueue = [];
        this.immediateQueue = [];
        this.dialogsToWaitFor = [];
        this.storeData("isIdle", false);
        this.storeData("showingLoader", true)
    },
    addDialogToWaitFor: function(a) {
        this.dialogsToWaitFor.push(a)
    },
    removeDialogToWaitFor: function(b) {
        var a = this.dialogsToWaitFor.indexOf(b);
        if (a !== -1) {
            this.dialogsToWaitFor.splice(a, 1)
        }
    },
    hasDialogsToWaitFor: function() {
        return this.dialogsToWaitFor.length > 0
    },
    addDialog: function(a) {
        if (a.immediate) {
            this.immediateQueue.push(a)
        } else {
            this.roundEndQueue.push(a)
        }
    },
    removeDialog: function(a) {
        this.spliceDialogFromQueue(this.roundEndQueue, a);
        this.spliceDialogFromQueue(this.immediateQueue, a)
    },
    spliceDialogFromQueue: function(b, d) {
        var a = b.length,
            c;
        for (c = 0; c < a; c++) {
            if (b[c].id === d) {
                return b.splice(c, 1)
            }
        }
        return null
    },
    popAllImmediate: function() {
        return this.immediateQueue.splice(0, this.immediateQueue.length)
    },
    popAllRoundEnd: function() {
        return this.roundEndQueue.splice(0, this.roundEndQueue.length)
    },
    popAll: function() {
        return this.popAllImmediate().concat(this.popAllRoundEnd())
    },
    hasImmediate: function() {
        return this.immediateQueue.length > 0
    },
    hasDialogs: function() {
        return this.immediateQueue.length > 0 || this.roundEndQueue.length > 0
    },
    getCloseButtonConfig: function(a) {
        return {
            scope: a,
            text: Services.languageManager.getText(Language.Keys.btn_casino),
            action: function() {
                a.fireEvent("notify:dialogBoxClosed", {
                    name: "netentExtendCustomError",
                    button: "home"
                });
                Sys.utils.goToLobby()
            }
        }
    },
    getContinueButtonConfig: function(b, a) {
        return {
            scope: b,
            text: Services.languageManager.getText(Language.Keys.btn_continue),
            action: function() {
                b.fireEvent("notify:dialogBoxClosed", {
                    name: "netentExtendCustomError",
                    button: "continue"
                });
                if (a) {
                    b.revertSpin()
                }
            }
        }
    }
};
Core.CustomMessagesModel = Sys.extend(Core.Model, Core.CustomMessagesModel, "Core.CustomMessagesModel");
Sys.ns("Core");
Core.CustomMessagesDesktopModel = {
    constructor: function() {
        Core.CustomMessagesDesktopModel.superclass.constructor.apply(this, arguments)
    },
    getCloseButtonConfig: function() {}
};
Core.CustomMessagesDesktopModel = Sys.extend(Core.CustomMessagesModel, Core.CustomMessagesDesktopModel, "Core.CustomMessagesDesktopModel");
Sys.ns("Core");
Core.ServerManager = {
    constructor: function() {
        Core.ServerManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.ServerManagerModel,
            controller: Core.ServerManagerController
        }
    }
};
Core.ServerManager = Sys.extend(Core.Module, Core.ServerManager, "Core.ServerManager");
Sys.ns("Core");
Core.ServerManagerController = {
    constructor: function() {
        Core.ServerManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:serverManager.sendAction": this.sendAction,
            "request:serverManager.storeParameter": this.storeParameter,
            "notify:moduleLoader.finishedLoadingModules": this.initResponse
        })
    },
    initResponse: function() {
        this.fireEvent("notify:serverManager.serverResponseReceived", {
            responseText: Resources.readData("unParsedGameServerInitResponse")
        })
    },
    sendAction: function(d, c, e) {
        var b = this.model.getRequestURL(d),
            f = this.model.readData("slowServerRequestTimeLimit"),
            a = setTimeout(function() {
                this.fireEvent("notify:serverManager.slowRequest")
            }.bind(this), f);
        this.fireEvent("notify:serverManager.actionRequestSent", d);
        Sys.utils.httpGet({
            url: b
        }).fail(function(g) {
            this.fireEvent("notify:serverManager.serverErrorReceived", g);
            this.fireEvent("request:errorManager.handleRequestError", g);
            this.fireEvent("notify:serverManager.actionRequestError", d);
            if (e) {
                this.fireEvent(e, g)
            }
        }, this).done(function(g) {
            this.fireEvent("notify:serverManager.serverResponseReceived", g, c)
        }, this).always(function() {
            clearTimeout(a)
        })
    },
    storeParameter: function(a, b) {
        this.model.storeData("parameter:" + a, b)
    }
};
Core.ServerManagerController = Sys.extend(Core.Controller, Core.ServerManagerController, "Core.ServerManagerController");
Sys.ns("Core");
Core.ServerManagerModel = {
    constructor: function() {
        Core.ServerManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("queryData");
        this.storeData("queryData", a);
        this.storeData("serverURL", a.server);
        this.storeData("parameter:sessionID", Resources.readData("sessionID"));
        this.storeData("parameter:gameID", a.gameId);
        this.storeData("slowServerRequestTimeLimit", 5000)
    },
    getRequestURL: function(b) {
        var a = [this.readData("serverURL"), "servlet/CasinoGameServlet;jsession=", this.readData("parameter:sessionID"), "?", this.getActionParameters(b), "&no-cache=", Sys.utils.pseudoGUID()].join("");
        return this.doIntegrationSpecificRequestUrlUpdates(a)
    },
    getActionParameters: function(a) {
        if (a === "init") {
            return this.getInitParameters(a)
        }
        return ""
    },
    getInitParameters: function(a) {
        return ["action=" + a, "&sessid=" + this.readData("parameter:sessionID"), "&gameId=" + this.readData("parameter:gameID")].join("")
    },
    doIntegrationSpecificRequestUrlUpdates: function(a) {
        return a
    }
};
Core.ServerManagerModel = Sys.extend(Core.Model, Core.ServerManagerModel, "Core.ServerManagerModel");
Sys.ns("Core");
Core.MoneyManager = {
    constructor: function() {
        Core.MoneyManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.MoneyManagerModel,
            controller: Core.MoneyManagerController
        }
    }
};
Core.MoneyManager = Sys.extend(Core.Module, Core.MoneyManager, "Core.MoneyManager");
Sys.ns("Core");
Core.MoneyManagerController = {
    constructor: function() {
        Core.MoneyManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.onBeforeLoaderClose,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:settingsManager.settingChanged": this.onSettingChanged,
            "request:moneyManager.revertBet": this.revertBet,
            "notify:freeRounds.reInitResponseReceived": this.onFreeRoundsReInit,
            "notify:freeRounds.ended": this.onFreeRoundsEnded
        })
    },
    onBeforeLoaderClose: function() {
        this.notifyBalanceChange()
    },
    onServerResponse: function(a) {
        if (typeof a.credit !== "undefined") {
            this.model.setBalance(a.credit)
        }
    },
    onSettingChanged: function(a, b) {
        if (a === "betLevel") {
            if (this.model.setBetLevel(b)) {
                this.notifyBetChange()
            }
        } else {
            if (a === "denomination") {
                if (this.model.setDenomination(b)) {
                    this.notifyBetChange()
                }
            }
        }
    },
    notifyBalanceChange: function() {
        this.fireEvent("notify:moneyManager.balanceChanged", {
            denomination: this.model.readData("denomination"),
            playerBetCents: this.model.readData("playerBetCents"),
            playerBalanceCoins: this.model.readData("playerBalanceCoins"),
            playerBalanceCents: this.model.readData("playerBalanceCents"),
            playerBalanceFormatted: this.formatMoneyCurrencySign(this.model.readData("playerBalanceCents"))
        })
    },
    notifyBetChange: function() {
        this.fireEvent("notify:moneyManager.betChanged", {
            playerBetCoins: this.model.readData("playerBetCoins"),
            playerBetCents: this.model.readData("playerBetCents"),
            playerBetFormatted: this.formatMoneyCurrencySign(this.model.readData("playerBetCents"))
        })
    },
    revertBet: function() {
        this.setBalance(this.getBalanceCents() + this.getBetCents());
        this.reloadBalance()
    },
    setBalance: function(a) {
        if (this.model.setBalance(a)) {
            this.notifyBetChange();
            this.notifyBalanceChange()
        }
    },
    reloadBalance: function() {
        var c = this,
            a = new Sys.Deferred(),
            b = function() {
                c.removeListener("notify:responseParser.reloadBalanceParsed");
                c.removeListener("notify:serverManager.reloadBalanceRequestFailed")
            };
        this.addListener("notify:responseParser.reloadBalanceParsed", function(d) {
            c.setBalance(parseInt(d.credit, 10));
            a.resolve(d);
            b();
            c.fireEvent("notify:moneyManager.balanceReloaded")
        });
        this.addListener("notify:serverManager.reloadBalanceRequestFailed", function(d) {
            a.reject(d);
            b()
        });
        this.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceParsed", "notify:serverManager.reloadBalanceRequestFailed");
        return a
    },
    formatMoney: function(f, h, c) {
        var a = this.model.getMoneyFormat(h),
            d = Sys.isNumber(c) ? c : 2,
            e = (Math.floor(f) / 100).toFixed(d).split("."),
            b = e[0],
            i = e[1],
            g = b.split("").reduce(function(n, m, l, k) {
                var j = n;
                if (l > 0 && l % 3 === 0) {
                    j = a.thousandsDivider + j
                }
                j = k[k.length - l - 1] + j;
                return j
            }, "");
        return g + (i ? a.decimalDivider + i : "")
    },
    formatMoneyCurrencySign: function(a, g, b) {
        var c = this.model.getMoneyFormat(g),
            f = c.currencyChar,
            e = this.formatMoney(a, g, b),
            d = function(h) {
                return h.length > 1 ? " " : ""
            };
        return c.isCurrCharAfter ? e + d(f) + f : f + d(f) + e
    },
    getBalanceCents: function() {
        return this.model.readData("playerBalanceCents")
    },
    getBalanceCoins: function() {
        return this.model.readData("playerBalanceCoins")
    },
    getBetCents: function() {
        return this.model.readData("playerBetCents")
    },
    getBetCoins: function() {
        return this.model.readData("playerBetCoins")
    },
    canPlaceAnotherBet: function() {
        return this.getBetCents() <= this.getBalanceCents() || this.model.readData("inFreeRounds")
    },
    placeBet: function() {
        if (!this.model.readData("inFreeRounds")) {
            this.setBalance(this.getBalanceCents() - this.getBetCents())
        }
    },
    getMinimumBetCents: function() {
        return this.model.readData("minimumBetInCents")
    },
    getCurrencyIsoName: function(a) {
        return this.model.getMoneyFormat(a).iso
    },
    onFreeRoundsReInit: function() {
        this.model.setupData()
    },
    onFreeRoundsEnded: function() {
        this.model.storeData("inFreeRounds", false)
    }
};
Core.MoneyManagerController = Sys.extend(Core.Controller, Core.MoneyManagerController, "Core.MoneyManagerController");
Sys.ns("Core");
Core.MoneyManagerModel = {
    constructor: function() {
        Core.MoneyManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponse");
        this.setupMoneyHandling();
        this.setBalance(Number(a.credit));
        this.storeData("betlineCoins", this.getBetlineCoinValue(a));
        this.storeData("inFreeRounds", parseInt(a.freeRoundsLeft, 10) > 0);
        this.calculateMinimumBetInCents()
    },
    setupMoneyHandling: function() {
        var b = Resources.readData("gameServerInitResponse"),
            a = {
                player: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_player"), b.playercurrencyiso),
                jackpot: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_jackpot"), b.jackpotcurrencyiso)
            };
        if (!a.player) {
            throw new Error("The player currency format is missing!")
        }
        if (!a.jackpot) {
            throw new Error("The jackpot currency format is missing!")
        }
        this.storeData("moneyFormats", a)
    },
    getMoneyFormat: function(b) {
        var a = this.readData("moneyFormats");
        return a[b] ? a[b] : a.player
    },
    getCurrency: function(a) {
        return this.getMoneyFormat(a).currencyChar
    },
    setBalance: function(b) {
        var a = parseInt(b, 10);
        if (!isNaN(a) && a >= 0) {
            this.storeData("playerBalanceCents", a);
            this.storeData("playerBalanceCoins", Math.floor(a / this.readData("denomination")));
            return true
        }
        return false
    },
    setBetLevel: function(b) {
        var a;
        if (b > 0 && Math.floor(b) === b) {
            this.storeData("betLevel", b);
            a = b * this.readData("betlineCoins");
            this.storeData("playerBetCoins", a);
            this.storeData("playerBetCents", a * this.readData("denomination"));
            return true
        }
        return false
    },
    setDenomination: function(a) {
        if (a > 0) {
            this.storeData("denomination", a);
            this.storeData("playerBetCents", this.readData("playerBetCoins") * a);
            this.storeData("playerBalanceCoins", Math.floor(this.readData("playerBalanceCents") / a));
            return true
        }
        return false
    },
    getBalanceCents: function() {
        return this.readData("playerBalanceCents")
    },
    getBalanceCoins: function() {
        return this.readData("playerBalanceCoins")
    },
    getBetCents: function() {
        return this.readData("playerBetCents")
    },
    getBetCoins: function() {
        return this.readData("playerBetCoins")
    },
    getBetlineCoinValue: function(d) {
        var b = d["bl.standard"].split(","),
            e = b.length,
            a = 0,
            c;
        for (c = 0; c < e; c++) {
            a += parseInt(d["bl.i" + c + ".coins"], 10)
        }
        return a
    },
    calculateMinimumBetInCents: function() {
        var b = Resources.readData("gameServerInitResponseObject"),
            c = b.betlevel.all,
            g = b.denomination.all,
            f = this.validateArray(c),
            e = this.validateArray(g),
            a = this.readData("betlineCoins"),
            d = f[0] * a * e[0];
        this.storeData("minimumBetInCents", d)
    },
    validateArray: function(a) {
        if (!Sys.isArray(a)) {
            return [a]
        }
        return a.slice(0).sort(function(d, c) {
            return d - c
        })
    },
    setMinimumBetInCents: function(a) {
        this.storeData("minimumBetInCents", a)
    },
    getMinimumBetInCents: function() {
        return this.readData("minimumBetInCents")
    }
};
Core.MoneyManagerModel = Sys.extend(Core.Model, Core.MoneyManagerModel, "Core.MoneyManagerModel");
Sys.ns("Core");
Core.SettingsManager = {
    constructor: function() {
        Core.SettingsManager.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["trigger"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.SettingsManagerModel,
            controller: Core.SettingsManagerController
        }
    }
};
Core.SettingsManager = Sys.extend(Core.Module, Core.SettingsManager, "Core.SettingsManager");
Sys.ns("Core");
Core.SettingsManagerController = {
    constructor: function() {
        Core.SettingsManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:settingsManager.storeData": a.storeSetting,
            "request:settingsManager.lockSetting": a.lockSetting,
            "request:settingsManager.unlockSetting": a.unlockSetting,
            "request:settingsManager.disableSetting": a.disableSetting,
            "request:settingsManager.enableSetting": a.enableSetting
        })
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:settingsManager.settingChanged", this, "When the settings are changed")
    },
    isSettable: function(a) {
        var b = this;
        return !b.model.isLocked(a) && !b.model.isDisabled(a)
    },
    storeSetting: function(c, e, f, a) {
        var d = this,
            b;
        if (!d.model.isLocked(c) && !d.model.isDisabled(c)) {
            b = d.model.readData("settings");
            if (b[c] !== e) {
                b[c] = e;
                d.model.storeData("settings", b);
                if (f) {
                    Services.localStorageManager.storeData(c, typeof e === "string" ? e : JSON.stringify(e))
                }
                if (!a) {
                    d.fireEvent("notify:settingsManager.settingChanged", c, e)
                }
            }
        }
    },
    getSetting: function(a) {
        return this.model.readData("settings")[a]
    },
    lockSetting: function(b, a) {
        var c = this.model.readData("lockedSettings");
        if (!Sys.isArray(c[b])) {
            c[b] = []
        }
        if (!c[b].contains(a)) {
            c[b].push(a);
            this.model.storeData("lockedSettings", c);
            if (c[b].length === 1) {
                this.fireEvent("notify:settingsManager.settingLocked", b)
            }
        }
    },
    unlockSetting: function(b, a) {
        var c = this.model.readData("lockedSettings");
        if (Sys.isArray(c[b]) && c[b].contains(a)) {
            c[b].splice(c[b].indexOf(a), 1);
            this.model.storeData("lockedSettings", c);
            if (c[b].length === 0) {
                this.fireEvent("notify:settingsManager.settingUnlocked", b)
            }
        }
    },
    disableSetting: function(a) {
        var b = this;
        b.model.readData("disabledSettings")[a] = true;
        b.fireEvent("notify:settingsManager.settingDisabled", a)
    },
    enableSetting: function(a) {
        var b = this;
        b.model.readData("disabledSettings")[a] = false;
        b.fireEvent("notify:settingsManager.settingEnabled", a)
    }
};
Core.SettingsManagerController = Sys.extend(Core.Controller, Core.SettingsManagerController, "Core.SettingsManagerController");
Sys.ns("Core");
Core.SettingsManagerModel = {
    constructor: function() {
        Core.SettingsManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.data = {
            settings: {},
            lockedSettings: {},
            disabledSettings: {}
        }
    },
    isLocked: function(b) {
        var a = this.readData("lockedSettings")[b];
        return Sys.isArray(a) && a.length > 0
    },
    isDisabled: function(a) {
        return this.readData("disabledSettings")[a]
    }
};
Core.SettingsManagerModel = Sys.extend(Core.Model, Core.SettingsManagerModel, "Core.SettingsManagerModel");
Sys.ns("Core");
Core.StopGame = {
    constructor: function() {
        Core.StopGame.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Core.StopGameController,
            view: Core.StopGameView
        }
    }
};
Core.StopGame = Sys.extend(Core.Module, Core.StopGame, "Core.StopGame");
Sys.ns("Core");
Core.StopGameController = {
    constructor: function() {
        Core.StopGameController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "request:stopGame.disable": this.disable,
            "request:stopGame.pause": this.pause
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    disable: function() {
        this.pause();
        this.view.displayOverlay()
    },
    disableAnimations: function() {
        this.fireEvent("request:stage.pauseAnimation")
    },
    disableAudio: function() {
        this.fireEvent("request:audioPlayer.stopAll");
        Services.settingsManager.storeSetting("volume", 0)
    },
    disableInterface: function() {
        var a = this;
        a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
        a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME)
    },
    pause: function() {
        this.disableInterface();
        this.disableAnimations();
        this.disableAudio()
    }
};
Core.StopGameController = Sys.extend(Core.Controller, Core.StopGameController, "Core.StopGameController");
Sys.ns("Core");
Core.StopGameView = {
    constructor: function() {
        Core.StopGameView.superclass.constructor.apply(this, arguments)
    },
    displayOverlay: function() {
        this.overlay.el.style.display = "block"
    },
    initAnimations: function() {
        this.overlay = new Sys.Element({
            tag: "div",
            id: "stopGameOverlay",
            cls: "stopGameOverlay",
            style: "display:none",
            renderTo: "gameWrapper"
        })
    }
};
Core.StopGameView = Sys.extend(Core.View, Core.StopGameView, "Core.StopGameView");
Sys.ns("Core");
Core.RealityCheck = {
    CONTROL_STATE: "idle",
    constructor: function() {
        Core.RealityCheck.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model,
            b = {
                realityCheck: {
                    state: {
                        name: "RealityCheck",
                        execute: function(c) {},
                        waitEvents: {
                            "notify:realityCheck:completed": false
                        }
                    }
                }
            };
        b[this.CONTROL_STATE] = {
            queue: [function(c) {
                if (a.isTimeToDoRealityCheck()) {
                    c.stateHandler.pushState(c.states.realityCheck)
                }
            }]
        };
        return b
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.RealityCheckModel,
            view: Core.View,
            controller: Core.RealityCheckController
        }
    }
};
Core.RealityCheck = Sys.extend(Core.Module, Core.RealityCheck, "Core.RealityCheck");
Sys.ns("Core");
Core.RealityCheckController = {
    constructor: function() {
        Core.RealityCheckController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringRealityCheckState": this.doRealityCheck,
            "notify:responseParser.rcInfoParsed": this.handleInfoResponse,
            "notify:responseParser.rcInfoReset": this.handleResetResponse,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:responseParser.gameConfigurationParsed": this.onFreeRoundsEnded
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    sendServerAction: function(a, b) {
        this.model.setState("requestPending");
        this.fireEvent("request:serverManager.sendAction", a, b)
    },
    handleResetResponse: function(a) {
        this.model.storeData("msUntilTimeout", a.rc.msuntiltimeout);
        this.model.storeData("lastCheckTime", Date.now())
    },
    handleInfoResponse: function(b) {
        var d = this,
            a = b.rc,
            c, f, e;
        if (Sys.isDefined(a) && a.msuntiltimeout <= 0) {
            e = Math.round(a.duration / 60 / 60 / 10) / 100;
            if (a.totalwin >= 0) {
                f = a.totalwin;
                c = Language.Keys.rc_checkPlayingWon
            } else {
                f = Sys.utils.toInt(-a.totalwin);
                c = Language.Keys.rc_checkPlayingLost
            }
            d.requestDialog(Services.languageManager.getText(c, [e, Services.moneyManager.formatMoneyCurrencySign(f)]));
            d.model.setState("dialogOpen")
        } else {
            d.handleResetResponse(b);
            d.complete()
        }
    },
    requestDialog: function(a) {
        this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(a, this))
    },
    complete: function() {
        this.fireEvent("notify:realityCheck:completed")
    },
    doRealityCheck: function() {
        this.sendServerAction("rcinfo", "notify:responseParser.rcInfoParsed")
    },
    onFreeRoundsEnded: function() {
        this.model.processInitData(Resources.readData("gameServerInitResponse"))
    }
};
Core.RealityCheckController = Sys.extend(Core.Controller, Core.RealityCheckController, "Core.RealityCheckController");
Sys.ns("Core");
Core.RealityCheckModel = {
    constructor: function() {
        Core.RealityCheckModel.superclass.constructor.apply(this, arguments)
    },
    getDialog: function(b, a) {
        return {
            title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
            text: b,
            buttons: [{
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_casino),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "realityCheck",
                        button: "home"
                    });
                    Sys.utils.goToLobby("0")
                }
            }, {
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "realityCheck",
                        button: "continue"
                    });
                    a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
                    a.complete()
                }
            }]
        }
    },
    setupData: function() {
        this.processInitData(Resources.readData("gameServerInitResponse"))
    },
    processInitData: function(a) {
        var b = Sys.utils.strIsTrue(a["rc.enabled"]);
        if (Sys.utils.toInt(a.freeRoundsLeft) > 0) {
            b = false
        }
        this.storeData("rcEnabled", b);
        if (b) {
            if (Sys.isDefined(a["rc.msuntiltimeout"])) {
                this.storeData("msUntilTimeout", Sys.utils.toInt(a["rc.msuntiltimeout"]));
                this.storeData("lastCheckTime", Date.now())
            } else {
                this.storeData("rcEnabled", false)
            }
        }
    },
    processServerResponse: function(a) {
        this.storeData("nextAction", a.nextaction)
    },
    isTimeToDoRealityCheck: function() {
        var a;
        if (this.readData("rcEnabled")) {
            a = this.readData("lastCheckTime") + this.readData("msUntilTimeout") <= Date.now();
            if (this.readData("nextAction") === "spin" && a) {
                return true
            }
        }
        return false
    }
};
Core.RealityCheckModel = Sys.extend(Core.Model, Core.RealityCheckModel, "Core.RealityCheckModel");
Sys.ns("Core");
Core.RealityCheckDesktopModel = {
    constructor: function() {
        Core.RealityCheckDesktopModel.superclass.constructor.apply(this, arguments)
    },
    getDialog: function(b, a) {
        return {
            title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
            text: b,
            buttons: [{
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_checkEnd),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "realityCheck",
                        button: "end"
                    });
                    a.fireEvent("request:stopGame.disable")
                }
            }, {
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "realityCheck",
                        button: "continue"
                    });
                    a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
                    a.complete()
                }
            }]
        }
    }
};
Core.RealityCheckDesktopModel = Sys.extend(Core.RealityCheckModel, Core.RealityCheckDesktopModel, "Core.RealityCheckDesktopModel");
Sys.ns("Core.Slots");
Core.Slots.RealityCheck = {
    CONTROL_STATE: "stopped",
    constructor: function() {
        Core.Slots.RealityCheck.superclass.constructor.apply(this, arguments)
    }
};
Core.Slots.RealityCheck = Sys.extend(Core.RealityCheck, Core.Slots.RealityCheck, "Core.Slots.RealityCheck");
Sys.ns("Core");
Core.KeepAlive = {
    constructor: function() {
        Core.KeepAlive.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.KeepAliveModel,
            view: Core.View,
            controller: Core.KeepAliveController
        }
    }
};
Core.KeepAlive = Sys.extend(Core.Module, Core.KeepAlive, "Core.KeepAlive");
Sys.ns("Core");
Core.KeepAliveController = {
    constructor: function() {
        Core.KeepAliveController.superclass.constructor.apply(this, arguments);
        if (this.model.readData("url")) {
            this.keepAlive()
        }
    },
    keepAlive: function() {
        var c = this,
            a = this.model.readData("interval"),
            b = Sys.utils.httpGet({
                url: this.model.readData("url"),
                handleError: false,
                showTimeoutDialog: false
            });
        b.always(function() {
            setTimeout(function() {
                c.keepAlive()
            }, a)
        })
    }
};
Core.KeepAliveController = Sys.extend(Core.Controller, Core.KeepAliveController, "Core.KeepAliveController");
Sys.ns("Core");
Core.KeepAliveModel = {
    constructor: function() {
        Core.KeepAliveModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var b = Resources.readData("queryData"),
            c = b.keepAliveURL,
            a = b.keepAliveInterval,
            d = Resources.readData("sessionID");
        if (d && Sys.utils.isUrl(c) && parseInt(a, 10) >= 5) {
            this.storeData("url", Sys.utils.appendParameterToQuery(c, "sessId=" + d));
            this.storeData("interval", a * 1000)
        }
    }
};
Core.KeepAliveModel = Sys.extend(Core.Model, Core.KeepAliveModel, "Core.KeepAliveModel");
Sys.ns("Core");
Core.PlayForRealPromo = {
    constructor: function() {
        Core.PlayForRealPromo.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            idle: {
                waitEvents: ["notify:playForRealPromo:completed"]
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.PlayForRealPromoModel,
            view: Core.View,
            controller: Core.PlayForRealPromoController
        }
    }
};
Core.PlayForRealPromo = Sys.extend(Core.Module, Core.PlayForRealPromo, "Core.PlayForRealPromo");
Sys.ns("Core");
Core.PlayForRealPromoController = {
    constructor: function() {
        Core.PlayForRealPromoController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "request:playForRealPromo:enable": a.onEnable,
            "request:playForRealPromo:disable": a.onDisable
        })
    },
    onEnteringIdleState: function() {
        var b = this,
            a = b.model.readData("roundsLeft");
        if (a === 0 && !b.isDisabled) {
            b.requestDialog()
        } else {
            b.complete()
        }
        if (Sys.isDefined(a)) {
            b.model.handleRounds()
        }
    },
    requestDialog: function() {
        this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(this))
    },
    complete: function() {
        this.fireEvent("notify:playForRealPromo:completed")
    },
    onEnable: function() {
        this.isDisabled = false
    },
    onDisable: function() {
        this.isDisabled = true
    }
};
Core.PlayForRealPromoController = Sys.extend(Core.Controller, Core.PlayForRealPromoController, "Core.PlayForRealPromoController");
Sys.ns("Core");
Core.PlayForRealPromoModel = {
    constructor: function() {
        Core.PlayForRealPromoModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var b = Resources.readData("gameServerInitResponse") || {},
            a;
        if (b.playforfun && Sys.isDefined(b["playforrealpromo.rounds"])) {
            a = Sys.utils.toInt(b["playforrealpromo.rounds"]);
            this.storeData("roundsLeft", a);
            this.storeData("rounds", a)
        }
    },
    getDialog: function(a) {
        return {
            title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
            buttons: [{
                text: Services.languageManager.getText(Language.Keys.btn_login),
                scope: a,
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "playForRealPromo",
                        button: "login"
                    });
                    Sys.utils.goToLobby("4")
                }
            }, {
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                scope: a,
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "playForRealPromo",
                        button: "continue"
                    });
                    a.complete()
                }
            }]
        }
    },
    handleRounds: function() {
        var a = this.readData("roundsLeft"),
            b;
        if (a === 0) {
            b = this.readData("rounds")
        } else {
            b = --a
        }
        this.storeData("roundsLeft", b)
    }
};
Core.PlayForRealPromoModel = Sys.extend(Core.Model, Core.PlayForRealPromoModel, "Core.PlayForRealPromoModel");
Sys.ns("Core");
Core.PlayForRealPromoDesktopModel = {
    constructor: function() {
        Core.PlayForRealPromoDesktopModel.superclass.constructor.apply(this, arguments)
    },
    getDialog: function(a) {
        return {
            title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
            buttons: [{
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                scope: a,
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "playForRealPromo",
                        button: "continue"
                    });
                    a.complete()
                }
            }]
        }
    }
};
Core.PlayForRealPromoDesktopModel = Sys.extend(Core.PlayForRealPromoModel, Core.PlayForRealPromoDesktopModel, "Core.PlayForRealPromoDesktopModel");
Sys.ns("Core");
Core.CountUp = {
    constructor: function() {
        Core.CountUp.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.CountUpModel,
            view: Core.CountUpView,
            controller: Core.CountUpController
        }
    }
};
Core.CountUp = Sys.extend(Core.Module, Core.CountUp, "Core.CountUp");
Sys.ns("Core");
Core.CountUpModel = {
    constructor: function() {
        Core.CountUpModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.setState("stopped");
        this.defineEasingMethods()
    },
    defineEasingMethods: function() {
        this.storeData("easingMethods", {
            "ease-in": 0,
            "ease-out": 1,
            linear: 0.5
        })
    }
};
Core.CountUpModel = Sys.extend(Core.Model, Core.CountUpModel, "Core.CountUpModel");
Sys.ns("Core");
Core.CountUpView = {
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 80,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{
        fillStyle: "#FFFFFF"
    }, {
        lineWidth: 5,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_TOP: 250,
    COUNT_UP_DEPTH: 100,
    COUNT_UP_EASING_TYPE: "ease-out",
    SHOW_TOTAL_DURATION: 3000,
    constructor: function() {
        var a = {
            COUNT_UP_LEFT: this.COUNT_UP_LEFT,
            COUNT_UP_TOP: this.COUNT_UP_TOP
        };
        Core.CountUpView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureStartAnimation: function(a) {},
    configureEndAnimation: function() {},
    createItems: function() {
        var a = this;
        a.countUpItem = a.createCountUpItem();
        a.list.add(a.countUpItem)
    },
    initAnimations: function() {
        this.scaleFactor = this.getScaleFactor();
        this.createList();
        this.createItems();
        Game.stage.view.addToRenderLoop(this.list);
        this.list.stop()
    },
    getScaleFactor: function() {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    refresh: function() {
        var b = this.scaleFactor,
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        if (Animation.utils.isAnimationItem(this.countUpItem)) {
            this.countUpItem.setLeft(Math.round(a.COUNT_UP_LEFT * b) || Environment.determineResolution().virtualResolution.width / 2);
            this.countUpItem.setTop(Math.round(a.COUNT_UP_TOP * b))
        }
    },
    createList: function() {
        this.list = new Animation.CanvasAnimationList({})
    },
    createCountUpItem: function() {
        var b = this,
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true),
            c = Animation.utils.text.createNumberDrawingProperties(b);
        return new Animation.CanvasAnimationItem({
            left: Math.round(a.COUNT_UP_LEFT * b.scaleFactor) || Environment.determineResolution().virtualResolution.width / 2,
            top: Math.round(a.COUNT_UP_TOP * b.scaleFactor),
            width: 0,
            height: 0,
            depth: b.COUNT_UP_DEPTH,
            executeBefore: function(d) {
                var f, g, h = this.value.toString(),
                    e;
                Animation.utils.text.drawTextFromImage(h, b.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, c.image, c.charMap, c.width, c.height, d);
                if (Sys.isDefined(this.fireOnValue)) {
                    f = this.fireOnValue.length;
                    for (e = -1; ++e < f;) {
                        g = this.fireOnValue[e];
                        if (!g.fired && this.value >= g.value) {
                            g.scope.fireEvent(g.event, g.argument);
                            g.fired = true
                        }
                    }
                }
            },
            operations: {}
        })
    },
    setCountUpValues: function(a) {
        var b = this,
            c = b.countUpItem.prop;
        c.fireOnValue = a.fireEventsOnValue;
        c.operations = {
            value: [{
                time: 0,
                value: a.from,
                support: b.model.readData("easingMethods")[b.COUNT_UP_EASING_TYPE] * a.to,
                numDecimals: 0
            }, {
                time: a.duration,
                value: a.to,
                fireEvent: {
                    event: "view:countUpComplete",
                    scope: b
                }
            }, {
                time: a.duration + 1,
                value: a.to
            }, {
                time: a.duration + 2,
                value: a.to,
                goTo: 2
            }]
        };
        b.configureStartAnimation(a.duration)
    },
    start: function(a) {
        this.list.restore();
        this.setCountUpValues(a);
        this.list.play()
    },
    stop: function() {
        this.list.stop()
    },
    pause: function() {
        this.list.pause()
    },
    resume: function() {
        this.list.play()
    },
    showTotal: function(e) {
        var c = this,
            b, d = [],
            a;
        e = e || {};
        c.list.stop();
        b = c.countUpItem.prop.operations.value[1].value;
        c.countUpItem.prop.fireOnValue.length = 0;
        c.list.restore();
        d.push({
            value: b,
            time: 0
        });
        if (e.showUntilStopped) {
            d.push({
                value: b,
                time: 1,
                goTo: 0
            })
        } else {
            a = Sys.isDefined(e.showDuration) ? e.showDuration : c.SHOW_TOTAL_DURATION;
            d.push({
                value: b,
                time: a,
                fireEvent: {
                    event: "view:showTotalDurationPassed",
                    scope: c
                }
            })
        }
        c.countUpItem.value(d);
        c.configureEndAnimation(a);
        c.list.play()
    }
};
Core.CountUpView = Sys.extend(Core.View, Core.CountUpView, "Core.CountUpView");
Sys.ns("Core");
Core.CountUpController = {
    constructor: function() {
        Core.CountUpController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = {
            "view:countUpComplete": this.onCountUpComplete,
            "view:showTotalDurationPassed": this.stop,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        };
        a["request:" + this.MODULE_NAME + ".start"] = this.start;
        a["request:" + this.MODULE_NAME + ".pause"] = this.pause;
        a["request:" + this.MODULE_NAME + ".resume"] = this.resume;
        a["request:" + this.MODULE_NAME + ".stop"] = this.stop;
        a["request:" + this.MODULE_NAME + ".showTotal"] = this.showTotal;
        this.on(a)
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    start: function(a) {
        this.view.start(a);
        this.model.setState("countingUp")
    },
    stop: function() {
        if (!this.model.isState("stopped")) {
            this.model.setState("stopped");
            this.view.stop();
            this.fireEvent("notify:" + this.MODULE_NAME + ".hidden")
        }
    },
    pause: function() {
        this.view.pause()
    },
    resume: function() {
        if (!this.model.isState("stopped")) {
            this.view.resume()
        }
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    showTotal: function(a) {
        if (!this.model.isState("showingTotal")) {
            this.view.showTotal(a);
            this.model.setState("showingTotal")
        }
    },
    onCountUpComplete: function() {
        this.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
    }
};
Core.CountUpController = Sys.extend(Core.Controller, Core.CountUpController, "Core.CountUpController");
Sys.ns("Game.Slots");
Game.Slots.BigWinCountUp = {
    constructor: function() {
        Game.Slots.BigWinCountUp.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.CountUpModel,
            view: Game.Slots.BigWinCountUpView,
            controller: Core.CountUpController
        }
    }
};
Game.Slots.BigWinCountUp = Sys.extend(Core.CountUp, Game.Slots.BigWinCountUp, "Game.Slots.BigWinCountUp");
Sys.ns("Game.Slots");
Game.Slots.BigWinCountUpView = {
    constructor: function() {
        Game.Slots.BigWinCountUpView.superclass.constructor.apply(this, arguments)
    },
    IMAGE: undefined,
    CHARACTER_WIDTH: 90,
    CHARACTER_HEIGHT: 100,
    FONT: "bold 100px Verdana",
    OFFSET: 0,
    TEXT_OPERATIONS: [{
        fillStyle: "#FFFFFF"
    }, {
        lineWidth: 5,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    LEFT: undefined,
    TOP: 188,
    DEPTH: 100,
    EASING: "ease-out",
    SHOW_TOTAL_DURATION: 1000,
    configureStartAnimation: function() {
        this.countUpItem.prop.ownOpacity = 1
    },
    configureEndAnimation: function(b) {
        var a = this;
        a.countUpItem.prop.operations.fade = [{
            value: 1,
            time: 0
        }, {
            value: 0,
            time: b
        }]
    }
};
Game.Slots.BigWinCountUpView = Sys.extend(Core.CountUpView, Game.Slots.BigWinCountUpView, "Game.Slots.BigWinCountUpView");
Sys.ns("Core");
Core.DialogWindow = {
    constructor: function() {
        Core.DialogWindow.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.DialogWindowModel,
            view: Core.DialogWindowBaseView,
            controller: Core.DialogWindowController
        }
    },
    getMixinDependencies: function() {
        return [{
            userInput: {
                inputEvents: ["start", "end", "move", "scroll"]
            }
        }, "orientation"]
    }
};
Core.DialogWindow = Sys.extend(Core.Module, Core.DialogWindow, "Core.DialogWindow");
Sys.ns("Core");
Core.DialogWindowController = {
    constructor: function() {
        Core.DialogWindowController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = {
            "request:dialogWindow.showDialog": this.onShowDialogRequest,
            "request:dialogWindow.removeDialog": this.onRemoveDialogRequest,
            "request:dialogWindow.closeCurrentDialog": this.onCloseDialogRequest,
            "view:dialogShown": this.onDialogShown,
            "view:showingDialog": this.onShowingDialog,
            "view:pauseGame": this.pauseGame,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:viewport.scaled": this.onGameSizeChanged
        };
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveStart"] = this.onUserInputStart;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveEnd"] = this.onUserInputEnd;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveMove"] = this.onUserInputMove;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveScroll"] = this.onUserInputScroll;
        this.on(a)
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    onShowDialogRequest: function(b) {
        var a = this.model.readData("currentDialogConfig") || {};
        if (!this.model.isState("showing")) {
            this.view.showDialog(b);
            if (typeof this.view.refresh === "function") {
                this.view.refresh()
            }
        } else {
            if (b.fatal && !a.fatal) {
                this.model.addAsFirst(b);
                this.view.closeCurrentDialog()
            } else {
                this.model.queue(b)
            }
        }
    },
    onRemoveDialogRequest: function(b) {
        var a = this.model.readData("currentDialogConfig") || {};
        if (this.model.isState("showing") && a.id === b) {
            this.view.closeCurrentDialog();
            this.fireEvent("request:userInputManager.deactivateExclusivity", this.MODULE_NAME)
        } else {
            this.model.remove(b)
        }
    },
    onCloseDialogRequest: function() {
        var a = this.model.readData("currentDialogConfig") || {};
        if (!a.fatal) {
            this.view.closeCurrentDialog();
            this.fireEvent("request:userInputManager.deactivateExclusivity", this.MODULE_NAME)
        }
    },
    onDialogShown: function(a) {
        if (this.model.hasQueuedDialog()) {
            this.view.showNextDialog()
        } else {
            this.fireEvent("request:quickSettingsMenu.externalActivate", this.MODULE_NAME);
            this.fireEvent("request:enableBasicGamePanel", this.MODULE_NAME);
            this.fireEvent("notify:dialogWindow.allDialogsClosed")
        }
        this.fireEvent("notify:dialogWindow.dialogShown", a.id)
    },
    onShowingDialog: function() {
        this.fireEvent("request:userInputManager.activateExclusivity", this.MODULE_NAME);
        this.fireEvent("request:quickSettingsMenu.externalDeactivate", this.MODULE_NAME);
        this.fireEvent("request:disableBasicGamePanel", this.MODULE_NAME);
        this.fireEvent("notify.dialogWindow.showingDialog")
    },
    pauseGame: function() {
        this.fireEvent("request:stopGame.pause")
    },
    onUserInputStart: function(b) {
        var a = this.view.getButtonFromCoordinate(b);
        this.view.handleScrolling("start", b);
        if (a) {
            this.model.storeData("activeButton", a)
        }
    },
    onUserInputEnd: function(c) {
        var a = Sys.UserInputUtils.getDOMElementFromCoordinates(c),
            b = this.model.readData("activeButton");
        this.view.handleScrolling("end", c);
        if (Sys.isDefined(b) && Sys.UserInputUtils.isParentAndChildElements(b.element, a)) {
            if (typeof b.action === "function") {
                b.action()
            }
            this.fireEvent("request:userInputManager.deactivateExclusivity", this.MODULE_NAME)
        }
        this.model.removeData("activeButton")
    },
    onUserInputMove: function(a) {
        this.view.handleScrolling("move", a)
    },
    onUserInputScroll: function(b, a) {
        this.view.handleScrolling("scroll", b, a)
    },
    onPortrait: function() {
        this.view.handleScrolling("orientation")
    },
    onLandscape: function() {
        this.view.handleScrolling("orientation")
    }
};
Core.DialogWindowController = Sys.extend(Core.Controller, Core.DialogWindowController, "Core.DialogWindowController");
Sys.ns("Core");
Core.DialogWindowModel = {
    constructor: function() {
        Core.DialogWindowModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.requestQueue = [];
        Services.storage.storeData("dialog.showing", false)
    },
    queue: function(a) {
        this.requestQueue.push(a)
    },
    addAsFirst: function(a) {
        this.requestQueue.unshift(a)
    },
    getNextDialogConfig: function() {
        if (this.requestQueue.length > 0) {
            return this.requestQueue.shift()
        }
        return undefined
    },
    remove: function(b) {
        var a;
        for (a = 0; a < this.requestQueue.length; a++) {
            if (this.requestQueue[a].id === b) {
                this.requestQueue.splice(a, 1);
                return true
            }
        }
        return false
    },
    hasQueuedDialog: function() {
        return this.requestQueue.length > 0
    },
    getQueue: function() {
        return this.requestQueue
    }
};
Core.DialogWindowModel = Sys.extend(Core.Model, Core.DialogWindowModel, "Core.DialogWindowModel");
Sys.ns("Core");
Core.DialogWindowView = {
    constructor: function() {
        Core.DialogWindowView.superclass.constructor.apply(this, arguments);
        this.dialogDOMElement = new Core.DialogWindowDOMElement()
    },
    button1Clicked: function() {
        var a = this.model.readData("currentDialogConfig");
        this.handleButtonClick(a.buttons[0], !a.fatal)
    },
    button2Clicked: function() {
        var a = this.model.readData("currentDialogConfig");
        this.handleButtonClick(a.buttons[1], !a.fatal)
    },
    handleButtonClick: function(b, a) {
        if (b && b.action) {
            b.action.call(b.scope || window)
        }
        if (a) {
            this.closeCurrentDialog()
        }
    },
    hideGame: function() {
        document.getElementById("gameWrapper").classList.add("hideGame");
        this.fireEvent("view:pauseGame")
    },
    showDialog: function(a) {
        var c = this,
            b = c.dialogDOMElement;
        b.setTitle(a.title);
        b.setMessage(a.text);
        b.setScrollable(b.text.el.textContent.length > 150);
        b.hideButtons();
        if (Sys.isArray(a.buttons)) {
            if (a.buttons.length === 2) {
                b.showDualButtons(a.buttons[0].text, a.buttons[1].text)
            } else {
                if (a.buttons.length === 1) {
                    b.showSingleButton(a.buttons[0].text)
                }
            }
        }
        c.model.storeData("currentDialogConfig", a);
        c.model.setState("showing");
        c.fireEvent("view:showingDialog");
        b.show();
        Services.storage.storeData("dialog.showing", true);
        c.dialogDOMElement.scroll.show();
        c.dialogDOMElement.scroll.scrollTo(0, 0, false);
        if (Sys.isDefined(a.hideGame) && a.hideGame) {
            c.hideGame()
        }
    },
    getButtonFromCoordinate: function(h) {
        var e = this,
            c = Sys.UserInputUtils.getDOMElementFromCoordinates(h),
            a = e.dialogDOMElement.singleButton.getContainer().el,
            b = e.dialogDOMElement.leftDualButton.getContainer().el,
            f = e.dialogDOMElement.rightDualButton.getContainer().el,
            g, d;
        if (Sys.UserInputUtils.isParentAndChildElements(a, c)) {
            g = a
        }
        if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(b, c)) {
            g = b
        }
        if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(f, c)) {
            g = f
        }
        switch (g) {
            case a:
            case b:
                d = e.button1Clicked.bind(e);
                break;
            case f:
                d = e.button2Clicked.bind(e);
                break;
            default:
                return undefined
        }
        return {
            element: g,
            action: d
        }
    },
    showNextDialog: function() {
        var a = this.model.getNextDialogConfig();
        if (a) {
            this.showDialog(a)
        }
    },
    closeCurrentDialog: function() {
        this.dialogDOMElement.close();
        this.model.setState("idle");
        this.fireEvent("view:dialogShown", this.model.readData("currentDialogConfig"));
        Services.storage.storeData("dialog.showing", false)
    },
    handleScrolling: function(a, d, c) {
        var b = this;
        if (b.dialogDOMElement.scroll) {
            switch (a) {
                case "start":
                    b.dialogDOMElement.scroll.onUserInputStart(d);
                    break;
                case "end":
                    b.dialogDOMElement.scroll.onUserInputEnd(d);
                    break;
                case "move":
                    b.dialogDOMElement.scroll.onUserInputMove(d);
                    break;
                case "scroll":
                    b.dialogDOMElement.scroll.onUserInputScroll(d, c);
                    break;
                case "orientation":
                    b.dialogDOMElement.scroll.show();
                    break;
                default:
            }
        }
    }
};
Core.DialogWindowView = Sys.extend(Core.View, Core.DialogWindowView, "Core.DialogWindowView");
Sys.ns("Gui");
Core.DialogWindowDOMElement = {
    constructor: function() {
        var a = this;
        a.initParentAsWrapper();
        a.initContainer();
        a.initTitle();
        a.initText();
        a.initButtonContainer();
        a.initSingleButton();
        a.initDualButtons()
    },
    initParentAsWrapper: function() {
        Core.DialogWindowDOMElement.superclass.constructor.call(this, {
            tag: "div",
            id: "dialogWindowWrapper",
            cls: "dialogWindowWrapper hidden"
        });
        document.body.appendChild(this.getEl())
    },
    initContainer: function() {
        this.container = new Sys.Element({
            tag: "div",
            id: "dialogWindowContainer",
            cls: "dialogWindowContainer"
        });
        this.add(this.container)
    },
    initTitle: function() {
        this.title = this.container.add(new Sys.Element({
            tag: "div",
            id: "dialogWindowTitle",
            cls: "dialogWindowTitle"
        }))
    },
    initText: function() {
        var a = this;
        a.text = new Sys.Element({
            tag: "div",
            id: "dialogWindowText",
            cls: "dialogWindowText"
        });
        a.scroll = new Interface.utils.DOMScrollableContent({
            content: a.text,
            id: "dialogWindowScroll",
            CSS: {
                base: "dialogWindowScrollWrapper"
            }
        });
        a.container.add(a.scroll.container);
        a.scroll.addScrollBar();
        a.scroll.enable()
    },
    initButtonContainer: function() {
        this.buttonContainer = new Sys.Element({
            tag: "div",
            id: "dialogWindowButtonContainer",
            cls: "dialogWindowButtonContainer"
        });
        this.container.add(this.buttonContainer)
    },
    initSingleButton: function() {
        this.singleButton = new Interface.utils.Button({
            id: "dialogWindowSingleButton",
            CSS: {
                base: "button dialogWindowSingleButton"
            },
            hidden: true
        });
        this.buttonContainer.add(this.singleButton.getContainer())
    },
    initDualButtons: function() {
        var a = this;
        a.leftDualButton = new Interface.utils.Button({
            id: "dialogWindowLeftDualButton",
            CSS: {
                base: "button dialogWindowDualButton dialogWindowRightButton"
            },
            hidden: true
        });
        a.buttonContainer.add(a.leftDualButton.getContainer());
        a.rightDualButton = new Interface.utils.Button({
            id: "dialogWindowRightDualButton",
            CSS: {
                base: "button dialogWindowDualButton dialogWindowLeftButton"
            },
            hidden: true
        });
        a.buttonContainer.add(a.rightDualButton.getContainer())
    },
    show: function() {
        this.removeCSSClass("hidden")
    },
    close: function() {
        this.addCSSClass("hidden")
    },
    setTitle: function(a) {
        this.title.el.textContent = a || ""
    },
    setMessage: function(d) {
        var b = this,
            a, c;
        if (Sys.isDefined(d)) {
            a = b.parseHyperlink(d);
            c = new Sys.Element({
                tag: "p"
            });
            c.addChildren(a);
            b.text.removeAll();
            b.text.addChildren([c.el])
        } else {
            b.text.el.textContent = ""
        }
    },
    parseHyperlink: function(d) {
        var a = /\[([^\]]+)\]\(([^)]+)\)/,
            c = {
                started: "notify:userInputManager.dialogWindowExclusiveStart",
                ended: "notify:userInputManager.dialogWindowExclusiveEnd",
                move: "notify:userInputManager.dialogWindowExclusiveMove",
                hover: "notify:userInputManager.dialogWindowExclusiveHover"
            },
            f = 0,
            e, b;
        d = d || "";
        e = d.split(/(\[[^\]]+\]\([^)]+\))/);
        e.forEach(function(i, g) {
            var h;
            if (g % 2 === 1) {
                h = a.exec(i);
                b = new Interface.utils.Button({
                    id: "dialogWindow_link_" + (f++),
                    label: h[1],
                    CSS: {
                        base: "dialogWindow_link"
                    },
                    clickCallback: function() {
                        Sys.utils.openURL(h[2])
                    },
                    userInputEvents: c
                });
                b.enable();
                e[g] = b.getContainer().getEl()
            } else {
                e[g] = document.createTextNode(e[g])
            }
        });
        return e
    },
    showSingleButton: function(b) {
        var a = this;
        a.singleButton.setText(b);
        a.singleButton.enable();
        a.singleButton.show("inline-block");
        a.leftDualButton.disable();
        a.leftDualButton.hide();
        a.rightDualButton.disable();
        a.rightDualButton.hide()
    },
    showDualButtons: function(b, a) {
        var c = this;
        c.singleButton.disable();
        c.singleButton.hide();
        c.leftDualButton.setText(b);
        c.leftDualButton.enable();
        c.leftDualButton.show("inline-block");
        c.rightDualButton.setText(a);
        c.rightDualButton.enable();
        c.rightDualButton.show("inline-block")
    },
    hideButtons: function() {
        var a = this;
        a.singleButton.disable();
        a.singleButton.hide();
        a.leftDualButton.disable();
        a.leftDualButton.hide();
        a.rightDualButton.disable();
        a.rightDualButton.hide()
    },
    hideGame: function() {
        this.addCls("hideGame")
    },
    setScrollable: function(b) {
        var a = "scrollable";
        if (b) {
            this.addCSSClass(a)
        } else {
            this.removeCSSClass(a)
        }
    }
};
Core.DialogWindowDOMElement = Sys.extend(Sys.Element, Core.DialogWindowDOMElement, "Core.DialogWindowDOMElement");
Sys.ns("Core");
Core.DialogWindowBaseView = {
    BASE_CSS: "interface-dialogWindow_base",
    PORTRAIT_CSS: "interface-dialogWindow_portrait",
    LANDSCAPE_CSS: "interface-dialogWindow_landscape",
    constructor: function() {
        var a = this;
        Core.DialogWindowBaseView.superclass.constructor.apply(a, arguments);
        a.container = a.dialogDOMElement
    },
    onPortrait: function() {
        var a = this;
        Mixins.orientation.view.methods.onPortrait.call(a)
    },
    onLandscape: function() {
        var a = this;
        Mixins.orientation.view.methods.onLandscape.call(a)
    },
    adaptToOrientation: function(a) {
        Mixins.orientation.view.methods.setStyle.call(this, a)
    }
};
Core.DialogWindowBaseView = Sys.extend(Core.DialogWindowView, Core.DialogWindowBaseView, "Core.DialogWindowBaseView");
Sys.ns("Core");
Core.DialogWindowMobileView = {
    PORTRAIT_CSS: "interface-dialogWindow-mobile_portrait",
    LANDSCAPE_CSS: "interface-dialogWindow-mobile_landscape",
    constructor: function() {
        Core.DialogWindowMobileView.superclass.constructor.apply(this, arguments);
        this.setScale()
    },
    refresh: function() {
        this.setScale()
    },
    setScale: function() {
        var d = Environment.determineResolution().resolution.pixelFactor,
            e = this.dialogDOMElement.el,
            a = this.dialogDOMElement.container.el,
            b = Sys.utils.getPrefixedCSSProperty("transform"),
            c;
        if (Sys.isNumber(d)) {
            a.style[b] = "";
            a.style.height = "";
            a.style.width = "";
            c = 1 / (a.offsetWidth / Utils.Platform.getViewportInnerSize().width);
            if (Utils.Platform.isPortrait()) {
                c = (isFinite(c) ? c : 1) * 0.95;
                a.style[b] = "scale(" + c.toFixed(1) + ")"
            } else {
                a.style[b] = "none"
            }
            if (e.classList.contains("scrollable")) {
                a.style[b] = "scale(" + 1 / d + ")";
                a.style.height = "calc(100% / " + 1 / d + ")";
                a.style.width = "calc(100% / " + 1 / d + ")"
            } else {
                a.style.height = "";
                a.style.width = ""
            }
        }
    }
};
Core.DialogWindowMobileView = Sys.extend(Core.DialogWindowBaseView, Core.DialogWindowMobileView, "Core.DialogWindowMobileView");
Sys.ns("Core");
Core.ResponseParser = {
    constructor: function() {
        Core.ResponseParser.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Core.ResponseParserController
        }
    }
};
Core.ResponseParser = Sys.extend(Core.Module, Core.ResponseParser, "Core.ResponseParser");
Sys.ns("Core");
Core.ResponseParserController = {
    constructor: function() {
        Core.ResponseParserController.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = Resources.readData("unParsedGameServerInitResponse") || "";
        Core.ResponseParserController.superclass.init.apply(this, arguments);
        this.doIntegrationSpecificResponseHandling(this.parseServerResponse(a))
    },
    setupEvents: function() {
        this.on({
            "notify:serverManager.serverResponseReceived": this.parseAndBroadcastServerResponse
        })
    },
    parseAndBroadcastServerResponse: function(d, c) {
        var a = Sys.isDefined(c) ? c : "notify:responseParser.responseParsed",
            b = this.doIntegrationSpecificResponseHandling(this.parseServerResponse(d.responseText));
        if (d.responseText.trim().length === 0) {
            this.fireEvent("request:errorManager.handleError")
        } else {
            if (Object.keys(b).length > 1) {
                this.fireEvent(a, b, d)
            }
        }
    },
    parseServerResponse: function(a) {
        return Sys.utils.parseQueryString(a, true)
    },
    doIntegrationSpecificResponseHandling: function(a) {
        return a
    }
};
Core.ResponseParserController = Sys.extend(Core.Controller, Core.ResponseParserController, "Core.ResponseParserController");
Sys.ns("Core");
Core.ErrorManager = {
    constructor: function() {
        Core.ErrorManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Core.ErrorManagerController,
            model: Core.ErrorManagerModel
        }
    }
};
Core.ErrorManager = Sys.extend(Core.Module, Core.ErrorManager, "Core.ErrorManager");
Sys.ns("Core");
Core.ErrorManagerModel = {
    constructor: function() {
        Core.ErrorManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("queryData"),
            b = Sys.isDefined(a.depositAvailable) && a.depositAvailable === true;
        this.storeData("depositAvailable", b);
        this.storeData("dialogConfig", this.setupDialogConfig(b))
    },
    setupDialogConfig: function(b) {
        var a = {};
        a.http = {
            title: Services.languageManager.getText(Language.Keys.connectionLost),
            text: Services.languageManager.getText(Language.Keys.reload),
            buttons: [{
                type: "casino",
                reason: "9"
            }, {
                type: "reload"
            }],
            fatal: true
        };
        a[11] = {
            title: Services.languageManager.getText(Language.Keys.playLimit),
            text: Services.languageManager.getText("11"),
            buttons: [{
                type: "casino",
                reason: "11"
            }]
        };
        a[12] = {
            title: Services.languageManager.getText(Language.Keys.freeRounds_expired),
            buttons: [{
                type: "casino"
            }],
            fatal: true
        };
        a[13] = {
            title: Services.languageManager.getText(Language.Keys.playLimit),
            text: Services.languageManager.getText("13"),
            buttons: [{
                type: "reduceBetAndRevertSpin"
            }, {
                type: "closeAndRevertSpin"
            }]
        };
        Sys.each([14, 16], function(c) {
            a[c] = {
                text: Services.languageManager.getText(Language.Keys.freeRoundsOfferUsed),
                buttons: [{
                    type: "closeBonusProgramWidget"
                }]
            }
        });
        a[20] = {
            title: Services.languageManager.getText(Language.Keys.sessionTimeOut),
            text: Services.languageManager.getText(Language.Keys.returnToLobby),
            buttons: [{
                type: "casino",
                reason: "3"
            }],
            fatal: true
        };
        Sys.each([10, 15, 51, 100, 101, 102], function(c) {
            a[c] = {
                title: Services.languageManager.getText(Language.Keys.outOfMoney),
                text: Services.languageManager.getText(Language.Keys.deposit),
                buttons: b ? [{
                    type: "deposit"
                }, {
                    type: "reduceBetAndRevertSpin"
                }] : [{
                    type: "casino"
                }, {
                    type: "reduceBetAndRevertSpin"
                }]
            }
        });
        Sys.each([0, 53, 56, 58], function(c) {
            a[c] = {
                title: Services.languageManager.getText(Language.Keys.gameUnavailable) + " (" + c + ")",
                buttons: [{
                    type: "casino",
                    reason: "9"
                }, {
                    type: "reload"
                }],
                fatal: true
            }
        });
        a[70] = {
            title: Services.languageManager.getText(Language.Keys.accountUnavailable),
            buttons: [{
                type: "casino"
            }, {
                type: "reload"
            }],
            fatal: true
        };
        a.generic = {
            title: Services.languageManager.getText(Language.Keys.error),
            text: Services.languageManager.getText(Language.Keys.returnToLobby),
            buttons: [{
                type: "casino",
                reason: "9"
            }],
            fatal: true,
            hideGame: true
        };
        a.gameInactive = {
            title: Services.languageManager.getText(Language.Keys.gameUnavailable),
            text: Services.languageManager.getText(Language.Keys.lostConnectInactivity),
            buttons: [{
                type: "casino",
                reason: "9"
            }, {
                type: "reload"
            }],
            fatal: true,
            hideGame: true
        };
        return a
    },
    getDialogConfig: function(a) {
        var c = this.readData("dialogConfig"),
            b;
        if (Sys.isDefined(c[a])) {
            b = c[a]
        } else {
            b = c.generic
        }
        b.errorCode = a;
        return b
    },
    setUpOutOfMoneyErrorConfig: function() {
        var f = Services.languageManager.getText(Language.Keys.outOfMoney),
            c = this.readData("depositAvailable"),
            b = Services.moneyManager.getBalanceCents(),
            e = Services.moneyManager.getMinimumBetCents(),
            d, a;
        if (b >= e) {
            if (c) {
                d = Services.languageManager.getText(Language.Keys.deposit);
                a = [{
                    type: "deposit"
                }, {
                    type: "reduceBet"
                }]
            } else {
                d = Services.languageManager.getText(Language.Keys.reduce);
                a = [{
                    type: "reduceBet"
                }, {
                    type: "close"
                }]
            }
        } else {
            d = Services.languageManager.getText(Language.Keys.depositPlay);
            if (c) {
                a = [{
                    type: "deposit"
                }, {
                    type: "close"
                }]
            } else {
                a = [{
                    type: "close"
                }]
            }
        }
        return {
            title: f,
            text: d,
            buttons: a,
            errorCode: 100
        }
    }
};
Core.ErrorManagerModel = Sys.extend(Core.Model, Core.ErrorManagerModel, "Core.ErrorManagerModel");
Sys.ns("Core");
Core.ErrorManagerController = {
    constructor: function() {
        Core.ErrorManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:errorManager.handleError": this.showDialogForErrorCode,
            "request:errorManager.handleRequestError": this.handleRequestError,
            "request:errorManager.handleGameInactive": this.handleGameInactive,
            "request:errorManager.handleClientOutOfMoneyError": this.handleClientOutOfMoneyError
        })
    },
    showDialog: function(a) {
        var b = a.errorCode === "http" ? 0 : a.errorCode;
        this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
        this.fireEvent("request:dialogWindow.showDialog", a)
    },
    showDialogForErrorCode: function(a) {
        this.showDialog(this.getDialogConfig(a))
    },
    handleRequestError: function(b) {
        var a = this.handleHttpErrors(b);
        if (!a) {
            a = this.handleIntegrationSpecificErrors(b)
        }
        if (!a) {
            a = this.handleGameSpecificErrors(b)
        }
        if (!a) {
            a = this.handleServerErrors(b)
        }
        if (!a) {
            this.fireEvent("notify:errorManager.noErrorDetected")
        } else {
            if (a.fatal) {
                this.fireEvent("request:audioPlayer.stopAll")
            }
            this.showDialog(a)
        }
    },
    handleHttpErrors: function(a) {
        if (Sys.utils.httpRequestIsOK(a)) {
            return undefined
        }
        return this.getDialogConfig("http")
    },
    handleIntegrationSpecificErrors: function(a) {},
    handleGameSpecificErrors: function(a) {},
    handleServerErrors: function(a) {
        var b = Sys.utils.getErrorCode(a);
        if (!Sys.isDefined(b)) {
            return undefined
        }
        return this.getDialogConfig(b)
    },
    handleGameInactive: function() {},
    handleClientOutOfMoneyError: function() {
        var a = this.model.setUpOutOfMoneyErrorConfig();
        a.buttons = this.getButtons(a.buttons);
        this.showDialog(a)
    },
    getDialogConfig: function(b) {
        var a = this.model.getDialogConfig(b);
        return {
            title: a.title,
            text: a.text,
            buttons: this.getButtons(a.buttons),
            fatal: Boolean(a.fatal),
            hideGame: Boolean(a.hideGame),
            errorCode: b
        }
    },
    getButtons: function(b) {
        var a = this;
        return b.map(function(c) {
            return a.getButton(c)
        })
    },
    getButton: function(a) {
        var c = this,
            b = a.type;
        switch (b) {
            case "casino":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_casino), action: function() {
                        c.onButtonInteraction("home");
                        Sys.utils.goToLobby(a.reason)
                    }
                };
            case "reload":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reload), action: function() {
                        c.onButtonInteraction(b);
                        Sys.utils.reload()
                    }
                };
            case "close":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function() {
                        c.onButtonInteraction(b)
                    }
                };
            case "closeBonusProgramWidget":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function() {
                        c.onButtonInteraction(b);
                        c.closeBonusProgramWidget()
                    }
                };
            case "closeAndRevertSpin":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function() {
                        c.onButtonInteraction(b);
                        c.revertSpin()
                    }
                };
            case "reduceBetAndRevertSpin":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reduceBet), action: function() {
                        c.onButtonInteraction(b);
                        c.revertSpin();
                        c.openBetSettings()
                    }
                };
            case "reduceBet":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reduceBet), action: function() {
                        c.onButtonInteraction(b);
                        c.openBetSettings()
                    }
                };
            case "deposit":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_deposit), action: function() {
                        c.onButtonInteraction(b);
                        Services.moneyManager.reloadBalance();
                        Sys.utils.goToCashier()
                    }
                };
            default:
                return {
                    text: "[ERROR]", action: function() {}
                }
        }
    },
    openBetSettings: function() {
        this.fireEvent("request:betSettings.show")
    },
    revertSpin: function() {
        this.fireEvent("request:moneyManager.revertBet");
        this.fireEvent("request:spin.activateDefaultOutcome", "basic")
    },
    closeBonusProgramWidget: function() {
        this.fireEvent("notify:bonusProgramWidget.close")
    },
    onButtonInteraction: function(a) {
        this.fireEvent("notify:errorManager.errorDialogClosed");
        this.fireEvent("notify:dialogBoxClosed", {
            name: "error",
            button: a
        })
    }
};
Core.ErrorManagerController = Sys.extend(Core.Controller, Core.ErrorManagerController, "Core.ErrorManagerController");
Sys.ns("Core");
Core.ErrorManagerDesktopModel = {
    constructor: function() {
        Core.ErrorManagerDesktopModel.superclass.constructor.apply(this, arguments)
    },
    setUpOutOfMoneyErrorConfig: function() {
        var e = Services.languageManager.getText(Language.Keys.outOfMoney),
            b = Services.moneyManager.getBalanceCents(),
            d = Services.moneyManager.getMinimumBetCents(),
            c, a = [{
                type: "close"
            }];
        if (b >= d) {
            c = Services.languageManager.getText(Language.Keys.reduce)
        } else {
            c = Services.languageManager.getText(Language.Keys.depositPlay)
        }
        return {
            title: e,
            text: c,
            buttons: a,
            errorCode: 100
        }
    },
    setupDialogConfig: function(b) {
        var a = Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments);
        a.http.buttons = [{
            type: "reload"
        }];
        a[11].buttons = [{
            type: "reload"
        }];
        a[12].buttons = [{
            type: "reload"
        }];
        a[13].buttons = [{
            type: "closeAndRevertSpin"
        }];
        a[20].buttons = [];
        a[20].text = Services.languageManager.getText("20");
        Sys.each([10, 15, 51, 100, 101, 102], function(c) {
            a[c].buttons = [{
                type: "closeAndRevertSpin"
            }]
        });
        Sys.each([0, 53, 56, 58], function(c) {
            a[c].buttons = [{
                type: "reload"
            }]
        });
        a[70].buttons = [{
            type: "reload"
        }];
        a.generic.buttons = [{
            type: "reload"
        }];
        a.generic.text = Services.languageManager.getText(Language.Keys.reload);
        a.gameInactive.buttons = [{
            type: "reload"
        }];
        return a
    }
};
Core.ErrorManagerDesktopModel = Sys.extend(Core.ErrorManagerModel, Core.ErrorManagerDesktopModel, "Core.ErrorManagerDesktopModel");
Sys.ns("Core");
Core.LocalStorageManager = {
    constructor: function() {
        Core.LocalStorageManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.LocalStorageManagerModel,
            controller: Core.LocalStorageManagerController
        }
    }
};
Core.LocalStorageManager = Sys.extend(Core.Module, Core.LocalStorageManager, "Core.LocalStorageManager");
Sys.ns("Core");
Core.LocalStorageManagerController = {
    constructor: function() {
        Core.LocalStorageManagerController.superclass.constructor.apply(this, arguments)
    },
    storeData: function(a, b) {
        this.model.writeToStorage(a, b)
    },
    readData: function(a) {
        return this.model.readFromStorage(a)
    },
    removeData: function(a) {
        this.model.removeFromStorage(a)
    },
    hasData: function(a) {
        return this.model.hasData(a)
    }
};
Core.LocalStorageManagerController = Sys.extend(Core.Controller, Core.LocalStorageManagerController, "Core.LocalStorageManagerController");
Sys.ns("Core");
Core.LocalStorageManagerModel = {
    constructor: function() {
        Core.LocalStorageManagerModel.superclass.constructor.apply(this, arguments)
    },
    writeToStorage: function(a, b) {
        if (this.readData("storageActive")) {
            if (typeof a === "string" && typeof b === "string") {
                this._setItemInStorage(this.accessKey + a, b)
            }
        }
    },
    readFromStorage: function(a) {
        var b = this;
        if (b.readData("storageActive")) {
            if (!Sys.isDefined(a)) {
                return b.getAllData()
            }
            if (typeof a === "string") {
                return b._getItemFromStorage(b.accessKey + a)
            }
        }
        return false
    },
    removeFromStorage: function(a) {
        if (this.readData("storageActive")) {
            if (typeof a === "string") {
                this._removeItemFromStorage(this.accessKey + a)
            }
        }
    },
    hasData: function(a) {
        if (Sys.isDefined(a)) {
            if (typeof this.readFromStorage(a) === "string") {
                return true
            }
        }
        return false
    },
    setupData: function() {
        var a = Resources.readData("queryData");
        this.accessKey = "netent." + a.operatorId + "." + a.gameId + ".";
        this.storeData("storageActive", this.isLocalStorageSupported())
    },
    createAccessKey: function(a, b, c) {
        if (Sys.isDefined(a) && Sys.isDefined(b) && Sys.isDefined(c)) {
            return this.hashValue(a + "." + b + "." + c) + "."
        }
        return undefined
    },
    activate: function() {
        this.storeData("storageActive", true)
    },
    deactivate: function() {
        this.storeData("storageActive", false)
    },
    getAllData: function() {
        var c = this,
            d = {},
            b = 0,
            a = c._getKeyFromStorage(b);
        while (a) {
            if (a.indexOf(c.accessKey) === 0) {
                d[a.replace(c.accessKey, "")] = c._getItemFromStorage(a)
            }++b;
            a = c._getKeyFromStorage(b)
        }
        return d
    },
    hashValue: function(c) {
        var d = 2285455121,
            b, a;
        if (typeof c !== "string") {
            return null
        }
        for (a = 0, b = c.length; a < b; a++) {
            d += c.charCodeAt(a) * (a + 1)
        }
        return d
    },
    isLocalStorageSupported: function() {
        if ((typeof window.localStorage === "object")) {
            try {
                this._setItemInStorage("availabilityCheck", "true");
                this._removeItemFromStorage("availabilityCheck");
                return true
            } catch (a) {
                return false
            }
        }
        return false
    },
    _setItemInStorage: function(a, b) {
        localStorage.setItem(a, b)
    },
    _removeItemFromStorage: function(a) {
        localStorage.removeItem(a)
    },
    _getItemFromStorage: function(a) {
        return localStorage.getItem(a)
    },
    _getKeyFromStorage: function(a) {
        return localStorage.key(a)
    }
};
Core.LocalStorageManagerModel = Sys.extend(Core.Model, Core.LocalStorageManagerModel, "Core.LocalStorageManagerModel");
Sys.ns("Core");
Core.AutoPlayer = {
    constructor: function() {
        Core.AutoPlayer.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.AutoPlayerModel,
            controller: Core.AutoPlayerController
        }
    }
};
Core.AutoPlayer = Sys.extend(Core.Module, Core.AutoPlayer, "Core.AutoPlayer");
Sys.ns("Core");
Core.AutoPlayerController = {
    constructor: function() {
        Core.AutoPlayerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:autoPlayer.stop": this.stop,
            "request:autoPlayer.pause": this.pause,
            "request:autoPlayer.start": this.start,
            "request:autoPlayer.resume": this.resume,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:serverManager.serverErrorReceived": this.stop,
            "notify:stateHandler.leavingIdleState": this.onLeavingIdleState,
            "notify:stateHandler.enteringIdleState": this.onEnteringIdleState,
            "notify:stateHandler.enteringStandardWinPresentationState": this.onEnteringWinPresentationState,
            "notify:stateHandler.enteringBigWinState": this.onEnteringWinPresentationState,
            "notify:spinButton.clicked": this.onSpinButtonClicked,
            "notify.dialogWindow.showingDialog": this.onShowingDialog,
            "notify:dialogWindow.allDialogsClosed": this.onAllDialogsClosed,
            "notify:settingsManager.settingChanged": this.onSettingChanged,
            "notify:errorManager.error": this.stop
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    playRound: function() {
        if (this.model.readData("nrRounds") > 0) {
            this.requestRoundStart()
        }
    },
    start: function() {
        this.play();
        if (!this.model.readData("spinning") && this.model.readData("isBasicState")) {
            this.requestRoundStart()
        }
    },
    stop: function() {
        if (!this.model.isState("STOPPED")) {
            this.fireEvent("request:spinButton.removeProperty", "visibleDuringRound", this.MODULE_NAME);
            this.fireEvent("request:spinButton.hideCounter");
            this.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
            this.fireEvent("request:spinButton.removeDisplayType", "autoPlayStop");
            this.fireEvent("request:quickStopper.enableInMode", "autoPlay");
            this.fireEvent("request:playModeManager.removeMode", "autoplay");
            this.model.setState("STOPPED");
            this.model.storeData("nrRounds", 0);
            this.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0);
            this.fireEvent("request:spinButton.enable", this.MODULE_NAME);
            this.fireEvent("request:settingsButton.enable", this.MODULE_NAME);
            this.fireEvent("request:pluginMenu.enable", this.MODULE_NAME);
            this.fireEvent("request:betSettings.enable", this.MODULE_NAME);
            this.fireEvent("request:maxBetButton.enable", this.MODULE_NAME);
            this.fireEvent("notify:autoPlayer.stopped")
        }
    },
    pause: function() {
        if (this.model.isState("PLAYING")) {
            this.model.setState("PAUSED")
        }
    },
    resume: function() {
        var a = this;
        if (this.model.isState("PAUSED")) {
            this.model.setState("PLAYING");
            if (!a.model.readData("spinning")) {
                a.playRound()
            }
        }
    },
    play: function() {
        var a = this;
        if (!a.model.isState("PLAYING") && a.model.readData("nrRounds") > 0) {
            a.model.setState("PLAYING");
            a.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
            a.fireEvent("request:spinButton.addDisplayType", "autoPlayStop");
            a.fireEvent("request:quickStopper.disableInMode", "autoPlay");
            a.fireEvent("request:spinButton.disable", a.MODULE_NAME);
            a.fireEvent("request:betSettings.disable", a.MODULE_NAME);
            a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
            a.fireEvent("request:settingsButton.disable", a.MODULE_NAME);
            a.fireEvent("request:pluginMenu.disable", a.MODULE_NAME);
            a.fireEvent("notify:autoPlayer.starting");
            a.fireEvent("request:playModeManager.addMode", "autoplay")
        }
    },
    onSpinButtonClicked: function(a) {
        if (Sys.isDefined(a) && a.hasOwnProperty("skip") && a.skip === true) {
            return false
        }
        if (this.model.isState("PLAYING") || this.model.isState("PAUSED") || this.model.isState("STOPPING")) {
            this.stop()
        }
        return true
    },
    onEnteringIdleState: function() {
        var b = this,
            a = b.model;
        a.storeData("spinning", false);
        if (a.isState("PLAYING")) {
            b.playRound()
        }
        if (a.isState("STOPPING")) {
            b.stop()
        }
        if (a.isState("WAITING")) {
            b.fireEvent("request:playModeManager.addMode", "autoplay");
            b.play();
            b.requestRoundStart()
        }
    },
    onLeavingIdleState: function() {
        var a = this;
        a.model.storeData("spinning", true);
        if (a.model.isState("WAITING")) {
            a.fireEvent("request:playModeManager.addMode", "autoplay");
            a.play()
        }
        if (a.model.isState("PLAYING")) {
            a.fireEvent("request:spinButton.updateCounter", a.model.readData("nrRounds"))
        }
    },
    onEnteringWinPresentationState: function() {
        var b = this,
            a = b.model;
        if (a.isState("STOPPING") && Services.settingsManager.getSetting("autoPlayNrSpins") > 0) {
            b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
        }
    },
    onShowingDialog: function() {
        if (this.model.readData("nrRounds") > 0) {
            this.pause()
        }
    },
    onAllDialogsClosed: function() {
        if (this.model.readData("nrRounds") > 0) {
            this.resume()
        }
    },
    reduceNumberOfRounds: function() {
        this.model.playRound();
        this.fireEvent("request:spinButton.updateCounter", this.model.readData("nrRounds"));
        this.fireEvent("notify:autoPlayer.reduceCounter", this.model.readData("nrRounds"))
    },
    onSettingChanged: function(a, c) {
        var b = this;
        if (a === "autoPlayNrSpins" && c !== b.model.readData("nrRounds")) {
            b.model.storeData("nrRounds", c);
            if (c === 0) {
                b.stop()
            } else {
                b.fireEvent("notify:autoPlayer.enabled", c);
                b.fireEvent("request:spinButton.showCounter", c);
                b.fireEvent("request:spinButton.addDisplayType", "autoPlay");
                b.fireEvent("request:spinButton.addProperty", "visibleDuringRound", b.MODULE_NAME);
                b.model.setState("WAITING");
                b.model.storeData("startingBalance", Services.moneyManager.getBalanceCents())
            }
        } else {
            if (["stopAutoplayIfBalanceIncreasedBy", "stopAutoplayIfBalanceDecreasedBy", "stopAutoplayOnAnyWin", "stopAutoplayIfWinExceeds"].contains(a)) {
                b.model.storeData(a, c)
            }
        }
    },
    requestRoundStart: function() {
        this.reduceNumberOfRounds();
        this.fireEvent("notify:autoPlayer.startRound", this.model.readData("nrRounds"));
        this.fireEvent("request:spinButton.startRound")
    }
};
Core.AutoPlayerController = Sys.extend(Core.Controller, Core.AutoPlayerController, "Core.AutoPlayerController");
Sys.ns("Core");
Core.AutoPlayerModel = {
    constructor: function() {
        Core.AutoPlayerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("nrRounds", 0);
        this.storeData("spinning", true);
        this.storeData("startingBalance", 0);
        this.storeData("stopAutoplayIfBalanceIncreasedBy", false);
        this.storeData("stopAutoplayIfBalanceDecreasedBy", false);
        this.storeData("stopAutoplayOnAnyWin", false);
        this.storeData("stopAutoplayIfWinExceeds", false);
        this.setState("STOPPED")
    },
    playRound: function() {
        var a = this.readData("nrRounds") - 1;
        if (a <= 0) {
            a = 0;
            this.setState("STOPPING")
        }
        this.storeData("nrRounds", a)
    },
    storeData: function(a, b) {
        Core.AutoPlayerModel.superclass.storeData.apply(this, arguments);
        if (a === "nrRounds") {
            Services.storage.storeData("autoPlayer.roundsLeft", b)
        }
    },
    shouldPlayAnotherRound: function() {
        return this.isState("PLAYING")
    },
    shouldStopAutoplay: function(e) {
        var d = this.readData("startingBalance"),
            i = this.readData("stopAutoplayIfBalanceIncreasedBy"),
            a = this.readData("stopAutoplayIfBalanceDecreasedBy"),
            c = this.readData("stopAutoplayOnAnyWin"),
            g = this.readData("stopAutoplayIfWinExceeds"),
            b = e.nextaction === "spin" ? Services.moneyManager.getBetCents() : 0,
            f, h;
        if (Sys.isObj(e.wins)) {
            f = e.wins.cents;
            h = e.wins.centsTotal
        }
        if ((i !== false && i !== 0) && (e.credit >= d + i)) {
            return true
        }
        if ((a !== false && a !== 0) && (e.credit - b < d - a)) {
            return true
        }
        if (c === true && (f > 0 || h > 0)) {
            return true
        }
        return g !== false && g !== 0 && (f >= g || h >= g)
    },
    processServerResponse: function(b) {
        var a = b.gamestate || {};
        if (!this.isState("STOPPED") && this.shouldStopAutoplay(b)) {
            this.setState("STOPPING")
        }
        this.storeData("isBasicState", a.current === "basic")
    }
};
Core.AutoPlayerModel = Sys.extend(Core.Model, Core.AutoPlayerModel, "Core.AutoPlayerModel");
Sys.ns("Core");
Core.G4 = {
    constructor: function() {
        Core.G4.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.G4Model,
            view: Core.View,
            controller: Core.G4Controller
        }
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            minimumRoundTimeEnforcement: {
                state: {
                    name: "MinimumRoundTimeEnforcement",
                    execute: function(b) {},
                    waitEvents: {
                        "notify:g4.minimumRoundTimePassed": false
                    }
                }
            },
            stopped: {
                queue: [function(b) {
                    if (a.isG4() && a.isNewRound()) {
                        b.stateHandler.pushState(b.states.minimumRoundTimeEnforcement)
                    }
                }]
            }
        }
    }
};
Core.G4 = Sys.extend(Core.Module, Core.G4, "Core.G4");
Sys.ns("Core");
Core.G4Model = {
    constructor: function() {
        Core.G4Model.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponse") || {};
        this.storeData("isG4", a.g4mode);
        this.storeData("G4Config", this.setupG4Config());
        this.storeData("isNewRound", false);
        this.storeData("roundTimeLimit", 3000);
        this.storeData("disabledDuringRound", false)
    },
    isG4: function() {
        return this.readData("isG4")
    },
    setupG4Config: function() {
        return {
            settings: [{
                name: "quickSpin",
                enabled: false,
                offValue: false
            }],
            modules: [{
                name: "systemClock",
                enabled: true
            }, {
                name: "quickStopper",
                enabled: false
            }]
        }
    },
    getMinimumTimeLeft: function() {
        var a = this.getRoundStartTime() + this.readData("roundTimeLimit"),
            b = a - Date.now();
        return b > 0 ? b : 0
    },
    isNewRound: function() {
        return this.readData("isNewRound")
    },
    setRoundStartTime: function() {
        var a = Date.now();
        this.storeData("roundStartTime", a)
    },
    getRoundStartTime: function() {
        return this.readData("roundStartTime")
    },
    getG4Config: function(b) {
        var a = this.readData("G4Config");
        if (a.hasOwnProperty(b)) {
            return a[b]
        }
        return undefined
    }
};
Core.G4Model = Sys.extend(Core.Model, Core.G4Model, "Core.G4Model");
Sys.ns("Core");
Core.G4DesktopModel = {
    constructor: function() {
        Core.G4DesktopModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        Core.G4DesktopModel.superclass.setupData.apply(this, arguments);
        this.storeData("disabledDuringRound", true)
    }
};
Core.G4DesktopModel = Sys.extend(Core.G4Model, Core.G4DesktopModel, "Core.G4DesktopModel");
Sys.ns("Core");
Core.G4Controller = {
    constructor: function() {
        Core.G4Controller.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.initG4IfActive,
            "notify:stateHandler.enteringMinimumRoundTimeEnforcementState": a.minimumRoundTimeEnforcement,
            "notify:stateHandler.enteringSpinningState": a.onStartSpin
        })
    },
    initG4IfActive: function() {
        var b = this,
            a;
        if (b.model.readData("isG4")) {
            a = b.model.readData("G4Config");
            b.requestModuleChanges(a.modules);
            b.requestSettingChanges(a.settings);
            if (b.model.readData("disabledDuringRound")) {
                b.fireEvent("request:spinButton.addProperty", "disabledDuringRound", b.MODULE_NAME)
            }
        }
    },
    minimumRoundTimeEnforcement: function() {
        var c = this,
            d, a, b;
        if (c.model.isNewRound()) {
            b = c.model.getMinimumTimeLeft();
            a = c.model.readData("roundExtensionTimer");
            if (b > 0) {
                if (Sys.isDefined(a)) {
                    clearTimeout(a)
                }
                d = setTimeout(function() {
                    c.fireEvent("notify:g4.minimumRoundTimePassed")
                }, b);
                c.model.storeData("roundExtensionTimer", d)
            } else {
                c.fireEvent("notify:g4.minimumRoundTimePassed")
            }
        }
    },
    onStartSpin: function() {
        this.model.storeData("isNewRound", true);
        this.model.setRoundStartTime()
    },
    requestSettingChanges: function(a) {
        var b = this;
        Sys.each(a, function(c) {
            if (c.enabled) {
                b.dispatchRequestEnableSettingEvent(c.name)
            } else {
                if (!c.enabled) {
                    b.dispatchRequestDisableSettingEvent(c.name, c.offValue)
                }
            }
        })
    },
    requestModuleChanges: function(a) {
        var b = this;
        Sys.each(a, function(c) {
            if (c.enabled) {
                b.dispatchRequestEnableModuleEvent(c.name)
            } else {
                if (!c.enabled) {
                    b.dispatchRequestDisableModuleEvent(c.name)
                }
            }
        })
    },
    dispatchRequestDisableSettingEvent: function(a, b) {
        var c = this;
        if (Sys.isDefined(b)) {
            c.fireEvent("request:settingsManager.storeValue", a, b)
        }
        c.fireEvent("request:settingsManager.disableSetting", a);
        c.fireEvent("request:settingsManager.lockSetting", a, c.MODULE_NAME)
    },
    dispatchRequestEnableSettingEvent: function(a) {
        this.fireEvent("request:settingsManager.enableSetting", a)
    },
    dispatchRequestDisableModuleEvent: function(a) {
        this.fireEvent("request:" + a + ".disableInMode", "g4")
    },
    dispatchRequestEnableModuleEvent: function(a) {
        this.fireEvent("request:" + a + ".enableInMode", "g4")
    }
};
Core.G4Controller = Sys.extend(Core.Controller, Core.G4Controller, "Core.G4Controller");
Sys.ns("Core");
Core.PlayModeManager = {
    constructor: function() {
        Core.PlayModeManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.PlayModeManagerModel,
            controller: Core.PlayModeManagerController
        }
    }
};
Core.PlayModeManager = Sys.extend(Core.Module, Core.PlayModeManager, "Core.PlayModeManager");
Sys.ns("Core");
Core.PlayModeManagerController = {
    USE_LOGGING: false,
    constructor: function() {
        Core.PlayModeManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:playModeManager.addMode": a.addMode,
            "request:playModeManager.removeMode": a.removeMode
        })
    },
    addMode: function(a) {
        this.model.addMode(a)
    },
    removeMode: function(a) {
        this.model.removeMode(a)
    }
};
Core.PlayModeManagerController = Sys.extend(Core.Controller, Core.PlayModeManagerController, "Core.PlayModeManagerController");
Sys.ns("Core");
Core.PlayModeManagerModel = {
    constructor: function() {
        Core.PlayModeManagerModel.superclass.constructor.apply(this, arguments)
    },
    addMode: function(b) {
        var a = this.readData("modes");
        if (a.indexOf(b) === -1) {
            a.push(b);
            this.storeModeString()
        }
    },
    removeMode: function(c) {
        var b = this.readData("modes"),
            a = b.indexOf(c);
        if (a >= 0) {
            b.splice(a, 1);
            this.storeModeString()
        }
    },
    getModeString: function() {
        var b = this.readData("modes"),
            d = b.length,
            c = "",
            a;
        for (a = -1; ++a < d;) {
            c += ((a > 0) ? "," : "") + b[a]
        }
        return c
    },
    setupData: function() {
        this.storeData("modes", []);
        this.storeModeString()
    },
    storeModeString: function() {
        Services.storage.storeData(this.MODULE_NAME + ".modes", this.getModeString())
    }
};
Core.PlayModeManagerModel = Sys.extend(Core.Model, Core.PlayModeManagerModel, "Core.PlayModeManagerModel");
Sys.ns("Core.Slots");
Core.Slots.FreeRounds = {
    constructor: function() {
        Core.Slots.FreeRounds.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            beforeLoaderClose: {
                queue: [function(b) {
                    if (a.hasFreeRounds() && !a.readData("hasShownSplash")) {
                        b.stateHandler.pushState(b.states.freeRoundsDialog)
                    }
                }]
            },
            stopped: {
                queue: [function(b) {
                    if (a.readData("freeRoundsLeft") === 0) {
                        b.stateHandler.pushState(b.states.checkForAdditionalFreeRounds)
                    }
                }]
            },
            checkForAdditionalFreeRounds: {
                state: {
                    name: "CheckForAdditionalFreeRounds",
                    execute: function() {},
                    waitEvents: {
                        "notify:responseParser.gameConfigurationParsed": false
                    }
                }
            },
            freeRoundsDialog: {
                state: {
                    name: "FreeRoundsDialog",
                    execute: function() {},
                    waitEvents: {}
                }
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.FreeRoundsModel,
            controller: Core.Slots.FreeRoundsController
        }
    }
};
Core.Slots.FreeRounds = Sys.extend(Core.Module, Core.Slots.FreeRounds, "Core.Slots.FreeRounds");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsController = {
    constructor: function() {
        Core.Slots.FreeRoundsController.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        Core.Slots.FreeRoundsController.superclass.init.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringFreeRoundsDialogState": this.showEnforcedContinueDialog,
            "notify:stateHandler.enteringCheckForAdditionalFreeRoundsState": this.requestGameConfiguration,
            "notify:responseParser.responseParsed": this.onResponseParsed,
            "notify:responseParser.gameConfigurationParsed": this.onGameConfigurationParsed,
            "request:freeRounds.requestGameConfiguration": this.requestGameConfiguration
        })
    },
    onResponseParsed: function(a) {
        this.model.handleFreeRounds(a)
    },
    startFreeRounds: function() {
        this.freeRoundsStarted = true;
        this.addListener("notify:stateHandler.enteringIdleState", this.onEnteringIdleState);
        this.addListener("notify:stateHandler.leavingIdleState", this.onLeavingIdleState);
        this.fireEvent("request:maxBetButton.disable", this.MODULE_NAME);
        this.fireEvent("request:betSettings.disable", this.MODULE_NAME);
        this.fireEvent("notify:freeRounds.started", this.model.readData("freeRoundsLeft"));
        this.setFreeroundModeParameter(true);
        this.model.storeData("hasShownSplash", true);
        this.model.storeData("totalFreeRounds", this.model.readData("freeRoundsLeft"))
    },
    endFreeRounds: function() {
        this.freeRoundsStarted = false;
        this.showFreeRoundsEndDialog();
        this.model.removeData("freeRoundsLeft");
        this.removeListener("notify:stateHandler.enteringIdleState");
        this.removeListener("notify:stateHandler.leavingIdleState");
        this.fireEvent("request:maxBetButton.enable", this.MODULE_NAME);
        this.fireEvent("notify:freeRounds.ended")
    },
    setFreeroundModeParameter: function(a) {
        this.setExtraParameter("freeroundmode", a)
    },
    setExtraParameter: function(c, a) {
        var b = Resources.readData("extraParams");
        if (Sys.isObj(b)) {
            b[c] = a;
            Resources.storeData("extraParams", b)
        }
    },
    onEnteringIdleState: function() {
        this.requestCounterUpdate()
    },
    onLeavingIdleState: function() {
        this.notifyFreeRoundsLeft()
    },
    notifyFreeRoundsLeft: function() {
        var b = this.model.readData("totalFreeRounds"),
            a = this.model.readData("freeRoundsLeft");
        this.fireEvent("notify:freeRounds.nextRound", b, a)
    },
    requestGameConfiguration: function() {
        this.fireEvent("request:autoPlayer.stop");
        this.setFreeroundModeParameter(false);
        this.fireEvent("request:serverManager.sendAction", "init", "notify:responseParser.gameConfigurationParsed", "notify:serverManager.reInitRequestFailed")
    },
    onGameConfigurationParsed: function(d, a) {
        var c = this,
            b = (d.nextaction === "spin");
        Resources.storeData("gameServerInitResponse", Sys.utils.qsToObj(a.responseText));
        Resources.storeData("gameServerInitResponseObject", d);
        Resources.storeData("unParsedGameServerInitResponse", a.responseText);
        this.bonusProgramWidgetQueued = Boolean(d.freeRoundWidgetEnabled);
        this.bonusProgramWidgetActive = Boolean(Resources.readData("bonusProgramWidgetActive"));
        this.model.storeData("hasShownSplash", false);
        this.model.handleFreeRounds(d);
        if (this.model.readData("freeRoundsLeft") > 0) {
            if (this.model.readData("isLowWinFreeRound")) {
                this.showExtraFreeRoundsDialog()
            } else {
                if (this.bonusProgramWidgetActive) {
                    this.fireEvent("notify:freeRounds.reInitResponseReceived", d);
                    this.startFreeRounds();
                    Resources.removeData("bonusProgramWidgetActive")
                } else {
                    this.showFreeRoundsEndDialog();
                    this.fireEvent("request:cashField.showBasicCashValues");
                    this.showEnforcedContinueDialog(function() {
                        c.fireEvent("notify:dialogBoxClosed", {
                            name: "freeRoundsStart",
                            button: "continue"
                        });
                        c.fireEvent("notify:freeRounds.reInitResponseReceived", d);
                        c.startFreeRounds()
                    })
                }
            }
            this.requestCounterUpdate();
            this.notifyFreeRoundsLeft();
            this.setFreeroundModeParameter(true)
        } else {
            if (!b) {
                this.showFreeRoundsReloadDialog()
            } else {
                if (this.freeRoundsStarted) {
                    this.endFreeRounds()
                }
            }
        }
    },
    requestCounterUpdate: function() {
        Services.storage.storeData("freeRounds.roundsLeft", this.model.readData("freeRoundsLeft"))
    },
    closeFreeRoundsDialog: function() {
        this.fireEvent("notify:freeRounds.dialogClosed");
        if (this.bonusProgramWidgetQueued) {
            this.fireEvent("notify:bonusProgramWidget.reInit", Resources.readData("gameServerInitResponse"));
            this.bonusProgramWidgetQueued = false
        }
    },
    showExtraFreeRoundsDialog: function() {
        var a = this;
        a.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsExtraTitle),
            text: Services.languageManager.getText(Language.Keys.freeRoundsExtraWon, [this.model.readData("freeRoundsLeft")]),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "freeRoundsExtra",
                        button: "continue"
                    });
                    a.closeFreeRoundsDialog()
                }
            }]
        })
    },
    showFreeRoundsReloadDialog: function() {
        var a = this;
        a.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsFinished),
            text: Services.languageManager.getText(Language.Keys.roundsUseAcctMoney) + " " + Services.languageManager.getText(Language.Keys.reload),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys.btn_reload),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "freeRoundsReload",
                        button: "reload"
                    });
                    Sys.utils.reload()
                }
            }]
        })
    },
    showFreeRoundsEndDialog: function() {
        var a = this;
        a.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsFinished),
            text: Services.languageManager.getText(Language.Keys.roundsUseAcctMoney),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "freeRoundsEnd",
                        button: "continue"
                    });
                    a.closeFreeRoundsDialog()
                }
            }]
        })
    },
    showEnforcedContinueDialog: function(b) {
        var a = this;
        a.requestDialog({
            title: Services.languageManager.getText(Language.Keys.roundsLeft),
            text: Services.languageManager.getText(Language.Keys.haveFreeRounds, [this.model.readData("freeRoundsLeft")]),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: b || function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "freeRoundsStart",
                        button: "continue"
                    });
                    a.startFreeRounds()
                }
            }]
        })
    },
    requestDialog: function(a) {
        this.fireEvent("request:dialogWindow.showDialog", a)
    }
};
Core.Slots.FreeRoundsController = Sys.extend(Core.Controller, Core.Slots.FreeRoundsController, "Core.Slots.FreeRoundsController");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsModel = {
    constructor: function() {
        Core.Slots.FreeRoundsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponseObject");
        this.storeData("hasShownSplash", false);
        this.handleFreeRounds(a)
    },
    hasFreeRounds: function() {
        return this.readData("freeRoundsLeft") > 0
    },
    handleFreeRounds: function(a) {
        if (Sys.isNumber(a.freeRoundsLeft)) {
            this.storeData("freeRoundsLeft", a.freeRoundsLeft);
            this.storeData("isLowWinFreeRound", a.isLowWinFreeRound)
        } else {
            this.removeData("freeRoundsLeft");
            this.removeData("isLowWinFreeRound")
        }
    }
};
Core.Slots.FreeRoundsModel = Sys.extend(Core.Model, Core.Slots.FreeRoundsModel, "Core.Slots.FreeRoundsModel");
Sys.ns("Core.Slots");
Core.Slots.ServerManager = {
    constructor: function() {
        Core.Slots.ServerManager.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            spinning: {
                queue: [function(a) {
                    a.stateHandler.pushState(a.states.processServerResponse)
                }]
            },
            processServerResponse: {
                state: {
                    name: "ProcessServerResponse",
                    execute: function(a) {},
                    waitEvents: {}
                }
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.ServerManagerModel,
            view: Core.View,
            controller: Core.Slots.ServerManagerController
        }
    }
};
Core.Slots.ServerManager = Sys.extend(Core.Module, Core.Slots.ServerManager, "Core.Slots.ServerManager");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerController = {
    constructor: function() {
        Core.Slots.ServerManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Core.Slots.ServerManagerController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "notify:responseParser.responseParsed": a.storeNextAction,
            "notify:settingsManager.settingChanged": a.onSettingsChanged
        })
    },
    onSettingsChanged: function(a, b) {
        if (a === "betLevel" || a === "denomination" || a === "betLines") {
            this.model.storeData("parameters:" + a, b)
        }
    },
    sendAction: function(b, a) {
        b = (b === "nextAction") ? this.model.readData("nextAction") : b;
        Core.Slots.ServerManagerController.superclass.sendAction.call(this, b, a)
    },
    storeNextAction: function(a) {
        this.model.storeData("nextAction", a.nextaction)
    }
};
Core.Slots.ServerManagerController = Sys.extend(Core.ServerManagerController, Core.Slots.ServerManagerController, "Core.Slots.ServerManagerController");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerModel = {
    constructor: function() {
        Core.Slots.ServerManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var d = this,
            c, a, b;
        Core.Slots.ServerManagerModel.superclass.setupData.apply(d, arguments);
        c = Resources.readData("gameServerInitResponse");
        a = c["bl.standard"].split(",").length;
        b = "0-" + (a - 1).toString();
        d.storeData("parameters:betLines", b);
        d.storeData("nextAction", c.nextaction)
    },
    getActionParameters: function(a) {
        var b = this.getBaseParameters(a);
        b = b + this.getFreeroundsParameters();
        switch (a) {
            case "init":
                return b + this.getInitParameters();
            case "jmxinit":
                return b + this.getJMXInitParameters();
            case "paytable":
                return b + this.getPaytableParameters();
            case "spin":
                return b + this.getSpinParameters();
            case "initfreespin":
                return b + this.getInitFreespinParameters();
            case "respin":
            case "freespin":
                return b + this.getFreespinParameters();
            case "widgetspin":
                return b + this.getWidgetspinParameters();
            case "initbonus":
                return b + this.getInitBonusParameters();
            case "bonusaction":
                return b + this.getBonusActionParameters();
            default:
                return b
        }
    },
    getBaseParameters: function(a) {
        return "action=" + a + "&sessid=" + this.readData("parameter:sessionID") + "&gameId=" + this.readData("parameter:gameID") + "&wantsreels=true"
    },
    getFreeroundsParameters: function() {
        var a = Resources.readData("extraParams");
        return "&wantsfreerounds=" + a.wantsfreerounds + "&freeroundmode=" + a.freeroundmode
    },
    getInitParameters: function() {
        return ""
    },
    getJMXInitParameters: function() {
        return this.getInitParameters()
    },
    getPaytableParameters: function() {
        return ""
    },
    getSpinParameters: function() {
        var c = this,
            b = "&bet.betlevel=" + c.readData("parameters:betLevel") + "&bet.denomination=" + c.readData("parameters:denomination") + "&bet.betlines=" + c.readData("parameters:betLines"),
            a = c.readData("parameter:jmx");
        if (a) {
            b += "&" + a
        }
        return b
    },
    getInitFreespinParameters: function() {
        return this.getInitParameters()
    },
    getFreespinParameters: function() {
        var b = this.getInitParameters(),
            a = this.readData("parameter:jmx");
        if (a) {
            b += "&" + a
        }
        return b
    },
    getInitBonusParameters: function() {
        var b = "&bonusid=" + this.readData("parameter:bonusid"),
            a = this.readData("parameter:jmx");
        if (a) {
            b += "&" + a
        }
        return b
    },
    getBonusActionParameters: function() {
        var b = "",
            c = this.readData("parameter:bonusactiontype"),
            a = this.readData("parameter:jmx");
        if (c) {
            b += "&bonusactiontype=" + c
        }
        if (a) {
            b += "&" + a
        }
        return b
    },
    getWidgetspinParameters: function() {
        return "&bonusProgramId=" + Resources.readData("gameServerInitResponse").bonusProgramId
    }
};
Core.Slots.ServerManagerModel = Sys.extend(Core.ServerManagerModel, Core.Slots.ServerManagerModel, "Core.Slots.ServerManagerModel");
Sys.ns("Core.Slots");
Core.Slots.ResponseParser = {
    constructor: function() {
        Core.Slots.ResponseParser.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            view: Core.View,
            controller: Core.Slots.ResponseParserController
        }
    }
};
Core.Slots.ResponseParser = Sys.extend(Core.ResponseParser, Core.Slots.ResponseParser, "Core.Slots.ResponseParser");
Sys.ns("Core.Slots");
Core.Slots.ResponseParserController = {
    constructor: function() {
        Core.Slots.ResponseParserController.superclass.constructor.apply(this, arguments)
    },
    parseServerResponse: function(e) {
        var c = this,
            d = Core.Slots.ResponseParserController.superclass.parseServerResponse.call(c, e),
            a = Resources.readData("config"),
            b;
        if (d.gamestate) {
            d.currentGameState = c.getCurrentGameState(d)
        }
        if (d.rs) {
            d.rs = this.sortReelSets(d.rs, a.expectedReelSetOrder);
            b = this.parseReelInfo(d);
            d.reelInfo = b;
            d.nearWinList = this.parseNearWin(d);
            if (d.ws) {
                d.wins = c.parseWinSituations(d, b);
                d.wins.winType = c.setWinType(d.wins.coins, Services.moneyManager.getBetCoins());
                d.wins.centsTotal = d.totalwin.cents;
                d.wins.coinsTotal = d.totalwin.coins
            } else {
                if (Sys.isDefined(d.totalwin)) {
                    d.wins = {
                        centsTotal: d.totalwin.cents,
                        coinsTotal: d.totalwin.coins
                    }
                }
            }
        } else {
            if (Sys.isDefined(d.totalwin)) {
                d.wins = {
                    centsTotal: d.totalwin.cents,
                    coinsTotal: d.totalwin.coins
                }
            }
        }
        return d
    },
    sortReelSets: function(b, a) {
        // alert('test');
        return Object.keys(b).map(function(c) {
            return b[c]
        })
        // .sort(function(d, c) {
        //     if (a) {
        //         if (a.indexOf(d.id) === -1 || a.indexOf(c.id) === -1) {
        //             throw new Error("Missing order of item.")
        //         }
        //         return a.indexOf(d.id) > a.indexOf(c.id) ? 1 : -1
        //     }
        //     return d.id > c.id ? 1 : -1
        // })
        .reduce(function(e, d, c) {
            e["i" + c] = d;
            return e
        }, {})
    },
    getCurrentGameState: function(c) {
        var b = this,
            a = b.model.readData("currentServerGameState");
        if (c.gamestate.current) {
            b.model.storeData("currentServerGameState", c.gamestate.current)
        } else {
            b.model.storeData("currentServerGameState", c.gamestate)
        }
        if (!a) {
            a = b.model.readData("currentServerGameState");
            if (a === "basic") {
                b.fireEvent("request:playModeManager.addMode", "basic")
            }
        }
        return a
    },
    parseNearWin: function(b) {
        var a;
        if (Sys.isDefined(b.rs.i0)) {
            a = b.rs.i0.nearwin;
            if (Sys.isArray(a)) {
                return a
            } else {
                if (Sys.isNumber(a)) {
                    return [a]
                }
            }
        }
        return undefined
    },
    setWinType: function(e, a) {
        var b = Resources.readData("config"),
            d = b.winTypes,
            c = "";
        if (e > 0) {
            if ((e >= a * d.smallWin.from) && (e < a * d.smallWin.to)) {
                c = "smallWin"
            } else {
                if ((e >= a * d.mediumWin.from) && (e < a * d.mediumWin.to)) {
                    c = "mediumWin"
                } else {
                    if ((e >= a * d.largeWin.from) && (e < a * d.largeWin.to)) {
                        c = "largeWin"
                    } else {
                        if (e >= a * d.bigWin.from) {
                            c = "bigWin"
                        }
                    }
                }
            }
        }
        return c
    },
    parseReelInfo: function(a) {
        return Sys.utils.parseReelInfo(a)
    },
    parseWinSituations: function(b, c) {
        var d = 0,
            a = [],
            e;
        if (b.ws) {
            while (b.ws["i" + d]) {
                a.push(b.ws["i" + d]);
                d++
            }
        }
        e = this.parseWinLayouts(a, c);
        this.doGameSpecificWinSituationParsing(e, a);
        return e
    },
    parseWinLayouts: function(a, f) {
        var b, g, c, d = [],
            i, j = 0,
            h = 0,
            e = 0;
        for (b = 0; b < a.length; b++) {
            d.push({
                betline: Sys.isNumber(a[b].betline) ? a[b].betline + 1 : undefined,
                positions: [],
                reelset: a[b].reelset,
                wins: {}
            });
            if (Sys.isDefined(a[b].pos)) {
                for (g = 0; Sys.isDefined(a[b].pos["i" + g]); g++) {
                    i = {};
                    i.reelIndex = a[b].pos["i" + g][0];
                    i.symbolIndex = a[b].pos["i" + g][1];
                    i = Sys.apply(i, f[i.reelIndex].symbols[i.symbolIndex]);
                    d[b].positions.push(i)
                }
                d[b].positions.sort(this.sortSymbols)
            }
            for (c = 0; Sys.isDefined(a[b].types["i" + c]) && Sys.isDefined(a[b].types["i" + c].wintype); c++) {
                d[b].wins.type = a[b].types["i" + c].wintype;
                if (a[b].types["i" + c].wintype === "coins") {
                    d[b].wins.coins = a[b].types["i" + c].coins;
                    d[b].wins.cents = a[b].types["i" + c].cents;
                    j += a[b].types["i" + c].coins;
                    h += a[b].types["i" + c].cents
                } else {
                    if (a[b].types["i" + c].wintype === "freespins") {
                        d[b].wins.freespins = a[b].types["i" + c].freespins;
                        e += a[b].types["i" + c].freespins
                    } else {}
                }
            }
        }
        d.sort(this.sortWinSituations);
        return {
            winSituations: d,
            coins: j,
            cents: h,
            freespins: e
        }
    },
    sortSymbols: function(b, a) {
        return b.reelIndex - a.reelIndex
    },
    sortWinSituations: function(b, a) {
        if (b.wins.coins) {
            if (a.wins.coins) {
                return a.wins.coins - b.wins.coins
            }
            return -1
        } else {
            if (a.wins.coins) {
                return 1
            }
        }
        return a.wins.freespins - b.wins.freespins
    },
    doGameSpecificWinSituationParsing: function(b, a) {}
};
Core.Slots.ResponseParserController = Sys.extend(Core.ResponseParserController, Core.Slots.ResponseParserController, "Core.Slots.ResponseParserController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayer = {
    ENGINE: false,
    constructor: function() {
        var a = Resources.readData("config") || {};
        this.ENGINE = a.enableWADE || this.ENGINE;
        Core.Audio.AudioPlayer.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            setupGame: {
                waitEvents: ["notify:audioPlayer.ready"]
            }
        }
    },
    getMixinDependencies: function() {
        return ["trigger"]
    },
    getDefaultMVCClasses: function() {
        if (Utils.Platform.isWebAudioAPISupported()) {
            return {
                model: Core.Audio.AudioPlayerModel,
                view: this.ENGINE ? Core.Audio.AudioPlayerEngineView : Core.Audio.AudioPlayerView,
                controller: Core.Audio.AudioPlayerController
            }
        }
        return {
            model: Core.Audio.AudioPlayerModel,
            view: Core.Audio.Legacy.LegacyAudioPlayerView,
            controller: Core.Audio.AudioPlayerController
        }
    }
};
Core.Audio.AudioPlayer = Sys.extend(Core.Module, Core.Audio.AudioPlayer, "Core.Audio.AudioPlayer");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerController = {
    constructor: function() {
        Core.Audio.AudioPlayerController.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Core.Audio.AudioPlayerController.superclass.init.apply(a, arguments);
        a.soundsToLoadOnEnable = ["main"];
        if (Sys.isDefined(Resources.readData("preloadedAudio"))) {
            a.model.storeData("hasPreloadedAudio", true);
            a.view.decodePreloadedAudio()
        } else {
            setTimeout(function() {
                a.fireEvent("notify:audioPlayer.ready")
            }, 0);
            a.model.storeData("hasPreloadedAudio", false)
        }
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:platform.visibilityChanged": a.onPageVisibilityChanged,
            "request:audioPlayer.play": a.play,
            "request:audioPlayer.stop": a.stop,
            "request:audioPlayer.stopAll": a.stopAll,
            "request:audioPlayer.stopNonLooping": a.stopNonLooping,
            "request:audioPlayer.loadSounds": a.loadSounds,
            "request:audioPlayer.disableEventInteractions": a.onDisableEventInteractions,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:resourceLoader.soundLoaded": a.view.onSoundResourceLoaded.bind(a.view),
            "notify:resourceLoader.soundLoadingFailed": a.handleLoadError,
            "notify:settingsManager.settingChanged": a.onSettingsChanged,
            "view:loadResource": a.fireEvent.bind(a, "request:resourceLoader.loadResource"),
            "view:soundLoaded": a.onSoundLoaded,
            "view:audioLoadError": a.handleLoadError
        })
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:audioPlayer.soundLoaded", this, "When the sound is loaded")
    },
    onDisableEventInteractions: function() {
        var a = this;
        a.removeListener("request:audioPlayer.play");
        a.removeListener("request:audioPlayer.stop");
        a.removeListener("request:audioPlayer.stopAll");
        a.removeListener("request:audioPlayer.stopNonLooping")
    },
    onSoundLoaded: function() {
        this.fireEvent("notify:audioPlayer.soundPlayable");
        this.fireEvent("notify:audioPlayer.soundLoaded");
        this.fireEvent("notify:audioPlayer.ready")
    },
    onBeforeLoaderClose: function() {
        this.setAudioState(this.model.readData("hasPreloadedAudio"))
    },
    onSettingsChanged: function(a, b) {
        if (a === "volume") {
            this.adjustVolume(b)
        }
    },
    loadSounds: function(a) {
        var b = this;
        a = a || ["main"];
        if (!Sys.isArray(a)) {
            a = [a]
        }
        if (b.model.isState("audioEnabled")) {
            b.fireEvent("notify:audioPlayer.loadingSound");
            Sys.each(a, function(c) {
                b.view.loadSounds(c)
            })
        } else {
            Sys.each(a, function(c) {
                if (!b.soundsToLoadOnEnable.contains(c)) {
                    b.soundsToLoadOnEnable.push(c)
                }
            })
        }
    },
    adjustVolume: function(a) {
        if (Sys.isNumber(a) && a >= 0 && a <= 1) {
            this.view.setVolume(a);
            if (a > 0) {
                this.setAudioState(true)
            }
        }
    },
    setAudioState: function(b) {
        var c = this,
            d = b ? "audioEnabled" : "audioDisabled",
            a = c.soundsToLoadOnEnable.slice(0);
        if (c.model.isState(d)) {
            return
        }
        c.model.setState(d);
        c.fireEvent("notify:audioPlayer.audioStateSet", d);
        if (b && a.length > 0 && !c.model.readData("hasPreloadedAudio")) {
            c.loadSounds(a);
            c.soundsToLoadOnEnable.length = 0
        }
    },
    onPageVisibilityChanged: function(b) {
        var a;
        if (b && this.model.isState("audioEnabled")) {
            this.model.setState("audioDisabled:hidden");
            this.adjustVolume(0);
            if (Audio.Engine) {
                Audio.Engine.setVolume(0)
            }
        } else {
            if (!b && this.model.isState("audioDisabled:hidden")) {
                this.model.setState("audioEnabled");
                a = Services.settingsManager.getSetting("volume");
                this.adjustVolume(a);
                if (Audio.Engine) {
                    Audio.Engine.setVolume(a)
                }
            }
        }
    },
    play: function(b) {
        var a = this;
        if (!a.model.isState("audioEnabled") && Sys.isDefined(b) && Sys.isDefined(b.callback)) {
            b.callback();
            delete b.callback
        }
        a.view.play(b);
        a.fireEvent("notify:audioPlayer.playing", b)
    },
    stop: function(b, a) {
        this.view.stop(b, a);
        this.fireEvent("notify:audioPlayer.stop", b)
    },
    stopAll: function() {
        this.view.abort();
        this.fireEvent("notify:audioPlayer.stopAll")
    },
    stopNonLooping: function() {
        this.view.stopNonLooping();
        this.fireEvent("notify:audioPlayer.stopNonLooping")
    },
    handleLoadError: function(a) {
        throw new Error("Could not load audio.", a)
    }
};
Core.Audio.AudioPlayerController = Sys.extend(Core.Controller, Core.Audio.AudioPlayerController, "Core.Audio.AudioPlayerController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerModel = {
    constructor: function() {
        Core.Audio.AudioPlayerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("audioConfig");
        this.storeData("clips", a.clips);
        this.storeData("files", a.files)
    }
};
Core.Audio.AudioPlayerModel = Sys.extend(Core.Model, Core.Audio.AudioPlayerModel, "Core.Audio.AudioPlayerModel");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerView = {
    constructor: function() {
        Core.Audio.AudioPlayerView.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var b = this,
            c = window.AudioContext;
        b.model = a.model;
        b.MODULE_NAME = a.name;
        b.audioPlaying = {};
        b.audioResources = {};
        b.audioBuffers = {};
        b.soundsToLoad = [];
        b.initializedAudio = false;
        b.context = new c();
        b.callbacks = {};
        b.duckingSounds = {};
        b.duckingRestore = {};
        if (b.context && b.context.state !== "running") {
            b.defaultVolume = Services.localStorageManager.readData("volume");
            if (b.defaultVolume !== null) {
                b.defaultVolume = Number(b.defaultVolume)
            }
            if (!b.defaultVolume && b.defaultVolume !== 0) {
                b.defaultVolume = 1
            }
            Services.settingsManager.storeSetting("volume", 0, true)
        }
    },
    setVolume: function(b) {
        var a = this;
        if (a.initializedAudio && Sys.isNumber(b)) {
            a.nodes.mainVolume.gain.value = b;
            if (a.context.onstatechange) {
                a.context.onstatechange = null
            }
            if (b > 0 && a.context) {
                a.context.resume().then(function() {
                    return null
                })
            }
        }
    },
    play: function(e) {
        var d = this,
            c, g, b, f, a;
        if (!Sys.isDefined(e.source)) {
            c = d.setUpSource(e)
        } else {
            c = e
        }
        if (!Sys.isDefined(c)) {
            return
        }
        if (d.context.state !== "running" && !e.loop) {
            return
        }
        c.source.playbackRate.value = 1;
        b = d.audioPlaying[e.syncWithId];
        if (!Sys.isEmpty(b)) {
            f = d.context.currentTime - b[0].initTime;
            a = (f % c.duration);
            c.duration -= a;
            c.start = a + c.clipOffsetFromFileStart
        }
        g = d.getId(e);
        d.addToPlayingList(g, c);
        d.setupCallback(e.callback, c, g);
        if (!e.loop) {
            d.setupCallback(d.clipFinished.bind(d, c, g), c, g)
        }
        if (Sys.isDefined(c.ducking)) {
            d.duckSounds(c.ducking, c, g, e)
        }
        c.initTime = d.context.currentTime + c.delay - c.start + c.clipOffsetFromFileStart;
        if (e.loop === true && d.canPlayWithoutDuration) {
            if (c.start > 0) {
                c.source.start(d.context.currentTime + c.delay, c.start);
                c.source.onended = function() {
                    if (!c.stopped) {
                        d.play(e)
                    }
                };
                c.stopped = false
            } else {
                c.source.start(d.context.currentTime + c.delay)
            }
        } else {
            c.source.start(d.context.currentTime + c.delay, c.start, c.duration)
        }
    },
    duckSounds: function(f, k, d, e) {
        var m = this,
            p = Object.keys(f),
            a = p.length,
            l, g, o, c, j, b, n, h;
        for (h = -1; ++h < a;) {
            b = p[h];
            n = f[b];
            g = m.duckingSounds[b];
            o = Sys.isDefined(n.duration) ? n.duration : k.duration;
            l = m.context.currentTime + k.delay + Math.min(k.duration, o);
            if (Sys.isObj(g)) {
                if (g.finishedAt > l) {
                    continue
                }
                c = m.callbacks[g.duckedBy].funcs.indexOf(g.restoreUsing);
                if (c > -1) {
                    m.callbacks[g.duckedBy].funcs.splice(c, 1)
                }
            }
            m.changePlayingSoundVolume(b, n, k, e);
            j = m.restoreDuckedSound.bind(m, b, n);
            m.setupCallback(j, k, d, e.loop);
            m.duckingSounds[b] = {
                duckedBy: d,
                restoreUsing: j,
                finishedAt: l
            }
        }
    },
    changePlayingSoundVolume: function(c, d, f, b) {
        var g = this,
            a = g.audioPlaying[c],
            i = g.context.currentTime + (f.delay || 0),
            h = i + (d.duration || f.duration || 0),
            j, e;
        Sys.each(a, function(k) {
            j = k.gainNode.gain;
            j.setTargetAtTime(d.value, i, d.attack);
            e = Math.max(j.value, g.duckingRestore[c] || 0);
            if (!b.loop) {
                j.setTargetAtTime(e, h, d.release)
            }
            g.duckingRestore[c] = e
        }, g)
    },
    restoreDuckedSound: function(b, a) {
        this.restoreGainValue(b, a);
        this.duckingSounds[b] = undefined
    },
    restoreGainValue: function(c, b) {
        var d = this,
            a = d.audioPlaying[c],
            e;
        if (!Sys.isDefined(d.duckingRestore[c])) {
            return
        }
        Sys.each(a, function(f) {
            e = f.gainNode.gain;
            e.cancelScheduledValues(d.context.currentTime);
            e.setTargetAtTime(d.duckingRestore[c], d.context.currentTime, b.release)
        }, d)
    },
    clipFinished: function(b, c) {
        var a = this.audioPlaying[c].indexOf(b);
        while (a >= 0) {
            this.audioPlaying[c].splice(a, 1);
            a = this.audioPlaying[c].indexOf(b)
        }
    },
    stop: function(e, b) {
        var d = this,
            c, a;
        if (!Sys.isDefined(d.audioPlaying[e])) {
            return
        }
        for (a = 0; a < d.audioPlaying[e].length; a++) {
            c = d.audioPlaying[e][a];
            if (Sys.isDefined(c)) {
                d.stopClip(c, b)
            }
        }
        d.removeFromPlayingList(e);
        if (Sys.isDefined(d.callbacks[e])) {
            clearTimeout(d.callbacks[e].timeout);
            d.callArrayOfCallbacks(e)
        }
    },
    stopClip: function(e, c) {
        var d = this,
            b = Sys.isDefined(c) ? c : e.fadeOut,
            f = d.context.currentTime,
            a = f;
        if (b && (d.context && d.context.state === "running")) {
            e.gainNode.gain.exponentialRampToValueAtTime(b.from, f);
            e.gainNode.gain.exponentialRampToValueAtTime(b.to, f + b.time);
            a += b.time
        }
        e.stopped = true;
        e.source.stop(a)
    },
    stopNonLooping: function() {
        var b = this,
            a;
        Sys.iterate(b.audioPlaying, function(d, c) {
            a = [];
            Sys.each(c, function(e) {
                if (e.source.loop) {
                    a.push(e)
                } else {
                    b.stopClip(e)
                }
            });
            b.audioPlaying[d].length = 0;
            b.audioPlaying[d] = a
        })
    },
    abort: function() {
        var a = this;
        Sys.iterate(a.audioPlaying, function(b) {
            a.stop(b)
        })
    },
    getId: function(a) {
        return a.id || "audioPlayer.noID"
    },
    addToPlayingList: function(b, a) {
        if (!Sys.isDefined(this.audioPlaying[b])) {
            this.audioPlaying[b] = []
        }
        this.audioPlaying[b].push(a)
    },
    removeFromPlayingList: function(a) {
        this.audioPlaying[a].length = 0
    },
    setUpSource: function(g) {
        var i = this,
            d = i.setUpSourceParams(g),
            h, c = this.context.currentTime,
            a, e, b, f;
        if (!Sys.isDefined(d)) {
            return undefined
        }
        a = i.context.createBufferSource();
        a.buffer = d.sourceBuffer;
        e = i.context.createGain();
        a.connect(e);
        e.gain.value = d.gain;
        if (d.fadeIn) {
            h = d.fadeIn;
            e.gain.exponentialRampToValueAtTime(h.from, c);
            e.gain.exponentialRampToValueAtTime(h.to, c + h.time)
        }
        if (d.fadeOut && !d.loop) {
            h = d.fadeOut;
            f = c + d.start + (d.duration - h.time);
            e.gain.exponentialRampToValueAtTime(h.from, f);
            e.gain.exponentialRampToValueAtTime(h.to, f + h.time)
        }
        a.loop = d.loop;
        if (a.loop && Sys.isDefined(d.start)) {
            a.loopStart = d.start;
            a.loopEnd = d.start + d.duration
        }
        if (Sys.isDefined(d.filter)) {
            b = this.filter(d.filter);
            e.connect(b);
            b.connect(i.nodes.mainVolume)
        } else {
            e.connect(i.nodes.mainVolume)
        }
        d = Sys.apply(d, {
            source: a,
            gainNode: e,
            filterNode: b
        });
        return d
    },
    setUpSourceParams: function(f) {
        var i = this,
            a, e, h, j = 1,
            g, b, c, d;
        if (!Sys.isDefined(f.name)) {
            return undefined
        }
        a = Sys.isDefined(f.buffer) ? f.buffer : "main";
        e = i.model.readData("clips")[a][f.name];
        h = i.audioBuffers[a];
        if (!Sys.isDefined(e)) {
            return undefined
        }
        if (!Sys.isDefined(h)) {
            return undefined
        }
        if (!Sys.isAudioBuffer(h)) {
            if (Sys.isAudioBuffer(h[f.name])) {
                h = h[f.name]
            } else {
                return undefined
            }
        }
        if (Sys.isDefined(f.volume)) {
            j = f.volume
        } else {
            if (Sys.isDefined(e.volume)) {
                j = e.volume
            }
        }
        g = Sys.isDefined(e.start) ? e.start : 0;
        b = g;
        if (Sys.isDefined(f.offset)) {
            b += f.offset
        }
        c = h.duration - b;
        if (Sys.isDefined(f.duration)) {
            c = Math.min(c, f.duration)
        } else {
            if (Sys.isDefined(e.duration)) {
                c = Math.min(c, e.duration)
            }
        }
        d = {
            sourceBuffer: h,
            delay: Sys.isDefined(f.delay) ? f.delay : 0,
            start: b,
            duration: c,
            clipOffsetFromFileStart: g,
            gain: j,
            loop: f.loop === true,
            fadeIn: Sys.isDefined(f.fadeIn) ? f.fadeIn : false,
            fadeOut: Sys.isDefined(f.fadeOut) ? f.fadeOut : false,
            filter: f.filter,
            ducking: e.duck
        };
        return d
    },
    setupCallback: function(h, e, g, a) {
        var d = this,
            f = (e.delay + e.duration) * 1000,
            b, c;
        if (!Sys.isDefined(h)) {
            return
        }
        b = function() {
            d.callArrayOfCallbacks(g)
        };
        if (Sys.isObj(d.callbacks[g])) {
            if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
                d.callbacks[g].timeout = setTimeout(b, f)
            }
            d.callbacks[g].funcs.push(h)
        } else {
            if (!a) {
                c = setTimeout(b, f)
            }
            d.callbacks[g] = {
                timeout: c,
                funcs: [h]
            }
        }
    },
    filter: function(a) {
        var b = this.context.createBiquadFilter();
        a.type = a.type || "allpass";
        b.type = typeof b.type === "string" ? a.type : b[a.type.toUpperCase()];
        if (Sys.isDefined(a.frequency)) {
            b.frequency.value = a.frequency
        }
        if (Sys.isDefined(a.q)) {
            b.Q.value = a.q
        }
        if (Sys.isDefined(a.gain)) {
            b.gain.value = a.q
        }
        return b
    },
    createMainNodes: function() {
        var c = this,
            a = c.context,
            b;
        b = a.createGain();
        b.gain.value = Services.settingsManager.getSetting("volume");
        c.nodes = {
            mainVolume: b
        }
    },
    connectMainNodes: function() {
        var b = this,
            a = b.nodes;
        a.mainVolume.connect(b.context.destination)
    },
    loadSounds: function(f) {
        var e = this,
            c, d, a, g, b;
        f = f || "main";
        c = e.model.readData("files")[f];
        if (Sys.isObj(c)) {
            a = Object.keys(c);
            g = a.length;
            for (b = -1; ++b < g;) {
                d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
            }
        } else {
            d = e.loadSoundResource(f, c)
        }
        if (d && f === "main") {
            e.fakeSound()
        }
    },
    loadSoundResource: function(b, a) {
        var c = this;
        if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
            c.soundsToLoad.push(b);
            c.fireEvent("view:loadResource", {
                name: b,
                type: "audioFile",
                url: a,
                successEvent: "notify:resourceLoader.soundLoaded",
                failEvent: "notify:resourceLoader.soundLoadingFailed"
            });
            return true
        }
        c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
        return false
    },
    fakeSound: function() {
        var a = this.context.createOscillator(),
            b = this.context.createGain();
        a.frequency.value = 440;
        b.gain.value = 0;
        a.connect(b);
        b.connect(this.context.destination);
        a.start(0);
        a.stop(0);
        a.disconnect(0);
        b.disconnect(0)
    },
    checkAPICompability: function(c) {
        var g = this,
            b = g.model.readData("clips"),
            a = c,
            f, i = true,
            d;
        if (Sys.isDefined(b[c])) {
            d = Object.keys(b[c]);
            a = d[d.length - 1]
        }
        f = g.setUpSource({
            name: a,
            volume: 0
        });
        try {
            f.source.start(0, 0);
            f.source.stop(g.context.currentTime)
        } catch (h) {
            i = false
        }
        g.canPlayWithoutDuration = i
    },
    onSoundResourceLoaded: function(g, c) {
        var h = this,
            e = g.split("/"),
            a, i = g,
            f = h.audioResources,
            d = h.audioBuffers,
            b = function() {
                if (h.context.state === "running" && h.defaultVolume) {
                    Services.settingsManager.storeSetting("volume", h.defaultVolume ? h.defaultVolume : 1, true)
                }
                h.context.onstatechange = null
            };
        if (e.length > 1) {
            a = e[0];
            i = e[1];
            f = f[a];
            d = d[a];
            if (!Sys.isDefined(f)) {
                f = {};
                h.audioResources[a] = f;
                d = {};
                h.audioBuffers[a] = d
            }
        }
        f[i] = c;
        h.context.decodeAudioData(c, function(j) {
            var k = h.soundsToLoad.indexOf(g);
            d[i] = j;
            if (!h.initializedAudio) {
                h.setupEvents();
                h.createMainNodes();
                h.connectMainNodes();
                h.checkAPICompability(i);
                h.initializedAudio = true;
                if (h.context.state === "running") {
                    b()
                } else {
                    if (h.defaultVolume > 0 && h.context.state === "suspended") {
                        h.context.onstatechange = b
                    }
                }
                h.context.resume()
            }
            if (k >= 0) {
                h.soundsToLoad.splice(k, 1);
                if (h.soundsToLoad.length === 0) {
                    h.fireEvent("view:soundLoaded")
                }
            }
        }, h.fireEvent.bind(h, "view:audioLoadError", "Failed to decode audio file", g))
    },
    decodePreloadedAudio: function() {
        var b = this,
            a = Resources.readData("preloadedAudio");
        Sys.iterate(a, function(c) {
            b.soundsToLoad.push(c)
        });
        Sys.iterate(a, function(c, d) {
            b.onSoundResourceLoaded(c, d)
        })
    },
    callArrayOfCallbacks: function(b) {
        var a = this;
        Sys.each(a.callbacks[b].funcs, function(c) {
            c.call(a)
        });
        a.callbacks[b].funcs = []
    }
};
Core.Audio.AudioPlayerView = Sys.extend(Core.View, Core.Audio.AudioPlayerView, "Core.Audio.AudioPlayerView");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerEngineView = {
    constructor: function() {
        Core.Audio.AudioPlayerEngineView.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var b = this;
        b.model = a.model;
        b.MODULE_NAME = a.name;
        b.initializedAudio = false;
        b.soundsToLoad = [];
        b.context = ("Engine" in Audio && Audio.Engine.getContext());
        if (b.context && b.context.state !== "running") {
            Services.settingsManager.storeSetting("volume", 0, true)
        }
    },
    setVolume: function(a) {
        if (a > 0 && this.context) {
            this.context.resume().then(function() {
                return null
            })
        }
    },
    play: function() {},
    stop: function() {},
    duckSounds: function() {},
    stopNonLooping: function() {},
    abort: function() {},
    loadSounds: function(f) {
        var e = this,
            c, d, a, g, b;
        f = f || "main";
        c = e.model.readData("files")[f];
        if (Sys.isObj(c)) {
            a = Object.keys(c);
            g = a.length;
            for (b = -1; ++b < g;) {
                d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
            }
        } else {
            d = e.loadSoundResource(f, c)
        }
        if (d && f === "main") {
            e.fakeSound()
        }
    },
    loadSoundResource: function(b, a) {
        var c = this;
        if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
            c.soundsToLoad.push(b);
            c.fireEvent("view:loadResource", {
                name: b,
                type: "audioFile",
                url: a,
                successEvent: "notify:resourceLoader.soundLoaded",
                failEvent: "notify:resourceLoader.soundLoadingFailed"
            });
            return true
        }
        c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
        return false
    },
    onSoundResourceLoaded: function(h, e) {
        var j = this,
            d = j.model.readData("clips"),
            g = h.split("/"),
            c, k = h,
            l, a, b, f;
        if (g.length > 1) {
            c = g[0];
            k = g[1]
        }
        Audio.Engine.add(k, e, function() {
            var i = j.soundsToLoad.indexOf(h);
            if (!j.initializedAudio) {
                j.setupEvents();
                j.initializedAudio = true
            }
            if (i >= 0) {
                j.soundsToLoad.splice(i, 1);
                if (j.soundsToLoad.length === 0) {
                    j.fireEvent("view:soundLoaded")
                }
            }
        }, j.fireEvent.bind(j, "view:audioLoadError", "Failed to decode audio file", h));
        if (!Sys.isDefined(c)) {
            c = k;
            l = d[c];
            a = Object.keys(l);
            b = a.length;
            for (f = -1; ++f < b;) {
                k = a[f];
                l[k].source = c;
                Audio.Engine.addClipConfig(k, l[k])
            }
        }
    },
    decodePreloadedAudio: function() {
        var b = this,
            a = Resources.readData("preloadedAudio");
        Sys.iterate(a, function(c) {
            b.soundsToLoad.push(c)
        });
        Sys.iterate(a, function(c, d) {
            b.onSoundResourceLoaded(c, d)
        })
    },
    fakeSound: function() {
        Audio.Engine.playSound("nosound", {
            volume: 0
        }).stop(0)
    }
};
Core.Audio.AudioPlayerEngineView = Sys.extend(Core.View, Core.Audio.AudioPlayerEngineView, "Core.Audio.AudioPlayerEngineView");
Sys.ns("Core.Audio.Legacy");
Core.Audio.Legacy.LegacyAudioPlayerView = {
    constructor: function() {
        Core.Audio.Legacy.LegacyAudioPlayerView.superclass.constructor.apply(this, arguments);
        this.audioElements = {};
        this.clipsToLoad = [];
        this.callbacks = {}
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:audioDisabled": a.abort,
            "model:audioDisabled:hidden": a.abort
        })
    },
    play: function(e) {
        var d = this,
            b, a = e.name,
            g, f;
        e.buffer = e.buffer || "main";
        b = d.audioElements[e.buffer];
        g = d.model.readData("clips")[e.buffer][a];
        if (Sys.isDefined(b) && d.model.isState("audioEnabled")) {
            f = b[e.name];
            if (Sys.isDefined(f)) {
                if (d.currentClip) {
                    d.stopCurrentClip()
                }
                if (!Sys.isDefined(e.volume)) {
                    e.volume = Sys.isDefined(g.volume) ? g.volume : 1
                }
                if (e.loop) {
                    e.loopHandler = function() {
                        f.play()
                    };
                    f.addEventListener("ended", e.loopHandler, false)
                }
                d.currentClip = e;
                f.volume = Services.settingsManager.getSetting("volume") * e.volume;
                d.setupCallback(e.callback, f.duration, e.id, e.loop);
                try {
                    f.play()
                } catch (c) {}
            }
        }
    },
    stopCurrentClip: function() {
        var c = this.currentClip,
            b = this.audioElements[c.buffer][c.name];
        try {
            b.currentTime = 0
        } catch (a) {}
        b.pause();
        if (c.loop) {
            b.removeEventListener("ended", c.loopHandler, false)
        }
        this.currentClip = undefined;
        if (Sys.isDefined(this.callbacks[c.id])) {
            clearTimeout(this.callbacks[c.id].timeout);
            this.callArrayOfCallbacks(c.id)
        }
    },
    stop: function(a) {
        if (Sys.isDefined(this.currentClip) && this.currentClip.id === a) {
            this.stopCurrentClip()
        }
    },
    stopNonLooping: function() {
        if (Sys.isDefined(this.currentClip) && !this.currentClip.loop) {
            this.stopCurrentClip()
        }
    },
    abort: function() {
        if (Sys.isDefined(this.currentClip)) {
            this.stopCurrentClip()
        }
    },
    setVolume: function(a) {
        var b = this.currentClip;
        if (Sys.isDefined(b)) {
            this.audioElements[b.buffer][b.name].volume = a * b.volume
        }
    },
    loadSounds: function(c) {
        var b = this,
            a, d;
        c = c || "main";
        if (!Sys.isObj(b.audioElements[c])) {
            a = b.model.readData("files")[c];
            if (Sys.isDefined(a)) {
                b.audioElements[c] = {};
                Sys.iterate(a, function(e, f) {
                    d = c + ":" + e;
                    b.clipsToLoad.push(d);
                    b.fireEvent("view:loadResource", {
                        name: d,
                        type: "audioElementSource",
                        url: f,
                        successEvent: "notify:resourceLoader.soundLoaded",
                        failEvent: "notify:resourceLoader.soundLoadingFailed"
                    })
                })
            } else {
                b.fireEvent("view:audioLoadError", "No config entry for sound resource", c)
            }
        } else {
            if (b.clipsToLoad.length === 0) {
                b.fireEvent("view:soundLoaded")
            }
        }
    },
    onSoundResourceLoaded: function(a, c) {
        var b = this,
            d = b.clipsToLoad.indexOf(a),
            e = a.split(":");
        b.audioElements[e[0]][e[1]] = c;
        if (d >= 0) {
            b.clipsToLoad.splice(d, 1);
            if (b.clipsToLoad.length === 0) {
                b.fireEvent("view:soundLoaded")
            }
        }
    },
    callArrayOfCallbacks: function(b) {
        var a = this;
        Sys.each(a.callbacks[b].funcs, function(c) {
            c.call(a)
        });
        a.callbacks[b].funcs = []
    },
    setupCallback: function(h, f, g, a) {
        var d = this,
            e = f * 1000,
            b, c;
        if (!Sys.isDefined(h)) {
            return
        }
        b = function() {
            d.callArrayOfCallbacks(g)
        };
        if (Sys.isObj(d.callbacks[g])) {
            if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
                d.callbacks[g].timeout = setTimeout(b, e)
            }
            d.callbacks[g].funcs.push(h)
        } else {
            if (!a) {
                c = setTimeout(b, e)
            }
            d.callbacks[g] = {
                timeout: c,
                funcs: [h]
            }
        }
    }
};
Core.Audio.Legacy.LegacyAudioPlayerView = Sys.extend(Core.View, Core.Audio.Legacy.LegacyAudioPlayerView, "Core.Audio.Legacy.LegacyAudioPlayerView");
Sys.ns("Core");
Core.ResourceLoader = {
    constructor: function() {
        Core.ResourceLoader.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.ResourceLoaderModel,
            view: Core.ResourceLoaderView,
            controller: Core.ResourceLoaderController
        }
    }
};
Core.ResourceLoader = Sys.extend(Core.Module, Core.ResourceLoader, "Core.ResourceLoader");
Sys.ns("Core");
Core.ResourceLoaderController = {
    constructor: function() {
        Core.ResourceLoaderController.superclass.constructor.apply(this, arguments);
        this.requestedResources = {}
    },
    setupEvents: function() {
        this.on({
            "request:resourceLoader.loadResource": this.loadResource,
            "request:resourceLoader.removeLoadAnimation": this.removeLoadAnimation
        })
    },
    removeLoadAnimation: function() {
        this.model.setState("clearAnimations")
    },
    loadResource: function(b) {
        var a = this.requestedResources[b.url];
        if (Sys.isObj(a)) {
            if (a.status === "fetched" && b.successEvent) {
                this.fireEvent(b.successEvent, b.name, a.data)
            } else {
                if (a.status === "fetching") {
                    a.requesters.push(b)
                }
            }
        } else {
            if (b.showLoadAnimation) {
                this.model.setState("showLoadAnimation")
            }
            this.requestedResources[b.url] = {
                status: "fetching",
                requesters: [b]
            };
            switch (b.type) {
                case "audioFile":
                    this.fetchAudioFile(b);
                    break;
                case "audioElementSource":
                    this.fetchAudioElementSource(b);
                    break;
                case "JSON":
                    this.fetchJSON(b);
                    break;
                default:
                    this.fetchGenericResource(b)
            }
        }
    },
    fetchAudioFile: function(b) {
        var a = this;
        Sys.utils.httpGet({
            url: b.url,
            responseType: "arraybuffer"
        }).fail(function() {
            a.failedToLoadResource(b)
        }).then(function(c) {
            a.fetchedResource(b, c.response)
        })
    },
    fetchAudioElementSource: function(c) {
        var b = this,
            d = document.createElement("audio"),
            a = Sys.utils.httpGet({
                url: c.url
            });
        a.fail(b.failedToLoadResource.bind(b, c)).then(function() {
            d.src = c.url;
            d.load();
            b.fetchedResource(c, d)
        })
    },
    fetchJSON: function(b) {
        var a = this;
        Sys.utils.httpGet({
            url: b.url
        }).fail(function() {
            a.failedToLoadResource(b)
        }).then(function(c) {
            a.fetchedResource(b, c.responseText)
        })
    },
    fetchGenericResource: function(b) {
        var a = this;
        Sys.utils.httpGet({
            url: b.url
        }).fail(function() {
            a.failedToLoadResource(b)
        }).then(function(c) {
            a.fetchedResource(b, c)
        })
    },
    failedToLoadResource: function(b) {
        var a = this;
        this.requestedResources[b.url].requesters.forEach(function(c) {
            if (c.failEvent) {
                a.fireEvent(c.failEvent, b.name)
            }
        });
        delete this.requestedResources[b.url]
    },
    fetchedResource: function(d, c) {
        var a = this,
            b = this.requestedResources[d.url];
        b.requesters.forEach(function(e) {
            if (e.successEvent) {
                a.fireEvent(e.successEvent, d.name, c)
            }
        });
        b.status = "fetched";
        b.data = c;
        b.requesters = [];
        this.requestedResources[d.url] = b
    }
};
Core.ResourceLoaderController = Sys.extend(Core.Controller, Core.ResourceLoaderController, "Core.ResourceLoaderController");
Sys.ns("Core");
Core.ResourceLoaderModel = {
    constructor: function() {
        Core.ResourceLoaderModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponse");
        this.storeData("isRestore", a.restore)
    }
};
Core.ResourceLoaderModel = Sys.extend(Core.Model, Core.ResourceLoaderModel, "Core.ResourceLoaderModel");
Sys.ns("Core");
Core.ResourceLoaderAbstractView = {
    constructor: function() {
        Core.ResourceLoaderAbstractView.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:showLoadAnimation": a.showLoadAnimation,
            "model:hideLoadAnimation": a.hideLoadAnimation,
            "model:clearAnimations": a.removeAnimations
        })
    },
    init: function(a) {},
    showLoadAnimation: function() {},
    hideLoadAnimation: function() {},
    removeAnimations: function() {}
};
Core.ResourceLoaderAbstractView = Sys.extend(Core.View, Core.ResourceLoaderAbstractView, "Core.ResourceLoaderAbstractView");
Sys.ns("Core");
Core.ResourceLoaderView = {
    SPINNER: {
        width: 132,
        height: 130,
        sprite: "loadingAnimation",
        frameWidth: 132,
        frameHeight: 130,
        totalSpriteWidth: 1188,
        duration: 1000,
        endFrame: 8
    },
    FADE: {
        RESTORE: {
            startOpacity: 1,
            endOpacity: 1,
            duration: 100
        },
        STANDARD: {
            startOpacity: 0,
            endOpacity: 0.2,
            duration: 100
        }
    },
    constructor: function() {
        Core.ResourceLoaderView.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var b = this;
        Core.ResourceLoaderView.superclass.init.call(b, a);
        b.loaderList = new Animation.CanvasAnimationList({});
        b.fadeList = new Animation.CanvasAnimationList({});
        b.bonusGameName = "";
        b.loading = Services.languageManager.getText(Language.Keys.loading);
        b.loaderItem = b.createLoadItem();
        b.fadeItem = b.createFadeItem();
        b.loaderList.add(b.loaderItem)
    },
    createFadeItem: function() {
        var b = this.getLayeringValues(),
            a = this.FADE.STANDARD;
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: b.fade,
            opacity: 0,
            executeBefore: function(c) {
                var d = this;
                c.fillStyle = "rgb(0,0,0)";
                c.fillRect(d.pivot.x, d.pivot.y, d.width, d.height)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: a.startOpacity
                }, {
                    time: a.duration,
                    value: a.endOpacity
                }, {
                    time: a.duration + 1,
                    value: a.endOpacity,
                    goTo: 1
                }]
            }
        })
    },
    createLoadItem: function() {
        var a = this.SPINNER,
            c = this.getLayeringValues(),
            b = Environment.determineResolution().virtualResolution;
        return new Animation.CanvasAnimationItem({
            left: Math.round((b.width - a.width) / 2),
            top: Math.round((b.height - a.height) / 2),
            width: a.width,
            height: a.height,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            image: a.sprite,
            spriteArray: Game.stage.view.animationManager.getSpriteSequence(a.sprite),
            depth: c.spinner,
            operations: {
                sprite: [{
                    time: 0,
                    value: 0
                }, {
                    time: a.duration,
                    value: a.endFrame,
                    goTo: 0
                }]
            }
        })
    },
    showLoadAnimation: function() {
        var c = this,
            d = c.model.readData("isRestore"),
            a = c.fadeItem.prop.operations.fade,
            b = (d) ? c.FADE.RESTORE : c.FADE.STANDARD;
        c.loaderItem.restore();
        c.fadeItem.restore();
        a[0].value = b.startOpacity;
        a[1].value = b.duration;
        a[1].value = b.endOpacity;
        a[2].value = b.duration + 1;
        a[2].value = b.endOpacity;
        c.bonusGameName = "";
        c.fadeList.add(c.fadeItem);
        Game.stage.view.addToRenderLoop(c.loaderList);
        Game.stage.view.addToRenderLoop(c.fadeList);
        c.isRestore = d
    },
    hideLoadAnimation: function() {
        Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
        if (this.isRestore) {
            this.clearFade()
        }
    },
    clearFade: function() {
        this.fadeList.items = [];
        Game.stage.view.removeFromRenderLoop(this.fadeList, "base")
    },
    removeAnimations: function() {
        Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
        this.clearFade()
    },
    getLayeringValues: function() {
        return Layering.Game.ResourceLoader
    }
};
Core.ResourceLoaderView = Sys.extend(Core.ResourceLoaderAbstractView, Core.ResourceLoaderView, "Core.ResourceLoaderView");
Sys.ns("Core");
Core.KeyboardManager = {
    constructor: function() {
        Core.KeyboardManager.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return [{
            userInput: {
                inputEvents: ["keyUp", "keyDown"],
                listenToUserInput: true
            }
        }, "properties"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.KeyboardManagerModel,
            controller: Core.KeyboardManagerController
        }
    }
};
Core.KeyboardManager = Sys.extend(Core.Module, Core.KeyboardManager, "Core.KeyboardManager");
Sys.ns("Core");
Core.KeyboardManagerController = {
    constructor: function() {
        Core.KeyboardManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringStoppedState": this.onEnteringStoppedState,
            "notify:stateHandler.enteringSpinningState": this.onEnteringSpinningState
        })
    },
    onEnteringStoppedState: function() {
        this.model.storeData("quickStopAvailable", false)
    },
    onEnteringSpinningState: function() {
        this.model.storeData("quickStopAvailable", true)
    },
    onUserInputKeyDown: function(b, a) {
        this.handleUserInput(a.keyCode, "down");
        this.model.storeData("currentState", "down")
    },
    onUserInputKeyUp: function(b, a) {
        this.handleUserInput(a.keyCode, "up");
        this.model.storeData("currentKey", "");
        this.model.storeData("currentState", "up")
    },
    handleUserInput: function(d, c) {
        var b = this.model.getKey(d),
            a = this.model.readData("currentKey") !== d || this.model.readData("currentState") !== c;
        if (!this.model.hasProperty("disabled") && b && a && b.triggerOnState.contains(c)) {
            this.model.storeData("currentKey", d);
            this[b.action](c)
        }
    },
    onSpaceBarPressed: function(a) {
        if (Services.settingsManager.getSetting("spacebarToSpin")) {
            if (a === "down") {
                window.onkeydown = function(b) {
                    return b.keyCode !== 32
                };
                this.fireEvent("request:spinButton.pressed")
            } else {
                if (a === "up") {
                    this.fireEvent("request:spinButton.released");
                    this.fireEvent("request:abortPresentation");
                    if (this.model.readData("quickStopAvailable")) {
                        this.fireEvent("request:quickStopper.quickStop")
                    }
                }
            }
        }
    }
};
Core.KeyboardManagerController = Sys.extend(Core.Controller, Core.KeyboardManagerController, "Core.KeyboardManagerController");
Sys.ns("Core");
Core.KeyboardManagerModel = {
    KEY_MAP: {
        32: {
            action: "onSpaceBarPressed",
            triggerOnState: ["down", "up"]
        }
    },
    constructor: function() {
        Core.KeyboardManagerModel.superclass.constructor.apply(this, arguments)
    },
    getKey: function(a) {
        return this.KEY_MAP[a]
    }
};
Core.KeyboardManagerModel = Sys.extend(Core.Model, Core.KeyboardManagerModel, "Core.KeyboardManagerModel");
Sys.ns("Interface");
Interface.Keyboard = {
    constructor: function() {
        Interface.Keyboard.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation", {
            userInput: {
                listenToUserInput: true
            }
        }]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            controller: Interface.KeyboardController,
            view: Interface.KeyboardView
        }
    }
};
Interface.Keyboard = Sys.extend(Core.Module, Interface.Keyboard, "Interface.Keyboard");
Sys.ns("Interface");
Interface.KeyboardController = {
    MAX_LENGTH: 8,
    constructor: function() {
        Interface.KeyboardController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:keyboard.open": a.open,
            "request:keyboard.close": a.close,
            "request:keyboard.cancel": a.cancel,
            "view:ok": a.onOkClicked,
            "view:cancel": a.onCancelClicked,
            "view:back": a.onBackKeyClicked,
            "view:keyClicked": a.onKeyClicked
        })
    },
    open: function(a) {
        var b = this;
        if (b.model.readData("isOpen") === true) {
            return
        }
        b.fireEvent("request:userInputManager.activateExclusivity", b.MODULE_NAME);
        a = a || {};
        if (a.formatFunction && typeof a.formatFunction === "function") {
            b.formatFunc = a.formatFunction
        }
        b.model.storeData("info", Sys.isDefined(a.info) ? a.info : "");
        b.model.storeData("label", Sys.isDefined(a.label) ? a.label : "");
        b.model.storeData("isOpen", true);
        b.model.storeData("minValue", a.minValue);
        b.updateModel("0");
        b.okCallback = a.okCallback;
        b.cancelCallback = a.cancelCallback;
        b.view.show()
    },
    close: function() {
        var a = this;
        a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
        a.view.hide();
        a.model.storeData("isOpen", false)
    },
    cancel: function() {
        if (this.model.readData("isOpen")) {
            this.onCancelClicked()
        }
    },
    onOkClicked: function() {
        var a = this;
        if (typeof a.okCallback === "function") {
            a.okCallback({
                formattedInput: a.model.readData("formattedInputField"),
                input: a.model.readData("inputField"),
                value: parseInt(a.model.readData("inputField"), 10),
                cents: parseInt(a.model.readData("inputField"), 10) * 100
            })
        }
        a.close()
    },
    onCancelClicked: function() {
        var a = this;
        a.updateModel("0");
        if (typeof a.cancelCallback === "function") {
            a.cancelCallback({
                formattedInput: a.model.readData("formattedInputField"),
                input: a.model.readData("inputField"),
                value: parseInt(a.model.readData("inputField"), 10),
                cents: parseInt(a.model.readData("inputField"), 10) * 100
            })
        }
        a.close()
    },
    onKeyClicked: function(b) {
        var c = this,
            a = c.model.readData("inputField");
        if (a.length < c.MAX_LENGTH) {
            a = Sys.utils.toInt(a) + b
        }
        c.updateModel(a);
        c.view.update()
    },
    onBackKeyClicked: function() {
        var b = this,
            a = b.model.readData("inputField");
        a = a.substring(0, a.length - 1);
        a = a.length === 0 ? "0" : a;
        b.updateModel(a);
        b.view.update()
    },
    updateModel: function(a) {
        var c = this,
            b = c.model;
        b.storeData("formattedInputField", c.formatFunc(a));
        b.storeData("inputField", a);
        b.storeData("value", parseInt(a, 10));
        b.storeData("cents", parseInt(a, 10) * 100);
        b.storeData("isOkButtonEnabled", c.isInputValid())
    },
    formatFunc: function(a) {
        return Services.moneyManager.formatMoneyCurrencySign(Sys.utils.toInt(a) * 100, undefined, 0)
    },
    isInputValid: function() {
        var b = this,
            c = b.model.readData("minValue"),
            a = b.model.readData("cents");
        return !Sys.isDefined(c) || (c > 0 && c <= a)
    }
};
Interface.KeyboardController = Sys.extend(Core.Controller, Interface.KeyboardController, "Interface.KeyboardController");
Sys.ns("Interface");
Interface.KeyboardView = {
    RENDER_TARGET: "gameWrapper",
    KEYPAD: "keyboardKeypad",
    constructor: function() {
        Interface.KeyboardView.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Interface.KeyboardView.superclass.init.apply(this, arguments);
        a.container = new Sys.Element({
            id: "keyboard",
            tag: "div",
            cls: "interface-keyboard_container",
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.info = new Sys.Element({
            id: "keyboardInfo",
            tag: "div",
            cls: "info",
            renderTo: "keyboard",
            innerHTML: a.model.readData("info")
        });
        a.label = new Sys.Element({
            id: "keyboardFieldContainerLabel",
            tag: "div",
            cls: "label",
            renderTo: "keyboard",
            innerHTML: a.model.readData("label")
        });
        a.fieldContainer = new Sys.Element({
            id: "keyboardFieldContainer",
            tag: "div",
            cls: "fieldContainer",
            renderTo: "keyboard"
        });
        a.value = new Sys.Element({
            id: "",
            tag: "div",
            cls: "value",
            renderTo: "keyboardFieldContainer",
            innerHTML: a.model.readData("formattedInputField")
        });
        a.keypad = new Sys.Element({
            id: a.KEYPAD,
            tag: "div",
            cls: "keypad digits",
            renderTo: "keyboard"
        });
        a.initKeyboard()
    },
    initKeyboard: function() {
        var d = this,
            c, a = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
            b;
        d.keys = [];
        for (c = 0; c < a.length; c++) {
            b = new Interface.utils.DOMButton({
                id: "keypad_num_" + a[c],
                textContent: a[c],
                clickCallback: d.fireEvent.bind(d, "view:keyClicked", a[c]),
                renderTo: d.KEYPAD,
                baseCSS: "button num_" + a[c],
                exclusiveUserInput: d.MODULE_NAME
            });
            d.keys.push(b)
        }
        d.cancelButton = new Interface.utils.DOMButton({
            id: "keypad_cancel",
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:cancel"),
            renderTo: d.KEYPAD,
            baseCSS: "button cancelButton ",
            exclusiveUserInput: d.MODULE_NAME
        });
        d.okButton = new Interface.utils.DOMButton({
            id: "keypad_ok",
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:ok"),
            renderTo: d.KEYPAD,
            baseCSS: "button okButton",
            exclusiveUserInput: d.MODULE_NAME
        });
        d.backButton = new Interface.utils.DOMButton({
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:back"),
            renderTo: "keyboardFieldContainer",
            baseCSS: "button removeDigit",
            exclusiveUserInput: d.MODULE_NAME
        })
    },
    show: function() {
        this.update();
        this.container.el.style.display = "block"
    },
    hide: function() {
        this.container.el.style.display = "none"
    },
    adaptToOrientation: function() {
        this.setHeight()
    },
    setHeight: function() {
        var a = Environment.determineResolution().resolution.height;
        if (Utils.Platform.isPortrait()) {
            this.container.el.style.height = (a + Environment.getSpaceBelowGame()) + "px"
        } else {
            this.container.el.style.height = a + "px"
        }
    },
    update: function() {
        var c = this,
            b = c.model,
            a = b.readData("isOkButtonEnabled");
        c.label.getEl().innerHTML = b.readData("label");
        c.info.getEl().innerHTML = b.readData("info");
        c.value.getEl().innerHTML = b.readData("formattedInputField");
        if (a) {
            c.okButton.enable()
        } else {
            c.okButton.disable()
        }
    }
};
Interface.KeyboardView = Sys.extend(Core.View, Interface.KeyboardView, "Interface.KeyboardView");
Sys.ns("Game");
Game.Stage = {
    constructor: function() {
        Game.Stage.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            setupGame: {
                waitEvents: ["notify:animationManager.allImagesLoaded"]
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.StageModel,
            view: Game.StageView,
            controller: Game.StageController
        }
    }
};
Game.Stage = Sys.extend(Core.Module, Game.Stage, "Game.Stage");
Sys.ns("Game");
Game.StageController = {
    constructor: function() {
        Game.StageController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.startRenderLoop,
            "request:stage.setupImages": a.onSetupImages,
            "request:stage.elevate": a.view.elevate.bind(a.view),
            "request:stage.lower": a.view.lower.bind(a.view),
            "request:stage.pauseAnimation": a.view.pauseAnimation.bind(a.view),
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    },
    startRenderLoop: function() {
        this.model.setState("playRenderLoop")
    },
    switchScenes: function(a) {
        this.model.switchScenes(a)
    },
    getGameContainer: function() {
        return this.view.getGameContainer()
    },
    onSetupImages: function(a) {
        this.view.setupImages(a)
    },
    onGameSizeChanged: function() {
        if (Environment.allowsCustomCanvasSize()) {
            this.view.updateActiveRenderContextSize()
        }
    },
    getOrientationSpecificImage: function(a) {
        return this.view.getOrientationSpecificImage(a)
    }
};
Game.StageController = Sys.extend(Core.Controller, Game.StageController, "Game.StageController");
Sys.ns("Game");
Game.StageModel = {
    constructor: function() {
        Game.StageModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("config");
        this.storeData("images", Resources.readData("images") || {});
        this.storeData("sprites", a.sprites);
        this.storeData("reelConfig", a.reel);
        this.storeData("reelGroups", a.reelGroups);
        this.storeData("scenes", a.scenes);
        this.switchScenes("base")
    },
    switchScenes: function(a) {
        this.storeData("currentScene", a);
        this.setState("switchScene", a)
    },
    getSymbolConfiguration: function(b, a) {
        if (this.readData("reelGroups")) {
            return this.getNewSymbolConfiguration(b, a)
        } else {
            if (this.readData("reelConfig")) {
                return this.getLegacySymbolConfiguration(b, a)
            }
        }
        return null
    },
    getCurrentReelGroupConfiguration: function() {
        if (this.readData("reelGroups")) {
            return this.getCompatibleReelGroupConfiguration()
        } else {
            if (this.readData("reelConfig")) {
                return this.readData("reelConfig")
            }
        }
        return null
    },
    getCompatibleReelGroupConfiguration: function() {
        var a = this.readData("reelGroups")["default"],
            j = this.readData("reelConfig") || {},
            h = j.reelFrame || {},
            k = this.getReelLayout(a.reelLayouts) || a.reelLayout,
            i = k.config || k.standard,
            d = i.left || 0,
            l = i.top || 0,
            b = 0,
            f = a.numberOfReels,
            e = i.numberOfOutcomeSymbols || 0,
            g = i.symbolWidths.standard,
            m = i.symbolHeights.standard,
            c = Sys.applyProperties({}, i);
        Object.keys(k).map(function(n) {
            return parseInt(n, 10)
        }).filter(Sys.isNumber).forEach(function(n) {
            var o = k[n];
            if (n === 0) {
                d = this.getNumberValue(o.left, d);
                l = this.getNumberValue(o.top, l);
                b = d
            } else {
                d = Math.min(d, this.getNumberValue(o.left, d));
                l = Math.min(l, this.getNumberValue(o.top, l));
                b = Math.max(b, this.getNumberValue(o.left, d))
            }
            e = Math.max(e, o.numberOfOutcomeSymbols || 0)
        }, this);
        b += g - d;
        return Sys.applyProperties(c, {
            symbolWidth: this.getNumberValue(j.symbolWidth, g),
            symbolHeight: this.getNumberValue(j.symbolHeight, m),
            symbolCols: this.getNumberValue(j.symbolCols, f),
            symbolRows: this.getNumberValue(j.symbolRows, e),
            reelFrame: {
                left: this.getNumberValue(h.left, d),
                top: this.getNumberValue(h.top, l),
                width: this.getNumberValue(h.width, b),
                height: this.getNumberValue(h.height, e * m)
            },
            reelAreaTop: this.getNumberValue(j.reelAreaTop, l),
            reelAreaLeft: this.getNumberValue(j.reelAreaLeft, d),
            reelSpacing: this.getNumberValue(j.reelSpacing, Math.round((b - (g * f)) / (f - 1))),
            symbolSpacing: this.getNumberValue(j.symbolSpacing, Math.round(i.symbolCenterToCenter - m))
        })
    },
    getNumberValue: function(a, b) {
        return Sys.isNumber(a) ? a : b
    },
    getReelLayout: function(a) {
        var b;
        if (!a) {
            return null
        }
        b = Environment.getConfigForCurrentDeviceState(a);
        if (!b) {}
        return b
    },
    getLegacySymbolConfiguration: function(e, b) {
        var d = this.readData("reelConfig"),
            c = d.symbolWidth,
            a = d.symbolHeight;
        return {
            width: c,
            height: a,
            top: d.reelAreaTop + (b * (a + d.symbolSpacing)),
            left: d.reelAreaLeft + (e * (c + d.reelSpacing))
        }
    },
    getNewSymbolConfiguration: function(f, c) {
        var g = this.readData("reelGroups")["default"],
            d = this.getReelLayout(g.reelLayouts) || g.reelLayout,
            e = d[f.toString()],
            h = d.config || d.standard,
            b = e.top || h.top,
            a = h.outcomeOffset || 0;
        return {
            width: h.symbolWidths.standard,
            height: h.symbolHeights.standard,
            top: b + a + (c * h.symbolCenterToCenter),
            left: e.left
        }
    }
};
Game.StageModel = Sys.extend(Core.Model, Game.StageModel, "Game.StageModel");
Sys.ns("Game");
Game.StageView = {
    constructor: function() {
        Game.StageView.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        this.model = a.model;
        this.setupAnimationManager();
        this.setupEvents()
    },
    setupAnimationManager: function() {
        var b = this,
            a = Environment.determineResolution().resolution;
        b.animationManager = this.getAnimationManager({
            parent: document.getElementById("gameElements"),
            images: b.model.readData("images"),
            sprites: b.model.readData("sprites"),
            top: "0px",
            left: "0px",
            height: a.height,
            width: a.width,
            scenes: b.model.readData("scenes")
        })
    },
    getAnimationManager: function(a) {
        return new Animation.CanvasAnimationManager(a)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:switchScene": a.switchScenes,
            "model:playRenderLoop": a.playRenderLoop
        })
    },
    updateActiveRenderContextSize: function() {
        var b = Environment.determineResolution().resolution,
            a = {
                width: b.width,
                height: b.height
            };
        this.animationManager.updateActiveRenderContextSize(a)
    },
    getOrientationSpecificImage: function(c) {
        var b = Utils.Platform.getOrientation(),
            a = c + "_" + b.toLowerCase(),
            d = this.animationManager.images[a];
        if (Environment.allowsCustomCanvasSize() && Sys.isDefined(d)) {
            return a
        }
        return c
    },
    pauseAnimation: function() {
        this.animationManager.pauseAnimation()
    },
    switchScenes: function(a) {
        this.animationManager.switchScenes(a)
    },
    clearScene: function(a) {
        this.animationManager.clearScene(a)
    },
    playRenderLoop: function() {
        var a = this.model.readData("currentScene");
        this.animationManager.start(a)
    },
    addToRenderLoop: function(a, b) {
        this.animationManager.addToRenderLoop(a, b)
    },
    removeFromRenderLoop: function(a, b) {
        this.animationManager.removeList(a, b)
    },
    addImages: function(a) {
        this.animationManager.addImages(a)
    },
    setupImages: function(a) {
        this.animationManager.setupImages(a[0], a[1])
    },
    getGameContainer: function() {
        return document.getElementById("gameElements")
    },
    elevate: function() {
        this.getGameContainer().classList.add("elevated")
    },
    lower: function() {
        this.getGameContainer().className = this.getGameContainer().className.replace(/\belevated\b/, "")
    }
};
Game.StageView = Sys.extend(Core.View, Game.StageView, "Game.StageView");
Sys.ns("Game.Slots");
Game.Slots.QuickStopper = {
    constructor: function() {
        Game.Slots.QuickStopper.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["userInput", "trigger"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.QuickStopperModel,
            view: Game.Slots.QuickStopperView,
            controller: Game.Slots.QuickStopperController
        }
    }
};
Game.Slots.QuickStopper = Sys.extend(Core.Module, Game.Slots.QuickStopper, "Game.Slots.QuickStopper");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperController = {
    constructor: function() {
        Game.Slots.QuickStopperController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:quickStopper.disableInMode": this.disableInMode,
            "request:quickStopper.enableInMode": this.enableInMode,
            "request:quickStopper.quickStop": this.performQuickStop,
            "notify:spin.spinAnimationStarted": this.spinStarted,
            "notify:spin.spinAnimationComplete": this.spinStopped,
            "notify:spinButton.clicked": this.performQuickStop,
            "notify:spinButton.clickedWhileHidden": this.performQuickStop,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:quickStopper.quickStop", this, "When a quick stop is performed.")
    },
    onUserInputStart: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.performQuickStop()
        }
    },
    spinStarted: function() {
        this.startListeningToUserInput();
        this.model.setState("spinning")
    },
    spinStopped: function() {
        var a = this;
        a.stopListeningToUserInput();
        a.model.setState("stopped");
        a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
    },
    disableInMode: function(a) {
        this.model.setDisabledMode(a)
    },
    enableInMode: function(a) {
        this.model.removeDisabledMode(a)
    },
    performQuickStop: function() {
        var a = this;
        if (a.model.canQuickStop()) {
            a.model.setState("quickStop");
            a.fireEvent("notify:quickStopper.quickStop");
            a.fireEvent("request:audioPlayer.play", {
                name: "quickStop"
            });
            a.fireEvent("request:spinButton.disable", a.MODULE_NAME)
        }
    }
};
Game.Slots.QuickStopperController = Sys.extend(Core.Controller, Game.Slots.QuickStopperController, "Game.Slots.QuickStopperController");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperModel = {
    constructor: function() {
        Game.Slots.QuickStopperModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeLayout();
        this.storeData("disabledInModes", [])
    },
    canQuickStop: function() {
        return this.isState("spinning") && !this.isInDisabledMode()
    },
    storeLayout: function() {
        var b = Game.stage.model.getCurrentReelGroupConfiguration() || {},
            a = b.symbolWidth * b.symbolCols + b.reelSpacing * (b.symbolCols - 1);
        return this.storeData("layout", {
            width: a,
            height: b.visibleLength,
            top: b.reelAreaTop,
            left: b.reelAreaLeft,
            depth: Layering.Game.Slots.QuickStop.flash
        })
    },
    isInDisabledMode: function() {
        return this.readData("disabledInModes").length > 0
    },
    setDisabledMode: function(c) {
        var b = this,
            a = b.readData("disabledInModes");
        if (a.indexOf(c) === -1) {
            a.push(c);
            b.storeData("disabledInModes", a)
        } else {}
    },
    removeDisabledMode: function(d) {
        var c = this,
            b = c.readData("disabledInModes"),
            a = b.indexOf(d);
        if (a > -1) {
            b.splice(a, 1);
            c.storeData("disabledInModes", b)
        } else {}
    }
};
Game.Slots.QuickStopperModel = Sys.extend(Core.Model, Game.Slots.QuickStopperModel, "Game.Slots.QuickStopperModel");
Sys.ns("Game.Slots");
Game.Slots.QuickStopperView = {
    constructor: function() {
        Game.Slots.QuickStopperView.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "model:quickStop": this.quickStop
        })
    },
    initAnimations: function() {
        var b = this,
            a = b.model.readData("layout");
        b.animationList = new Animation.CanvasAnimationList();
        b.item = new Animation.CanvasAnimationItem({
            top: a.top,
            left: a.left,
            width: a.width,
            height: a.height,
            depth: a.depth,
            executeBefore: function(c) {
                c.fillStyle = "#FFFFFF";
                c.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 100,
                    value: 0.2
                }, {
                    time: 200,
                    value: 0
                }]
            }
        });
        b.animationList.add(b.item);
        Game.stage.view.addToRenderLoop(b.animationList);
        b.animationList.stop()
    },
    refresh: function() {
        var b, a = this.item;
        if (Animation.utils.isAnimationItem(a)) {
            b = this.model.storeLayout();
            a.setLeft(b.left);
            a.setTop(b.top);
            a.setWidth(b.width);
            a.setHeight(b.height)
        }
    },
    quickStop: function() {
        this.animationList.restore();
        this.animationList.play()
    }
};
Game.Slots.QuickStopperView = Sys.extend(Core.View, Game.Slots.QuickStopperView, "Game.Slots.QuickStopperView");
Sys.ns("Game");
Game.Background = {
    constructor: function() {
        Game.Background.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Game.BackgroundController,
            view: Game.BackgroundView
        }
    }
};
Game.Background = Sys.extend(Core.Module, Game.Background, "Game.Background");
Sys.ns("Game");
Game.BackgroundView = {
    BACKGROUND_IMAGE: "background",
    constructor: function() {
        Game.BackgroundView.superclass.constructor.apply(this, arguments)
    },
    changeImage: function(b) {
        var a = Resources.readData("animationImages");
        if ((typeof b === "string" && Sys.isDefined(a[b])) || Sys.isObj(b)) {
            this.currentImage = b;
            this.item.setImage(Game.stage.getOrientationSpecificImage(b))
        }
    },
    restoreImage: function() {
        this.currentImage = this.BACKGROUND_IMAGE;
        this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage))
    },
    refresh: function() {
        var a = Environment.determineResolution().virtualResolution;
        if (Animation.utils.isAnimationItem(this.item)) {
            this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage));
            this.item.setWidth(a.width);
            this.item.setHeight(a.height)
        }
    },
    initAnimations: function() {
        var b = this,
            c = new Animation.CanvasAnimationList({}),
            a = new Animation.CanvasAnimationItem({
                fullScreen: true,
                depth: Layering.Game.Background.image,
                image: Game.stage.getOrientationSpecificImage(b.BACKGROUND_IMAGE)
            });
        c.add(a);
        b.list = c;
        b.item = a;
        b.currentImage = b.BACKGROUND_IMAGE;
        Game.stage.view.addToRenderLoop(c)
    }
};
Game.BackgroundView = Sys.extend(Core.View, Game.BackgroundView, "Game.BackgroundView");
Sys.ns("Core");
Core.Slots.Spin = {
    constructor: function() {
        Core.Slots.Spin.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            idle: {
                queue: [function(b) {
                    b.stateHandler.pushState(b.states.validateSpin);
                    b.stateHandler.pushState(b.states.spinning)
                }],
                waitEvents: ["notify:spin.roundStart"]
            },
            validateSpin: {
                state: {
                    name: "ValidateSpin",
                    execute: function(b) {
                        if (a.readData("isValidServerResponse")) {
                            b.stateHandler.pushState(b.states.stopped);
                            b.stateHandler.pushState(b.states.stopping);
                            b.stateHandler.pushState(b.states.beforeStopping)
                        } else {
                            b.stateHandler.pushState(b.states.idle)
                        }
                    },
                    waitEvents: {
                        "notify:spin:serverResponseReceived": false
                    }
                }
            },
            spinning: {
                state: {
                    name: "Spinning",
                    execute: function() {},
                    waitEvents: {
                        "notify:spin:serverResponseReceived": false
                    }
                }
            },
            beforeStopping: {
                state: {
                    name: "BeforeStopping",
                    execute: function() {},
                    waitEvents: {}
                }
            },
            stopping: {
                state: {
                    name: "Stopping",
                    execute: function() {},
                    waitEvents: {
                        "notify:spin.AllIsStopped": false
                    }
                }
            },
            stopped: {
                state: {
                    name: "Stopped",
                    execute: function() {},
                    waitEvents: {}
                }
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.SpinModel,
            view: Core.Slots.SpinView,
            controller: Core.Slots.SpinController
        }
    }
};
Core.Slots.Spin = Sys.extend(Core.Module, Core.Slots.Spin, "Core.Slots.Spin");
Sys.ns("Core.Slots");
Core.Slots.SpinModel = {
    constructor: function() {
        Core.Slots.SpinModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var i = this,
            c = Resources.readData("config"),
            g = Resources.readData("gameServerInitResponse"),
            b = c.reel.clientReels,
            e = i.getDefaultOutcome(c),
            a = i.parseInitialOutcome(),
            f = {},
            h, d = c.clientConfig.spinTimes;
        if (!Sys.isDefined(d.respin)) {
            d.respin = d.standard
        }
        if (!Sys.isDefined(d.freeSpin)) {
            d.freeSpin = d.standard
        }
        i.storeData("spinTimes", d);
        i.storeData("minimumSpinTime", c.clientConfig.spinTimes.minimumSpinTime);
        i.storeData("nearwinEnabled", g.nearwinallowed);
        i.storeData("isValidServerResponse", false);
        if (i.isUsingStackedSymbols()) {
            i.modifyReelsForStackedSymbols(c.reel)
        }
        Sys.each(Object.keys(b), function(j) {
            h = {};
            h.reels = b[j];
            h.reelLists = [];
            h.defaultOutcome = e[j] || e.generic;
            h.initReelInfo = a[j] || h.defaultOutcome;
            h.reelInfo = h.initReelInfo;
            f[j] = h
        });
        i.storeData("reelsets", f);
        Resources.storeData("symbolLayout", [])
    },
    isUsingStackedSymbols: function() {
        var b = Resources.readData("config"),
            c = Sys.isDefined(b.reel.stackedSymbols),
            a = false;
        if (c && b.reel.stackedSymbols.length > 0) {
            a = true
        }
        return a
    },
    modifyReelsForStackedSymbols: function(b) {
        var m = b.clientReels,
            h = b.stackedSymbols,
            o = [],
            g = {},
            c, n, f, a, e = 0,
            l, k, d = function(s, q, i, p) {
                Sys.each(q, function(t, r) {
                    s[t.index] = i + "." + p + "." + r
                })
            },
            j = function(i) {
                l = g[i].filter(function(p) {
                    return p.reelIndex === e
                });
                return l
            };
        Sys.iterate(m, function(i, p) {
            e = 0;
            if (!Sys.isDefined(g[i])) {
                g[i] = []
            }
            Sys.each(p, function(q) {
                Sys.each(h, function(r) {
                    o = [];
                    n = q.length;
                    for (c = 0; c < n + r.size; c++) {
                        f = c >= n ? c - n : c;
                        a = q[f];
                        if (a === r.symbol) {
                            o.push({
                                sym: a,
                                index: f
                            });
                            if (o.length === r.size) {
                                d(q, o, a, r.size);
                                k = j(i);
                                if (k.length === 0) {
                                    g[i].push({
                                        reelIndex: e,
                                        symbols: [a]
                                    })
                                } else {
                                    if (k[0].symbols.indexOf(a) === -1) {
                                        k[0].symbols.push(a)
                                    }
                                }
                            }
                        } else {
                            o = []
                        }
                    }
                });
                e++
            })
        });
        Resources.storeData("reelsWithStackedSymbols", g)
    },
    getNoWinOutcome: function() {
        var a = this.readData("reelsets"),
            b = this.readData("currentReelset");
        return a[b].defaultOutcome
    },
    getDefaultOutcome: function(a) {
        return a.reel.defaultOutcome
    },
    parseInitialOutcome: function() {
        var b = Resources.readData("gameServerInitResponseObject"),
            c = b.rs,
            a = {};
        Sys.iterate(c, function(e, d) {
            a[d.id] = Sys.utils.parseReelInfo(b, d.id)
        });
        return a
    },
    updateInitReelInfo: function(c, b) {
        var a = this.readData("reelsets"),
            d = a[c];
        if (d) {
            d.initReelInfo = b;
            d.reelInfo = d.initReelInfo
        }
    },
    startSpin: function() {
        var a = this;
        a.restoreSpinType();
        a.storeData("spinStartTime", Date.now());
        a.storeData("hasFinishedStartSequence", false);
        a.removeData("stopSequenceStartTime");
        a.setState("spinning")
    },
    setStopSequenceStartTime: function(a) {
        this.storeData("stopSequenceStartTime", a)
    },
    restoreSpinType: function() {
        if (this.spinType === "quickStop") {
            this.spinType = this.previousSpinType
        }
    },
    insertRandomSymbolsInReel: function(e, d, c, f) {
        var b, a;
        for (b = 0; b < d; b++) {
            this.insertRandomSymbol(e, b, d - 1, 0)
        }
        for (a = 0; a < c; a++) {
            this.insertRandomSymbol(e, d + f + a, (d + f + c) - 1, 1)
        }
    },
    insertRandomSymbol: function(a, d, s, c) {
        var r = this,
            g = r.readData("reelsets"),
            j = r.readData("currentReelset"),
            f = g[j],
            i = f.reelLists[a],
            h = f.reels[a],
            k = h.length,
            o, n = [],
            q, b, m, l;
        if (r.isUsingStackedSymbols()) {
            n = Sys.pluck(Resources.readData("config").reel.stackedSymbols, "symbol")
        }
        if (a > 0) {
            q = f.reelLists[a - 1];
            if (Sys.isDefined(q.model.nextOutcomeSymbols)) {
                l = q.model.nextOutcomeSymbols[d]
            } else {
                l = q.model.outcomeSymbols[d]
            }
            if (!r.checkIfCanBeAdjacent(l)) {
                n = r.addToExcludedSymbols(n, [l])
            }
        }
        if (d > 0) {
            b = i.model.nextOutcomeSymbols[d - 1];
            if (!r.checkIfCanBeAdjacent(b)) {
                n = r.addToExcludedSymbols(n, [b])
            }
        }
        if (d < k - 1) {
            if (d === s) {
                m = h[d + 1];
                if (!r.checkIfCanBeAdjacent(m)) {
                    n = r.addToExcludedSymbols(n, [m])
                }
            }
        }
        if (!r.checkIfPartOfStackedSymbol(i, d)) {
            try {
                o = r.getRandomSymbol(n);
                i.model.setOutcomeSymbol(d, o, s, c)
            } catch (p) {}
        }
    },
    checkIfPartOfStackedSymbol: function(c, b) {
        var d = false,
            a;
        if (Sys.isDefined(c.model.outcomeSymbols[b])) {
            a = c.model.outcomeSymbols[b];
            if (a.indexOf(".") > -1) {
                d = true
            }
        }
        return d
    },
    checkIfCanBeAdjacent: function(c) {
        var a = Resources.readData("config"),
            b = a.reel.nonAdjacentSymbols || [];
        return b.indexOf(c) <= -1
    },
    addToExcludedSymbols: function(f, a) {
        var d = this,
            c = f || [],
            g = a || [],
            h = g.length,
            e, b;
        for (b = 0; b < h; b++) {
            e = g[b];
            if (c.indexOf(e) === -1) {
                c.push(e);
                g.splice(b, 1);
                return d.addToExcludedSymbols(c, g)
            }
        }
        return c
    },
    getAllSymbolNames: function() {
        var h = this,
            e = h.readData("reelsets"),
            g = e.basic,
            a = g.reels,
            b, k = [],
            d, c, f;
        if (h.isUsingStackedSymbols()) {
            k = k.concat(h.getAllStackedSymbolNames())
        }
        if (a.length > 0) {
            for (d = 0; d < a.length; d++) {
                b = a[d];
                for (c = 0; c < b.length; c++) {
                    f = b[c];
                    if (k.indexOf(f) === -1) {
                        k.push(f)
                    }
                }
            }
        }
        return k
    },
    getAllStackedSymbolNames: function() {
        var b = Resources.readData("config"),
            e = [],
            d, a, c;
        Sys.each(b.reel.stackedSymbols, function(f) {
            c = f.size;
            e.push(f.symbol);
            for (d = 0; d < c; d++) {
                a = f.symbol + "." + c + "." + d;
                e.push(a)
            }
        });
        return e
    },
    checkIfSymbolIsAllowed: function(f, c) {
        var b = true,
            a = c || [],
            e = a.length,
            d;
        for (d = 0; d < e; d++) {
            if (f === a[d]) {
                return false
            }
        }
        return b
    },
    getRandomSymbol: function(a) {
        var d = this,
            c, g, f = a || [],
            e = d.getAllSymbolNames(),
            b;
        f = d.addToExcludedSymbols(f, d.getAllStackedSymbolNames());
        b = e.length - f.length;
        if (b < 1) {
            throw new Error("No available symbol identifiers... Available: " + e.length + " Excluded: " + f.length)
        }
        g = e.length;
        c = Sys.Math.randomIntBetween(0, g - 1);
        if (f.length > 0) {
            if (!d.checkIfSymbolIsAllowed(e[c], a)) {
                return d.getRandomSymbol(a)
            }
        }
        return e[c]
    },
    stopSpin: function(c, a) {
        var d = this,
            b = d.readData("reelsets"),
            e = d.readData("currentReelset"),
            f = b[e];
        d.setStopSequenceStartTime(Date.now());
        f.reelInfo = c;
        d.storeData("reelInfo", c);
        d.storeData("nearWinList", a);
        d.setState("stopped")
    },
    timeToStop: function(e) {
        var f = this,
            b = Date.now(),
            a = f.readData("spinStartTime"),
            c = f.readData("minimumSpinTime"),
            g = f.readData("hasFinishedStartSequence"),
            h = (b - a) >= c,
            d = f.spinType === "quickSpin",
            i = f.spinType === "quickStop";
        if (g && (h || d || i)) {
            return b >= f.getStopTime(e)
        }
        return false
    },
    getStopTime: function(e) {
        var d = this,
            a = d.readData("stopSequenceStartTime"),
            b = d.readData("nearwinEnabled"),
            c = a + d.getReelStopDelay(e);
        if (b && d.spinType !== "quickStop") {
            c += d.getNearWinDelay(e)
        }
        return c
    },
    getReelStopDelay: function(d) {
        var b = this,
            e = b.readData("currentReelset"),
            c = b.readData("spinTimes"),
            a;
        if (b.spinType === "quickStop" || b.spinType === "quickSpin") {
            a = c[b.spinType]
        } else {
            if (e === "freeSpin" || e === "respin") {
                a = c[e]
            } else {
                a = c.standard
            }
        }
        return a.reelStopDelays[d] + a.duration
    },
    getNearWinDelay: function(d) {
        var b = 0,
            e = this.readData("spinTimes").nearWinDelay,
            a = this.readData("nearWinList") || [],
            c;
        for (c = 0; c < a.length; c++) {
            if (a[c] <= d) {
                b += e
            }
        }
        return b
    },
    setSpinType: function(a) {
        var b = this;
        b.previousSpinType = b.spinType;
        b.spinType = a;
        b.fireEvent("model:" + a)
    }
};
Core.Slots.SpinModel = Sys.extend(Core.Model, Core.Slots.SpinModel, "Core.Slots.SpinModel");
Sys.ns("Core.Slots");
Core.Slots.SpinView = {
    SPIN_SOUNDS: {
        basic: {
            spinStart: {
                id: "spinStart",
                name: "spinStart"
            },
            reelSpin: {
                id: "reelSpin",
                name: "reelSpin",
                loop: true
            },
            reelBounce: {
                id: "reelBounce",
                name: "reelBounce"
            },
            reelStop: {
                id: "reelStop",
                name: "reelStop"
            }
        }
    },
    constructor: function() {
        Core.Slots.SpinView.superclass.constructor.apply(this, arguments)
    },
    pauseStopSequenceConfig: {},
    setupEvents: function() {
        var a = this;
        a.on({
            "model:spinning": a.startSpin,
            "model:stopped": a.stopSpin
        })
    },
    loaded: function() {
        var a = this;
        Sys.iterate(a.model.readData("reelsets"), a.setupReelListsForReelset.bind(a))
    },
    setupReelListsForReelset: function(g, f) {
        var t = this,
            o, s, a = Resources.readData("config").reel,
            p = a.symbolRows,
            q = a.symbolCols,
            d = a.orientation,
            c = a.reelAreaTop,
            k = a.reelAreaLeft,
            j = a.reelSpacing,
            l = d === "horizontal" ? p : q,
            r = d === "horizontal" ? q : p,
            b = a.reelDepthModifiers || Sys.utils.initArray(l, 0),
            m = f.reels,
            n = f.reelLists,
            u = Layering.Game.Slots.Spin.symbols,
            h, e;
        for (o = 0; o < l; o++) {
            if (d === "horizontal") {
                h = k;
                e = c + o * (a.symbolHeight + j)
            } else {
                h = k + o * (a.symbolWidth + j);
                e = c
            }
            s = new Animation.ReelList({
                id: g + "_" + o,
                symbolWidths: a.symbolWidths,
                symbolHeights: a.symbolHeights,
                blurredSymbolWidths: a.blurredSymbolWidths,
                blurredSymbolHeights: a.blurredSymbolHeights,
                symbolCenterToCenter: a.symbolCenterToCenter,
                baseDepth: u + b[o],
                depthDistribution: a.depthDistribution,
                symbolSpecificDepthModifiers: a.symbolSpecificDepthModifiers,
                numberOfOutcomeSymbols: r,
                x: h,
                y: e,
                orientation: d,
                visibleLength: a.visibleLength,
                outcomeOffset: a.outcomeOffset,
                spinDirection: a.spinDirection,
                reelStrip: m[o],
                timeToMoveOneSlot: a.timeToMoveOneSlot,
                startBounceSupportPointOffset: a.startBounceSupportPointOffset,
                endBounceSupportPointOffsets: a.endBounceSupportPointOffsets,
                endBounceDurations: a.endBounceDurations,
                startSpinCompleteCallback: t.startSpinComplete.bind(t),
                bounceStartCallback: t.reelStartedBouncing.bind(t),
                reelStoppedCallback: t.reelStopped.bind(t)
            });
            n.push(s)
        }
    },
    setActiveSpinSound: function(a) {
        var b = this;
        switch (a) {
            case "freespin":
                if (Sys.isDefined(b.SPIN_SOUNDS.freeSpins)) {
                    b.activeSpinSounds = b.SPIN_SOUNDS.freeSpins
                } else {
                    b.activeSpinSounds = b.SPIN_SOUNDS.basic
                }
                break;
            case "respin":
                if (Sys.isDefined(b.SPIN_SOUNDS.respin)) {
                    b.activeSpinSounds = b.SPIN_SOUNDS.respin
                } else {
                    b.activeSpinSounds = b.SPIN_SOUNDS.basic
                }
                break;
            default:
                b.activeSpinSounds = b.SPIN_SOUNDS.basic;
                break
        }
    },
    startSpin: function() {
        var e = this,
            d, c = e.model.readData("reelsets"),
            b = c[e.model.readData("currentReelset")].reelLists,
            a = b.length;
        e.fireEvent("view:playAudio", e.activeSpinSounds.spinStart);
        e.isStopSequenceResuming = false;
        e.numReelsStarted = 0;
        e.reelStoppedCount = 0;
        for (d = 0; d < a; d++) {
            b[d].startSpin()
        }
    },
    startSpinComplete: function() {
        var a = this;
        a.fireEvent("view:startSpinComplete", a.numReelsStarted);
        if (a.numReelsStarted === 0) {
            a.fireEvent("view:playAudio", a.activeSpinSounds.reelSpin)
        }
        a.numReelsStarted++
    },
    stopSpin: function() {
        var b = this,
            a = b.model.readData("reelInfo");
        this.stopped = 0;
        this.checkIfTimeToStop(a)
    },
    checkIfTimeToStop: function(f) {
        var j = this,
            g, h = j.model.readData("reelsets"),
            k = h[j.model.readData("currentReelset")].reelLists,
            b = k.length,
            d, e = Resources.readData("config").reel,
            c = e.symbolRows,
            a = j.getNumberOfExtraRows();
        clearTimeout(j.checkTimeout);
        for (g = 0; g < b; g++) {
            d = k[g];
            if (!d.isStopping() && j.model.timeToStop(g) && !j.isStopSequencePaused()) {
                d.model.numberOfOutcomeSymbols = c + a + j.getNumberOfExtraRowsAbove();
                j.fireEvent("view:reelStopStarted", g);
                d.stopSpin(f[g]);
                if (j.model.isUsingStackedSymbols()) {
                    j.model.insertRandomSymbolsInReel(g, j.getNumberOfExtraRowsAbove(), a, c)
                }
                j.stopped++
            }
        }
        if (j.stopped < b) {
            j.checkTimeout = setTimeout(function() {
                j.checkIfTimeToStop(f)
            }, 40)
        }
    },
    isStopSequencePaused: function() {
        return (this.stopped === this.pauseStopSequenceConfig.reelIndex)
    },
    reelStopped: function() {
        var c = this,
            b = c.model.readData("reelsets"),
            a = b[c.model.readData("currentReelset")].reelLists;
        c.activeSpinSounds.reelStop.id = "reelStop" + c.reelStoppedCount;
        c.fireEvent("view:playAudio", c.activeSpinSounds.reelStop);
        c.updateSymbolLayout(c.reelStoppedCount);
        c.fireEvent("view:reelStoppedSpinning", c.reelStoppedCount);
        c.reelStoppedCount += 1;
        if (c.reelStoppedCount === a.length) {
            c.fireEvent("view:stopAudio", c.activeSpinSounds.reelSpin.id);
            c.fireEvent("view:allReelsStoppedSpinning");
            if (c.model.isUsingStackedSymbols()) {
                c.fireEvent("view:stackedSymbolsReplaced", a)
            }
        }
    },
    reelStartedBouncing: function() {
        var a = this;
        a.activeSpinSounds.reelBounce.id = "reelBounce" + a.reelStoppedCount;
        a.fireEvent("view:playAudio", a.activeSpinSounds.reelBounce)
    },
    updateSymbolLayout: function(d) {
        var c = this,
            b = c.model.readData("reelsets"),
            a = b[c.model.readData("currentReelset")].reelLists;
        Resources.readData("symbolLayout")[d] = a[d].getSymbolLayout()
    },
    getNumberOfExtraRows: function() {
        var e = this,
            d = 0,
            b = Resources.readData("config"),
            f = (Sys.isDefined(b.reel.fixedSpacingRows)) ? b.reel.fixedSpacingRows : -1,
            a = 0,
            c;
        if (e.model.isUsingStackedSymbols()) {
            if (f > -1) {
                return f
            }
            Sys.each(b.reel.stackedSymbols, function(g) {
                c = g.size;
                a = Math.max(a, c)
            });
            d = ((a - 1) * 2) + 1
        }
        return d
    },
    getNumberOfExtraRowsAbove: function() {
        var d = this,
            b = Resources.readData("config"),
            a = 0,
            c;
        if (d.model.isUsingStackedSymbols()) {
            Sys.each(b.reel.stackedSymbols, function(e) {
                c = e.size;
                a = Math.max(a, c)
            });
            a += 2
        } else {
            a = 0
        }
        return a
    },
    resumeStopSequence: function() {
        var a = this,
            b = a.pauseStopSequenceConfig.reelIndex;
        if (a.isStopSequencePaused() && !a.isStopSequenceResuming) {
            a.model.setStopSequenceStartTime(Date.now() - a.model.getReelStopDelay(b));
            if (!a.hasFiredPausedStopSequenceEvent) {
                a.fireEvent("view:stopSequencePaused");
                a.hasFiredPausedStopSequenceEvent = true
            }
        }
        a.pauseStopSequenceConfig = {}
    },
    activateReelset: function(e, d) {
        var c = this,
            b = c.model.readData("reelsets"),
            a = b[e].reelLists;
        Sys.each(a, function(f) {
            Game.stage.view.addToRenderLoop(f, d)
        });
        c.setActiveSpinSound(e);
        c.model.storeData("currentReelset", e);
        c.model.storeData("currentScene", d);
        c.model.storeData("reelInfo", b[e].reelInfo);
        Sys.each(a, function(g, f) {
            c.updateSymbolLayout(f)
        })
    },
    deactivateReelset: function() {
        var c = this,
            e = c.model.readData("currentReelset"),
            b = c.model.readData("reelsets"),
            a, d = this.model.readData("currentScene");
        if (!e) {
            return
        }
        a = b[e].reelLists;
        Sys.each(a, function(f) {
            Game.stage.view.removeFromRenderLoop(f, d)
        });
        c.model.removeData("currentReelset");
        c.model.removeData("currentScene");
        c.model.removeData("reelInfo")
    },
    setAllReelSymbols: function(g, e) {
        var f = this,
            d = f.model.readData("reelsets"),
            h = d[g],
            c = h.reelLists,
            a = c.length,
            b;
        e = Sys.isDefined(e) ? e : f.model.readData("reelInfo");
        for (b = 0; b < a; b++) {
            c[b].setAllReelSymbols(e[b])
        }
        h.reelInfo = e
    },
    setSymbols: function(d) {
        var l = this,
            k = l.model.readData("reelsets"),
            n = k[l.model.readData("currentReelset")].reelLists,
            b = Object.keys(d),
            c = b.length,
            a, e, m, g, h = 0,
            f;
        while (h < c) {
            g = b[h];
            a = Object.keys(d[g]);
            m = a.length;
            f = 0;
            while (f < m) {
                e = a[f];
                n[g].setReelSymbol(d[g][e], Sys.utils.toInt(e));
                ++f
            }++h
        }
    },
    pauseStopSequence: function(a) {
        var b = this;
        a = a || {};
        if (!Sys.isDefined(a.reelIndex)) {
            a.reelIndex = 0
        }
        if (Sys.isDefined(a.duration)) {
            setTimeout(function() {
                b.fireEvent("view:resumeStopSequence")
            }, a.duration)
        }
        if (Sys.isDefined(b.pauseStopSequenceConfig.reelIndex)) {
            b.model.setStopSequenceStartTime(Date.now())
        }
        b.pauseStopSequenceConfig = a
    },
    hide: function() {
        var b = this,
            a = b.model.readData("reelsets")[b.model.readData("currentReelset")].reelLists;
        Sys.each(a, function(c) {
            Sys.each(c.animationItems, function(d) {
                d.prop.opacity = 0;
                d.prop.operations.fade = [{
                    time: 0,
                    value: 0
                }, {
                    time: 100,
                    value: 0,
                    goTo: 0
                }]
            })
        })
    },
    show: function() {
        var b = this,
            a = b.model.readData("reelsets")[b.model.readData("currentReelset")].reelLists;
        Sys.each(a, function(c) {
            Sys.each(c.animationItems, function(d) {
                d.prop.opacity = 1;
                d.prop.operations.fade = [{
                    time: 0,
                    value: 1
                }, {
                    time: 100,
                    value: 1,
                    goTo: 0
                }]
            })
        })
    },
    setReelVisibility: function(d) {
        var h = this,
            e = h.model.readData("reelsets"),
            l = e[h.model.readData("currentReelset")].reelLists,
            a = d.reels.length,
            f = d.opacity,
            g, k, c, b;
        for (c = 0; c < a; c++) {
            g = l[d.reels[c]].animationItems;
            k = g.length;
            for (b = 0; b < k; b++) {
                g[b].prop.opacity = f;
                g[b].prop.operations.fade = [{
                    time: 0,
                    value: f
                }, {
                    time: 100,
                    value: f,
                    goTo: (f === 0) ? 0 : undefined
                }]
            }
        }
    },
    handleSymbols: function(c, f) {
        var g = this,
            e = g.model.readData("reelsets")[g.model.readData("currentReelset")].reelLists,
            a = Object.keys(c),
            b = a.length,
            d = 0,
            h;
        while (d < b) {
            h = a[d];
            e[Sys.utils.toInt(h)][f](c[h]);
            ++d
        }
    },
    setOverlaySymbols: function(b) {
        var a = this.model.readData("reelLists");
        Sys.each(a, function(d, c) {
            d.setAllReelSymbols({
                symbols: b[c]
            })
        })
    },
    getOverlaySymbols: function() {
        var b = this.model.readData("serverResponse"),
            a = [];
        Sys.each(b.reelInfo, function(d) {
            var c = [];
            Sys.each(d.symbols, function(e) {
                c.push(e)
            });
            a.push(c)
        });
        Sys.each(b.overlayData.childless, function(c) {
            a[c.pos.x][c.pos.y] = c.sym
        });
        return a
    }
};
Core.Slots.SpinView = Sys.extend(Core.View, Core.Slots.SpinView, "Core.Slots.SpinView");
Sys.ns("Core.Slots");
Core.Slots.SpinController = {
    constructor: function() {
        Core.Slots.SpinController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
            "notify:responseParser.responseParsed": a.serverResponse,
            "notify:serverManager.serverErrorReceived": a.errorResponse,
            "notify:stateHandler.enteringSpinningState": a.wantStartSpin,
            "notify:stateHandler.enteringStoppingState": a.wantStopSpin,
            "notify:quickStopper.quickStop": a.quickStop,
            "notify:settingsManager.settingChanged": a.onSettingsChanged,
            "request:spin.startNewRound": a.startNewRound,
            "request:spin.activateReelset": a.activateReelset,
            "request:spin.activateInitReelset": a.activateInitReelset,
            "request:spin.activateDefaultOutcome": a.activateDefaultOutcome,
            "request:spin.deactivateReelset": a.deactivateReelset,
            "request:spin.startSpin": a.startSpin,
            "request:spin.stopSpin": a.stopSpin,
            "request:spin.abortSpin": a.abortSpin,
            "request:spin.cancelSpin": a.cancelSpin,
            "request:spin.setSymbols": a.setSymbols,
            "request:spin.pauseStopSequence": a.pauseStopSequence,
            "request:spin.resumeStopSequence": a.resumeStopSequence,
            "request:spin.changeMinSpinTime": a.changeMinSpinTime,
            "request:spin.updateInitReelInfo": a.updateInitReelInfo,
            "request:spin.hideSymbols": a.hideSymbols,
            "request:spin.showSymbols": a.showSymbols,
            "view:startSpinComplete": a.onStartSpinComplete,
            "view:reelStoppedSpinning": a.announceReelStopped,
            "view:allReelsStoppedSpinning": a.announceSpinComplete,
            "view:stopSequencePaused": a.announceSpinStopSequencePaused,
            "view:stopSequenceResumed": a.announceSpinStopSequenceResumed,
            "view:resumeStopSequence": a.resumeStopSequence,
            "view:reelStopStarted": a.announceStopSpinStarted,
            "view:stackedSymbolsReplaced": a.stackedSymbolsReplaced,
            "view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
            "view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop")
        })
    },
    updateSpinType: function() {
        var a = this;
        if (Services.settingsManager.getSetting("quickSpin")) {
            a.model.setSpinType("quickSpin")
        } else {
            a.model.setSpinType("standard")
        }
    },
    onModulesFinishedLoading: function() {
        this.view.loaded()
    },
    serverResponse: function(a) {
        this.fireEvent("request:spin.child.storeServerResponse", a);
        if (!a.clientaction.contains("init") && a.clientaction !== "endbonus") {
            this.model.storeData("isValidServerResponse", true);
            this.fireEvent("notify:spin:serverResponseReceived")
        }
    },
    errorResponse: function(a) {
        var b = this;
        b.model.storeData("isValidServerResponse", false);
        if (Sys.utils.httpRequestIsOK(a) && b.model.readData("currentReelset") === "basic") {
            b.fireEvent("notify:spin:serverResponseReceived")
        }
        if (Sys.isDefined(b.model.readData("currentReelset"))) {
            b.fireEvent("request:reelStopAnimations.abort");
            b.abortSpin()
        }
    },
    wantStartSpin: function() {
        this.fireEvent("request:spin.child.wantStartSpin");
        this.fireEvent("request:serverManager.sendAction", "nextAction")
    },
    wantStopSpin: function() {
        this.fireEvent("request:spin.child.wantStopSpin")
    },
    quickStop: function() {
        this.model.setSpinType("quickStop")
    },
    onSettingsChanged: function(a, b) {
        if (a === "quickSpin") {
            if (b) {
                this.fireEvent("request:spinButton.addDisplayType", "quickSpin")
            } else {
                this.fireEvent("request:spinButton.removeDisplayType", "quickSpin")
            }
        }
    },
    updateInitReelInfo: function(b, a) {
        this.model.updateInitReelInfo(b, a)
    },
    startNewRound: function() {
        var a = this;
        if (a.waitingToStart) {
            return
        }
        if (Services.moneyManager.canPlaceAnotherBet()) {
            a.performSpin()
        } else {
            a.waitingToStart = true;
            Services.moneyManager.reloadBalance().done(function() {
                if (Services.moneyManager.canPlaceAnotherBet()) {
                    a.performSpin()
                } else {
                    a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
                }
            }).fail(function() {
                a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
            }).always(function() {
                a.waitingToStart = false
            })
        }
    },
    performSpin: function() {
        this.updateSpinType();
        this.fireEvent("notify:spin.roundStart");
        Services.moneyManager.placeBet()
    },
    activateReelset: function(d, c) {
        var b = this,
            a = b.model.readData("reelsets"),
            e = a[d];
        if (b.model.readData("currentReelset") === d) {
            return
        }
        if (b.model.readData("currentReelset")) {
            b.view.deactivateReelset()
        }
        b.view.setAllReelSymbols(d, e.reelInfo);
        b.view.activateReelset(d, c);
        b.fireEvent("notify:spin.reelsetActivated", d)
    },
    activateInitReelset: function(d, c) {
        var b = this,
            a = b.model.readData("reelsets"),
            e = a[d];
        b.view.setAllReelSymbols(d, e.initReelInfo);
        b.activateReelset(d, c);
        if (this.allReelsHaveStopped) {
            this.view.show()
        } else {
            this.dialogClosed = true
        }
    },
    activateDefaultOutcome: function(d, c) {
        var b = this,
            a = b.model.readData("reelsets"),
            e = a[d];
        b.view.setAllReelSymbols(d, e.defaultOutcome);
        b.activateReelset(d, c);
        if (this.allReelsHaveStopped) {
            this.view.show()
        } else {
            this.dialogClosed = true
        }
        b.fireEvent("request:spin.child.revertSpin")
    },
    deactivateReelset: function() {
        if (this.model.readData("currentReelset")) {
            this.view.deactivateReelset()
        }
    },
    startSpin: function(c, b) {
        var a = this;
        a.aborted = false;
        a.dialogClosed = false;
        a.allReelsHaveStopped = false;
        a.announceSpinStarted(c);
        if (a.model.readData("currentReelset") !== c) {
            a.view.setAllReelSymbols(c);
            a.activateReelset(c, b)
        }
        a.model.startSpin()
    },
    stopSpin: function(b, a) {
        this.model.stopSpin(b, a)
    },
    setSymbols: function(a) {
        this.view.setSymbols(a)
    },
    pauseStopSequence: function(a) {
        this.view.pauseStopSequence(a)
    },
    resumeStopSequence: function() {
        this.view.resumeStopSequence()
    },
    changeMinSpinTime: function(a) {
        this.model.storeData("minimumSpinTime", a)
    },
    abortSpin: function() {
        var a = this;
        a.view.hide();
        a.model.setSpinType("quickStop");
        a.model.storeData("hasFinishedStartSequence", true);
        a.stopSpin(a.model.getNoWinOutcome());
        a.fireEvent("notify:spin.spinAborted");
        a.aborted = true
    },
    cancelSpin: function() {
        var a = this;
        a.model.storeData("isValidServerResponse", false);
        a.fireEvent("notify:spin:serverResponseReceived");
        a.fireEvent("request:reelStopAnimations.abort");
        a.fireEvent("request:spin.child.revertSpin");
        a.dialogClosed = true;
        a.abortSpin()
    },
    hideSymbols: function(a) {
        this.view.handleSymbols(a, "hideSymbols")
    },
    showSymbols: function(a) {
        this.view.handleSymbols(a, "showSymbols")
    },
    announceSpinStarted: function(a) {
        this.fireEvent("notify:spin.spinAnimationStarted", a)
    },
    onStartSpinComplete: function() {
        this.model.storeData("hasFinishedStartSequence", true);
        this.fireEvent("notify:spin.startSpinComplete")
    },
    announceReelStopped: function(a) {
        this.fireEvent("notify:spin.reelStoppedSpinning", a)
    },
    announceSpinComplete: function() {
        var a = this;
        if (a.aborted) {
            if (a.dialogClosed) {
                a.view.show()
            }
        }
        a.allReelsHaveStopped = true;
        this.fireEvent("notify:spin.spinAnimationComplete");
        this.fireEvent("notify:spin.AllIsStopped")
    },
    announceSpinStopSequencePaused: function() {
        this.fireEvent("notify:spin.stopSequencePaused")
    },
    announceSpinStopSequenceResumed: function() {
        this.fireEvent("notify:spin.stopSequenceResumed")
    },
    announceStopSpinStarted: function(a) {
        this.fireEvent("notify:spin.reelStopStarted", a)
    },
    stackedSymbolsReplaced: function(a) {
        this.fireEvent("notify:spin.stackedSymbolsReplaced", a)
    }
};
Core.Slots.SpinController = Sys.extend(Core.Controller, Core.Slots.SpinController, "Core.Slots.SpinController");
Sys.ns("Interface");
Interface.Ticker = {
    constructor: function() {
        Interface.Ticker.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["properties"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.TickerController,
            view: Interface.TickerBaseView,
            model: Core.Model
        }
    }
};
Interface.Ticker = Sys.extend(Core.Module, Interface.Ticker, "Interface.Ticker");
Sys.ns("Interface");
Interface.TickerBaseView = {
    BASE_CSS: "interface-ticker_container",
    CONTENT_CSS: "interface-ticker_text",
    BACKGROUND_URI: "interface-ticker_uri",
    RENDER_TARGET: "gameWrapper",
    ANIMATION_SPEED: 20000,
    constructor: function() {
        Interface.TickerBaseView.superclass.constructor.apply(this, arguments)
    },
    enable: function() {},
    disable: function() {},
    update: function() {}
};
Interface.TickerBaseView = Sys.extend(Core.View, Interface.TickerBaseView, "Interface.TickerBaseView");
Sys.ns("Interface");
Interface.TickerMobileView = {
    constructor: function() {
        Interface.TickerMobileView.superclass.constructor.apply(this, arguments);
        this.constructDOMElement();
        this.setupAnimation()
    },
    enable: function() {
        var a = this;
        if (a.model.hasProperty("enabled")) {
            a.container.el.style.display = "block";
            a.update();
            a.fireEvent("view:enabled")
        }
    },
    disable: function() {
        var a = this;
        if (!a.model.hasProperty("enabled")) {
            a.container.el.style.display = "none";
            a.update();
            a.fireEvent("view:disabled")
        }
    },
    update: function() {
        var b = this,
            a = b.model.readData("content");
        b.textContainer.removeAll();
        if (Sys.isDefined(a)) {
            if (!Sys.isArray(a)) {
                b.textContainer.add(a)
            } else {
                a.forEach(function(c) {
                    b.textContainer.add(c)
                })
            }
        }
        if (b.model.readData("animate") === true) {
            b.textContainer.el.style.paddingLeft = "100%";
            b.textContainer.el.style.width = "auto";
            b.animation.run(b.textContainer.el)
        } else {
            b.textContainer.el.style.paddingLeft = "0";
            b.textContainer.el.style.width = "100%";
            b.animation.removeAnimation(b.textContainer.el)
        }
    },
    constructDOMElement: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "ticker",
            tag: "div",
            cls: a.BASE_CSS + " " + a.BACKGROUND_URI,
            renderTo: a.RENDER_TARGET
        });
        a.textContainer = new Sys.Element({
            tag: "div",
            cls: a.CONTENT_CSS
        });
        a.container.add(a.textContainer)
    },
    setupAnimation: function() {
        var a = this;
        if (!Sys.isDefined(a.animation)) {
            a.animationConfig = {
                name: "scrollingAnimation",
                duration: a.ANIMATION_SPEED,
                timingFunction: "linear",
                iterationCount: "infinite",
                frames: {
                    "0%": {
                        "-webkit-transform": "translateX(0);",
                        "-moz-transform": "translateX(0);",
                        "-o-transform": "translateX(0);",
                        "-MS-transform": "translateX(0);",
                        transform: "translateX(0);"
                    },
                    "100%": {
                        "-webkit-transform": "translateX(-100%);",
                        "-moz-transform": "translateX(-100%);",
                        "-o-transform": "translateX(-100%);",
                        "-MS-transform": "translateX(-100%);",
                        transform: "translateX(-100%);"
                    }
                }
            };
            a.animation = new Interface.utils.CSSAnimation(a.animationConfig)
        }
    },
    onOrientationChange: function() {
        var a = this.container.el;
        if (Platform.isEdgeBrowser) {
            setTimeout(function() {
                a.style.visibility = "hidden";
                setTimeout(function() {
                    a.style.visibility = ""
                }, 200)
            }, 150)
        }
    }
};
Interface.TickerMobileView = Sys.extend(Interface.TickerBaseView, Interface.TickerMobileView, "Interface.TickerMobileView");
Sys.ns("Interface");
Interface.TickerController = {
    constructor: function() {
        Interface.TickerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:ticker.enable": this.enable,
            "request:ticker.disable": this.disable,
            "request:ticker.setText": this.setText,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "view:enabled": this.viewEnabled,
            "view:disabled": this.viewDisabled
        })
    },
    onGameSizeChanged: function() {
        if (typeof this.view.onOrientationChange === "function") {
            this.view.onOrientationChange()
        }
    },
    enable: function(b, a) {
        this.addProperty("enabled", b);
        this.model.storeData("animate", a === true);
        this.view.enable()
    },
    disable: function(a) {
        this.removeProperty("enabled", a);
        this.model.storeData("animate", false);
        this.view.disable()
    },
    setText: function(a) {
        this.model.storeData("content", a);
        this.view.update()
    },
    viewEnabled: function() {
        var a = this.model.readData("spinButtonAlignment") || false;
        if (!a) {
            this.model.storeData("spinButtonAlignment", true);
            this.fireEvent("request:spinButton.moveButton", {
                orientation: "portrait",
                vertical: 0.13
            })
        }
        this.fireEvent("request:balanceDisplay.addClass", "ticker")
    },
    viewDisabled: function() {
        var a = this.model.readData("spinButtonAlignment") || false;
        if (a) {
            this.model.storeData("spinButtonAlignment", false);
            this.fireEvent("request:spinButton.moveButton", {
                orientation: "portrait",
                vertical: -0.13
            })
        }
        this.fireEvent("request:balanceDisplay.removeClass", "ticker")
    }
};
Interface.TickerController = Sys.extend(Core.Controller, Interface.TickerController, "Interface.TickerController");
Sys.ns("Interface");
Interface.RoundStartButton = {
    constructor: function() {
        Interface.RoundStartButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation", "userInput", "properties"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.RoundStartButtonModel,
            view: Interface.RoundStartButtonBaseView,
            controller: Interface.RoundStartButtonController
        }
    }
};
Interface.RoundStartButton = Sys.extend(Core.Module, Interface.RoundStartButton, "Interface.RoundStartButton");
Sys.ns("Game.Slots");
Interface.RoundStartButtonController = {
    ROUND_START_EVENT: undefined,
    constructor: function() {
        Interface.RoundStartButtonController.superclass.constructor.apply(this, arguments);
        this.view.setUpDOMStructure();
        this.properties = {}
    },
    setupEvents: function() {
        var a = this,
            b = {
                "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
                "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
                "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingIdleState,
                "notify:gameModeChanged": a.onGameModeChanged,
                "view:clicked": a.onClick,
                "view:hidden": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".hidden"),
                "view:shown": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".shown"),
                "view:pressed": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".pressed"),
                "view:released": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".released"),
                "view:disable": a.disable.bind(a),
                "view:hide": a.hide.bind(a),
                "view:show": a.show.bind(a),
                "view:enable": a.enable.bind(a),
                "request:enableBasicGamePanel": a.enable,
                "request:disableBasicGamePanel": a.disable
            };
        b["request:" + a.MODULE_NAME + ".hide"] = a.hideRequested;
        b["request:" + a.MODULE_NAME + ".show"] = a.show;
        b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
        b["request:" + a.MODULE_NAME + ".disable"] = a.disableRequested;
        b["request:" + a.MODULE_NAME + ".addDisplayType"] = a.addDisplayType;
        b["request:" + a.MODULE_NAME + ".removeDisplayType"] = a.removeDisplayType;
        b["request:" + a.MODULE_NAME + ".addProperty"] = a.addProperty;
        b["request:" + a.MODULE_NAME + ".removeProperty"] = a.removeProperty;
        a.on(b)
    },
    onUserInputStart: function(a) {
        this.view.userInputStart(a)
    },
    onUserInputMove: function(a) {
        this.view.userInputMove(a)
    },
    onUserInputHover: function(a) {
        this.view.userInputHover(a)
    },
    onUserInputEnd: function(a) {
        this.view.userInputEnd(a)
    },
    onClick: function() {
        this.fireEvent(this.ROUND_START_EVENT)
    },
    removeProperty: function(c, b) {
        var a = this;
        if (a.model.hasProperty(c)) {
            a.model.removeProperty(c, b);
            if (!a.model.hasProperty(c)) {
                a.updateAppearance()
            }
            if (!a.model.readData("inIdleState") && !a.model.hasProperty("visibleDuringRound")) {
                a.hide(a.MODULE_NAME)
            }
        }
    },
    addDisplayType: function(b) {
        var a = !this.model.hasDisplayType(b);
        this.model.addDisplayType(b);
        if (a) {
            this.updateAppearance()
        }
    },
    removeDisplayType: function(a) {
        var b = this;
        if (b.model.hasDisplayType(a)) {
            b.model.removeDisplayType(a);
            if (!b.model.hasDisplayType(a)) {
                b.updateAppearance()
            }
        }
    },
    updateAppearance: function() {},
    hide: function(a) {
        this.addProperty("hidden", a)
    },
    hideRequested: function(a) {
        this.view.hideRequested(a)
    },
    show: function(a) {
        this.removeProperty("hidden", a)
    },
    enable: function(a) {
        this.removeProperty("disabled", a)
    },
    disable: function(a) {
        this.addProperty("disabled", a)
    },
    disableRequested: function(a) {
        this.view.disableRequested(a)
    },
    onEnteringIdleState: function() {
        var a = this;
        a.model.storeData("inIdleState", true);
        a.show(a.MODULE_NAME)
    },
    onLeavingIdleState: function() {
        var a = this;
        a.model.storeData("inIdleState", false);
        if (!a.model.hasProperty("visibleDuringRound")) {
            a.hide(a.MODULE_NAME)
        }
    },
    onGameModeChanged: function(b) {
        var a = this;
        a.model.storeData("currentGameMode", b);
        if (b === "BASIC") {
            a.enable("notInBasicGame");
            a.show("globalRequest");
            a.view.show()
        } else {
            a.disable("notInBasicGame");
            a.hide("globalRequest");
            a.view.disableRequested("notInBasicGame");
            a.view.hideRequested("globalRequest");
            a.updateVisibility()
        }
    }
};
Interface.RoundStartButtonController = Sys.extend(Core.Controller, Interface.RoundStartButtonController, "Interface.RoundStartButtonController");
Sys.ns("Interface");
Interface.RoundStartButtonModel = {
    DISPLAY_TYPES: {},
    PROPERTIES: {
        hidden: [],
        visibleDuringRound: [],
        visibleOnInput: []
    },
    constructor: function() {
        Interface.RoundStartButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var b = Resources.readData("gameServerInitResponseObject"),
            a = b.gamestate ? b.gamestate : undefined,
            c = a ? a.current : undefined;
        this.data = {
            properties: this.PROPERTIES,
            displayTypes: this.DISPLAY_TYPES,
            currentGameMode: c ? c.toUpperCase() : undefined
        }
    },
    hasDisplayType: function(a) {
        return this.readData("displayTypes")[a]
    },
    addDisplayType: function(a) {
        this.readData("displayTypes")[a] = true
    },
    removeDisplayType: function(a) {
        this.readData("displayTypes")[a] = false
    }
};
Interface.RoundStartButtonModel = Sys.extend(Core.Model, Interface.RoundStartButtonModel, "Interface.RoundStartButtonModel");
Sys.ns("Interface");
Interface.RoundStartButtonBaseView = {
    BUTTON_ID: "roundStartButton",
    BASE_CSS: "interface-roundStartButton_base",
    PRESSED_CSS: "interface-roundStartButton_pressed",
    URI_BASE_CSS: "interface-roundStartButton",
    PORTRAIT_POSITION: {
        TOP: 0.5,
        LEFT: 0.5
    },
    LANDSCAPE_POSITION: {
        TOP: 0.5,
        LEFT: 0.5
    },
    PORTRAIT_SIZE: {
        ASPECT_RATIO: 1,
        HEIGHT: 0.2
    },
    LANDSCAPE_SIZE: {
        ASPECT_RATIO: 1,
        WIDTH: 0.2
    },
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.RoundStartButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            id: a.BUTTON_ID,
            cls: a.BASE_CSS + " " + a.URI_BASE_CSS + "_default_uri",
            renderTo: a.RENDER_TARGET
        });
        a.model.storeData("currentUri", a.URI_BASE_CSS + "_default_uri");
        a.show();
        if (Sys.isDefined(a.model.hasProperty) && !a.model.hasProperty("hidden")) {
            a.show()
        } else {
            a.hide()
        }
    },
    userInputStart: function(c) {
        var b = this,
            a = b.isInputTarget(c);
        if (a) {
            if (!b.hidden()) {
                b.press()
            }
        } else {
            if (b.shouldBeHiddenByUserInput(c)) {
                b.hide()
            }
        }
        b.model.storeData("wasInitialInputTarget", a)
    },
    shouldBeHiddenByUserInput: function(a) {
        return !this.model.hasProperty("visibleOnInput") && Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)
    },
    userInputMove: function(c) {
        var b = this,
            a = b.isInputTarget(c);
        if (b.model.readData("wasInitialInputTarget") && !a) {
            b.userInputEnd(c)
        }
    },
    userInputHover: function(a) {},
    userInputEnd: function(c) {
        var b = this,
            a;
        if (b.model.readData("wasInitialInputTarget")) {
            a = b.isInputTarget(c);
            b.release(a);
            if (a) {
                b.fireEvent("view:clicked")
            }
        } else {
            if (!b.model.hasProperty("hidden")) {
                b.show()
            }
        }
        b.model.storeData("wasInitialInputTarget", false)
    },
    isInputTarget: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    press: function() {
        this.container.addCls(this.PRESSED_CSS);
        this.fireEvent("view:pressed")
    },
    release: function(a) {
        this.container.removeCls(this.PRESSED_CSS);
        this.fireEvent("view:released", a)
    },
    hide: function() {
        if (!this.hidden()) {
            this.container.el.style.display = "none";
            this.fireEvent("view:hidden")
        }
    },
    hidden: function() {
        return this.container.el.style.display === "none"
    },
    show: function() {
        if (this.hidden()) {
            this.container.el.style.display = "block";
            this.fireEvent("view:shown")
        }
    },
    enable: function() {
        this.container.el.style.opacity = 1
    },
    disable: function() {
        this.container.el.style.opacity = 0.5
    },
    setAppearance: function(c) {
        var d = this.URI_BASE_CSS + "_" + c + "_uri",
            b = this.container,
            a = this.model.readData("currentUri");
        b.replaceCSSClass(a, d, true);
        this.model.storeData("currentUri", d)
    },
    disableRequested: function(a) {
        this.fireEvent("view:disable", a)
    },
    hideRequested: function(a) {
        if (Sys.isDefined(a)) {
            this.fireEvent("view:hide", a)
        } else {
            this.hide()
        }
    },
    beforeLoaderClose: function() {}
};
Interface.RoundStartButtonBaseView = Sys.extend(Core.View, Interface.RoundStartButtonBaseView, "Interface.RoundStartButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButton = {
    constructor: function() {
        Interface.Slots.SpinButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["orientation", "userInput", "properties", "trigger"],
            desktop: [{
                userInput: {
                    inputEvents: ["start", "end", "cancel", "move", "hover"]
                }
            }, "properties", "trigger"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.Slots.SpinButtonModel,
            view: Interface.Slots.SpinButtonBaseView,
            controller: Interface.Slots.SpinButtonController
        }
    }
};
Interface.Slots.SpinButton = Sys.extend(Interface.RoundStartButton, Interface.Slots.SpinButton, "Interface.Slots.SpinButton");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonController = {
    ROUND_START_EVENT: "request:spin.startNewRound",
    AUTOPLAY_START_EVENT: "request:spinSettings.startAutoPlay",
    constructor: function() {
        Interface.Slots.SpinButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        Interface.Slots.SpinButtonController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "view:setSafeArea": this.fireEvent.bind(this, "request:fullscreen.setSafeArea"),
            "request:spinButton.startRound": this.startRound,
            "request:spinButton.showCounter": this.showCounter,
            "request:spinButton.hideCounter": this.hideCounter,
            "request:spinButton.updateCounter": this.updateCounter,
            "request:spinButton.pressed": this.onPressedRequest,
            "request:spinButton.released": this.onReleasedRequest,
            "request:spinButton.moveButton": this.onMoveButtonRequest,
            "notify:settingsManager.settingChanged": this.settingsChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "notify:stateHandler.enteringFreeSpinIntroState": this.onEnteringFreespinIntro,
            "notify:stateHandler.leavingFreeSpinIntroState": this.onLeavingFreespinIntro,
            "notify:stateHandler.enteringFreeSpinOutroState": this.onEnteringFreespinOutro,
            "notify:stateHandler.leavingFreeSpinOutroState": this.onLeavingFreespinOutro,
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.onBeforeLoaderClose,
            "view:playSound": this.playSoundForView,
            "view:notify": this.onViewNotify
        });
        if (Sys.isGcmEnabled) {
            this.on({
                "notify:stateHandler.enteringspinTypeRespinRestoreState": this.disable,
                "notify:stateHandler.leavingspinTypeRespinRestoreState": this.enable
            })
        }
    },
    initAnimations: function() {
        if (typeof this.view.initAnimations === "function") {
            this.view.initAnimations()
        }
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:spinButton.clicked", this, "Executed when the spin button is clicked");
        Services.trigger.registerTrigger("notify:spinButton.up", this, "When the spin button returns to the up state.");
        Services.trigger.registerTrigger("notify:spinButton.hover", this, "Executed when the spin button is hovered");
        Services.trigger.registerTrigger("notify:spinButton.down", this, "Executed when the spin button is down")
    },
    onMoveButtonRequest: function(a) {
        this.view.moveButtonPosition(a);
        this.fireEvent("request:quickSettingsMenu.movePosition", a)
    },
    playSoundForView: function(a) {
        this.fireEvent("request:audioPlayer.play", {
            name: a
        })
    },
    startRound: function() {
        this.fireEvent(this.ROUND_START_EVENT)
    },
    onPressedRequest: function() {
        if (this.model.readData("inIdleState")) {
            this.view.onPressedRequest()
        }
    },
    onReleasedRequest: function() {
        if (this.model.readData("inIdleState")) {
            this.view.onReleasedRequest()
        }
    },
    onLandscape: function() {
        var a = this;
        Mixins.orientation.controller.methods.onLandscape.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            if (a.view.canInteractWhileHidden()) {
                a.startListeningToUserInput()
            } else {
                a.stopListeningToUserInput()
            }
        }
    },
    onPortrait: function() {
        var a = this;
        Mixins.orientation.controller.methods.onPortrait.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            if (a.view.canInteractWhileHidden()) {
                a.startListeningToUserInput()
            } else {
                a.stopListeningToUserInput()
            }
        }
    },
    onEnteringIdleState: function() {
        var a = this;
        Interface.Slots.SpinButtonController.superclass.onEnteringIdleState.apply(a, arguments);
        if (a.model.hasProperty("disabledDuringRound")) {
            a.enable(a.MODULE_NAME)
        }
        a.view.disableSpinningAnimations()
    },
    onLeavingIdleState: function() {
        var a = this;
        Interface.Slots.SpinButtonController.superclass.onLeavingIdleState.apply(a, arguments);
        if (a.model.hasProperty("disabledDuringRound")) {
            a.disable(a.MODULE_NAME)
        }
        if (!a.model.hasProperty("disabled")) {
            a.view.enableSpinningAnimations()
        }
    },
    onBeforeLoaderClose: function() {
        this.view.beforeLoaderClose();
        this.updateAppearance();
        this.view.setFullscreenSafeArea()
    },
    onClick: function() {
        var b = this,
            a = b.model;
        if (a.hasProperty("hidden")) {
            if (b.view.canInteractWhileHidden()) {
                b.fireEvent("notify:spinButton.clickedWhileHidden")
            }
        } else {
            b.fireEvent("request:audioPlayer.play", {
                name: "spinButtonClick"
            });
            b.fireEvent("notify:spinButton.clicked", {
                skip: a.readData("noStopOnSpin")
            });
            if (a.readData("inIdleState")) {
                if (a.hasDisplayType("autoPlay")) {
                    b.fireEvent(b.AUTOPLAY_START_EVENT)
                } else {
                    b.fireEvent(b.ROUND_START_EVENT)
                }
            }
        }
    },
    onViewNotify: function(a) {
        this.fireEvent(a)
    },
    showCounter: function(a) {
        this.view.showCounter();
        if (Sys.isDefined(a)) {
            this.view.updateCounter(a)
        }
    },
    hideCounter: function() {
        this.view.hideCounter()
    },
    updateCounter: function(a) {
        this.view.updateCounter(a)
    },
    updateAppearance: function() {
        var c = this,
            b = c.model,
            a = "default";
        if (b.hasDisplayType("autoPlay")) {
            a = "autoPlay"
        } else {
            if (b.hasDisplayType("autoPlayStop")) {
                a = "autoPlayStop"
            } else {
                if (b.hasDisplayType("quickSpin")) {
                    a = "quickSpin"
                }
            }
        }
        c.view.setAppearance(a);
        c.updateVisibility()
    },
    updateVisibility: function() {
        var b = this,
            c = b.model.hasProperty("hidden"),
            a = b.model.hasProperty("disabled");
        if (c) {
            b.view.hide()
        } else {
            b.view.show()
        }
        if (a) {
            b.view.disable()
        } else {
            b.view.enable()
        }
        if (!a && (!c || b.view.canInteractWhileHidden())) {
            b.startListeningToUserInput()
        } else {
            b.stopListeningToUserInput()
        }
    },
    settingsChanged: function(a, c) {
        var b = this;
        if (a === "leftHandMode") {
            b.model.storeData("leftHandMode", c);
            b.view.setPosition()
        }
    },
    onEnteringFreespinIntro: function() {
        this.hide(this.MODULE_NAME)
    },
    onLeavingFreespinIntro: function() {
        this.show(this.MODULE_NAME)
    },
    onEnteringFreespinOutro: function() {
        this.hide(this.MODULE_NAME)
    },
    onLeavingFreespinOutro: function() {
        this.show(this.MODULE_NAME)
    }
};
Interface.Slots.SpinButtonController = Sys.extend(Interface.RoundStartButtonController, Interface.Slots.SpinButtonController, "Interface.Slots.SpinButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonModel = {
    DISPLAY_TYPES: {
        autoPlay: false,
        autoPlayStop: false,
        quickSpin: false
    },
    constructor: function() {
        Interface.Slots.SpinButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true";
        Interface.Slots.SpinButtonModel.superclass.setupData.apply(this, arguments);
        this.storeData("leftHandMode", a)
    }
};
Interface.Slots.SpinButtonModel = Sys.extend(Interface.RoundStartButtonModel, Interface.Slots.SpinButtonModel, "Interface.Slots.SpinButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonBaseView = {
    BUTTON_ID: "spinButton",
    BASE_CSS: "interface-roundStartButton_base",
    URI_BASE_CSS: "interface-spinButton",
    COUNTER_BASE_CSS: "utils_center interface-spinButton_counter",
    BUTTON_POSITION: {
        PORTRAIT: {
            LEFT: {
                RIGHT: 0.5
            },
            RIGHT: {
                LEFT: 0.5
            }
        },
        LANDSCAPE: {
            LEFT: {
                RIGHT: 0.5
            },
            RIGHT: {
                LEFT: 0.5
            }
        }
    },
    constructor: function() {
        Interface.Slots.SpinButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpDOMStructure: function() {
        var a = this;
        a.updatePositionProperties();
        Interface.Slots.SpinButtonBaseView.superclass.setUpDOMStructure.apply(a, arguments);
        a.counter = new Sys.Element({
            tag: "div",
            cls: a.COUNTER_BASE_CSS,
            style: "display:none;"
        });
        a.container.add(a.counter)
    },
    setFullscreenSafeArea: function() {
        var a = this;
        a.fireEvent("view:setSafeArea", "spinButton", {
            element: a.container.getEl()
        })
    },
    showCounter: function() {
        this.counter.el.style.display = "block"
    },
    hideCounter: function() {
        this.counter.el.style.display = "none"
    },
    updateCounter: function(a) {
        this.counter.el.textContent = a
    },
    setStyle: function(c) {
        var d = this,
            a = d.counter,
            b = c === "LANDSCAPE" ? "PORTRAIT" : "LANDSCAPE";
        Mixins.orientation.view.methods.setStyle.call(d, c);
        a.removeCls(d["COUNTER_" + b + "_CSS"]);
        a.addCls(d["COUNTER_" + c + "_CSS"])
    },
    canInteractWhileHidden: function() {
        return false
    },
    setPosition: function(a) {
        this.updatePositionProperties();
        Mixins.orientation.view.methods.setPosition.call(this, a || this.currentOrientation)
    },
    updatePositionProperties: function() {
        var c = this,
            a, b = Resources.readData("queryData").enableDefaultSwedenButtons;
        if (b) {
            a = "RIGHT"
        } else {
            a = c.model.readData("leftHandMode") ? "LEFT" : "RIGHT"
        }
        c.LANDSCAPE_POSITION = c.BUTTON_POSITION.LANDSCAPE[a];
        c.PORTRAIT_POSITION = c.BUTTON_POSITION.PORTRAIT[a]
    },
    enable: function() {
        if (!this.model.hasProperty("hidden")) {
            this.show()
        }
    },
    disable: function() {
        this.hide()
    },
    enableSpinningAnimations: function() {},
    disableSpinningAnimations: function() {},
    onPressedRequest: function() {},
    onReleasedRequest: function() {},
    moveButtonPosition: function() {}
};
Interface.Slots.SpinButtonBaseView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonBaseView, "Interface.Slots.SpinButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonMobileView = {
    BUTTON_POSITION: {
        PORTRAIT: {
            LEFT: {
                BELOW_GAME: true,
                TOP: 0.4,
                LEFT: 0.5,
                MIN_TOP: 825
            },
            RIGHT: {
                BELOW_GAME: true,
                TOP: 0.4,
                LEFT: 0.5,
                MIN_TOP: 825
            }
        },
        LANDSCAPE: {
            LEFT: {
                TOP: 0.5,
                RIGHT: 0.82
            },
            RIGHT: {
                TOP: 0.5,
                LEFT: 0.9
            }
        }
    },
    PORTRAIT_POSITION: {
        BELOW_GAME: true,
        TOP: 0.4,
        LEFT: 0.5,
        MIN_TOP: 825
    },
    LANDSCAPE_POSITION: {
        TOP: 0.5,
        LEFT: 0.9
    },
    PORTRAIT_SIZE: {
        VERTICAL_OFFSET: "center",
        HORIZONTAL_OFFSET: "center",
        ASPECT_RATIO: 1,
        WIDTH: 0.296
    },
    LANDSCAPE_SIZE: {
        VERTICAL_OFFSET: "center",
        HORIZONTAL_OFFSET: "center",
        ASPECT_RATIO: 1,
        HEIGHT: 0.296
    },
    constructor: function() {
        var a;
        Interface.Slots.SpinButtonMobileView.superclass.constructor.apply(this, arguments);
        this.canInteract = false;
        a = Resources.readData("config");
        this.hideSpinButtonInMobilePortrait = Sys.isObj(a) && Boolean(a.hideSpinButtonInMobilePortrait)
    },
    shouldBeHiddenByUserInput: function(a) {
        return Interface.Slots.SpinButtonMobileView.superclass.shouldBeHiddenByUserInput.apply(this, arguments) && (Utils.Platform.isLandscape() || this.hideSpinButtonInMobilePortrait)
    },
    moveButtonPosition: function(b) {
        var c = this,
            a;
        if (Sys.isDefined(b)) {
            if (Sys.isDefined(b.orientation)) {
                a = b.orientation.toLowerCase() === "portrait" ? "PORTRAIT" : "LANDSCAPE";
                if (Sys.isDefined(b.vertical)) {
                    c.BUTTON_POSITION[a].LEFT.TOP = c.BUTTON_POSITION[a].LEFT.TOP + b.vertical;
                    c.BUTTON_POSITION[a].RIGHT.TOP = c.BUTTON_POSITION[a].RIGHT.TOP + b.vertical
                }
                if (Sys.isDefined(b.horizontal)) {
                    c.BUTTON_POSITION[a].LEFT.RIGHT = c.BUTTON_POSITION[a].LEFT.RIGHT + (-1 * b.horizontal);
                    c.BUTTON_POSITION[a].RIGHT.LEFT = c.BUTTON_POSITION[a].RIGHT.LEFT + b.horizontal
                }
            }
            c.setPosition()
        }
    },
    setStyle: function() {
        var a = this;
        Interface.Slots.SpinButtonMobileView.superclass.setStyle.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            a.hide()
        } else {
            a.show()
        }
    },
    show: function(a) {
        this.container.el.style.opacity = 1;
        Interface.Slots.SpinButtonMobileView.superclass.show.call(this, a)
    },
    hide: function(a) {
        var b = this;
        if (Utils.Platform.isPortrait() && !b.hideSpinButtonInMobilePortrait) {
            b.container.el.style.opacity = "0.5";
            b.container.el.style.display = "block";
            b.canInteract = true
        } else {
            b.canInteract = false;
            b.container.el.style.opacity = 1;
            Interface.Slots.SpinButtonMobileView.superclass.hide.call(b, a)
        }
    },
    disable: function() {
        var a = this;
        if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
            a.hide()
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    disableRequested: function() {
        this.disable()
    },
    hideRequested: function(b) {
        var a = this;
        if (a.model.readData("currentGameMode") === "BASIC") {
            a.fireEvent("view:hide", b)
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    hidden: function() {
        var a = this,
            b = Utils.Platform.isPortrait() && a.hideSpinButtonInMobilePortrait;
        return a.container.el.style.display === "none" || (b && a.container.el.style.opacity === "0.5")
    },
    canInteractWhileHidden: function() {
        return this.canInteract
    }
};
Interface.Slots.SpinButtonMobileView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonMobileView, "Interface.Slots.SpinButtonMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonTabletView = {
    BUTTON_POSITION: {
        PORTRAIT: {
            LEFT: {
                TOP: 0.5,
                RIGHT: 0.82
            },
            RIGHT: {
                TOP: 0.5,
                LEFT: 0.9
            }
        },
        LANDSCAPE: {
            LEFT: {
                TOP: 0.5,
                RIGHT: 0.82
            },
            RIGHT: {
                TOP: 0.5,
                LEFT: 0.9
            }
        }
    },
    PORTRAIT_POSITION: {
        TOP: 0.5,
        LEFT: 0.9
    },
    LANDSCAPE_POSITION: {
        TOP: 0.5,
        LEFT: 0.9
    },
    PORTRAIT_SIZE: {
        VERTICAL_OFFSET: "center",
        HORIZONTAL_OFFSET: "center",
        ASPECT_RATIO: 1,
        HEIGHT: 0.296
    },
    LANDSCAPE_SIZE: {
        VERTICAL_OFFSET: "center",
        HORIZONTAL_OFFSET: "center",
        ASPECT_RATIO: 1,
        HEIGHT: 0.222
    },
    constructor: function() {
        Interface.Slots.SpinButtonTabletView.superclass.constructor.apply(this, arguments)
    },
    disable: function() {
        var a = this;
        if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
            a.hide()
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    disableRequested: function() {
        this.disable()
    },
    hideRequested: function(b) {
        var a = this;
        if (a.model.readData("currentGameMode") === "BASIC") {
            a.fireEvent("view:hide", b)
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    }
};
Interface.Slots.SpinButtonTabletView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonTabletView, "Interface.Slots.SpinButtonTabletView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonDesktopView = {
    SOUND_UP: "buttonUp",
    SOUND_DOWN: "buttonDown",
    SOUND_HOVER: "buttonHover",
    IMAGE_UP: "spinButtonIdle",
    IMAGE_DOWN: "spinButtonDown",
    IMAGE_OVER: "spinButtonOver",
    IMAGE_DISABLED: "spinButtonDisabled",
    BUTTON_POSITION: {
        x: 589,
        y: 597,
        width: 103,
        height: 105,
        centerX: 640,
        centerY: 649,
        radius: 51
    },
    constructor: function() {
        var a = this;
        Interface.Slots.SpinButtonDesktopView.superclass.constructor.apply(a, arguments);
        a.pressed = false;
        a.isHighlighted = false;
        a.permanentHighlight = false
    },
    initAnimations: function() {
        var c = this,
            b = new Animation.List({}),
            a = new Animation.Item({
                top: c.BUTTON_POSITION.y,
                left: c.BUTTON_POSITION.x,
                width: c.BUTTON_POSITION.width,
                height: c.BUTTON_POSITION.height,
                depth: c.getButtonDepth(),
                image: c.IMAGE_UP
            });
        b.add(a);
        Game.stage.view.addToRenderLoop(b);
        c.buttonList = b;
        c.buttonItem = a
    },
    getButtonDepth: function() {
        return 40
    },
    beforeLoaderClose: function() {
        this.fireEvent("view:addProperty", "visibleDuringRound", this.MODULE_NAME)
    },
    setUpDOMStructure: function() {},
    press: function() {
        var a = this;
        a.fireEvent("view:playSound", a.SOUND_DOWN);
        a.fireEvent("view:notify", "notify:spinButton.down");
        a.buttonItem.prop.image = a.IMAGE_DOWN
    },
    release: function() {
        this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
    },
    enable: function() {
        this.playButtonSpecialEffects();
        this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
    },
    disable: function() {
        this.removeHighlight();
        this.stopButtonSpecialEffects();
        this.buttonItem.prop.image = this.IMAGE_DISABLED
    },
    disableRequested: function(a) {
        this.fireEvent("view:disable", a)
    },
    userInputStart: function(b) {
        var a = this.isCollision(b) && !this.pressed;
        if (a) {
            this.press()
        }
        this.model.storeData("wasInitialInputTarget", a)
    },
    userInputMove: function(a) {
        if (this.model.readData("wasInitialInputTarget")) {
            this.toggleHighlight(a, true)
        }
    },
    userInputHover: function(a) {
        if (!this.pressed) {
            this.toggleHighlight(a)
        }
    },
    userInputEnd: function(c) {
        var b = this,
            a;
        if (b.model.readData("wasInitialInputTarget")) {
            a = b.isCollision(c);
            b.release(a);
            if (a) {
                if (!b.model.readData("noStopOnSpin")) {
                    b.model.storeData("noStopOnSpin", true)
                }
                b.fireEvent("view:clicked")
            }
        }
        b.model.storeData("wasInitialInputTarget", false)
    },
    enableSpinningAnimations: function() {
        this.addHighlight(false, true);
        this.permanentHighlight = true
    },
    disableSpinningAnimations: function() {
        this.permanentHighlight = false;
        if (!this.isHoveredOver) {
            this.removeHighlight()
        }
    },
    shouldBeHiddenByUserInput: function() {},
    hide: function() {
        var a = this;
        if (a.model.hasProperty("hidden") || !a.model.hasProperty("visibleDuringRound")) {
            a.buttonList.stop();
            a.fireEvent("view:hidden")
        }
    },
    hidden: function() {},
    show: function() {
        this.buttonList.play();
        this.fireEvent("view:shown")
    },
    setAppearance: function(a) {},
    canInteractWhileHidden: function() {
        return false
    },
    showCounter: function() {},
    updateCounter: function() {},
    hideCounter: function() {},
    onPressedRequest: function() {
        this.pressed = true;
        this.press()
    },
    onReleasedRequest: function() {
        this.pressed = false;
        this.release(true);
        this.fireEvent("view:clicked")
    },
    toggleHighlight: function(c, b) {
        var a = this;
        if (a.isCollision(c)) {
            if (!a.isHoveredOver) {
                a.fireEvent("view:playSound", a.SOUND_HOVER);
                a.fireEvent("view:notify", "notify:spinButton.hover")
            }
            a.isHoveredOver = true;
            a.addHighlight(b)
        } else {
            if (a.isHoveredOver) {
                a.fireEvent("view:playSound", a.SOUND_UP);
                a.fireEvent("view:notify", "notify:spinButton.up")
            }
            a.isHoveredOver = false;
            a.removeHighlight(b)
        }
    },
    isCollision: function(h) {
        var e = this,
            c = Sys.UserInputUtils.getCoordinatesRelativeToElement(h, Game.stage.getGameContainer()),
            f = Environment.determineResolution().windowToVirtualScale,
            a = e.BUTTON_POSITION,
            d = Math.abs((c.x * f) - a.centerX),
            b = Math.abs((c.y * f) - a.centerY),
            g = Math.sqrt((d * d) + (b * b));
        return (g <= a.radius)
    },
    addHighlight: function(c, a) {
        var b = this;
        if ((!b.isHighlighted || a) && !b.permanentHighlight) {
            b.isHighlighted = true;
            b.buttonItem.prop.image = b.IMAGE_OVER;
            if (c) {
                b.press()
            }
        }
    },
    removeHighlight: function(b) {
        var a = this;
        if (a.isHighlighted && !a.permanentHighlight) {
            a.isHighlighted = false;
            a.buttonItem.prop.image = this.IMAGE_UP;
            if (b) {
                a.playButtonSpecialEffects()
            }
        }
    },
    stopButtonSpecialEffects: function() {},
    playButtonSpecialEffects: function() {},
    setFullscreenSafeArea: function() {}
};
Interface.Slots.SpinButtonDesktopView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonDesktopView, "Interface.Slots.SpinButtonDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButton = {
    constructor: function() {
        Interface.Slots.MaxBetButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["trigger"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.Slots.MaxBetButtonModel,
            controller: Interface.Slots.MaxBetButtonController,
            view: Interface.Slots.MaxBetButtonBaseView
        }
    }
};
Interface.Slots.MaxBetButton = Sys.extend(Core.Module, Interface.Slots.MaxBetButton, "Interface.Slots.MaxBetButton");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonModel = {
    constructor: function() {
        Interface.Slots.MaxBetButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var d = Resources.readData("gameServerInitResponseObject").betlevel.all,
            a = Resources.readData("config"),
            b = Object.keys(a.winSituationsDisplay.betlines.numbers.configurations),
            e = a.winSituationsDisplay.winSituationMinimumDisplayTime,
            c = 0;
        Interface.Slots.MaxBetButtonModel.superclass.setupData.apply(this, arguments);
        Sys.each(d, function(f) {
            c = Math.max(f, c)
        });
        this.storeData("maxBetLevel", c);
        this.storeData("betlines", b);
        this.storeData("winSituationMinimumDisplayTime", e)
    }
};
Interface.Slots.MaxBetButtonModel = Sys.extend(Core.Model, Interface.Slots.MaxBetButtonModel, "Interface.Slots.MaxBetButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonController = {
    ROUND_START_EVENT: "request:spin.startNewRound",
    constructor: function() {
        Interface.Slots.MaxBetButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.disable.bind(this, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": this.onLeavingIdleState,
            "notify:stateHandler.enteringIdleState": this.enable.bind(this, "notInIdleState"),
            "notify:gameModeChanged": this.onGameModeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "notify:freeRounds.ended": this.refreshModelData,
            "notify:freeRounds.reInitResponseReceived": this.refreshModelData,
            "view:clicked": this.onClick,
            "request:enableBasicGamePanel": this.enable,
            "request:disableBasicGamePanel": this.disable,
            "request:maxBetButton.enable": this.enable,
            "request:maxBetButton.disable": this.disable
        })
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:maxBetButton.startedRound", this, "When the max bet button is clicked and started a round.")
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onClick: function() {
        var d = this,
            b = Services.settingsManager.getSetting("betLevel"),
            c = d.model.readData("maxBetLevel"),
            a;
        if (b < c) {
            d.fireEvent("request:settingsManager.storeData", "betLevel", c);
            a = d.model.readData("betlines");
            d.fireEvent("request:winSituations.showDisplayBetline", a, "maxBetButton");
            setTimeout(d.fireEvent.bind(d, "request:winSituations.hideDisplayBetline", "maxBetButton"), d.model.readData("winSituationMinimumDisplayTime"))
        } else {
            d.startRound()
        }
    },
    onGameModeChanged: function(a) {
        if (a === "BASIC") {
            this.view.show("gameModeNotBasic")
        } else {
            this.view.hide("gameModeNotBasic")
        }
    },
    onLeavingIdleState: function() {
        var a = this;
        a.disable("notInIdleState");
        a.fireEvent("request:winSituations.hideDisplayBetline", "maxBetButton")
    },
    startRound: function() {
        var a = this;
        a.fireEvent("request:audioPlayer.play", {
            name: "spinButtonClick"
        });
        a.fireEvent(a.ROUND_START_EVENT);
        a.fireEvent("notify:maxBetButton.startedRound")
    },
    enable: function(a) {
        this.view.enable(a)
    },
    disable: function(a) {
        this.view.disable(a)
    },
    refreshModelData: function() {
        this.model.setupData()
    }
};
Interface.Slots.MaxBetButtonController = Sys.extend(Core.Controller, Interface.Slots.MaxBetButtonController, "Interface.Slots.MaxBetButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonBaseView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 700,
            y: 613,
            width: 143,
            height: 72
        },
        buttonImages: {
            up: "maxBetButtonUp",
            down: "maxBetButtonDown",
            hover: "maxBetButtonOver",
            disabled: "maxBetButtonDisabled"
        },
        buttonLabel: {
            width: 133,
            height: 67,
            text: Language.Keys.btn_maxbet,
            breakOn: "<br>",
            font: "24px NetentStandardUI",
            lineHeight: 24,
            color: "#000000",
            alignment: "center"
        }
    },
    constructor: function() {
        Interface.Slots.MaxBetButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    show: function(a) {
        this.keypadButton.show(a)
    },
    hide: function(a) {
        this.keypadButton.hide(a)
    },
    enable: function(a) {
        this.keypadButton.enable(a)
    },
    disable: function(a) {
        this.keypadButton.disable(a)
    },
    onButtonClick: function() {
        this.fireEvent("view:clicked")
    },
    initAnimations: function() {
        this.setUpKeypadButton()
    },
    setUpKeypadButton: function() {
        var b = this,
            a = Sys.applyProperties({
                clickCallback: b.onButtonClick.bind(b)
            }, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.maxBet.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.maxBet.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.maxBet.button
        }
        b.keypadButton = new Interface.utils.CanvasButton(a)
    },
    shouldBeHiddenByUserInput: function() {
        return false
    }
};
Interface.Slots.MaxBetButtonBaseView = Sys.extend(Core.View, Interface.Slots.MaxBetButtonBaseView, "Interface.Slots.MaxBetButtonBaseView");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseController = {
    constructor: function() {
        Core.Slots.SpinBaseController.superclass.constructor.apply(this, arguments);
        this.stopper = 0
    },
    setupEvents: function() {
        var b = this,
            c = {
                "request:spin.child.storeServerResponse": b.handleServerResponse,
                "request:spin.child.wantStartSpin": b.startSpin,
                "request:spin.child.wantStopSpin": b.stopSpin,
                "request:spin.child.setSymbols": b.setSymbols,
                "request:spin.child.revertSpin": b.revertSpin
            },
            a = "notify:stateHandler.entering" + b.MODULE_NAME + "RestoreState";
        c[a] = b.onRestore;
        b.on(c)
    },
    handleServerResponse: function(b) {
        var a = this;
        a.model.storeServerResponse(b);
        if (b.clientaction === "init") {
            a.model.initData();
            if (a.model.readData("active")) {
                a.fireEvent("request:spin.activateInitReelset", "basic", a.model.readData("defaultScene"))
            }
        }
    },
    onRestore: function() {
        this.requestRestoreStateDialog();
        this.startSpin()
    },
    requestRestoreStateDialog: function() {
        var a = this;
        a.fireEvent("request:dialogWindow.showDialog", {
            title: Services.languageManager.getText(Language.Keys.restoredGameHeader),
            text: Services.languageManager.getText(Language.Keys.continuePlaying),
            buttons: [{
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "restoreState",
                        button: "continue"
                    });
                    a.fireEvent("notify:" + a.MODULE_NAME + "RestoreStateDialog.closed")
                }
            }]
        })
    },
    activateReelset: function() {
        var a = this,
            c = a.model.readData("requestedReelset"),
            b = a.model.readData("defaultScene");
        a.model.storeData("active", true);
        a.fireEvent("request:spin.activateReelset", c, b)
    },
    startSpin: function() {
        var b = this,
            a = b.model,
            d = a.readData("requestedReelset"),
            c = a.readData("defaultScene");
        if (!a.isState("spinning")) {
            b.fireEvent("request:settingsWindow.close");
            if (a.readData("spinRequested")) {
                a.storeData("active", true);
                a.setState("spinning");
                b.fireEvent("request:spin.startSpin", d, c)
            } else {
                a.storeData("active", false)
            }
        }
    },
    stopSpin: function() {
        var a = this,
            b = a.model.readData("serverResponse");
        if (a.model.readData("active")) {
            a.model.setState("stopped");
            a.fireEvent("request:spin.stopSpin", b.reelInfo, b.nearWinList, b)
        }
    },
    revertSpin: function() {
        if (this.model.readData("active")) {
            this.model.setState("stopped")
        }
    }
};
Core.Slots.SpinBaseController = Sys.extend(Core.Controller, Core.Slots.SpinBaseController, "Core.Slots.SpinBaseController");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseModel = {
    DEFAULT_SCENE: "base",
    constructor: function() {
        Core.Slots.SpinBaseModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        Core.Slots.SpinBaseModel.superclass.setupData.apply(this, arguments);
        this.storeData("defaultScene", this.DEFAULT_SCENE)
    },
    storeServerResponse: function(b) {
        var a = this;
        a.storeData("serverResponse", b)
    },
    initData: function() {
        var b = this,
            a = Resources.readData("config");
        b.storeData("layeringConfig", a.layering)
    }
};
Core.Slots.SpinBaseModel = Sys.extend(Core.Model, Core.Slots.SpinBaseModel, "Core.Slots.SpinBaseModel");
Sys.ns("Core");
Core.Slots.SpinTypeBasic = {
    constructor: function() {
        Core.Slots.SpinTypeBasic.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model,
            b = {
                stopped: {
                    queue: [function(c) {
                        if (a.readData("spinRequested")) {
                            c.stateHandler.pushState(c.states.idle)
                        }
                    }]
                }
            };
        return b
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.SpinTypeBasicModel,
            controller: Core.Slots.SpinBaseController
        }
    }
};
Core.Slots.SpinTypeBasic = Sys.extend(Core.Module, Core.Slots.SpinTypeBasic, "Core.Slots.SpinTypeBasic");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeBasicModel = {
    constructor: function() {
        Core.Slots.SpinTypeBasicModel.superclass.constructor.apply(this, arguments)
    },
    storeServerResponse: function(c) {
        var b = this,
            a;
        b.storeData("serverResponse", c);
        if (c.nextaction === "spin") {
            b.storeData("spinRequested", true);
            if (c.next) {
                a = c.next.rs
            } else {
                a = "basic"
            }
            b.storeData("requestedReelset", a)
        } else {
            b.storeData("spinRequested", false)
        }
    },
    initData: function() {
        var c = this,
            b = Resources.readData("gameServerInitResponse"),
            d = false,
            a = false;
        Core.Slots.SpinTypeBasicModel.superclass.initData.apply(c, arguments);
        if (b.nextaction === "spin") {
            d = true;
            a = true
        }
        c.storeData("active", d);
        c.storeData("spinRequested", a)
    }
};
Core.Slots.SpinTypeBasicModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeBasicModel, "Core.Slots.SpinTypeBasicModel");
Sys.ns("Core");
Core.Slots.SpinTypeRespin = {
    constructor: function() {
        Core.Slots.SpinTypeRespin.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model,
            b = {
                respinRestore: {
                    state: {
                        name: this.MODULE_NAME + "Restore",
                        execute: function(c) {},
                        waitEvents: {}
                    }
                },
                stopped: {
                    queue: [function(c) {
                        if (a.readData("spinRequested")) {
                            c.stateHandler.pushState(c.states.stopped);
                            c.stateHandler.pushState(c.states.stopping);
                            c.stateHandler.pushState(c.states.beforeStopping);
                            c.stateHandler.pushState(c.states.spinning)
                        }
                    }]
                },
                beforeLoaderClose: {
                    queue: [function(c) {
                        if (a.readData("spinRequested")) {
                            c.stateHandler.pushState(c.states.stopped);
                            c.stateHandler.pushState(c.states.stopping);
                            c.stateHandler.pushState(c.states.beforeStopping);
                            c.stateHandler.pushState(c.states.spinning);
                            if (a.readData("basicRestoreState")) {
                                c.stateHandler.pushState(c.states.respinRestore)
                            }
                        }
                    }]
                }
            };
        b.respinRestore.state.waitEvents["notify:" + this.MODULE_NAME + "RestoreStateDialog.closed"] = false;
        return b
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.SpinTypeRespinModel,
            controller: Core.Slots.SpinBaseController
        }
    }
};
Core.Slots.SpinTypeRespin = Sys.extend(Core.Module, Core.Slots.SpinTypeRespin, "Core.Slots.SpinTypeRespin");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeRespinModel = {
    constructor: function() {
        Core.Slots.SpinTypeRespinModel.superclass.constructor.apply(this, arguments)
    },
    storeServerResponse: function(c) {
        var b = this,
            a;
        b.storeData("serverResponse", c);
        if (c.nextaction === "respin" || c.nextaction === "drop") {
            b.storeData("spinRequested", true);
            b.storeData("basicRestoreState", (c.currentGameState === "basic") && (c.restore === true));
            if (c.next) {
                a = c.next.rs
            } else {
                a = "respin"
            }
            b.storeData("requestedReelset", a)
        } else {
            b.storeData("spinRequested", false)
        }
    },
    initData: function() {
        this.storeData("active", Resources.readData("gameServerInitResponseObject").nextaction === "respin");
        Core.Slots.SpinTypeRespinModel.superclass.initData.apply(this, arguments)
    }
};
Core.Slots.SpinTypeRespinModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeRespinModel, "Core.Slots.SpinTypeRespinModel");
Sys.ns("Core.Slots");
Core.Slots.StandardWin = {
    constructor: function() {
        Core.Slots.StandardWin.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model,
            b = {
                standardWinPresentation: {
                    state: {
                        name: "StandardWinPresentation",
                        execute: function() {},
                        waitEvents: {
                            "notify:standardWin.presentationComplete": false
                        }
                    }
                },
                noWinPresentation: {
                    state: {
                        name: "NoWinPresentation",
                        execute: function() {},
                        waitEvents: {
                            "notify:standardWin.presentationComplete": false
                        }
                    }
                },
                stopped: {
                    queue: [function(c) {
                        if (a.readData("isStandardWin")) {
                            c.stateHandler.pushState(c.states.standardWinPresentation)
                        } else {
                            if (a.readData("isNoWin")) {
                                c.stateHandler.pushState(c.states.noWinPresentation)
                            }
                        }
                    }]
                }
            };
        return b
    },
    getMixinDependencies: function() {
        return ["userInput", "waitSequence", "trigger"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Slots.StandardWinModel,
            view: Core.View,
            controller: Core.Slots.StandardWinController
        }
    }
};
Core.Slots.StandardWin = Sys.extend(Core.Module, Core.Slots.StandardWin, "Core.Slots.StandardWin");
Sys.ns("Core.Slots");
Core.Slots.StandardWinController = {
    constructor: function() {
        Core.Slots.StandardWinController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringStandardWinPresentationState": this.startPresentation,
            "notify:stateHandler.enteringNoWinPresentationState": this.startNoWinPresentation,
            "notify:winBanner.countUpComplete": this.onShowingTotal,
            "notify:coinsField.countUpComplete": this.onShowingTotal,
            "notify:spinButton.clicked": this.handleUserInput,
            "notify:spinButton.clickedWhileHidden": this.handleUserInput,
            "request:abortPresentation": this.handleUserInput,
            "notify:winSituationsDisplay.showingAllWins": this.waitForWinSituationsDisplay,
            "notify:responseParser.responseParsed": this.onServerResponse
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:standardWin.countupAborted", this, "When the countup is aborted.");
        Services.trigger.registerTrigger("notify:standardWin.presentationComplete", this, "When the standard win presentation has completed.");
        Services.trigger.registerTrigger("notify:standardWin.startPresentation", this, "When the win presentation starts.")
    },
    startPresentation: function() {
        var b = this,
            a = b.model.readData("winClip"),
            c = b.model.readData("countUpDuration"),
            d = b.model.readData("totalWinDisplayDuration");
        b.fireEvent("request:settingsWindow.close");
        b.startListeningToUserInput();
        b.model.setState("countingUp");
        b.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
            showDuration: c + d,
            "standardWin:countUpDuration": c,
            "standardWin:showTotalDuration": d
        });
        if (b.model.readData("countUpDisplay") === "winBanner") {
            b.fireEvent("request:winBanner.animate", c)
        } else {
            b.fireEvent("request:coinsField.countUp", c)
        }
        if (a) {
            b.fireEvent("request:audioPlayer.play", {
                name: a,
                id: "winClip"
            })
        }
        b.fireEvent("notify:standardWin.startPresentation", a)
    },
    startNoWinPresentation: function() {
        var b = this,
            a = b.model.readData("noWinDisplayDuration");
        b.fireEvent("request:coinsField.showWin");
        b.fireEvent("request:cashField.showWin");
        b.model.storeData("inNoWinPresentation", true);
        b.noWinTimeout = setTimeout(b.abortNoWinPresentation.bind(b), a)
    },
    abortNoWinPresentation: function() {
        var a = this;
        if (a.model.readData("inNoWinPresentation")) {
            clearTimeout(a.noWinTimeout);
            a.endPresentation();
            a.model.storeData("inNoWinPresentation", false)
        }
    },
    onUserInputStart: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    },
    handleUserInput: function() {
        var a = this;
        if (a.model.readData("inNoWinPresentation")) {
            a.abortNoWinPresentation()
        } else {
            if (a.model.isState("countingUp")) {
                if (a.model.readData("countUpDisplay") === "winBanner") {
                    a.fireEvent("request:winBanner.showTotal", {
                        showUntilStopped: true
                    })
                } else {
                    a.fireEvent("request:coinsField.showWin")
                }
                a.fireEvent("request:audioPlayer.stop", "winClip");
                a.onShowingTotal();
                a.fireEvent("notify:standardWin.countupAborted")
            } else {
                if (a.model.isState("showingTotal")) {
                    a.endPresentation(true)
                }
            }
        }
    },
    onShowingTotal: function() {
        var a = this;
        if (a.model.isState("countingUp")) {
            a.model.setState("showingTotal");
            a.fireEvent("notify:standardWin.showingWinTotal");
            a.fireEvent("request:coinsField.showWin");
            a.fireEvent("request:cashField.showWin");
            if (a.eventsToWaitFor.indexOf("notify:winSituationsDisplay.finishedShowingAllWins") === -1) {
                a.showWinTimeout = setTimeout(a.endPresentation.bind(a, false), a.model.readData("totalWinDisplayDuration"))
            }
        }
    },
    endPresentation: function(b) {
        var a = this;
        if (!a.model.isState("showingTotal") && !a.model.readData("inNoWinPresentation")) {
            return
        }
        a.stopListeningToUserInput();
        a.model.setState("complete");
        clearTimeout(a.showWinTimeout);
        a.fireEvent("request:winSituationsDisplay.abort");
        a.fireEvent("request:audioPlayer.stop", "winClip");
        if (a.model.readData("countUpDisplay") === "winBanner") {
            a.fireEvent("request:winBanner.hide")
        }
        if (a.model.shouldToggleWins()) {
            a.fireEvent("request:winSituationsDisplay.toggleWins")
        }
        a.fireEvent("notify:standardWin.presentationComplete", b)
    },
    waitForWinSituationsDisplay: function() {
        this.onWaitRequested("notify:winSituationsDisplay.finishedShowingAllWins")
    },
    onWaitIsComplete: function() {
        this.endPresentation(false)
    }
};
Core.Slots.StandardWinController = Sys.extend(Core.Controller, Core.Slots.StandardWinController, "Core.Slots.StandardWinController");
Sys.ns("Core.Slots");
Core.Slots.StandardWinModel = {
    STANDARD_WIN_TYPES: ["smallWin", "mediumWin", "largeWin"],
    COUNT_UP_DURATIONS: {
        smallWin: 1000,
        mediumWin: 2000,
        largeWin: 3000
    },
    NO_WIN_DISPLAY_DURATION: 500,
    NO_WIN_DISPLAY_DESKTOP_DURATION: 0,
    TOTAL_WIN_DISPLAY_DURATION: 3000,
    constructor: function() {
        Core.Slots.StandardWinModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = this;
        a.storeData("inFreeSpins", false);
        a.storeData("noWinDisplayDuration", a.NO_WIN_DISPLAY_DURATION);
        a.storeData("totalWinDisplayDuration", a.TOTAL_WIN_DISPLAY_DURATION);
        a.setupDesktopSpecificData()
    },
    processServerResponse: function(b) {
        var f = this,
            g = b.currentGameState === "freespin" ? "coinsField" : "winBanner",
            d = b.currentGameState === "freespin" || b.nextaction === "freespin",
            c, e, a;
        if (Sys.isDefined(b.wins)) {
            c = b.wins.winType;
            e = f.STANDARD_WIN_TYPES.contains(c);
            a = !Sys.isDefined(c);
            f.storeData("isStandardWin", e);
            f.storeData("isNoWin", a);
            f.storeData("countUpDuration", f.COUNT_UP_DURATIONS[c]);
            f.storeWinSound(c)
        }
        f.storeData("countUpDisplay", g);
        f.storeData("togglePreventedByFreeSpins", d)
    },
    storeWinSound: function(a) {
        this.storeData("winClip", a)
    },
    shouldToggleWins: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (!Sys.isDefined(a) || a === 0) && !this.readData("togglePreventedByFreeSpins")
    },
    setupDesktopSpecificData: function() {
        if (Platform.isDesktopDevice) {
            this.storeData("noWinDisplayDuration", this.NO_WIN_DISPLAY_DESKTOP_DURATION)
        }
    }
};
Core.Slots.StandardWinModel = Sys.extend(Core.Model, Core.Slots.StandardWinModel, "Core.Slots.StandardWinModel");
Sys.ns("Core");
Core.AbstractCountUp = {
    constructor: function() {
        Core.AbstractCountUp.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.CountUpModel,
            view: Core.AbstractCountUpView,
            controller: Core.AbstractCountUpController
        }
    }
};
Core.AbstractCountUp = Sys.extend(Core.CountUp, Core.AbstractCountUp, "Core.AbstractCountUp");
Sys.ns("Core");
Core.AbstractCountUpView = {
    constructor: function() {
        Core.AbstractCountUpView.superclass.constructor.apply(this, arguments)
    },
    COUNT_UP_EASING_TYPE: "ease-out",
    SHOW_TOTAL_DURATION: 1000,
    countUpCallback: function(a) {},
    setCountUpCallback: function(a) {
        this.countUpCallback = a
    },
    createCountUpItem: function() {
        var a = this;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: a.COUNT_UP_DEPTH,
            executeBefore: function() {
                var d = this.value,
                    c, e, b;
                if (a.model.readData("lastValue") !== d) {
                    a.countUpCallback(d);
                    a.model.storeData("lastValue", d);
                    if (Sys.isDefined(this.fireOnValue)) {
                        c = this.fireOnValue.length;
                        for (b = -1; ++b < c;) {
                            e = this.fireOnValue[b];
                            if (!e.fired && d >= e.value) {
                                e.scope.fireEvent(e.event, e.argument);
                                e.fired = true
                            }
                        }
                    }
                }
            },
            operations: {}
        })
    }
};
Core.AbstractCountUpView = Sys.extend(Core.CountUpView, Core.AbstractCountUpView, "Core.AbstractCountUpView");
Sys.ns("Core");
Core.AbstractCountUpController = {
    constructor: function() {
        Core.AbstractCountUpController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = {};
        Core.AbstractCountUpController.superclass.setupEvents.apply(this, arguments);
        a["request:" + this.MODULE_NAME + ".setCallback"] = this.view.setCountUpCallback.bind(this.view);
        this.on(a)
    }
};
Core.AbstractCountUpController = Sys.extend(Core.CountUpController, Core.AbstractCountUpController, "Core.AbstractCountUpController");
Sys.ns("Game");
Game.AmbienceManager = {
    constructor: function() {
        Game.AmbienceManager.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.AmbienceManagerModel,
            controller: Game.AmbienceManagerController
        }
    }
};
Game.AmbienceManager = Sys.extend(Core.Module, Game.AmbienceManager, "Game.AmbienceManager");
Sys.ns("Game");
Game.AmbienceManagerModel = {
    constructor: function() {
        Game.AmbienceManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = this;
        a.storeData("activeAmbience", [{
            name: "ambienceGeneral",
            id: "ambienceGeneral",
            loop: true
        }]);
        Services.storage.storeData("AmbienceManager.playing", false)
    },
    getActiveAmbience: function() {
        return this.readData("activeAmbience")
    },
    setActiveAmbience: function(a) {
        this.storeData("activeAmbience", a)
    }
};
Game.AmbienceManagerModel = Sys.extend(Core.Model, Game.AmbienceManagerModel, "Game.AmbienceManagerModel");
Sys.ns("Game");
Game.AmbienceManagerController = {
    constructor: function() {
        Game.AmbienceManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:audioPlayer.soundLoaded": a.changeAmbienceEnableState.bind(a, true),
            "request:ambienceManager.ambienceEnableState": a.changeAmbienceEnableState,
            "request:ambienceManager.ambienceChangeActive": a.setActiveAmbience,
            "request:ambienceManager.ambiencePauseSwitch": a.changePauseSwitch,
            "request:ambienceManager.ambienceStopActive": a.stopAmbience,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose
        })
    },
    onBeforeLoaderClose: function() {
        if (!this.model.isState("ambienceOn")) {
            this.changeAmbienceEnableState(false)
        }
        this.changePauseSwitch(false)
    },
    changeAmbienceEnableState: function(a) {
        var b = this;
        if (a) {
            if (!b.model.isState("ambienceOn")) {
                b.model.setState("ambienceOn");
                b.playActiveAmbience()
            }
        } else {
            b.stopAmbience();
            b.model.setState("ambienceOff")
        }
    },
    changePauseSwitch: function(a) {
        var b = this;
        if (a) {
            b.model.storeData("paused", true);
            if (b.model.isState("ambienceOn")) {
                b.stopAmbience()
            }
        } else {
            if (b.model.readData("paused")) {
                b.model.storeData("paused", false);
                if (b.model.isState("ambienceOn")) {
                    b.playActiveAmbience()
                }
            }
        }
    },
    playAmbience: function(a) {
        var b = this;
        if (b.model.isState("ambienceOn")) {
            if (!b.model.readData("paused")) {
                Sys.each(a, function(c) {
                    b.dispatchPlaySoundRequest(c)
                })
            }
        } else {
            b.model.setActiveAmbience(a)
        }
    },
    playActiveAmbience: function() {
        this.playAmbience(this.model.getActiveAmbience())
    },
    stopAmbience: function() {
        var b = this,
            a = b.model.getActiveAmbience();
        if (b.model.isState("ambienceOn")) {
            Sys.each(a, function(c) {
                b.dispatchStopSoundRequest(c)
            })
        }
    },
    setActiveAmbience: function(c) {
        var b = this,
            a;
        if (!Sys.isArray(c)) {
            a = [{
                name: c.name,
                id: c.id,
                loop: c.loop,
                buffer: c.buffer,
                syncWithId: c.syncWithId,
                fadeIn: c.fadeIn,
                fadeOut: c.fadeOut
            }]
        } else {
            a = c
        }
        b.playAmbience(a);
        b.stopAmbience();
        b.model.setActiveAmbience(a)
    },
    dispatchPlaySoundRequest: function(a) {
        if (this.model.isState("ambienceOn")) {
            this.fireEvent("request:audioPlayer.play", a)
        }
    },
    dispatchStopSoundRequest: function(a) {
        if (this.model.isState("ambienceOn")) {
            this.fireEvent("request:audioPlayer.stop", a.id)
        }
    }
};
Game.AmbienceManagerController = Sys.extend(Core.Controller, Game.AmbienceManagerController, "Game.AmbienceManagerController");
Sys.ns("Game.Slots");
Game.Slots.BigWin = {
    constructor: function() {
        Game.Slots.BigWin.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            bigWin: {
                state: {
                    name: "BigWin",
                    execute: function(b) {},
                    waitEvents: {
                        "notify:bigWin.presentationFinished": false
                    }
                }
            },
            stopped: {
                queue: [function(b) {
                    if (a.isState("animationRequested")) {
                        b.stateHandler.pushState(b.states.bigWin)
                    }
                }]
            }
        }
    },
    getMixinDependencies: function() {
        return ["userInput", "waitSequence", "trigger"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.BigWinModel,
            controller: Game.Slots.BigWinController,
            view: Game.Slots.BigWinView
        }
    }
};
Game.Slots.BigWin = Sys.extend(Core.Module, Game.Slots.BigWin, "Game.Slots.BigWin");
Sys.ns("Game.Slots");
Game.Slots.BigWinController = {
    constructor: function() {
        Game.Slots.BigWinController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "view:startCountUp": this.onConutUpStart,
            "view:showTotalInCountUp": this.onShowTotalRequest,
            "view:hideCountUp": this.fireEvent.bind(this, "request:bigWinCountUp.stop"),
            "view:showWinText": this.showWinText,
            "view:playAudio": this.fireEvent.bind(this, "request:audioPlayer.play"),
            "view:stopAudio": this.fireEvent.bind(this, "request:audioPlayer.stop"),
            "notify:stateHandler.enteringBigWinState": this.show,
            "notify:bigWinCountUp.countUpComplete": this.finish,
            "notify:bigWinCountUp.hidden": this.close,
            "notify:stateHandler.leavingBigWinState": this.toggleWins,
            "notify:winSituationsDisplay.showingAllWins": this.waitForWinSituationsDisplay,
            "notify:spinButton.clicked": this.handleUserInput,
            "notify:spinButton.clickedWhileHidden": this.handleUserInput,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "request:abortPresentation": this.handleUserInput,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:bigWin.showTotalInCountUp", this, "Show total count up")
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onUserInputStart: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    },
    handleUserInput: function() {
        var a = this;
        if (a.model.isState("showing")) {
            a.finish()
        } else {
            if (a.model.isState("finished")) {
                a.close()
            } else {
                if (a.model.isState("showingAllWins")) {
                    a.fireEvent("request:winSituationsDisplay.abort")
                }
            }
        }
    },
    show: function() {
        var a = this;
        a.fireEvent("request:settingsWindow.close");
        a.startListeningToUserInput();
        a.model.setState("showing");
        a.view.show()
    },
    onConutUpStart: function(a) {
        this.fireEvent("request:bigWinCountUp.start", a)
    },
    onShowTotalRequest: function() {
        var a = this;
        a.fireEvent("notify:bigWin.showTotalInCountUp");
        a.fireEvent("request:bigWinCountUp.showTotal", {
            showDuration: a.model.readData("showTotalDuration")
        });
        a.fireEvent("request:coinsField.showWin");
        a.fireEvent("request:cashField.showWin")
    },
    showWinText: function(a) {
        this.view.showWinText(a);
        this.fireEvent("notify:bigWin.showingWinType", a)
    },
    finish: function() {
        var a = this;
        a.model.setState("finished");
        a.view.finish()
    },
    close: function() {
        var a = this;
        a.model.setState("closed");
        a.view.close();
        if (a.model.readData("showAllWins")) {
            a.model.setState("showingAllWins");
            a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
                showDuration: a.model.readData("showAllWinsDuration")
            })
        } else {
            a.onWaitIsComplete()
        }
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    waitForWinSituationsDisplay: function() {
        this.onWaitRequested("notify:winSituationsDisplay.finishedShowingAllWins")
    },
    onWaitIsComplete: function() {
        var a = this;
        a.stopListeningToUserInput();
        a.model.storeData("showAllWins", false);
        a.fireEvent("notify:bigWin.presentationFinished")
    },
    toggleWins: function() {
        if (this.model.shouldToggleWins()) {
            this.fireEvent("request:dimmedSymbols.dimNoWinSymbols");
            this.fireEvent("request:noWinSymbols.animate");
            this.fireEvent("request:winSituationsDisplay.toggleWins")
        }
    }
};
Game.Slots.BigWinController = Sys.extend(Core.Controller, Game.Slots.BigWinController, "Game.Slots.BigWinController");
Sys.ns("Game.Slots");
Game.Slots.BigWinView = {
    TEXT_OPERATIONS: [{
        fillStyle: "#FFFFFF"
    }, {
        lineWidth: 5,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    FONT: "bold 80px Verdana",
    TEXT_OFFSET: 0,
    TEXT_TOP: 100,
    TEXT_LEFT: undefined,
    WIN_TEXTS: {
        bigWin: Language.Keys.bigWin,
        megaWin: Language.Keys.megaWin,
        superMegaWin: Language.Keys.superMegaWin
    },
    constructor: function() {
        var a = {
            TEXT_OFFSET: this.TEXT_OFFSET,
            TEXT_TOP: this.TEXT_TOP,
            TEXT_LEFT: this.TEXT_LEFT
        };
        Game.Slots.BigWinView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureTextAnimation: function(a) {
        a.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 300,
            value: 1
        }, {
            time: 1300,
            value: 0.5,
            goTo: 1
        }]
    },
    configureSwitchAnimation: function(a) {
        a.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 1,
                scaleY: 1
            }
        }, {
            time: 200,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }];
        a.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: 200,
            value: 0
        }]
    },
    configureTextEndingAnimation: function(a) {
        a.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: this.model.readData("showTotalDuration"),
            value: 0
        }]
    },
    initAnimations: function() {
        var a = this,
            c = new Animation.CanvasAnimationList({}),
            e = {},
            b, d;
        a.scaleFactor = a.getScaleFactor();
        Sys.each(a.model.getSupportedSubTypes(), function(f) {
            d = Services.languageManager.getText(a.WIN_TEXTS[f]);
            b = a.createWinAnimation(d);
            e[f] = b;
            c.add(b);
            b = a.createSwitchAnimation(d);
            e[f + "Switch"] = b;
            c.add(b);
            b = a.createEndAnimation(d);
            e[f + "End"] = b;
            c.add(b)
        });
        Game.stage.view.addToRenderLoop(c);
        c.stop();
        a.animations = e;
        a.list = c
    },
    getScaleFactor: function() {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    show: function() {
        var a = this,
            b = a.model.readData("coinWin"),
            c = a.model.getWinCountUpDuration();
        a.doAnimation(0, b, c);
        a.playAudio("bigWinStart");
        a.fireEvent("view:playAudio", {
            name: "bigWinLoop",
            id: "bigWinLoop",
            loop: true
        })
    },
    finish: function() {
        var b = this,
            a = b.animations[b.model.readData("winType") + "End"],
            c = b.remainingWinTypes.length - 1;
        b.list.stop();
        b.fireEvent("view:stopAudio", "bigWinLoop");
        b.list.play(a);
        if (c >= 0) {
            b.fireEvent("view:stopAudio", "bigWin");
            b.playAudio(b.remainingWinTypes[c])
        }
        b.playAudio("bigWinEnd");
        b.playAudio("bigWinLoopEnd");
        b.fireEvent("view:showTotalInCountUp")
    },
    close: function() {
        this.list.stop();
        this.fireEvent("view:stopAudio", "bigWin");
        this.fireEvent("view:hideCountUp")
    },
    refresh: function() {
        var b = this,
            a;
        Sys.iterate(this.animations, function(c, d) {
            if (Animation.utils.isAnimationItem(d)) {
                a = b.getRenderingAttributes(d.prop);
                d.setTop(a.top);
                d.setLeft(a.left)
            }
        })
    },
    doAnimation: function(e, d, c) {
        var b = this,
            a = {
                from: e,
                to: d,
                duration: c,
                fireEventsOnValue: []
            };
        b.remainingWinTypes = [];
        Sys.iterate(b.model.readData("winTypeCoinLimits"), function(f, g) {
            a.fireEventsOnValue.push({
                value: g,
                event: "view:showWinText",
                argument: f,
                scope: b
            });
            if (g <= d) {
                b.remainingWinTypes.push(f)
            }
        });
        b.currentlyShowingWin = undefined;
        b.fireEvent("view:startCountUp", a)
    },
    showWinText: function(c) {
        var e = this,
            d = e.currentlyShowingWin,
            a = e.animations[d + "Switch"],
            b = Sys.isArray(e.animations[c]) ? e.animations[c] : [e.animations[c]];
        e.list.stop();
        if (Sys.isDefined(d) && Sys.isDefined(a)) {
            a = Sys.isArray(a) ? a : [a];
            b = b.concat(a)
        }
        e.currentlyShowingWin = c;
        e.list.play(b);
        e.playAudio(c);
        e.remainingWinTypes.splice(e.remainingWinTypes.indexOf(c), 1)
    },
    createText: (function() {
        var a = {};
        return function(c) {
            var b = this;
            return a[c] || (a[c] = Animation.utils.text.createText(c, b.FONT, b.TEXT_OFFSET, b.TEXT_OPERATIONS))
        }
    }()),
    createSwitchAnimation: function(c) {
        var b = this,
            a = b.createTextAnimation(c);
        b.configureSwitchAnimation(a);
        return a
    },
    createEndAnimation: function(c) {
        var b = this,
            a = b.createTextAnimation(c);
        b.configureTextEndingAnimation(a);
        return a
    },
    createWinAnimation: function(c) {
        var b = this,
            a = b.createTextAnimation(c);
        b.configureTextAnimation(a);
        return a
    },
    createTextAnimation: function(f) {
        var d = this,
            e = d.createText(f),
            c = e.width,
            a = e.height,
            b = d.getRenderingAttributes({
                width: c
            });
        return new Animation.CanvasAnimationItem({
            width: c,
            height: a,
            top: b.top,
            left: b.left,
            opacity: 1,
            depth: Layering.Game.Slots.BigWin.text,
            image: e,
            operations: {},
            text: f
        })
    },
    playAudio: function(b, a) {
        this.fireEvent("view:playAudio", {
            name: b,
            id: "bigWin",
            loop: a
        })
    },
    getRenderingAttributes: function(b) {
        var d = this.getScaleFactor(),
            c = Environment.determineResolution().virtualResolution,
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        return {
            left: Sys.isDefined(a.TEXT_LEFT) ? a.TEXT_LEFT * d : (c.width - b.width) / 2,
            top: a.TEXT_TOP * d
        }
    }
};
Game.Slots.BigWinView = Sys.extend(Core.View, Game.Slots.BigWinView, "Game.Slots.BigWinView");
Sys.ns("Game.Slots");
Game.Slots.BigWinModel = {
    SUPPORTED_SUB_TYPES: ["bigWin"],
    SUB_TYPE_LIMITS: {
        bigWin: {
            from: 0
        }
    },
    COUNT_UP_DURATIONS: {
        bigWin: 9000
    },
    SHOW_TOTAL_DURATION: 3000,
    SHOW_ALL_WINS_DURATION: 1000,
    constructor: function() {
        Game.Slots.BigWinModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = this;
        a.storeData("autoplayActive", false);
        a.storeData("showTotalDuration", a.SHOW_TOTAL_DURATION);
        a.storeData("showAllWinsDuration", a.SHOW_ALL_WINS_DURATION);
        a.storeData("latestWinnings", {
            previousWinnings: 0,
            currentWinnings: 0
        })
    },
    processServerResponse: function(d) {
        var c = this,
            a, b = d.currentGameState === "freespin" || d.nextaction === "freespin";
        c.storeData("serverResponse", d);
        if (Sys.isDefined(d.wins) && d.wins.winType === "bigWin") {
            a = d.wins.coins;
            c.storeData("coinWin", a);
            c.determineWinType(a);
            c.setState("animationRequested");
            c.storeData("togglePreventedByFreeSpins", b);
            c.storeData("showAllWins", c.shouldShowAllWins(d))
        } else {
            c.storeData("coinWin", 0);
            c.storeData("winType", undefined);
            c.setState("idle")
        }
    },
    determineWinType: function(d) {
        var c = this,
            f = Services.moneyManager.getBetCoins(),
            b, e, a, g = {};
        Sys.iterate(c.SUB_TYPE_LIMITS, function(i, h) {
            e = f * h.from;
            a = f * h.to;
            g[i] = e;
            if (d >= e && (isNaN(a) || d < f * a)) {
                b = i
            }
        });
        this.storeData("winType", b);
        this.storeData("winTypeCoinLimits", g)
    },
    shouldShowAllWins: function(a) {
        return true
    },
    getWinCountUpDuration: function() {
        var b = this,
            a = b.readData("winType");
        return b.COUNT_UP_DURATIONS[a]
    },
    getSupportedSubTypes: function() {
        return this.SUPPORTED_SUB_TYPES
    },
    shouldToggleWins: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            b = Sys.isDefined(a) && a > 0;
        return !b && !this.readData("togglePreventedByFreeSpins")
    }
};
Game.Slots.BigWinModel = Sys.extend(Core.Model, Game.Slots.BigWinModel, "Game.Slots.BigWinModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplay = {
    constructor: function() {
        Game.Slots.WinSituationsDisplay.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["waitSequence"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.WinSituationsDisplayModel,
            controller: Game.Slots.WinSituationsDisplayController
        }
    }
};
Game.Slots.WinSituationsDisplay = Sys.extend(Core.Module, Game.Slots.WinSituationsDisplay, "Game.Slots.WinSituationsDisplay");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayModel = {
    constructor: function() {
        Game.Slots.WinSituationsDisplayModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("config");
        this.storeData("winSituationMinimumDisplayTime", a.winSituationsDisplay.winSituationMinimumDisplayTime)
    },
    processServerResponse: function(c) {
        var b = this,
            a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            Sys.each(c.wins.winSituations, function(e, d) {
                if (b.shouldToggleWinSituation(e)) {
                    a.push(d)
                }
            })
        }
        b.storeData("winSituationsToToggle", a)
    },
    shouldToggleWinSituation: function(a) {
        return a.wins.type === "coins"
    }
};
Game.Slots.WinSituationsDisplayModel = Sys.extend(Core.Model, Game.Slots.WinSituationsDisplayModel, "Game.Slots.WinSituationsDisplayModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayController = {
    constructor: function() {
        Game.Slots.WinSituationsDisplayController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringSpinningState": this.abort,
            "request:winSituationsDisplay.abort": this.abort,
            "request:winSituationsDisplay.showAllWins": this.showAllWins,
            "request:winSituationsDisplay.toggleWins": this.startToggling,
            "notify:settingsManager.settingChanged": this.processSettingsChanges,
            "request:winSituationsDisplay.waitFor": this.handleWaitRequest,
            "notify:responseParser.responseParsed": this.onServerResponse
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    showAllWins: function(b) {
        var a = this;
        a.model.setState("showingAllWins");
        a.initializeWaitSequence("notify:winSituationsDisplay.showingAllWins", b)
    },
    startToggling: function(b) {
        var a = this;
        a.winSituationCounter = -1;
        a.pulseDurationPassed = true;
        a.clearWaitSequence();
        a.model.storeData("extraTogglingParameters", b);
        a.showNextBetline()
    },
    showNextBetline: function() {
        var b = this,
            a = b.model.readData("winSituationsToToggle");
        if (b.eventsToWaitFor.length === 0 && a.length > 0 && b.pulseDurationPassed) {
            b.abort();
            b.model.setState("toggling");
            ++b.winSituationCounter;
            b.initializeWaitSequence("notify:winSituationsDisplay.togglingWinSituation", a[b.winSituationCounter % a.length], b.model.readData("extraTogglingParameters"));
            b.pulseDurationPassed = false;
            b.toggleTimeout = setTimeout(function() {
                b.pulseDurationPassed = true;
                b.showNextBetline()
            }, b.model.readData("winSituationMinimumDisplayTime"))
        }
    },
    handleWaitRequest: function(a) {
        this.onWaitRequested(a)
    },
    onWaitIsComplete: function() {
        var b = this,
            a = b.model.isState("toggling");
        if (a) {
            b.showNextBetline()
        } else {
            b.abort()
        }
    },
    processSettingsChanges: function(a) {
        if (this.model.isState("toggling") && (a === "betLevel" || a === "denomination")) {
            this.abort()
        }
    },
    abort: function() {
        var b = this,
            a = b.model.isState("showingAllWins");
        clearTimeout(b.toggleTimeout);
        if (!b.model.isState("abort")) {
            b.model.setState("abort");
            b.fireEvent("notify:winSituationsDisplay.abort");
            if (a) {
                b.fireEvent("notify:winSituationsDisplay.finishedShowingAllWins")
            }
        }
    }
};
Game.Slots.WinSituationsDisplayController = Sys.extend(Core.Controller, Game.Slots.WinSituationsDisplayController, "Game.Slots.WinSituationsDisplayController");
Sys.ns("Game.Slots");
Game.Slots.WinSituations = {
    constructor: function() {
        Game.Slots.WinSituations.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.WinSituationsModel,
            view: Game.Slots.WinSituationsView,
            controller: Game.Slots.WinSituationsController
        }
    }
};
Game.Slots.WinSituations = Sys.extend(Core.Module, Game.Slots.WinSituations, "Game.Slots.WinSituations");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsController = {
    constructor: function() {
        Game.Slots.WinSituationsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:winSituationsDisplay.showingAllWins": this.animateAllWinningBetlines,
            "notify:winSituationsDisplay.togglingWinSituation": this.animateWinSituation,
            "notify:winSituationsDisplay.abort": this.abort,
            "request:winSituations.showDisplayBetline": this.showDisplayBetline,
            "request:winSituations.hideDisplayBetline": this.hideDisplayBetline,
            "view:animationComplete": this.fireEvent.bind(this, "notify:winSituations.animationComplete"),
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    animateAllWinningBetlines: function(a) {
        this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
        this.view.showAllWinningBetlines(a)
    },
    animateWinSituation: function(a, b) {
        this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
        this.model.storeData("currentWinSituationIndex", a);
        this.view.showSingleWinSituation(a, b)
    },
    abort: function() {
        this.view.stop();
        this.model.removeData("currentWinSituationIndex")
    },
    showDisplayBetline: function(b, a) {
        this.view.showDisplayBetline(b, a)
    },
    hideDisplayBetline: function(a) {
        this.view.hideDisplayBetline(a)
    }
};
Game.Slots.WinSituationsController = Sys.extend(Core.Controller, Game.Slots.WinSituationsController, "Game.Slots.WinSituationsController");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsModel = {
    constructor: function() {
        Game.Slots.WinSituationsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("config").winSituationsDisplay || {},
            b = a.betlines || {};
        this.storeData("lineConfig", b.lines);
        this.storeData("frameConfig", b.frames)
    },
    processServerResponse: function(b) {
        var a = this;
        if (b.wins && Sys.isArray(b.wins.winSituations)) {
            a.storeData("winSituations", b.wins.winSituations.slice(0))
        }
    },
    shouldFrameWinningSymbols: function() {
        return Sys.isDefined(this.readData("frameConfig"))
    }
};
Game.Slots.WinSituationsModel = Sys.extend(Core.Model, Game.Slots.WinSituationsModel, "Game.Slots.WinSituationsModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsView = {
    constructor: function() {
        Game.Slots.WinSituationsView.superclass.constructor.apply(this, arguments)
    },
    setAllBetlinesDisplayItemProps: function(a) {},
    setSingleWinSituationDisplayItemProps: function(a) {},
    initAnimations: function() {
        var a = this,
            b = Environment.determineResolution().virtualResolution;
        a.origin = {
            x: 0,
            y: 0
        };
        a.offlineCanvas = document.createElement("canvas");
        a.offlineCanvas.width = b.width;
        a.offlineCanvas.height = b.height;
        a.offlineContext = a.offlineCanvas.getContext("2d");
        a.animationList = new Animation.CanvasAnimationList();
        a.hoverBetlineCanvas = document.createElement("canvas");
        a.hoverBetlineCanvas.width = b.width;
        a.hoverBetlineCanvas.height = b.height;
        a.hoverBetlineContext = a.hoverBetlineCanvas.getContext("2d");
        a.hoverBetlineAnimationList = new Animation.CanvasAnimationList();
        a.createAnimationItems();
        a.createHoverBetlineAnimationItems();
        Game.stage.view.addToRenderLoop(a.animationList);
        Game.stage.view.addToRenderLoop(a.hoverBetlineAnimationList);
        a.hoverBetlineAnimationList.stop();
        a.animationList.stop()
    },
    createAnimationItems: function() {
        var a = this;
        a.item = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: a.offlineCanvas.width,
            height: a.offlineCanvas.height,
            depth: Layering.Game.Slots.WinSituationsDisplay.betlines,
            image: a.offlineCanvas,
            operations: {
                fade: [{
                    time: 0,
                    value: 1,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: a
                    }
                }, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }]
            }
        });
        a.animationList.add(a.item)
    },
    createHoverBetlineAnimationItems: function() {
        var a = this,
            b = Layering.Game.Slots.WinSituationsDisplay.hoverBetlines || Layering.Game.Slots.WinSituationsDisplay.betlines;
        a.hoverItem = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: a.hoverBetlineCanvas.width,
            height: a.hoverBetlineCanvas.height,
            depth: b,
            image: a.hoverBetlineCanvas
        });
        a.hoverBetlineAnimationList.add(a.hoverItem)
    },
    showAllWinningBetlines: function(c) {
        var b = this,
            a = b.model.readData("winSituations");
        Sys.each(a, function(d) {
            if (Sys.isDefined(d.betline)) {
                b.drawBetline(d.betline)
            }
        });
        b.setAllBetlinesDisplayItemProps(c);
        b.animationList.restore();
        b.animationList.play()
    },
    drawBetline: function(e, b) {
        var d = this,
            g = d.model.readData("lineConfig"),
            c = g[e].lineCoordinates,
            f = g[e].color || g.defaultColor,
            a, h;
        b = b ? b : d.offlineContext;
        if (!Array.isArray(c)) {
            h = Environment.getConfigForCurrentDeviceState(c)
        } else {
            h = c
        }
        b.beginPath();
        b.moveTo(h[0], h[1]);
        if (g.lineType === "curve") {
            for (a = 2; a < h.length; a += 6) {
                b.bezierCurveTo(h[a], h[a + 1], h[a + 2], h[a + 3], h[a + 4], h[a + 5])
            }
        } else {
            for (a = 2; a < h.length; a += 2) {
                b.lineTo(h[a], h[a + 1])
            }
        }
        for (a = 0; a < g.drawingOperations.length; a++) {
            b.strokeStyle = f;
            b = Sys.applyProperties(b, g.drawingOperations[a]);
            b.stroke()
        }
    },
    showSingleWinSituation: function(c, d) {
        var b = this,
            a = b.model.readData("winSituations")[c];
        if (Sys.isDefined(a.betline)) {
            b.drawBetline(a.betline)
        }
        if (b.model.shouldFrameWinningSymbols()) {
            b.frameWinningSymbols(a)
        }
        b.setSingleWinSituationDisplayItemProps(d);
        b.animationList.restore();
        b.animationList.play()
    },
    frameWinningSymbols: function(k) {
        var h = this,
            b = h.model.readData("lineConfig"),
            g = h.model.readData("frameConfig"),
            e = (k.betline && b[k.betline].color) || b.defaultColor,
            c = h.offlineContext,
            j, l, i, a, m, f = g.image,
            d;
        if (f) {
            f = Resources.readData("animationImages")[f]
        }
        Sys.each(k.positions, function(n) {
            j = Game.stage.model.getSymbolConfiguration(n.reelIndex, n.symbolIndex);
            l = j.left + g.xOffset;
            i = j.top + g.yOffset;
            a = j.width - g.xOffset * 2;
            m = j.height - g.yOffset * 2;
            c.clearRect(l, i, a, m);
            if (f) {
                c.drawImage(f, l, i)
            } else {
                for (d = 0; d < b.drawingOperations.length; d++) {
                    c.strokeStyle = e;
                    c = Sys.applyProperties(c, b.drawingOperations[d]);
                    c.strokeRect(l, i, a, m)
                }
            }
        })
    },
    stop: function() {
        var a = this;
        a.animationList.stop();
        a.offlineContext.clearRect(0, 0, a.offlineCanvas.width, a.offlineCanvas.height)
    },
    showDisplayBetline: function(a, b) {
        var d = this,
            c = d.model.readData("displayBetlineWho");
        if (!Sys.isArray(a)) {
            a = [a]
        }
        if (!Sys.isDefined(b)) {
            b = "hover"
        }
        if (b !== c) {
            d.hideDisplayBetline(c)
        }
        d.model.storeData("displayBetlineWho", b);
        a.forEach(function(e) {
            d.drawBetline(e, d.hoverBetlineContext)
        });
        d.hoverBetlineAnimationList.play()
    },
    hideDisplayBetline: function(a) {
        var b = this;
        if (!Sys.isDefined(a)) {
            a = "hover"
        }
        if (a === b.model.readData("displayBetlineWho")) {
            b.hoverBetlineAnimationList.stop();
            b.hoverBetlineContext.clearRect(0, 0, b.hoverBetlineCanvas.width, b.hoverBetlineCanvas.height)
        }
    },
    refresh: function() {
        var b = this.model.readData("currentWinSituationIndex"),
            a = this.item,
            c;
        this.animationList.stop();
        c = Environment.determineResolution().virtualResolution;
        this.offlineCanvas.width = c.width;
        this.offlineCanvas.height = c.height;
        if (Animation.utils.isAnimationItem(a)) {
            a.setWidth(c.width);
            a.setHeight(c.height);
            a.updatePivot()
        }
        if (Sys.isNumber(b)) {
            this.showSingleWinSituation(b, {})
        }
    }
};
Game.Slots.WinSituationsView = Sys.extend(Core.View, Game.Slots.WinSituationsView, "Game.Slots.WinSituationsView");
Sys.ns("Game.Slots");
Game.Slots.BetlineIndicators = {
    constructor: function() {
        Game.Slots.BetlineIndicators.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            desktop: [{
                userInput: {
                    inputEvents: ["hover"],
                    listenToUserInput: true
                }
            }]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.BetlineIndicatorsModel,
            view: Game.Slots.BetlineIndicatorsView,
            controller: Game.Slots.BetlineIndicatorsController
        }
    }
};
Game.Slots.BetlineIndicators = Sys.extend(Core.Module, Game.Slots.BetlineIndicators, "Core.BetlineIndicators");
Sys.ns("Game.Slots");
Game.Slots.BetlineIndicatorsModel = {
    constructor: function() {
        Game.Slots.BetlineIndicatorsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        Game.Slots.BetlineIndicatorsModel.superclass.setupData.apply(this, arguments);
        this.storeData("numberConfig", Resources.readData("config").winSituationsDisplay.betlines.numbers)
    },
    processServerResponse: function(b) {
        var a = [];
        if (b.wins && Sys.isArray(b.wins.winSituations)) {
            Sys.each(b.wins.winSituations, function(c) {
                a.push(c.betline)
            })
        }
        this.storeData("betlineNumbers", a)
    }
};
Game.Slots.BetlineIndicatorsModel = Sys.extend(Core.Model, Game.Slots.BetlineIndicatorsModel, "Game.Slots.BetlineIndicatorsModel");
Sys.ns("Game.Slots");
Game.Slots.BetlineIndicatorsView = {
    constructor: function() {
        Game.Slots.BetlineIndicatorsView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function() {
        var a = this;
        a.highlightAnimationList = new Animation.CanvasAnimationList();
        a.highlightDisplayAnimationList = new Animation.CanvasAnimationList();
        a.createHighlightItems(a.highlightAnimationList);
        a.createHighlightItems(a.highlightDisplayAnimationList);
        Game.stage.view.addToRenderLoop(a.highlightAnimationList);
        Game.stage.view.addToRenderLoop(a.highlightDisplayAnimationList);
        a.highlightAnimationList.stop();
        a.highlightDisplayAnimationList.stop()
    },
    refresh: function() {
        var d = this.highlightAnimationList,
            a = d.items,
            b, c;
        if (!d.isRunning()) {
            return
        }
        for (b = 0; b < a.length; b++) {
            c = a[b].prop.customProps.number;
            this.animate(c, d, {})
        }
    },
    createHighlightItems: function(d) {
        var c = this,
            e = c.calculateNumberOfNeededItems(),
            a = c.model.readData("numberConfig").style,
            f = Animation.utils.text.createNumberDrawingProperties(a),
            b;
        d = d ? d : c.highlightAnimationList;
        for (b = -1; ++b < e;) {
            d.add(new Animation.CanvasAnimationItem({
                width: 0,
                height: 0,
                depth: Layering.Game.Slots.WinSituationsDisplay.betlineNumberHighlight,
                customProps: {
                    number: "not set yet"
                },
                executeBefore: function(g) {
                    Animation.utils.text.drawTextFromImage(this.customProps.number, a.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, f.image, f.charMap, f.width, f.height, g)
                },
                operations: {
                    fade: [{
                        time: 0,
                        value: 1,
                        fireEvent: {
                            event: "view:animationComplete",
                            scope: c
                        }
                    }, {
                        time: 1,
                        value: 1,
                        goTo: 0
                    }]
                }
            }))
        }
    },
    calculateNumberOfNeededItems: function() {
        var a = this.model.readData("numberConfig").configurations,
            b = 1;
        Sys.iterate(a, function(c, d) {
            if (Sys.isArray(d)) {
                b = Math.max(b, d.length)
            }
        });
        return b
    },
    animate: function(g, e, f) {
        var d = this,
            c = this.model.readData("numberConfig").configurations[g],
            b, a = [];
        e = e ? e : d.highlightAnimationList;
        if (!Sys.isDefined(c.left) && !Sys.isDefined(c.top)) {
            c = Environment.getConfigForCurrentDeviceState(c)
        }
        if (!Sys.isArray(c)) {
            c = [c]
        }
        Sys.each(c, function(h, i) {
            b = e.items[i];
            d.configureItemForHighlight(b, g, h, f);
            a.push(b)
        });
        e.play(a)
    },
    configureItemForHighlight: function(a, d, c, b) {
        a.prop.customProps.number = d;
        a.prop.top = c.top;
        a.prop.left = c.left
    },
    stop: function(b) {
        var a = this;
        b = b ? b : a.highlightAnimationList;
        b.stop()
    },
    onUserInputHover: function(g) {
        var f = this,
            a = Sys.UserInputUtils.getCoordinatesRelativeToElement(g, Game.stage.getGameContainer()),
            b, d = f.model.readData("numberConfig").panelArea,
            c, e;
        if (!Sys.isDefined(f.highlightAnimationList)) {
            return
        }
        c = {
            x: d.left.left,
            y: d.left.top,
            width: d.left.width,
            height: d.left.height
        };
        e = {
            x: d.right.left,
            y: d.right.top,
            width: d.right.width,
            height: d.right.height
        };
        if (Sys.UserInputUtils.isCoordinateTarget(document.getElementById("canvasAnimationManager"), g) && (Sys.UserInputUtils.isUserInputInSegment(a, c) || Sys.UserInputUtils.isUserInputInSegment(a, e))) {
            b = f.isUserInputInBetlineSegment(a);
            if (b === -1) {
                f.fireEvent("view:hideBetline")
            } else {
                f.fireEvent("view:showBetline", b)
            }
        } else {
            f.fireEvent("view:hideBetline")
        }
    },
    isUserInputInBetlineSegment: function(c) {
        var d = this,
            f = d.model.readData("numberConfig").configurations,
            b = d.model.readData("numberConfig").hoverArea,
            e, a = -1;
        Sys.iterate(f, function(g) {
            var h = Environment.getConfigForCurrentDeviceState(f[g]) || f[g];
            e = {
                x: h.left + b.offsetX,
                y: h.top + b.offsetY,
                width: b.width,
                height: b.height
            };
            if (Sys.UserInputUtils.isUserInputInSegment(c, e)) {
                a = g
            }
        });
        return a
    }
};
Game.Slots.BetlineIndicatorsView = Sys.extend(Core.View, Game.Slots.BetlineIndicatorsView, "Game.Slots.BetlineIndicatorsView");
Sys.ns("Game.Slots");
Game.Slots.BetlineIndicatorsController = {
    constructor: function() {
        Game.Slots.BetlineIndicatorsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:winSituationsDisplay.togglingWinSituation": this.animateBetlineNumber,
            "view:showBetline": this.showBetline,
            "view:hideBetline": this.hideBetline,
            "notify:winSituationsDisplay.abort": this.view.stop.bind(this.view),
            "notify:gameModeChanged": this.onGameModeChanged,
            "view:animationComplete": this.fireEvent.bind(this, "notify:betlineIndicators.animationComplete"),
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    animateBetlineNumber: function(a, c) {
        var b = this.model.readData("betlineNumbers")[a];
        if (Sys.isDefined(b)) {
            this.fireEvent("request:winSituationsDisplay.waitFor", "notify:betlineIndicators.animationComplete");
            this.view.animate(b, null, c)
        }
    },
    showBetline: function(b) {
        var a = this;
        a.view.animate(b, a.view.highlightDisplayAnimationList);
        a.fireEvent("request:winSituations.showDisplayBetline", b)
    },
    hideBetline: function() {
        var a = this;
        a.view.stop(a.view.highlightDisplayAnimationList);
        a.fireEvent("request:winSituations.hideDisplayBetline")
    },
    onUserInputHover: function(a) {
        this.view.onUserInputHover(a)
    },
    onGameModeChanged: function(b) {
        var a = this;
        if (!Sys.isDefined(a.startListeningToUserInput) || !Sys.isDefined(a.stopListeningToUserInput)) {
            return
        }
        if (b !== "BASIC") {
            a.stopListeningToUserInput()
        } else {
            a.startListeningToUserInput()
        }
    }
};
Game.Slots.BetlineIndicatorsController = Sys.extend(Core.Controller, Game.Slots.BetlineIndicatorsController, "Game.Slots.BetlineIndicatorsController");
Sys.ns("Game.Slots");
Game.Slots.WinBanner = {
    constructor: function() {
        Game.Slots.WinBanner.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.WinBannerModel,
            view: Game.Slots.WinBannerView,
            controller: Game.Slots.WinBannerController
        }
    }
};
Game.Slots.WinBanner = Sys.extend(Core.CountUp, Game.Slots.WinBanner, "Game.Slots.WinBanner");
Sys.ns("Game.Slots");
Game.Slots.WinBannerController = {
    COUNT_UP_NAME: "winBanner",
    constructor: function() {
        Game.Slots.WinBannerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        Game.Slots.WinBannerController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "notify:responseParser.responseParsed": this.model.processServerResponse.bind(this.model),
            "request:winBanner.animate": this.start,
            "request:winBanner.hide": this.stop,
            "view:playSound": this.fireEvent.bind(this, "request:audioPlayer.play", {
                name: "countUpLoop",
                loop: true,
                id: "winBannerCountUp"
            }),
            "view:stopSound": this.fireEvent.bind(this, "request:audioPlayer.stop", "winBannerCountUp"),
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged
        })
    }
};
Game.Slots.WinBannerController = Sys.extend(Core.CountUpController, Game.Slots.WinBannerController, "Game.Slots.WinBannerController");
Sys.ns("Game.Slots");
Game.Slots.WinBannerModel = {
    constructor: function() {
        Game.Slots.WinBannerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        Game.Slots.WinBannerModel.superclass.setupData.apply(this, arguments);
        this.storeData("coinWin", 0);
        this.storeData("countUpDuration", 0)
    },
    processServerResponse: function(d) {
        var b = this,
            a = 0,
            c = 0;
        if (Sys.isDefined(d.wins) && Sys.isDefined(d.wins.coins)) {
            a = d.wins.coins
        }
        if (Sys.isDefined(d.wins) && Sys.isDefined(d.wins.coinsTotal)) {
            c = d.wins.coinsTotal
        }
        b.storeData("coinWin", a);
        b.storeData("totalCoinWin", c)
    }
};
Game.Slots.WinBannerModel = Sys.extend(Core.CountUpModel, Game.Slots.WinBannerModel, "Game.Slots.WinBannerModel");
Sys.ns("Game.Slots");
Game.Slots.WinBannerView = {
    BACKGROUND_LEFT: 0,
    BACKGROUND_TOP: 460,
    BACKGROUND_DEPTH: 101,
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_IMAGE_WIDTH: 0,
    BACKGROUND_IMAGE_HEIGHT: 0,
    SHOW_TOTAL_DURATION: 500,
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 80,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{
        fillStyle: "#FFFFFF"
    }, {
        lineWidth: 5,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_DEPTH: 100,
    COUNT_UP_TOP: 475,
    COUNT_UP_EASING_TYPE: "ease-out",
    constructor: function() {
        var a = {
            BACKGROUND_LEFT: this.BACKGROUND_LEFT,
            BACKGROUND_TOP: this.BACKGROUND_TOP,
            COUNT_UP_LEFT: this.COUNT_UP_LEFT,
            COUNT_UP_TOP: this.COUNT_UP_TOP
        };
        Game.Slots.WinBannerView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureStartAnimation: function(a) {},
    configureEndAnimation: function() {},
    createBackgroundItem: function() {
        var c = this,
            b = this.scaleFactor,
            a = this.getPositionForBackgroundItem();
        return new Animation.CanvasAnimationItem({
            left: a.left,
            top: a.top,
            width: Math.round(c.BACKGROUND_IMAGE_WIDTH * b),
            height: Math.round(c.BACKGROUND_IMAGE_HEIGHT * b),
            image: c.BACKGROUND_IMAGE,
            opacity: 1,
            delay: 0,
            depth: c.BACKGROUND_DEPTH,
            operations: {}
        })
    },
    getPositionForBackgroundItem: function() {
        var a = Environment.getOrientationSpecificConfig(this.CONFIG, true),
            c = Environment.determineResolution().virtualResolution,
            b = this.scaleFactor;
        return {
            left: Sys.isDefined(a.BACKGROUND_LEFT) ? Math.round(a.BACKGROUND_LEFT * b) : c.width / 2 - Math.round(this.BACKGROUND_IMAGE_WIDTH * b) / 2,
            top: Math.round(a.BACKGROUND_TOP * b)
        }
    },
    createItems: function() {
        var a = this;
        Game.Slots.WinBannerView.superclass.createItems.apply(this, arguments);
        a.backgroundItem = a.createBackgroundItem();
        a.list.add(a.backgroundItem)
    },
    start: function(c) {
        var b = this,
            a = b.model.readData("coinWin"),
            d = b.model.readData("totalCoinWin");
        Game.Slots.WinBannerView.superclass.start.call(b, {
            from: d - a,
            to: d,
            duration: c,
            fireEventsOnValue: [{
                value: 0,
                event: "view:playSound",
                scope: b
            }, {
                value: d,
                event: "view:stopSound",
                scope: b
            }]
        })
    },
    stop: function() {
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.stop.apply(this, arguments)
    },
    pause: function() {
        this.fireEvent("view:stopSound");
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.pause.apply(this, arguments)
    },
    resume: function() {
        if (this.model.isState("countingUp")) {
            this.fireEvent("view:playSound")
        }
        Game.Slots.WinBannerView.superclass.resume.apply(this, arguments)
    },
    refresh: function() {
        var a = this.getPositionForBackgroundItem(),
            b = this.backgroundItem;
        if (Animation.utils.isAnimationItem(b)) {
            b.setLeft(a.left);
            b.setTop(a.top)
        }
        Game.Slots.WinBannerView.superclass.refresh.apply(this)
    },
    showTotal: function() {
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.showTotal.apply(this, arguments)
    }
};
Game.Slots.WinBannerView = Sys.extend(Core.CountUpView, Game.Slots.WinBannerView, "Game.Slots.WinBannerView");
Sys.ns("Game.Slots");
Game.Slots.CoinWin = {
    constructor: function() {
        Game.Slots.CoinWin.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.CoinWinModel,
            view: Game.Slots.CoinWinView,
            controller: Game.Slots.CoinWinController
        }
    }
};
Game.Slots.CoinWin = Sys.extend(Core.Module, Game.Slots.CoinWin, "Game.Slots.CoinWin");
Sys.ns("Game.Slots");
Game.Slots.CoinWinModel = {
    SYMBOL_ORDER_FREFERENCE: [2, 1, 3, 0, 4],
    constructor: function() {
        Game.Slots.CoinWinModel.superclass.constructor.apply(this, arguments)
    },
    processServerResponse: function(c) {
        var b = this,
            a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            Sys.each(c.wins.winSituations, function(d) {
                a.push(b.parseWinSituation(d))
            })
        }
        b.storeData("winSituations", a)
    },
    parseWinSituation: function(e) {
        var d, a = [],
            c, f, b;
        if (e.wins.type === "coins") {
            d = e.positions;
            for (b = 0; b < d.length; b++) {
                a.push(d[b].reelIndex)
            }
            for (b = 0; b < this.SYMBOL_ORDER_FREFERENCE.length; b++) {
                f = this.SYMBOL_ORDER_FREFERENCE[b];
                c = a.indexOf(f);
                if (c >= 0) {
                    return {
                        x: f,
                        y: d[c].symbolIndex,
                        coins: e.wins.coins
                    }
                }
            }
        }
        return undefined
    }
};
Game.Slots.CoinWinModel = Sys.extend(Core.Model, Game.Slots.CoinWinModel, "Game.Slots.CoinWinModel");
Sys.ns("Game.Slots");
Game.Slots.CoinWinView = {
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 100,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{
        fillStyle: "#fff"
    }, {
        lineWidth: 5,
        strokeStyle: "#000",
        drawType: "stroke"
    }],
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_DRAWING_FUNCTION: function(a) {
        a.fillStyle = "#ff00e0";
        a.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
    },
    BACKGROUND_WIDTH: undefined,
    BACKGROUND_HEIGHT: undefined,
    constructor: function() {
        var b = this,
            a = {
                NUMBER_IMAGE: b.NUMBER_IMAGE,
                NUMBER_WIDTH: b.NUMBER_WIDTH,
                NUMBER_HEIGHT: b.NUMBER_HEIGHT,
                NUMBER_FONT: b.NUMBER_FONT,
                NUMBER_OFFSET: b.NUMBER_OFFSET,
                NUMBER_TEXT_OPERATIONS: b.NUMBER_TEXT_OPERATIONS,
                BACKGROUND_IMAGE: b.BACKGROUND_IMAGE,
                BACKGROUND_DRAWING_FUNCTION: b.BACKGROUND_DRAWING_FUNCTION,
                BACKGROUND_WIDTH: b.BACKGROUND_WIDTH,
                BACKGROUND_HEIGHT: b.BACKGROUND_HEIGHT
            };
        Game.Slots.CoinWinView.superclass.constructor.apply(b, arguments);
        b.CONFIG = b.CONFIG || {};
        b.CONFIG.DEFAULT = b.CONFIG.DEFAULT || {};
        Sys.applyProperties(b.CONFIG.DEFAULT, a);
        b.renderingProperties = {}
    },
    initAnimations: function() {
        var a = this;
        a.animationList = new Animation.CanvasAnimationList();
        a.textItem = a.createTextItem();
        a.backgroundItem = a.createBackgroundItem();
        a.animationList.add(a.backgroundItem);
        a.animationList.add(a.textItem);
        Game.stage.view.addToRenderLoop(a.animationList);
        a.animationList.stop()
    },
    createTextItem: function() {
        var b = this,
            a = Environment.getOrientationSpecificConfig(b.CONFIG, true),
            c = Animation.utils.text.createNumberDrawingProperties(a);
        b.renderingProperties[Utils.Platform.getOrientation()] = c;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: Layering.Game.Slots.CoinWin.text,
            customProps: {
                text: "not set yet",
                renderingProperties: c
            },
            executeBefore: function(d) {
                var e = this.customProps.renderingProperties;
                Animation.utils.text.drawTextFromImage(this.customProps.text, a.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, e.image, e.charMap, e.width, e.height, d)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 1,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: b
                    }
                }, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }]
            }
        })
    },
    createBackgroundItem: function() {
        var a = this,
            b = Game.stage.model.getSymbolConfiguration(0, 0);
        return new Animation.CanvasAnimationItem({
            width: a.CONFIG.DEFAULT.BACKGROUND_WIDTH || b.width,
            height: a.CONFIG.DEFAULT.BACKGROUND_HEIGHT || b.height,
            depth: Layering.Game.Slots.CoinWin.background,
            executeBefore: a.CONFIG.DEFAULT.BACKGROUND_DRAWING_FUNCTION,
            image: a.CONFIG.DEFAULT.BACKGROUND_IMAGE
        })
    },
    animate: function(a) {
        this.animationList.restore();
        this.updateAnimationItems(a);
        this.animationList.play()
    },
    updateAnimationItems: function(a) {
        var b = this,
            c;
        c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        b.backgroundItem.prop.top = c.top;
        b.backgroundItem.prop.left = c.left;
        b.textItem.setTop(c.top + c.height / 2);
        b.textItem.setLeft(c.left + c.width / 2);
        b.textItem.prop.customProps.text = a.coins
    },
    abort: function() {
        this.animationList.stop();
        this.fireEvent("view:animationAborted")
    },
    updateItems: function() {
        var e = this,
            c = Environment.getOrientationSpecificConfig(e.CONFIG, true),
            d = e.model.readData("currentWinSituation") || {
                x: 0,
                y: 0
            },
            b = Utils.Platform.getOrientation(),
            f = Game.stage.model.getSymbolConfiguration(d.x, d.y),
            a = e.setRenderingProperties(c, b);
        if (Animation.utils.isAnimationItem(e.textItem)) {
            e.textItem.setWidth(a.width);
            e.textItem.setHeight(a.height);
            e.textItem.setTop(f.top + f.height / 2);
            e.textItem.setLeft(f.left + f.width / 2);
            e.textItem.prop.customProps.renderingProperties = a
        }
        if (Animation.utils.isAnimationItem(e.backgroundItem)) {
            e.backgroundItem.setWidth(c.BACKGROUND_WIDTH || f.width);
            e.backgroundItem.setHeight(c.BACKGROUND_HEIGHT || f.height);
            e.backgroundItem.setTop(f.top);
            e.backgroundItem.setLeft(f.left)
        }
    },
    setRenderingProperties: function(b, a) {
        if (!Sys.isDefined(this.renderingProperties[a])) {
            this.renderingProperties[a] = Animation.utils.text.createNumberDrawingProperties(b)
        }
        return this.renderingProperties[a]
    },
    refresh: function() {
        this.updateItems()
    }
};
Game.Slots.CoinWinView = Sys.extend(Core.View, Game.Slots.CoinWinView, "Game.Slots.CoinWinView");
Sys.ns("Game.Slots");
Game.Slots.CoinWinController = {
    constructor: function() {
        Game.Slots.CoinWinController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:responseParser.responseParsed": this.model.processServerResponse.bind(this.model),
            "notify:winSituationsDisplay.togglingWinSituation": this.animate,
            "notify:winSituationsDisplay.abort": this.abort,
            "view:animationComplete": this.animationComplete,
            "view:animationAborted": this.animationComplete,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    animate: function(b) {
        var d = this,
            a = d.model.readData("winSituations"),
            c = b % a.length;
        if (a.length > 0 && Sys.isDefined(a[c])) {
            d.model.setState("animating");
            d.view.animate(a[c]);
            d.model.storeData("currentWinSituation", a[c]);
            d.fireEvent("request:winSituationsDisplay.waitFor", "notify:coinWin.animationComplete")
        }
    },
    animationComplete: function() {
        this.fireEvent("notify:coinWin.animationComplete")
    },
    abort: function() {
        if (this.model.isState("animating")) {
            this.view.abort();
            this.model.removeData("currentWinSituation");
            this.model.setState("idle")
        }
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    }
};
Game.Slots.CoinWinController = Sys.extend(Core.Controller, Game.Slots.CoinWinController, "Game.Slots.CoinWinController");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbols = {
    constructor: function() {
        Game.Slots.DimmedSymbols.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.DimmedSymbolsModel,
            view: Game.Slots.DimmedSymbolsView,
            controller: Game.Slots.DimmedSymbolsController
        }
    }
};
Game.Slots.DimmedSymbols = Sys.extend(Core.Module, Game.Slots.DimmedSymbols, "Game.Slots.DimmedSymbols");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbolsView = {
    OPACITY: 0.3,
    constructor: function() {
        Game.Slots.DimmedSymbolsView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function() {
        var e = this,
            a = Resources.readData("animationImages"),
            b, c, d = {};
        Sys.iterate(a, function(f, g) {
            if (f.match(/^SYM\d+$/)) {
                b = document.createElement("canvas");
                b.width = g.width;
                b.height = g.height;
                c = b.getContext("2d");
                c.globalAlpha = e.OPACITY;
                c.drawImage(g, 0, 0);
                d[f] = b
            }
        });
        this.model.storeData("dimmedSymbolImages", d)
    },
    dimNoWinSymbols: function() {
        var d = this,
            b = d.model.readData("symbolsToDim"),
            g = d.model.readData("dimmedSymbolImages"),
            f, e, a = {},
            c = {};
        Sys.each(b, function(h) {
            f = h.x;
            e = h.y;
            if (!Sys.isDefined(a[f])) {
                a[f] = {};
                c[f] = {}
            }
            a[f][e] = g[h.symbol];
            c[f][e] = h.symbol
        });
        d.model.storeData("unDimSymbolConfig", c);
        d.fireEvent("view:setReelSymbols", a)
    },
    unDimNoWinSymbols: function() {
        this.fireEvent("view:setReelSymbols", this.model.readData("unDimSymbolConfig"))
    }
};
Game.Slots.DimmedSymbolsView = Sys.extend(Core.View, Game.Slots.DimmedSymbolsView, "Game.Slots.DimmedSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.DimmedSymbolsController = {
    constructor: function() {
        Game.Slots.DimmedSymbolsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:responseParser.responseParsed": this.model.processServerResponse.bind(this.model),
            "notify:winSituationsDisplay.showingAllWins": this.dimNoWinSymbols,
            "request:dimmedSymbols.dimNoWinSymbols": this.dimNoWinSymbols,
            "notify:stateHandler.enteringSpinningState": this.unDimNoWinSymbols,
            "notify:stateHandler.enteringFreeSpinOutroState": this.unDimNoWinSymbols,
            "notify:stateHandler.enteringFreeSpinIntroState": this.unDimNoWinSymbols,
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "view:setReelSymbols": this.fireEvent.bind(this, "request:spin.setSymbols")
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    dimNoWinSymbols: function() {
        var b = this,
            a = b.model;
        if (!a.isState("animateSymbols") && a.readData("symbolsToDim").length > 0) {
            a.setState("animateSymbols");
            b.view.dimNoWinSymbols()
        }
    },
    unDimNoWinSymbols: function() {
        if (this.model.isState("animateSymbols")) {
            this.model.setState("idle");
            this.view.unDimNoWinSymbols()
        }
    }
};
Game.Slots.DimmedSymbolsController = Sys.extend(Core.Controller, Game.Slots.DimmedSymbolsController, "Game.Slots.DimmedSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimations = {
    constructor: function() {
        Game.Slots.ReelStopAnimations.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["trigger"]
    },
    getStateChanges: function() {
        var c = this,
            b = c.model,
            a = c.MODULE_NAME,
            d = {
                state: {
                    name: a[0].toUpperCase() + a.substr(1),
                    execute: function() {},
                    waitEvents: {}
                }
            },
            e = {
                stopped: {
                    queue: [function(f) {
                        if (b.readData("shouldAnimate") && !b.readData("quickStopTriggered") && !b.readData("animationsComplete")) {
                            f.stateHandler.pushState(f.states[a])
                        }
                    }]
                }
            };
        d.state.waitEvents["notify:" + a + ".animationsComplete"] = false;
        e[a] = d;
        return e
    },
    getDefaultMVCClasses: function() {
        return {}
    }
};
Game.Slots.ReelStopAnimations = Sys.extend(Core.Module, Game.Slots.ReelStopAnimations, "Game.Slots.ReelStopAnimations");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsModel = {
    SYMBOLS_TO_ANIMATE: [],
    constructor: function() {
        Game.Slots.ReelStopAnimationsModel.superclass.constructor.apply(this, arguments)
    },
    processServerResponse: function(d) {
        var a = this.SYMBOLS_TO_ANIMATE,
            c = [],
            b;
        Sys.each(d.reelInfo, function(e, f) {
            c.push([]);
            Sys.each(e.symbols, function(h, g) {
                b = e.overlaySymbols[g];
                if (a.contains(b)) {
                    c[f].push({
                        symbol: b,
                        symbolIndex: g
                    })
                } else {
                    if (a.contains(h)) {
                        c[f].push({
                            symbol: h,
                            symbolIndex: g
                        })
                    }
                }
            })
        });
        c = this.applyConditions(c);
        this.calculateLastReelToAnimate(c);
        this.storeData("symbolsToAnimateInOutcome", c)
    },
    applyConditions: function(a) {
        return a
    },
    calculateLastReelToAnimate: function(c) {
        var b = this,
            d = {},
            a = false;
        Sys.each(c, function(f, e) {
            Sys.each(f, function(g) {
                if (b.SYMBOLS_TO_ANIMATE.contains(g.symbol)) {
                    a = true;
                    d[g.symbol] = e
                }
            })
        });
        b.storeData("shouldAnimate", a);
        b.storeData("lastReelToAnimate", d)
    }
};
Game.Slots.ReelStopAnimationsModel = Sys.extend(Core.Model, Game.Slots.ReelStopAnimationsModel, "Game.Slots.ReelStopAnimationsModel");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsController = {
    constructor: function() {
        Game.Slots.ReelStopAnimationsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringSpinningState": this.onSpinStart,
            "notify:quickStopper.quickStop": this.onQuickStopTriggered,
            "request:reelStopAnimations.abort": this.abortTriggered,
            "notify:spin.reelStoppedSpinning": this.onReelStopped,
            "view:animationsComplete": this.onAnimationsComplete,
            "view:playSound": this.fireEvent.bind(this, "request:audioPlayer.play"),
            "view:stopSound": this.fireEvent.bind(this, "request:audioPlayer.stop"),
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    registerTriggers: function() {
        Services.trigger.registerTrigger("notify:reelStopAnimations.symbolsToAnimate", this, "When there are scatter symbols to animate.")
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onSpinStart: function() {
        this.model.storeData("quickStopTriggered", false);
        this.model.storeData("animationsComplete", false);
        this.model.storeData("abortTriggered", false)
    },
    onQuickStopTriggered: function() {
        this.model.storeData("quickStopTriggered", true);
        this.abort()
    },
    abortTriggered: function() {
        this.model.storeData("abortTriggered", true);
        this.abort()
    },
    onReelStopped: function(c) {
        var b = this.model,
            a = b.readData("symbolsToAnimateInOutcome")[c];
        if (!b.readData("quickStopTriggered") && !b.readData("abortTriggered") && a.length > 0) {
            this.view.animate(a, c);
            this.fireEvent("notify:reelStopAnimations.symbolsToAnimate", c, a)
        }
    },
    onAnimationsComplete: function() {
        this.model.storeData("animationsComplete", true);
        this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
    },
    abort: function() {
        this.view.abort();
        this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
    }
};
Game.Slots.ReelStopAnimationsController = Sys.extend(Core.Controller, Game.Slots.ReelStopAnimationsController, "Game.Slots.ReelStopAnimationsController");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbols = {
    constructor: function() {
        Game.Slots.WinningSymbols.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.WinningSymbolsModel,
            view: Game.Slots.WinningSymbolsView,
            controller: Game.Slots.WinningSymbolsController
        }
    }
};
Game.Slots.WinningSymbols = Sys.extend(Core.Module, Game.Slots.WinningSymbols, "Game.Slots.WinningSymbols");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsModel = {
    SYMBOLS_TO_ANIMATE_ON_TOGGLE: ["SYM0", "SYM1"],
    constructor: function() {
        Game.Slots.WinningSymbolsModel.superclass.constructor.apply(this, arguments)
    },
    processServerResponse: function(h) {
        var i = this,
            e = h.reelInfo,
            d, c, a = [],
            g, b, j = [],
            f;
        if (h.wins && Sys.isArray(h.wins.winSituations)) {
            Sys.each(h.wins.winSituations, function(k) {
                g = [];
                Sys.each(k.positions, function(l) {
                    d = l.reelIndex;
                    c = l.symbolIndex;
                    if (e[d].overlaySymbols[c]) {
                        f = e[d].overlaySymbols[c]
                    } else {
                        f = e[d].symbols[c]
                    }
                    b = {
                        x: d,
                        y: c,
                        symbol: f
                    };
                    j.push(b);
                    if (i.SYMBOLS_TO_ANIMATE_ON_TOGGLE.contains(f)) {
                        g.push(b)
                    }
                });
                a.push(g)
            })
        }
        i.storeData("winningSymbols", j);
        i.storeData("winSituationSymbols", a)
    }
};
Game.Slots.WinningSymbolsModel = Sys.extend(Core.Model, Game.Slots.WinningSymbolsModel, "Game.Slots.WinningSymbolsModel");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsView = {
    constructor: function() {
        Game.Slots.WinningSymbolsView.superclass.constructor.apply(this, arguments)
    },
    ALL_WINNING_SYMBOLS_ANIMATION_TIME: 1000,
    WIN_SITUATION_ANIMATION_TIMES: {
        SYM0: 1000,
        SYM1: 1000
    },
    configureItemForAllWinningSymbolsDisplay: function(d, a, f) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.ALL_WINNING_SYMBOLS_ANIMATION_TIME;
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function(h, i, g, k) {
                var j = k.prop;
                h.fillStyle = "#ffffff";
                h.fillRect(j.pivot.x, j.pivot.y, j.width, j.height)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: e / 2,
                    value: 1
                }, {
                    time: e,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: b
                    }
                }]
            }
        });
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.restore()
    },
    configureItemForWinSituationToggling: function(d, a, f) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.WIN_SITUATION_ANIMATION_TIMES[a.symbol];
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function(g) {
                g.fillStyle = "#fdfd00";
                g.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: e / 2,
                    value: 1
                }, {
                    time: e,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: b
                    }
                }]
            }
        });
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.restore()
    },
    initAnimations: function() {
        var c = this,
            d = Game.stage.model.getCurrentReelGroupConfiguration(),
            a = d.symbolCols,
            b = d.symbolRows;
        c.animationItems = Sys.utils.init2dMatrix(a, b);
        c.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.animationList);
        c.animationList.stop()
    },
    animateAllWinningSymbols: function(a) {
        this.animateSymbols(this.model.readData("winningSymbols"), this.configureItemForAllWinningSymbolsDisplay, a)
    },
    animateWinSituationSymbols: function(a, b) {
        this.animateSymbols(a, this.configureItemForWinSituationToggling, b)
    },
    animateSymbols: function(b, c, g) {
        var e = this,
            a, f, d;
        e.animationList.restore();
        e.animationList.stop();
        Sys.each(b, function(h) {
            a = h.x;
            f = h.y;
            if (Sys.isDefined(e.animationItems[a][f])) {
                d = e.animationItems[a][f]
            } else {
                d = new Animation.CanvasAnimationItem({});
                e.animationList.add(d);
                e.animationItems[a][f] = d
            }
            c.call(e, d, h, g);
            d.play()
        })
    },
    stop: function() {
        this.animationList.stop();
        this.fireEvent("view:animationComplete")
    },
    refresh: function() {
        var b = this,
            a = this.model.readData("winningSymbols");
        Sys.each(a, function(f) {
            var c = f.x,
                g = f.y,
                e = Game.stage.model.getSymbolConfiguration(c, g),
                d = b.animationItems[c][g];
            if (Animation.utils.isAnimationItem(d)) {
                d.prop.top = e.top;
                d.prop.left = e.left;
                d.prop.width = e.width;
                d.prop.height = e.height
            }
        })
    }
};
Game.Slots.WinningSymbolsView = Sys.extend(Core.View, Game.Slots.WinningSymbolsView, "Game.Slots.WinningSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsController = {
    constructor: function() {
        Game.Slots.WinningSymbolsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:responseParser.responseParsed": this.model.processServerResponse.bind(this.model),
            "notify:winSituationsDisplay.showingAllWins": this.animateAllWinningSymbols,
            "notify:winSituationsDisplay.togglingWinSituation": this.animateWinSituationSymbols,
            "notify:winSituationsDisplay.abort": this.abort,
            "view:animationComplete": this.onAnimationComplete,
            "view:hideSymbol": this.hideSymbol,
            "view:showSymbol": this.showSymbol,
            "view:playSound": this.playSound,
            "view:stopSound": this.stopSound,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    },
    playSound: function(a) {
        this.fireEvent("request:audioPlayer.play", a)
    },
    stopSound: function(a) {
        this.fireEvent("request:audioPlayer.stop", a)
    },
    animateWinSituationSymbols: function(b, d) {
        var c = this,
            a = c.model.readData("winSituationSymbols")[b];
        if (Sys.isArray(a) && a.length > 0) {
            c.model.setState("animating");
            c.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
            c.view.animateWinSituationSymbols(a, d)
        }
    },
    animateAllWinningSymbols: function(b) {
        var a = this;
        if (a.model.readData("winningSymbols").length > 0) {
            a.model.setState("animating");
            a.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
            a.view.animateAllWinningSymbols(b)
        }
    },
    abort: function() {
        if (this.model.isState("animating")) {
            this.view.stop()
        }
    },
    onAnimationComplete: function() {
        this.model.setState("idle");
        this.fireEvent("notify:winningSymbols.animationComplete")
    },
    hideSymbol: function(a) {
        this.fireEvent("request:spin.hideSymbols", a)
    },
    showSymbol: function(a) {
        this.fireEvent("request:spin.showSymbols", a)
    }
};
Game.Slots.WinningSymbolsController = Sys.extend(Core.Controller, Game.Slots.WinningSymbolsController, "Game.Slots.WinningSymbolsController");
Sys.ns("Interface.utils");
Interface.utils.CSSAnimation = {
    constructor: function(a) {
        Interface.utils.CSSAnimation.superclass.constructor.apply(this, arguments);
        this.init(a)
    },
    run: function(a, c) {
        var b = this;
        if (Sys.isDefined(c)) {
            b.setupEvent(a, "AnimationEnd", c)
        }
        a.style[b.animationType] = b.name + " " + b.duration + "ms " + b.delay + "ms";
        if (Sys.isDefined(b.timingFunction)) {
            a.style[b.animationType + "TimingFunction"] = b.timingFunction
        }
        if (Sys.isDefined(b.iterationCount)) {
            a.style[b.animationType + "IterationCount"] = b.iterationCount
        }
        if (Sys.isDefined(b.fillMode.mode)) {
            a.style[b.fillMode.type] = b.fillMode.mode
        }
    },
    removeAnimation: function(a) {
        a.style[this.animationType] = "none"
    },
    init: function(a) {
        var b = this;
        b.name = a.name;
        b.duration = a.duration;
        b.delay = Sys.isDefined(a.delay) ? a.delay : 0;
        b.timingFunction = a.timingFunction;
        b.iterationCount = a.iterationCount;
        b.fillMode = {
            type: Sys.utils.getPrefixedCSSProperty("animationFillMode"),
            mode: a.fillMode
        };
        b.setupAnimation(a);
        b.animationType = Sys.utils.getPrefixedCSSProperty("animation");
        b.prefixes = ["webkit", "moz", "MS", "o", ""]
    },
    setupAnimation: function(a) {
        var c = this,
            b = this.getRuleString(a);
        c.style = document.head.appendChild(document.createElement("style"));
        c.insertRule(b)
    },
    insertRule: function(a) {
        if (CSSRule.WEBKIT_KEYFRAMES_RULE) {
            this.style.sheet.insertRule("@-webkit-keyframes" + a, 0)
        } else {
            if (CSSRule.KEYFRAMES_RULE) {
                this.style.sheet.insertRule("@keyframes" + a, 0)
            }
        }
    },
    removeRule: function(a) {
        this.style.sheet.deleteRule(a)
    },
    getRuleString: function(a) {
        var g = Object.keys(a.frames),
            b = g.length,
            d = 0,
            f = " " + a.name + " {",
            k, l, h, e, c;
        while (d < b) {
            k = g[d];
            f += " " + k;
            l = Object.keys(a.frames[k]);
            e = l.length;
            c = 0;
            f += " {";
            while (c < e) {
                h = l[c];
                f += h + " : " + a.frames[k][h] + ";";
                ++c
            }
            f += " }";
            ++d
        }
        f += " }";
        return f
    },
    setupEvent: function(c, d, g) {
        var e = this,
            f = e.prefixes,
            b, a;
        for (b = -1, a = f.length; ++b < a;) {
            if (!f[b]) {
                d = d.toLowerCase()
            }
            c.addEventListener(f[b] + d, g, false)
        }
    },
    removeEvent: function(c, d, g) {
        var e = this,
            f = e.prefixes,
            b, a;
        for (b = -1, a = f.length; ++b < a;) {
            if (!f[b]) {
                d = d.toLowerCase()
            }
            c.removeEventListener(f[b] + d, g, false)
        }
    }
};
Interface.utils.CSSAnimation = Sys.extend(Sys.Observable, Interface.utils.CSSAnimation, "Interface.utils.CSSAnimation");
Sys.ns("Interface.utils");
Interface.utils.CardNavigation = {
    CSS: {
        ARROWS: "interface-cardNavigation_arrows clearfix trim",
        ARROWS_PREVIOUS: "interface-cardNavigation_arrows_previous",
        ARROWS_CLOSE: "interface-cardNavigation_arrows_close",
        ARROWS_NEXT: "interface-cardNavigation_arrows_next",
        INDICATORS: "interface-cardNavigation_indicators clearfix utils_horizontal_center trim",
        INDICATORS_CHILD: "interface-cardNavigation_indicator",
        INDICATORS_SELECTED: "interface-cardNavigation_selectedIndicator",
        DISABLED: "interface-cardNavigation_disabled"
    },
    constructor: function(a) {
        this.currentCard = 0;
        Interface.utils.CardNavigation.superclass.constructor.apply(this, arguments)
    },
    getArrows: function() {
        return this.arrowContainer
    },
    getIndicators: function() {
        return this.indicatorContainer
    },
    getContainer: function(a) {
        if (a === "arrows") {
            return this.getArrows()
        } else {
            if (a === "indicators") {
                return this.getIndicators()
            }
        }
        return undefined
    },
    getCurrentCardIndex: function() {
        return this.currentCard
    },
    next: function() {
        var c = this,
            a = c.currentCard + 1,
            b = false;
        if (a >= c.numCards) {
            a = 0;
            b = true
        }
        c.selectCard(a, false, b)
    },
    previous: function() {
        var c = this,
            a = c.currentCard - 1,
            b = false;
        if (a < 0) {
            a = c.numCards - 1;
            b = true
        }
        c.selectCard(a, false, b)
    },
    selectCard: function(b, e, a) {
        var d = this,
            c = d.indicatorChildren;
        if (b >= 0 && b < d.numCards) {
            c[d.currentCard].removeCls(d.CSS.INDICATORS_SELECTED);
            c[b].addCls(d.CSS.INDICATORS_SELECTED);
            if (e !== true) {
                d.selectionCallback(b, d.currentCard, a)
            }
            d.currentCard = b
        }
    },
    enable: function() {
        var a = this;
        a.enabled = true;
        a.arrowContainer.removeCls(a.CSS.DISABLED);
        a.indicatorContainer.removeCls(a.CSS.DISABLED);
        a.performActionOnSubComponent("enable")
    },
    disable: function() {
        var a = this;
        a.enabled = false;
        a.arrowContainer.removeCls(a.CSS.DISABLED);
        a.indicatorContainer.removeCls(a.CSS.DISABLED);
        a.performActionOnSubComponent("disable")
    },
    close: function() {
        if (this.hasCloseButton) {
            this.closeCallback()
        }
    },
    performActionOnSubComponent: function(d) {
        var c = this.subComponents,
            a = c.length,
            b;
        for (b = -1; ++b < a;) {
            c[b][d]()
        }
    },
    setupContainer: function(b) {
        var c = this,
            a = Sys.isDefined(b.selectedCard) ? b.selectedCard : 0;
        c.numCards = b.numCards;
        c.selectionCallback = b.selectionCallback;
        c.closeCallback = b.closeCallback;
        c.hasCloseButton = Sys.isDefined(b.closeCallback);
        c.subComponents = [];
        c.setupArrows(b.arrowLabels);
        c.setupIndicators();
        c.selectCard(a, true)
    },
    setupArrows: function(c) {
        var b = this,
            a = Sys.isObj(c);
        b.arrowContainer = new Sys.Element({
            id: b.id + "_arrows",
            tag: "ul",
            cls: b.CSS.ARROWS
        });
        b.previousArrow = new Interface.utils.DOMButton({
            id: "paytablePrevious",
            tag: "li",
            baseCSS: b.CSS.ARROWS_PREVIOUS,
            textContent: (a && Sys.isDefined(c.previous)) ? c.previous : "",
            clickCallback: b.previous.bind(b)
        });
        b.arrowContainer.add(b.previousArrow.getContainer());
        b.subComponents.push(b.previousArrow);
        if (b.hasCloseButton) {
            b.closeArrow = new Interface.utils.DOMButton({
                id: "paytableClose",
                tag: "li",
                baseCSS: b.CSS.ARROWS_CLOSE,
                textContent: (a && Sys.isDefined(c.close)) ? c.close : "",
                clickCallback: b.close.bind(b)
            });
            b.arrowContainer.add(b.closeArrow.getContainer());
            b.subComponents.push(b.closeArrow)
        }
        b.nextArrow = new Interface.utils.DOMButton({
            id: "paytableNext",
            tag: "li",
            baseCSS: b.CSS.ARROWS_NEXT,
            textContent: (a && Sys.isDefined(c.next)) ? c.next : "",
            clickCallback: b.next.bind(b)
        });
        b.arrowContainer.add(b.nextArrow.getContainer());
        b.subComponents.push(b.nextArrow)
    },
    setupIndicators: function() {
        var c = this,
            d = new Sys.Element({
                id: c.id + "indicators",
                tag: "ul",
                cls: c.CSS.INDICATORS
            }),
            b = [],
            e, a;
        for (a = -1; ++a < c.numCards;) {
            e = new Interface.utils.DOMButton({
                id: "paytableIndicator_" + a,
                tag: "li",
                baseCSS: c.CSS.INDICATORS_CHILD,
                clickCallback: c.selectCard.bind(c, a)
            });
            b.push(d.add(e.getContainer()));
            c.subComponents.push(e)
        }
        c.indicatorContainer = d;
        c.indicatorChildren = b
    }
};
Interface.utils.CardNavigation = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CardNavigation, "Interface.utils.CardNavigation");
Sys.ns("Interface.utils");
Interface.utils.GroupTitle = {
    CSS: {
        base: "interface-groupTitle_base",
        disabled: "interface-groupTitle_disabled",
        label: "interface-groupTitle_label"
    },
    constructor: function(a) {
        Interface.utils.GroupTitle.superclass.constructor.apply(this, arguments)
    },
    init: function(b) {
        var c = this,
            a = b.CSS;
        if (Sys.isDefined(a)) {
            c.CSS = Sys.applyIf(a, c.CSS)
        }
        c.title = b.title;
        Interface.utils.GroupTitle.superclass.init.apply(c, arguments)
    },
    setupContainer: function(a) {
        var b = this;
        b.container = new Sys.Element({
            id: b.id,
            tag: "div",
            cls: a.cls + " " + b.CSS.base
        });
        if (b.title) {
            b.label = b.container.add(new Sys.Element({
                id: b.id + "_title",
                tag: "div",
                cls: b.CSS.label,
                textContent: b.title
            }))
        }
    },
    setCSS: function(d) {
        var c = this,
            b = c.container,
            a = c.CSS;
        if (d.base) {
            b.replaceCSSClass(a.base, d.base)
        }
        if (!c.enabled && d.disabled) {
            b.replaceCSSClass(a.disabled, d.disabled)
        }
        if (d.label) {
            c.label.replaceCSSClass(a.label, d.label)
        }
        c.CSS = Sys.applyIf(d, a)
    }
};
Interface.utils.GroupTitle = Sys.extend(Interface.utils.UserInputBase, Interface.utils.GroupTitle, "Interface.utils.GroupTitle");
Sys.ns("Interface.utils");
Interface.utils.ToggleSwitch = {
    CSS: {
        base: "interface-toggleSwitch_base",
        disabled: "interface-toggleSwitch_disabled",
        label: "interface-toggleSwitch_label",
        button_wrapper: "interface-toggleSwitch_buttonWrapper",
        button_background: "interface-toggleSwitch_buttonBackground interface-toggleSwitch_buttonBackgroundSize",
        button_handle: "interface-toggleSwitch_buttonHandle interface-toggleSwitch_buttonHandleSize",
        loadAnimation: "interface-toggleSwitch_loadAnimation interface-smallSpinner_uri hidden"
    },
    constructor: function(a) {
        Interface.utils.ToggleSwitch.superclass.constructor.apply(this, arguments)
    },
    init: function(b) {
        var c = this,
            a = b.CSS || {};
        b.cls = typeof b.cls === "string" ? b.cls : "";
        if (Sys.isDefined(a)) {
            c.CSS = Sys.applyIf(a, c.CSS)
        }
        c.title = b.title;
        c.callback = b.callback;
        c.turnedOn = false;
        c.listensToInput = b.listensToInput !== false;
        Interface.utils.ToggleSwitch.superclass.init.apply(c, arguments)
    },
    setupContainer: function(a) {
        var b = this;
        b.container = new Sys.Element({
            id: b.id,
            tag: "div",
            cls: a.cls + " " + b.CSS.base + " off"
        });
        if (b.title) {
            b.label = b.container.add(new Sys.Element({
                id: b.id + "_title",
                tag: "div",
                cls: b.CSS.label,
                textContent: b.title
            }))
        }
        b.buttonWrapper = b.container.add(new Sys.Element({
            id: b.id + "_button_wrapper",
            tag: "div",
            cls: b.CSS.button_wrapper
        }));
        b.background = b.buttonWrapper.add(new Sys.Element({
            id: b.id + "_button_background",
            tag: "div",
            cls: b.CSS.button_background
        }));
        b.handle = b.background.add(new Sys.Element({
            id: b.id + "_button_handle",
            tag: "div",
            cls: b.CSS.button_handle
        }));
        b.loadAnimation = b.container.add(new Sys.Element({
            id: b.id + "_loadAnimation",
            tag: "div",
            cls: b.CSS.loadAnimation
        }))
    },
    setCSS: function(e) {
        var d = this,
            b = d.container,
            c = d.button,
            a = d.CSS;
        if (e.base) {
            b.replaceCSSClass(a.base, e.base)
        }
        if (!d.enabled && e.disabled) {
            b.replaceCSSClass(a.disabled, e.disabled)
        }
        if (e.label) {
            d.label.replaceCSSClass(a.label, e.label)
        }
        if (e.button_wrapper) {
            c.replaceCSSClass(a.button_wrapper, e.button_wrapper)
        }
        if (e.button_background) {
            c.replaceCSSClass(a.button_background, e.button_background)
        }
        if (e.button_handle) {
            c.replaceCSSClass(a.button_handle, e.button_handle)
        }
        d.CSS = Sys.applyIf(e, a)
    },
    toggle: function(e, d) {
        var b = this,
            a = b.turnedOn,
            c = Sys.isDefined(e) ? e : !a;
        if (b.isLocked()) {
            return
        }
        if (c !== a) {
            if (c) {
                b.container.replaceCSSClass("off", "on")
            } else {
                b.container.replaceCSSClass("on", "off")
            }
            b.turnedOn = c;
            if (!d) {
                b.callback(c)
            }
        }
    },
    isOn: function() {
        return this.turnedOn
    },
    onUserInputStart: function(a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.buttonWrapper.el, a) && this.enabled
    },
    onUserInputEnd: function(c) {
        var b = this,
            a = Sys.UserInputUtils.isCoordinateTarget(b.buttonWrapper.el, c);
        if (a && b.wasInitialInputTarget) {
            b.toggle()
        }
        b.wasInitialInputTarget = false
    },
    startListeningToUserInput: function() {
        var a = this;
        if (!a.listensToInput) {
            return
        }
        a.on({
            "notify:userInputManager.userInputStarted": a.onUserInputStart,
            "notify:userInputManager.userInputEnded": a.onUserInputEnd
        })
    },
    stopListeningToUserInput: function() {
        if (!this.listensToInput) {
            return
        }
        this.removeListener("notify:userInputManager.userInputStarted");
        this.removeListener("notify:userInputManager.userInputEnded")
    },
    displayLoadAnimation: function() {
        this.loadAnimation.removeCls("hidden");
        this.buttonWrapper.addCls("hidden")
    },
    hideLoadAnimation: function() {
        this.loadAnimation.addCls("hidden");
        this.buttonWrapper.removeCls("hidden")
    },
    setValue: function(b, a) {
        this.toggle(b, a)
    }
};
Interface.utils.ToggleSwitch = Sys.extend(Interface.utils.UserInputBase, Interface.utils.ToggleSwitch, "Interface.utils.ToggleSwitch");
Sys.ns("Interface.utils");
Interface.utils.Slider = {
    CSS: {
        base: "interface-slider_base",
        disabled: "interface-slider_disabled",
        label: "interface-slider_label",
        sliderWrapper: "interface-slider_sliderWrapper",
        background: "interface-slider_background",
        handle: "utils_center interface-slider_handle",
        fill: "interface-slider_fill",
        display: "utils_center interface-slider_display",
        verticalLine: "utils_center interface-slider_verticalLine"
    },
    constructor: function() {
        Interface.utils.Slider.superclass.constructor.apply(this, arguments)
    },
    init: function(b) {
        var d = this,
            a, c;
        if (Sys.isArray(b.values)) {
            a = b.values
        } else {
            a = [];
            for (c = b.minValue; c <= b.maxValue; c = Animation.utils.toNthDecimalPlace(c + b.valueStep, 5)) {
                a.push(c)
            }
        }
        if (!Sys.isDefined(b.useStepIndicator)) {
            b.useStepIndicator = true
        }
        d.callback = b.callback;
        d.values = a;
        d.callbackOnlyOnEndEvent = (b.callbackOnlyOnEndEvent === true);
        d.endCallback = typeof b.endCallback === "function" ? b.endCallback : function() {};
        Interface.utils.Slider.superclass.init.apply(d, arguments);
        d.setStartValue(b);
        d.selectRenderFunction();
        d.transform = Sys.utils.getPrefixedCSSProperty("transform")
    },
    setStartValue: function(c) {
        var b = c.startValue,
            a = this.values,
            d = (Sys.isDefined(b) && a.indexOf(b) !== -1) ? b : a[0];
        this.setValue(d, true)
    },
    setupContainer: function(a) {
        var b = this,
            c;
        b.container = new Sys.Element({
            id: b.id,
            tag: "div",
            cls: b.CSS.base,
            "data-input": true
        });
        b.sliderWrapper = b.container.add(new Sys.Element({
            id: b.id + "Slider",
            tag: "div",
            cls: b.CSS.sliderWrapper
        }));
        b.background = b.sliderWrapper.add(new Sys.Element({
            id: b.id + "SliderBackground",
            tag: "div",
            cls: b.CSS.background
        }));
        b.fill = b.background.add(new Sys.Element({
            id: b.id + "Fill",
            tag: "div",
            cls: b.CSS.fill
        }));
        if (a.showLabels) {
            b.showLabels = true;
            c = b.values[0].toString();
            b.minimumLabel = b.container.addAsFirst(new Sys.Element({
                id: b.id + "Minimum",
                tag: "div",
                cls: b.CSS.label + " " + b.CSS.label + "_left",
                textContent: c
            }));
            c = b.values[b.values.length - 1].toString();
            b.maximumLabel = b.container.add(new Sys.Element({
                id: b.id + "Maximum",
                tag: "div",
                cls: b.CSS.label + " " + b.CSS.label + "_right",
                textContent: c
            }))
        }
        b.handle = b.sliderWrapper.add(new Sys.Element({
            id: b.id + "Handle",
            tag: "div",
            cls: b.CSS.handle
        }));
        if (a.showDisplay !== false) {
            b.display = b.sliderWrapper.add(new Sys.Element({
                id: b.id + "Display",
                tag: "div",
                cls: b.CSS.display
            }));
            b.showDisplay = true
        }
    },
    onUserInputStart: function(a) {
        var c = this,
            b = Sys.UserInputUtils.isCoordinateTarget(c.container.el, a) && c.enabled;
        c.startValue = c.value;
        if (b) {
            c.moveSliderToCoordinate(a, c.callbackOnlyOnEndEvent)
        }
        this.wasInitialInputTarget = b
    },
    onUserInputMove: function(a) {
        var b = this;
        if (this.wasInitialInputTarget) {
            if (!b.bigDisplayShowing) {
                if (b.showDisplay) {
                    b.display.addCls("interface-slider_bigDisplay")
                }
                b.bigDisplayShowing = true
            }
            this.animationFunction.call(window, function() {
                b.moveSliderToCoordinate(a, b.callbackOnlyOnEndEvent)
            })
        }
    },
    onUserInputEnd: function() {
        var b = this,
            a;
        if (b.wasInitialInputTarget) {
            b.animationFunction(function() {
                a = b.calculatePercentageFromValue(b.value);
                b.moveSlider(a, false, true);
                if (b.showDisplay) {
                    b.display.removeCls("interface-slider_bigDisplay")
                }
                if (b.bigDisplayShowing) {
                    b.bigDisplayShowing = false
                }
            });
            b.endCallback(b.value)
        }
        b.wasInitialInputTarget = false
    },
    moveSliderToCoordinate: function(b, c) {
        var a = this.calculatePercentageFromCoordinate(b);
        this.moveSlider(a, c)
    },
    calculatePercentageFromCoordinate: function(c) {
        var a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).x,
            d = this.sliderWrapper.el.offsetWidth,
            b;
        if (a < 0) {
            b = 0
        } else {
            if (a > d) {
                b = 1
            } else {
                b = a / d
            }
        }
        return b
    },
    moveSlider: function(c, g, f) {
        var d = this,
            a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%",
            e = d.getValueFromPercentage(c),
            b = d.value;
        d.fill.el.style.width = a;
        d.handle.el.style.marginLeft = a;
        if (d.showDisplay) {
            d.display.el.style.marginLeft = a
        }
        if (e !== b || f) {
            d.setValue(e, g)
        }
    },
    getValueFromPercentage: function(a) {
        var b = this.values,
            c = Math.round(a * (b.length - 1));
        return b[c]
    },
    setValue: function(b, c) {
        var a = this;
        a.value = b;
        if (a.showDisplay) {
            a.display.el.textContent = b
        }
        if (!a.wasInitialInputTarget) {
            a.moveSlider(a.calculatePercentageFromValue(b), c)
        }
        if (!c) {
            a.callback(b)
        }
    },
    calculatePercentageFromValue: function(d) {
        var b = this.values,
            c = b.indexOf(d),
            a = 1 / (b.length - 1);
        return c * a
    },
    getValue: function() {
        return this.value
    },
    selectRenderFunction: function() {
        var a = this;
        a.animationFunction = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(b) {
            clearTimeout(a.renderTimeout);
            a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
        }).bind(window)
    }
};
Interface.utils.Slider = Sys.extend(Interface.utils.UserInputBase, Interface.utils.Slider, "Interface.utils.Slider");
Sys.ns("Interface.utils");
Interface.utils.VerticalSlider = {
    CSS: {
        base: "interface-verticalSlider_base",
        disabled: "interface-slider_disabled",
        label: "interface-slider_label",
        sliderWrapper: "interface-verticalSlider_sliderWrapper",
        background: "interface-verticalSlider_background interface-soundSettings_sliderBar_background_uri",
        handle: "interface-verticalSlider_handle interface-soundSettings_sliderHandle_uri",
        fill: "interface-verticalSlider_fill interface interface-soundSettings_sliderBar_fill_uri",
        display: "utils_center interface-verticalSlider_display",
        verticalLine: "utils_center interface-slider_verticalLine"
    },
    ASCENDING_GROWTH: false,
    constructor: function() {
        Interface.utils.VerticalSlider.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var c = this,
            b = (a.ascendingGrowth === true);
        c.ASCENDING_GROWTH = b;
        Interface.utils.VerticalSlider.superclass.init.apply(this, arguments);
        if (b) {
            c.fill.el.style.top = "auto";
            c.fill.el.style.bottom = 0
        }
    },
    calculatePercentageFromCoordinate: function(c) {
        var d = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).y,
            a = this.sliderWrapper.el.offsetHeight,
            b;
        if (d < 0) {
            b = 0
        } else {
            if (d > a) {
                b = 1
            } else {
                b = d / a
            }
        }
        if (this.ASCENDING_GROWTH) {
            b = 1 - b
        }
        return b
    },
    moveSlider: function(c, g, f) {
        var d = this,
            a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%",
            e = d.getValueFromPercentage(c),
            b = d.value;
        d.fill.el.style.height = a;
        a = Animation.utils.toNthDecimalPlace(((d.ASCENDING_GROWTH ? 1 - c : c) * 100), 2) + "%";
        d.handle.el.style.top = a;
        if (e !== b || f) {
            d.setValue(e, g)
        }
    }
};
Interface.utils.VerticalSlider = Sys.extend(Interface.utils.Slider, Interface.utils.VerticalSlider, "Interface.utils.VerticalSlider");
Sys.ns("Interface.utils");
Interface.utils.CanvasValueSelector = {
    FONT_LABEL: "10px Verdana",
    FILLSTYLE_LABEL: "rgba( 238, 239, 206, 1 )",
    POSITION_OFFSET_LABEL: {
        x: 0,
        y: -18
    },
    FONT_VALUE: "bold 12px Verdana",
    FILLSTYLE_VALUE: "rgba( 238, 239, 206, 1 )",
    POSITION_OFFSET_VALUE: {
        x: 0,
        y: 9
    },
    IMAGE_RIGHT_UP: "selectorPlusUp",
    IMAGE_RIGHT_OVER: "selectorPlusUp",
    IMAGE_RIGHT_CLICK: "selectorPlusUp",
    IMAGE_RIGHT_DISABLED: "selectorPlusDisabled",
    IMAGE_RIGHT_DOWN: "selectorPlusDown",
    IMAGE_RIGHT_HOVER: "selectorPlusOver",
    IMAGE_LEFT_UP: "selectorMinusUp",
    IMAGE_LEFT_OVER: "selectorMinusUp",
    IMAGE_LEFT_CLICK: "selectorMinusUp",
    IMAGE_LEFT_DISABLED: "selectorMinusDisabled",
    IMAGE_LEFT_DOWN: "selectorMinusDown",
    IMAGE_LEFT_HOVER: "selectorMinusOver",
    HANDLE_DIMENSIONS: {
        LEFT: {
            width: 44,
            height: 52
        },
        RIGHT: {
            width: 44,
            height: 52
        }
    },
    HANDLE_POSITION_OFFSET: {
        LEFT: {
            x: 0,
            y: 0
        },
        RIGHT: {
            x: 88,
            y: 0
        }
    },
    HANDLE_COLLISION_BOX: {
        LEFT: {
            xOffset: 0,
            yOffset: 0,
            width: 44,
            height: 52
        },
        RIGHT: {
            xOffset: 0,
            yOffset: 0,
            width: 44,
            height: 52
        }
    },
    BAR_BACKGROUND: "selectorBarBackground",
    BAR_BACKGROUND_DISABLED: "selectorBarBackgroundDisabled",
    BAR_FILL: "selectorBarFill",
    BAR_FILL_DISABLED: "selectorBarFillDisabled",
    BAR_DIMENSIONS: {
        background: {
            width: 57,
            height: 7
        },
        fill: {
            width: 53,
            height: 3
        }
    },
    BAR_POSITION_OFFSET: {
        background: {
            x: 37,
            y: 36
        },
        fill: {
            x: 39,
            y: 38
        }
    },
    SLIDER_BAR_INPUT_OFFSET: {
        start: {
            width: 0,
            height: 0
        },
        move: {
            width: 0,
            height: 0
        }
    },
    constructor: function() {
        Interface.utils.CanvasValueSelector.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var b = this;
        Interface.utils.CanvasValueSelector.superclass.init.call(b, a);
        b.currentIndex = 0;
        b.callback = a.callback;
        b.label = a.label;
        b.valueArray = a.values;
        b.valueNameArray = Sys.isDefined(a.valueNames) ? a.valueNames : b.valueArray;
        b.basePosition = {
            x: a.x,
            y: a.y
        };
        b.setupConfiguration(a);
        b.setupLayering(a);
        b.setupFontStyle(a);
        b.initAnimations();
        if (a.disabled === true) {
            b.disable("CanvasValueSelector")
        } else {
            b.enable("CanvasValueSelector")
        }
    },
    destroy: function() {
        this.disable("CanvasValueSelector");
        this.clearAnimationLists();
        this.destroyButtons()
    },
    destroyButtons: function() {
        this.buttons.LEFT.destroy();
        this.buttons.RIGHT.destroy();
        delete this.buttons
    },
    setupConfiguration: function(a) {
        var c = this,
            b = {
                position: {
                    offsetLabel: a.positionOffsetLabel || c.POSITION_OFFSET_LABEL,
                    offsetValue: a.positionOffsetValue || c.POSITION_OFFSET_VALUE
                },
                rightButton: a.rightButtonImage || {},
                leftButton: a.leftButtonImage || {},
                handle: {
                    positionOffset: a.handlePositionOffset || c.HANDLE_POSITION_OFFSET,
                    dimensions: a.handleDimensions || c.HANDLE_DIMENSIONS,
                    collisionBox: a.handleCollisionBox || c.HANDLE_COLLISION_BOX
                },
                bar: {
                    background: a.barBackground || c.BAR_BACKGROUND,
                    backgroundDisabled: a.barBackgroundDisabled || c.BAR_BACKGROUND_DISABLED,
                    fill: a.barFill || c.BAR_FILL,
                    fillDisabled: a.barFillDisabled || c.BAR_FILL_DISABLED,
                    dimensions: a.barDimensions || c.BAR_DIMENSIONS,
                    positionOffset: a.barPositionOffset || c.BAR_POSITION_OFFSET
                }
            };
        c.setupPositionConfig(b.position);
        c.setupRightButtonConfig(b.rightButton);
        c.setupLeftButtonConfig(b.leftButton);
        c.setupHandleConfig(b.handle);
        c.setupBarConfig(b.bar)
    },
    setupPositionConfig: function(a) {
        var b = this;
        b.POSITION_OFFSET_LABEL = a.offsetLabel || b.POSITION_OFFSET_LABEL;
        b.POSITION_OFFSET_VALUE = a.offsetValue || b.POSITION_OFFSET_VALUE
    },
    setupRightButtonConfig: function(a) {
        var b = this;
        if (a && !Sys.isEmpty(a)) {
            b.IMAGE_RIGHT_UP = a.up || b.IMAGE_RIGHT_UP;
            b.IMAGE_RIGHT_DOWN = a.down || b.IMAGE_RIGHT_DOWN;
            b.IMAGE_RIGHT_HOVER = a.hover || b.IMAGE_RIGHT_HOVER;
            b.IMAGE_RIGHT_DISABLED = a.disabled || b.IMAGE_RIGHT_DISABLED
        }
    },
    setupLeftButtonConfig: function(a) {
        var b = this;
        if (a && !Sys.isEmpty(a)) {
            b.IMAGE_LEFT_UP = a.up || b.IMAGE_LEFT_UP;
            b.IMAGE_LEFT_DOWN = a.down || b.IMAGE_LEFT_DOWN;
            b.IMAGE_LEFT_HOVER = a.hover || b.IMAGE_LEFT_HOVER;
            b.IMAGE_LEFT_DISABLED = a.disabled || b.IMAGE_LEFT_DISABLED
        }
    },
    setupHandleConfig: function(a) {
        var b = this;
        b.HANDLE_POSITION_OFFSET = a.positionOffset || b.HANDLE_POSITION_OFFSET;
        b.HANDLE_DIMENSIONS = a.dimensions || b.HANDLE_DIMENSIONS;
        b.HANDLE_COLLISION_BOX = a.collisionBox || b.HANDLE_COLLISION_BOX
    },
    setupBarConfig: function(a) {
        var b = this;
        b.BAR_BACKGROUND = a.background || b.BAR_BACKGROUND;
        b.BAR_BACKGROUND_DISABLED = a.backgroundDisabled || b.BAR_BACKGROUND_DISABLED;
        b.BAR_FILL = a.fill || b.BAR_FILL;
        b.BAR_FILL_DISABLED = a.fillDisabled || b.BAR_FILL_DISABLED;
        b.BAR_DIMENSIONS = a.dimensions || b.BAR_DIMENSIONS;
        b.BAR_POSITION_OFFSET = a.positionOffset || b.BAR_POSITION_OFFSET
    },
    setupLayering: function(a) {
        var b = a.depth;
        this.layeringConfig = {
            background: b,
            barBackground: b + 1,
            value: b + 2,
            barFrame: b + 3,
            barFill: b + 4,
            buttons: b + 4,
            label: b + 4
        }
    },
    setupFontStyle: function(a) {
        var b = this;
        b.FILLSTYLE_LABEL = a.fillstyleLabel || b.FILLSTYLE_LABEL;
        b.FILLSTYLE_VALUE = a.fillstyleValue || b.FILLSTYLE_VALUE;
        b.FONT_LABEL = a.fontLabel || b.FONT_LABEL;
        b.FONT_VALUE = a.fontValue || b.FONT_VALUE
    },
    initAnimations: function() {
        var a = this;
        a.initAnimationLists();
        a.initCanvasButtons(a.HANDLE_POSITION_OFFSET, a.HANDLE_DIMENSIONS, a.HANDLE_COLLISION_BOX);
        a.initBar();
        a.initValueItem();
        a.initLabelItem()
    },
    initAnimationLists: function() {
        var e = ["VALUE", "BAR", "LABEL"],
            b = {},
            c, a, d;
        for (c = -1, a = e.length; ++c < a;) {
            d = new Animation.List({});
            b[e[c]] = d;
            Game.stage.view.addToRenderLoop(d)
        }
        this.animationLists = b
    },
    clearAnimationLists: function() {
        Sys.iterate(this.animationLists, function(a, b) {
            Game.stage.view.removeFromRenderLoop(b)
        })
    },
    initCanvasButtons: function(a, c, b) {
        var d = this;
        d.buttons = {
            LEFT: d.createCanvasButton(a.LEFT, c.LEFT, b.LEFT, "LEFT"),
            RIGHT: d.createCanvasButton(a.RIGHT, c.RIGHT, b.RIGHT, "RIGHT")
        }
    },
    initBar: function() {
        var a = this;
        a.bar = new Interface.utils.CanvasStepSlider({
            images: {
                background: {
                    enabled: a.BAR_BACKGROUND,
                    disabled: a.BAR_BACKGROUND_DISABLED
                },
                fill: {
                    enabled: a.BAR_FILL,
                    disabled: a.BAR_FILL_DISABLED
                }
            },
            dimensions: {
                background: {
                    x: a.basePosition.x + a.BAR_POSITION_OFFSET.background.x,
                    y: a.basePosition.y + a.BAR_POSITION_OFFSET.background.y,
                    width: a.BAR_DIMENSIONS.background.width,
                    height: a.BAR_DIMENSIONS.background.height
                },
                fill: {
                    x: a.basePosition.x + a.BAR_POSITION_OFFSET.fill.x,
                    y: a.basePosition.y + a.BAR_POSITION_OFFSET.fill.y,
                    width: a.BAR_DIMENSIONS.fill.width,
                    height: a.BAR_DIMENSIONS.fill.height
                }
            },
            depth: {
                background: a.layeringConfig.barBackground,
                fill: a.layeringConfig.barFill
            },
            sliderInputOffsets: a.SLIDER_BAR_INPUT_OFFSET,
            values: a.valueArray,
            callback: a.onBarChanged.bind(a)
        });
        a.animationLists.BAR.add(a.bar.getContainer());
        a.updateBar()
    },
    initValueItem: function() {
        var a = this,
            b = Animation.utils.text.createText(0, a.FONT_VALUE, 0, [{
                fillStyle: a.FILLSTYLE_VALUE,
                drawType: "fill"
            }]);
        a.valueItem = new Animation.Item({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: a.layeringConfig.value,
            image: b,
            customProps: {
                ctx: b.getContext("2d")
            }
        });
        a.animationLists.VALUE.add(a.valueItem);
        a.updateValueItem(a.valueArray[a.currentIndex])
    },
    initLabelItem: function() {
        var a = this,
            f = Animation.utils.text.createText(a.label, a.FONT_LABEL, 0, [{
                fillStyle: a.FILLSTYLE_LABEL,
                drawType: "fill"
            }]),
            e = a.HANDLE_DIMENSIONS.RIGHT.width + a.HANDLE_POSITION_OFFSET.RIGHT.x,
            d = a.POSITION_OFFSET_LABEL,
            c = ((a.basePosition.x + (e / 2)) - (f.width / 2)) + d.x,
            b = a.basePosition.y + d.y;
        a.labelItem = new Animation.Item({
            top: b,
            left: c,
            width: f.width,
            height: f.height,
            depth: a.layeringConfig.label,
            image: f
        });
        a.animationLists.LABEL.add(a.labelItem)
    },
    createCanvasButton: function(a, d, b, c) {
        var e = this;
        return new Interface.utils.CanvasButton({
            buttonLayoutParameters: {
                x: e.basePosition.x + a.x,
                y: e.basePosition.y + a.y,
                width: d.width,
                height: d.height,
                depth: e.layeringConfig.buttons
            },
            dimensions: {
                x: e.basePosition.x + a.x + b.xOffset,
                y: e.basePosition.y + a.y + b.yOffset,
                width: b.width,
                height: b.height
            },
            buttonImages: {
                up: e["IMAGE_" + c + "_UP"],
                down: e["IMAGE_" + c + "_DOWN"],
                hover: e["IMAGE_" + c + "_HOVER"],
                disabled: e["IMAGE_" + c + "_DISABLED"]
            },
            clickCallback: e.click.bind(e, c)
        })
    },
    click: function(a) {
        var b = this,
            c = b.getValue(a);
        if (this.enabled) {
            b.updateValueItem(c);
            b.callback(c)
        }
    },
    getValue: function(a) {
        var b = this;
        b.currentIndex = (a === "LEFT") ? b.currentIndex -= 1 : b.currentIndex += 1;
        if (b.currentIndex < 0) {
            b.currentIndex = 0
        } else {
            if (b.currentIndex > b.valueArray.length - 1) {
                b.currentIndex = b.valueArray.length - 1
            }
        }
        return b.valueArray[b.currentIndex]
    },
    updateValueItem: function(e) {
        var b = this,
            h = b.valueItem.prop,
            a = h.customProps.ctx,
            d = b.valueNameArray[b.valueArray.indexOf(e)],
            c = Animation.utils.text.measureText(d, b.FONT_VALUE, 0, a),
            g = b.HANDLE_DIMENSIONS.RIGHT.width + b.HANDLE_POSITION_OFFSET.RIGHT.x,
            f = b.POSITION_OFFSET_VALUE;
        h.image.width = c.width;
        h.image.height = c.height;
        h.width = c.width;
        h.height = c.height;
        h.top = b.basePosition.y + f.y;
        h.left = ((b.basePosition.x + (g / 2)) - (h.image.width / 2)) + f.x;
        a.clearRect(0, 0, h.width, h.height);
        Animation.utils.text.performOperations(d, b.FONT_VALUE, 0, c.height / 2, [{
            fillStyle: b.FILLSTYLE_VALUE,
            drawType: "fill"
        }], a)
    },
    updateBar: function() {
        var a = this;
        a.bar.setValue(a.valueArray[a.currentIndex], true)
    },
    onBarChanged: function(a) {
        this.update(a);
        this.callback(a)
    },
    enable: function(b) {
        var a = this;
        a.enabled = true;
        if (Sys.isDefined(this.animationLists) && Sys.isDefined(a.buttons)) {
            a.enableLeftButton(b);
            a.enableRightButton(b);
            a.bar.enable(b)
        }
    },
    disable: function(b) {
        var a = this;
        if (Sys.isDefined(a.animationLists) && Sys.isDefined(a.buttons)) {
            a.bar.disable(b);
            a.disableLeftButton(b);
            a.disableRightButton(b);
            a.enabled = false
        }
    },
    enableLeftButton: function(b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.LEFT.enable(b)
        }
    },
    disableLeftButton: function(b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.LEFT.disable(b)
        }
    },
    enableRightButton: function(b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.RIGHT.enable(b)
        }
    },
    disableRightButton: function(b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.RIGHT.disable(b)
        }
    },
    hide: function(b) {
        var a = this;
        Sys.iterate(a.animationLists, function(c, d) {
            d.stop()
        });
        a.buttons.LEFT.hide(b);
        a.buttons.RIGHT.hide(b)
    },
    show: function(b) {
        var a = this;
        Sys.iterate(a.animationLists, function(c, d) {
            d.play()
        });
        a.buttons.LEFT.show(b);
        a.buttons.RIGHT.show(b)
    },
    update: function(e) {
        var c = this,
            b = this.valueArray,
            a = b.indexOf(e),
            d = "CanvasValueSelector";
        if (a === 0) {
            c.disableLeftButton(d);
            c.enableRightButton(d)
        } else {
            if (a === b.length - 1) {
                c.disableRightButton(d);
                c.enableLeftButton(d)
            } else {
                c.enableLeftButton(d);
                c.enableRightButton(d)
            }
        }
        if (Sys.isDefined(b[a])) {
            c.currentIndex = a;
            c.updateValueItem(b[a]);
            c.updateBar()
        }
    }
};
Interface.utils.CanvasValueSelector = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CanvasValueSelector, "Interface.utils.CanvasValueSelector");
Sys.ns("Interface");
Interface.AbstractButton = {
    STATES: ["UP", "DOWN", "HOVER", "CLICK"],
    SOUND_UP: "buttonUp",
    SOUND_DOWN: "buttonDown",
    SOUND_CLICK: "buttonClick",
    SOUND_HOVER: "buttonHover",
    ID: "button",
    DEFAULT_USER_INPUT_EVENTS: {
        started: "notify:userInputManager.userInputStarted",
        ended: "notify:userInputManager.userInputEnded",
        move: "notify:userInputManager.userInputMove",
        hover: "notify:userInputManager.userInputHover"
    },
    constructor: function(a) {
        Interface.AbstractButton.superclass.constructor.apply(this, arguments);
        this.init(a)
    },
    enable: function(a) {
        this.removeProperty("disabled", a);
        this.tryStartListeningToUserInput()
    },
    disable: function(a) {
        this.addProperty("disabled", a);
        this.stopListeningToUserInput()
    },
    isEnabled: function() {
        return !this.hasProperty("disabled")
    },
    show: function(a) {
        this.removeProperty("hidden", a);
        this.tryStartListeningToUserInput()
    },
    hide: function(a) {
        this.addProperty("hidden", a);
        this.stopListeningToUserInput()
    },
    isHidden: function() {
        return !this.hasProperty("hidden")
    },
    init: function(a) {
        var b = this;
        b.dimensions = a.dimensions;
        b.properties = {};
        if (Sys.isDefined(a.id)) {
            b.ID = a.id
        }
        if (Sys.isDefined(a.upCallback)) {
            b.upCallback = a.upCallback
        } else {
            b.upCallback = function() {}
        }
        if (Sys.isDefined(a.downCallback)) {
            b.downCallback = a.downCallback
        } else {
            b.downCallback = function() {}
        }
        if (Sys.isDefined(a.overCallback)) {
            b.overCallback = a.overCallback
        } else {
            b.overCallback = function() {}
        }
        if (Sys.isDefined(a.clickCallback)) {
            b.clickCallback = a.clickCallback
        } else {
            b.clickCallback = function() {}
        }
        if (Sys.isDefined(a.hoverCallback)) {
            b.hoverCallback = a.hoverCallback
        } else {
            b.hoverCallback = function() {}
        }
        b.userInputEvents = b.DEFAULT_USER_INPUT_EVENTS;
        if (Sys.isDefined(a.exclusiveUserInput)) {
            b.userInputEvents = {
                started: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveStart",
                ended: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveEnd",
                move: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveMove",
                hover: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveKeyUp"
            }
        }
        if (Sys.isDefined(a.userInputEvents)) {
            Sys.iterate(a.userInputEvents, function(c, d) {
                b.userInputEvents[c] = d
            })
        }
        b.startListeningToUserInput();
        b.state = "up";
        if (Sys.isDefined(a.sounds)) {
            b.setupSounds(a.sounds)
        }
        if (Sys.isDefined(Services.trigger)) {
            b.registerTriggers()
        }
    },
    setupSounds: function(b) {
        var e = this,
            c = e.STATES,
            d, a, f;
        for (d = -1, a = c.length; ++d < a;) {
            f = c[d].toLowerCase();
            if (Sys.isDefined(b[f])) {
                e["SOUND_" + e[c[d]]] = b.state
            }
        }
    },
    registerTriggers: function() {
        var a = this.ID;
        Services.trigger.registerTrigger("notify:" + a + ".up", this, "When the button returns to the up state.");
        Services.trigger.registerTrigger("notify:" + a + ".hover", this, "When the button is hovered.");
        Services.trigger.registerTrigger("notify:" + a + ".over", this, "When the button hovered but wasn't the initial input target.");
        Services.trigger.registerTrigger("notify:" + a + ".down", this, "When the button is pressed down.");
        Services.trigger.registerTrigger("notify:" + a + ".click", this, "When the button is clicked.")
    },
    up: function() {
        var a = this;
        if (a.state !== "up") {
            a.state = "up";
            a.upCallback();
            a.fireEvent("request:audioPlayer.play", {
                name: a.SOUND_UP
            });
            a.fireEvent("notify:" + a.ID + ".up")
        }
    },
    click: function() {
        var a = this;
        a.clickCallback();
        a.fireEvent("request:audioPlayer.play", {
            name: a.SOUND_CLICK
        });
        a.fireEvent("notify:" + a.ID + ".click")
    },
    over: function() {
        var a = this;
        if (a.state !== "over") {
            a.overCallback();
            a.state = "over";
            a.fireEvent("notify:" + a.ID + ".over")
        }
    },
    down: function() {
        var a = this;
        if (a.state !== "down") {
            a.downCallback();
            a.state = "down";
            a.fireEvent("request:audioPlayer.play", {
                name: a.SOUND_DOWN
            });
            a.fireEvent("notify:" + a.ID + ".down")
        }
    },
    hover: function(a) {
        var b = this;
        if (b.state !== "hover") {
            b.hoverCallback();
            b.state = "hover";
            if (!a) {
                b.fireEvent("request:audioPlayer.play", {
                    name: b.SOUND_HOVER
                })
            }
            b.fireEvent("notify:" + b.ID + ".hover", a)
        }
    },
    userInputStart: function(c) {
        var b = this,
            a = b.isInputTarget(c);
        if (a) {
            b.down()
        }
        b.active = a;
        b.wasInitialInputTarget = a
    },
    userInputHover: function(c) {
        var b = this,
            a = b.isInputTarget(c);
        if (a) {
            b.hover()
        } else {
            if (b.state !== "up") {
                b.up()
            }
        }
    },
    userInputEnd: function(b) {
        var a = this;
        if (a.isInputTarget(b) && a.wasInitialInputTarget) {
            a.wasInitialInputTarget = false;
            if (!(Utils.Platform.isTouchSupported() && Platform.isDesktopDevice)) {
                a.hover(true)
            } else {
                a.up()
            }
            a.click()
        } else {
            if (a.active) {
                a.up()
            }
        }
    },
    userInputMove: function(c) {
        var b = this,
            a = b.isInputTarget(c);
        if (a) {
            if (b.wasInitialInputTarget) {
                b.down()
            } else {
                b.over()
            }
            b.active = true
        } else {
            if (b.wasInitialInputTarget || b.active) {
                b.up()
            }
        }
    },
    tryStartListeningToUserInput: function() {
        if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
            this.startListeningToUserInput()
        }
    },
    startListeningToUserInput: function() {
        var a = this;
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.addListener(a.userInputEvents.started, a.userInputStart)
        }
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.addListener(a.userInputEvents.ended, a.userInputEnd)
        }
        if (Sys.isDefined(a.userInputEvents.move)) {
            a.addListener(a.userInputEvents.move, a.userInputMove)
        }
        if (Sys.isDefined(a.userInputEvents.hover)) {
            a.addListener(a.userInputEvents.hover, a.userInputHover)
        }
    },
    stopListeningToUserInput: function() {
        var a = this;
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.removeListener(a.userInputEvents.started)
        }
        if (Sys.isDefined(a.userInputEvents.ended)) {
            a.removeListener(a.userInputEvents.ended)
        }
        if (Sys.isDefined(a.userInputEvents.move)) {
            a.removeListener(a.userInputEvents.move)
        }
        if (Sys.isDefined(a.userInputEvents.hover)) {
            a.removeListener(a.userInputEvents.hover)
        }
    },
    isInputTarget: function(c) {
        var a = this,
            b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
        return a.isDOMElement(a.dimensions) ? Sys.UserInputUtils.isCoordinateTarget(a.dimensions, c) : Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions)
    },
    isDOMElement: function(a) {
        return a.nodeType === 1
    },
    hasProperty: function(b) {
        var a = this.properties[b];
        return Sys.isDefined(a) && a.length > 0
    },
    addProperty: function(d, c) {
        var b = this.properties,
            a = false;
        if (!Sys.isDefined(b[d])) {
            b[d] = [c];
            a = true
        } else {
            if (!b[d].contains(c)) {
                a = b[d].length === 0;
                b[d].push(c)
            }
        }
        if (a) {
            this.update()
        }
    },
    removeProperty: function(c, b) {
        var a = this.properties[c];
        if (Sys.isDefined(a) && a.contains(b)) {
            a.splice(a.indexOf(b), 1);
            if (a.length === 0) {
                this.update()
            }
        }
    },
    update: function() {}
};
Interface.AbstractButton = Sys.extend(Sys.Observable, Interface.AbstractButton, "Interface.AbstractButton");
Sys.ns("Interface.utils");
Interface.utils.AbstractUserInputBase = {
    constructor: function(a) {
        Interface.utils.AbstractUserInputBase.superclass.constructor.apply(this, arguments);
        this.init(a)
    },
    enable: function() {
        this.enabled = true;
        this.startListeningToUserInput()
    },
    disable: function() {
        this.enabled = false;
        this.stopListeningToUserInput()
    },
    isEnabled: function() {
        return this.enabled
    },
    init: function(a) {
        var b = this;
        b.id = a.id;
        b.listensToInput = a.listensToInput !== false;
        if (a.enabled) {
            b.enable()
        } else {
            b.disable()
        }
    },
    onUserInputStart: function() {},
    onUserInputEnd: function() {},
    startListeningToUserInput: function() {
        if (!this.listensToInput) {
            return
        }
        this.on({
            "notify:userInputManager.userInputStarted": this.onUserInputStart,
            "notify:userInputManager.userInputEnded": this.onUserInputEnd
        })
    },
    stopListeningToUserInput: function() {
        if (!this.listensToInput) {
            return
        }
        this.removeListener("notify:userInputManager.userInputStarted");
        this.removeListener("notify:userInputManager.userInputEnded")
    }
};
Interface.utils.AbstractUserInputBase = Sys.extend(Sys.Observable, Interface.utils.AbstractUserInputBase, "Interface.utils.AbstractUserInputBase");
Sys.ns("Interface.utils");
Interface.utils.AbstractSlider = {
    constructor: function(a) {
        var b = this;
        Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.wasInitialInputTarget = false;
        b.properties = {};
        b.setUpContent(a)
    },
    setUpContent: function() {},
    enable: function(a) {
        this.removeProperty("disabled", a);
        this.tryStartListeningToUserInput()
    },
    disable: function(a) {
        this.addProperty("disabled", a);
        this.stopListeningToUserInput()
    },
    tryStartListeningToUserInput: function() {
        if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
            this.startListeningToUserInput()
        }
    },
    startListeningToUserInput: function() {
        var a = this;
        a.on({
            "notify:userInputManager.userInputStarted": a.userInputStart,
            "notify:userInputManager.userInputEnded": a.userInputEnd,
            "notify:userInputManager.userInputMove": a.userInputMove
        })
    },
    stopListeningToUserInput: function() {
        var a = this;
        a.removeListener("notify:userInputManager.userInputStarted");
        a.removeListener("notify:userInputManager.userInputEnded");
        a.removeListener("notify:userInputManager.userInputMove")
    },
    hasProperty: function(b) {
        var a = this.properties[b];
        return Sys.isDefined(a) && a.length > 0
    },
    addProperty: function(d, c) {
        var b = this.properties,
            a = false;
        if (!Sys.isDefined(b[d])) {
            b[d] = [c];
            a = true
        } else {
            if (!b[d].contains(c)) {
                a = b[d].length === 0;
                b[d].push(c)
            }
        }
        if (a) {
            this.update()
        }
    },
    removeProperty: function(c, b) {
        var a = this.properties[c];
        if (Sys.isDefined(a) && a.contains(b)) {
            a.splice(a.indexOf(b), 1);
            if (a.length === 0) {
                this.update()
            }
        }
    },
    userInputMove: function(b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            a.movedTo(b)
        }
    },
    userInputEnd: function(b) {
        var a = this;
        if (a.wasInitialInputTarget && a.isInputTarget(b)) {
            a.clickedAt(b)
        }
    },
    userInputStart: function(b) {
        var a = this;
        a.wasInitialInputTarget = a.isInputTarget(b)
    },
    update: function() {},
    setValue: function() {},
    clickedAt: function() {},
    movedTo: function() {},
    isInputTarget: function() {}
};
Interface.utils.AbstractSlider = Sys.extend(Sys.Observable, Interface.utils.AbstractSlider, "Interface.utils.AbstractSlider");
Sys.ns("Interface.utils");
Interface.utils.AbstractOptionScroller = {
    constructor: function() {
        Interface.utils.AbstractOptionScroller.superclass.constructor.apply(this, arguments)
    },
    onUserInputStart: function(a) {
        this.initialInputTarget = this.getInputTarget(a)
    },
    onUserInputEnd: function(d) {
        var b = this,
            a = b.getInputTarget(d),
            c = b.initialInputTarget;
        if (Sys.isDefined(c) && a === c) {
            b.scroll(a)
        } else {
            if (Sys.isObj(a) && Sys.isObj(c) && a.value === c.value) {
                b.callback(a)
            } else {
                b.initialInputTarget = undefined
            }
        }
    },
    init: function(a) {
        Interface.utils.AbstractOptionScroller.superclass.init.apply(this, arguments);
        this.callback = a.callback
    },
    getInputTarget: function(a) {},
    scroll: function(a) {}
};
Interface.utils.AbstractOptionScroller = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractOptionScroller, "Interface.utils.AbstractOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.AbstractInputField = {
    constructor: function() {
        Interface.utils.AbstractInputField.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        Interface.utils.AbstractInputField.superclass.init.apply(this, arguments);
        this.callback = a.callback
    },
    onKeyUp: function(a) {
        var b = this,
            c;
        if (b.enabled && b.active) {
            c = b.getValue(a);
            b.setValue(c);
            b.callback(c)
        }
    },
    getValue: function(a) {},
    setValue: function(a) {}
};
Interface.utils.AbstractInputField = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractInputField, "Interface.utils.AbstractInputField");
Sys.ns("Interface.utils");
Interface.utils.AbstractControlList = {
    constructor: function(a) {
        var b = this;
        Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.model = new Core.Model({
            name: a.id + "ControlListModel"
        });
        b.controls = {};
        b.setUpContent(a)
    },
    setUpContent: function(a) {},
    getContainer: function() {},
    getControl: function(a) {
        return this.controls[a]
    }
};
Interface.utils.AbstractControlList = Sys.extend(Sys.Observable, Interface.utils.AbstractControlList, "Interface.utils.AbstractControlList");
Sys.ns("Interface.utils");
Interface.utils.AbstractCheckBoxWithInput = {
    constructor: function(a) {
        var b = this;
        Interface.utils.AbstractCheckBoxWithInput.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.model = new Core.Model({
            name: a.id + "CheckBoxWithInputModel"
        });
        b.setUpContent(a)
    },
    setUpContent: function() {},
    getContainer: function() {}
};
Interface.utils.AbstractCheckBoxWithInput = Sys.extend(Sys.Observable, Interface.utils.AbstractCheckBoxWithInput, "Interface.utils.AbstractCheckBoxWithInput");
Sys.ns("Interface.utils");
Interface.utils.CanvasButton = {
    constructor: function(a) {
        Interface.utils.CanvasButton.superclass.constructor.apply(this, arguments);
        this.setUpAnimations(a)
    },
    destroy: function() {
        this.disable("CanvasButton");
        Game.stage.view.removeFromRenderLoop(this.animationList)
    },
    down: function() {
        Interface.utils.CanvasButton.superclass.down.apply(this, arguments);
        this.setActiveAnimation(this.downAnimation)
    },
    up: function() {
        Interface.utils.CanvasButton.superclass.up.apply(this, arguments);
        this.setActiveAnimation(this.upAnimation)
    },
    hover: function() {
        Interface.utils.CanvasButton.superclass.hover.apply(this, arguments);
        this.setActiveAnimation(this.hoverAnimation)
    },
    setActiveAnimation: function(a) {
        this.activeAnimation = a;
        this.update()
    },
    update: function() {
        var a = this;
        a.animationList.stop();
        if (!a.hasProperty("hidden")) {
            if (a.hasProperty("disabled")) {
                a.textLabelAnimation.prop.ownOpacity = 0.32;
                a.animationList.play(a.disabledAnimation)
            } else {
                a.textLabelAnimation.prop.ownOpacity = 1;
                a.animationList.play(a.activeAnimation)
            }
            a.animationList.play(a.textLabelAnimation)
        }
    },
    isInputTarget: function(c) {
        var a = this,
            b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
        return Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions) && Sys.UserInputUtils.isCoordinateTarget(a.canvasElement, c)
    },
    init: function(a) {
        Interface.utils.CanvasButton.superclass.init.apply(this, arguments);
        this.canvasElement = (a.canvasElement) ? a.canvasElement : document.getElementById("canvasAnimationManager")
    },
    setUpAnimations: function(b) {
        var d = this,
            e = new Animation.List({}),
            g = b.buttonImages,
            f, c, a = b.buttonLabel;
        ["up", "down", "hover", "disabled"].forEach(function(h) {
            f = d.verifyImage(g[h]);
            c = new Animation.Item(d.createBaseConfig(f, b.buttonLayoutParameters));
            d[h + "Animation"] = c;
            e.add(c)
        });
        if (Sys.isDefined(a)) {
            d.textLabelAnimation = d.createTextLabel(a)
        } else {
            d.textLabelAnimation = new Animation.Item({})
        }
        e.add(d.textLabelAnimation);
        e.stop();
        Game.stage.view.addToRenderLoop(e);
        d.animationList = e;
        d.setActiveAnimation(d.upAnimation)
    },
    verifyImage: function(a) {
        if (a.indexOf("#") === 0 || a.indexOf("rgba") === 0) {
            return this.createButtonImage(a)
        }
        return a
    },
    createTextLabel: function(i) {
        var g = this,
            f = i.text,
            c = i.offsetY || 0,
            e = i.offsetX || 0,
            j = 0,
            k = i.width,
            d = i.height,
            b = Animation.utils.getInMemoryCanvas(k, d),
            a = Services.languageManager.hasText(f) ? Services.languageManager.getText(f) : f;
        if (i.alignment === "center") {
            b.ctx.textAlign = i.alignment;
            j = k / 2
        }
        Animation.utils.text.wrapCanvasText(a, i.font, j, 0, k, i.lineHeight, [{
            fillStyle: i.color,
            drawType: "fill"
        }], b.ctx, true, i.breakOn);
        return new Animation.Item({
            width: k,
            height: d,
            left: g.dimensions.x + Math.round(Math.abs((k - g.dimensions.width) / 2)) + e,
            top: g.dimensions.y + Math.round(Math.abs((d - g.dimensions.height) / 2)) + c,
            depth: i.depth,
            image: b.canvas
        })
    },
    createBaseConfig: function(c, b) {
        var a = Sys.isDefined(b) ? b : this.dimensions;
        return {
            width: a.width,
            height: a.height,
            left: a.x,
            top: a.y,
            depth: a.depth,
            image: c
        }
    },
    createButtonImage: function(a) {
        var d = this,
            b = document.createElement("canvas"),
            c;
        b.width = d.dimensions.width;
        b.height = d.dimensions.height;
        c = b.getContext("2d");
        c.fillStyle = a;
        c.fillRect(0, 0, d.dimensions.width, d.dimensions.height);
        return b
    }
};
Interface.utils.CanvasButton = Sys.extend(Interface.AbstractButton, Interface.utils.CanvasButton, "Interface.utils.CanvasButton");
Sys.ns("Interface.utils");
Interface.utils.CanvasStepSlider = {
    DEFAULT_CANVAS_ELEMENT_ID: "canvasAnimationManager",
    constructor: function(a) {
        var b = this;
        b.canvasElement = Sys.isDefined(a.canvasElement) ? a.canvasElement : document.getElementById(b.DEFAULT_CANVAS_ELEMENT_ID);
        b.dimensions = a.dimensions;
        b.depth = a.depth;
        b.images = a.images;
        b.valueArray = a.values;
        b.sliderInputOffsets = a.sliderInputOffsets || {
            start: {
                width: 0,
                height: 0
            },
            move: {
                width: 0,
                height: 0
            },
            end: {
                width: 0,
                height: 0
            }
        };
        if (Sys.isDefined(a.collisionDimensions)) {
            b.collisionDimensions = a.collisionDimensions
        } else {
            b.collisionDimensions = a.dimensions.background
        }
        b.stepWidth = b.dimensions.fill.width / b.valueArray.length;
        b.currentIndex = 0;
        Interface.utils.CanvasStepSlider.superclass.constructor.apply(b, arguments)
    },
    setUpAnimations: function() {
        var a = this;
        a.animationList = new Animation.List({});
        a.backgroundAnimation = a.createItem(a.images.background.enabled, a.dimensions.background, a.depth.background);
        a.fillAnimation = a.createItem(a.images.fill.enabled, a.dimensions.fill, a.depth.fill);
        a.animationList.add(a.backgroundAnimation);
        a.animationList.add(a.fillAnimation);
        a.animationList.play();
        a.update()
    },
    getContainer: function() {
        return this.animationList
    },
    createItem: function(b, a, c) {
        return new Animation.CanvasAnimationItem({
            width: a.width,
            height: a.height,
            top: a.y,
            left: a.x,
            depth: c,
            image: b
        })
    },
    setUpContent: function(a) {
        this.setUpAnimations(a)
    },
    localCoordinates: function(a) {
        return Sys.UserInputUtils.getCoordinatesRelativeToElement(a, Game.stage.getGameContainer())
    },
    relativeCoordinates: function(c) {
        var a = this,
            b = a.localCoordinates(c);
        return {
            x: b.x - a.collisionDimensions.x,
            y: b.y - a.collisionDimensions.y
        }
    },
    isInputTarget: function(f, e) {
        var b = this,
            d = b.localCoordinates(f),
            a = e || {
                width: 0,
                height: 0
            },
            c = {
                x: b.collisionDimensions.x - a.width / 2,
                y: b.collisionDimensions.y - a.height / 2,
                width: b.collisionDimensions.width + a.width,
                height: b.collisionDimensions.height + a.height
            };
        return Sys.UserInputUtils.isUserInputInSegment(d, c) && Sys.UserInputUtils.isCoordinateTarget(b.canvasElement, f)
    },
    userInputStart: function(b) {
        var a = this;
        a.wasInitialInputTarget = a.isInputTarget(b, a.sliderInputOffsets.start);
        a.on({
            "notify:userInputManager.userInputMove": a.userInputMove
        })
    },
    userInputMove: function(b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            if (a.isInputTarget(b, a.sliderInputOffsets.move)) {
                a.movedTo(b)
            } else {
                a.removeListener("notify:userInputManager.userInputMove")
            }
        }
    },
    userInputEnd: function(b) {
        var a = this;
        if (a.wasInitialInputTarget && a.isInputTarget(b, a.sliderInputOffsets.end)) {
            a.clickedAt(b)
        }
    },
    update: function() {
        var a = this;
        a.fillAnimation.prop.width = a.stepWidth + (a.stepWidth * a.currentIndex);
        if (!a.hasProperty("hidden")) {
            if (a.hasProperty("disabled")) {
                a.backgroundAnimation.prop.image = a.images.background.disabled;
                a.fillAnimation.prop.image = a.images.fill.disabled
            } else {
                a.backgroundAnimation.prop.image = a.images.background.enabled;
                a.fillAnimation.prop.image = a.images.fill.enabled
            }
        }
    },
    setValue: function(d, a) {
        var c = this,
            b = c.valueArray.indexOf(d);
        if (b >= 0 && Sys.isDefined(c.valueArray[b])) {
            c.currentIndex = b;
            c.update();
            if (!a) {
                c.sendValueUpdate()
            }
        }
    },
    getValue: function() {
        var a = this;
        return a.valueArray[a.currentIndex]
    },
    sendValueUpdate: function() {
        var a = this,
            b = a.getValue();
        a.callback(b)
    },
    updateFromCoordinates: function(d) {
        var c = this,
            a = Math.floor(d.x / c.stepWidth),
            b = c.valueArray.length - 1;
        if (a < 0) {
            a = 0
        } else {
            if (a > b) {
                a = b
            }
        }
        if (a !== c.currentIndex) {
            c.currentIndex = a;
            c.update();
            c.sendValueUpdate()
        }
    },
    clickedAt: function(c) {
        var a = this,
            b = a.relativeCoordinates(c);
        a.updateFromCoordinates(b)
    },
    movedTo: function(c) {
        var a = this,
            b = a.relativeCoordinates(c);
        a.updateFromCoordinates(b)
    }
};
Interface.utils.CanvasStepSlider = Sys.extend(Interface.utils.AbstractSlider, Interface.utils.CanvasStepSlider, "Interface.utils.CanvasStepSlider");
Sys.ns("Interface.utils");
Interface.utils.DOMControlList = {
    constructor: function(a) {
        Interface.utils.DOMControlList.superclass.constructor.apply(this, arguments);
        this.callback = a.callback
    },
    setUpContent: function(c) {
        var f = this,
            d, b = c.controls,
            a, g, e;
        f.container = new Sys.Element({
            id: c.id,
            tag: "ul",
            cls: "",
            renderTo: "gameWrapper"
        });
        for (d = 0; d < b.length; d++) {
            a = b[d];
            e = f.container.add(new Sys.Element({
                id: c.id + "_" + a.id,
                tag: "li"
            }));
            if (!Sys.isDefined(f.controls[a.id])) {
                f.controls[a.id] = []
            }
            if (a.type === "checkbox") {
                if (Sys.isDefined(a.withInput)) {
                    g = f.setupCheckBoxWithInput(a.id, a.label, a.withInput);
                    f.controls[a.id].push(g);
                    e.add(g.getContainer())
                } else {
                    g = f.setupCheckBox(a.id, a.label);
                    f.controls[a.id].push(g);
                    e.add(g.getContainer())
                }
                f.model.storeData(a.id, false)
            }
        }
    },
    setupCheckBoxWithInput: function(d, a, c) {
        var b = this;
        return new Interface.utils.DOMCheckBoxWithInput({
            id: d,
            label: b.getTranslatedText(a),
            inputConfig: c,
            callback: b.onControlChanged.bind(b)
        })
    },
    onControlChanged: function(b, a) {
        this.model.storeData(b, a);
        this.callback(b, a)
    },
    setupCheckBox: function(c, a) {
        var b = this;
        return new Interface.utils.DOMCheckBox({
            id: c,
            title: b.getTranslatedText(a),
            enabled: true,
            callback: b.onControlChanged.bind(b, c)
        })
    },
    getContainer: function() {
        return this.container
    },
    update: function(c, b) {
        var a = this.controls[c];
        this.model.storeData(c, b);
        if (Sys.isDefined(a)) {
            Sys.each(a, function(d) {
                d.setValue(b)
            })
        }
    },
    hide: function(b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function(c) {
                c.getContainer().el.parentElement.style.display = "none"
            })
        }
    },
    show: function(b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function(c) {
                c.getContainer().el.parentElement.style.display = ""
            })
        }
    },
    disable: function(b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function(c) {
                c.disable()
            })
        }
    },
    enable: function(b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function(c) {
                c.enable()
            })
        }
    },
    getTranslatedText: function(a) {
        return Services.languageManager.hasText(a) ? Services.languageManager.getText(a) : a
    }
};
Interface.utils.DOMControlList = Sys.extend(Interface.utils.AbstractControlList, Interface.utils.DOMControlList, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBoxWithInput = {
    DEFAULT_INPUT_TYPE: "money",
    DEFAULT_INPUT_FILTER: /[^\d]/g,
    DEFAULT_CLEAR_ON_FOCUS: false,
    DEFAULT_CHECKBOX_VALUE: false,
    DEFAULT_INPUT_VALUE: "",
    NOT_CHECKED_VALUE: false,
    NOT_DEFINED_INPUT_VALUE: "",
    constructor: function(a) {
        var b = this;
        b.checkBox = undefined;
        b.input = undefined;
        Interface.utils.DOMCheckBoxWithInput.superclass.constructor.apply(b, arguments);
        b.setupEvents()
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:userInputManager.userInputStarted": a.onUserInputStart,
            "notify:userInputManager.userInputEnded": a.onUserInputEnd
        })
    },
    setUpContent: function(a) {
        var b = this;
        b.id = a.id;
        b.checkBoxId = b.id + "CheckBox";
        b.inputId = b.id + "Input";
        b.container = new Sys.Element({
            id: b.id,
            tag: "div",
            cls: ""
        });
        b.checkBox = b.setUpCheckBox(a.label);
        b.input = b.setUpInput(a.inputConfig);
        b.container.add(b.checkBox.getContainer());
        b.container.add(b.input.getContainer())
    },
    getContainer: function() {
        return this.container
    },
    setValue: function(d) {
        var c = this,
            b, a;
        if (d === false) {
            b = false;
            a = ""
        } else {
            b = true;
            a = d
        }
        c.setCheckBoxValue(b);
        c.setInputValue(a)
    },
    getValue: function() {
        var c = this,
            b = c.model.readData(c.checkBoxId),
            a = c.model.readData(c.inputId),
            d;
        if (b && a !== c.NOT_DEFINED_INPUT_VALUE) {
            d = a
        } else {
            d = c.NOT_CHECKED_VALUE
        }
        return d
    },
    enable: function() {
        this.checkBox.enable();
        this.input.enable()
    },
    disable: function() {
        this.checkBox.disable();
        this.input.disable()
    },
    setUpCheckBox: function(a) {
        var b = this,
            c = b.checkBoxId;
        b.model.storeData(c, b.DEFAULT_CHECKBOX_VALUE);
        return new Interface.utils.DOMCheckBox({
            id: c,
            enabled: true,
            title: a,
            listensToInput: false,
            callback: b.onCheckBoxToggled.bind(b)
        })
    },
    setUpInput: function(a) {
        var c = this,
            d = c.inputId,
            b = Sys.isDefined(a.type) ? a.type : c.DEFAULT_INPUT_TYPE;
        c.model.storeData(d, c.DEFAULT_INPUT_VALUE);
        return new Interface.utils.DOMInputField({
            id: d,
            enabled: true,
            listensToInput: false,
            label: Sys.isDefined(a.label) ? a.label : "",
            callback: c.onInputFieldEdited.bind(c, b),
            clearOnFocus: Sys.isDefined(a.clearOnFocus) ? a.clearOnFocus : c.DEFAULT_CLEAR_ON_FOCUS,
            inputFilter: Sys.isDefined(a.inputFilter) ? a.inputFilter : c.DEFAULT_INPUT_FILTER,
            blurCallback: function() {
                if (c.model.readData(d).length <= 0) {
                    c.setCheckBoxValue(false)
                }
            }
        })
    },
    onCheckBoxToggled: function(b) {
        var a = this,
            c = a.checkBoxId;
        a.model.storeData(c, b);
        if (b) {
            a.input.setActive(true)
        }
        a.sendValueUpdate()
    },
    onInputFieldEdited: function(b, d) {
        var c = this,
            e = c.inputId,
            a;
        if (d === "") {
            a = c.NOT_DEFINED_INPUT_VALUE
        } else {
            if (b === "money") {
                a = Math.floor(Number(d) * 100);
                a = isNaN(a) ? c.NOT_DEFINED_INPUT_VALUE : a
            } else {
                a = d
            }
        }
        if (a !== c.NOT_DEFINED_INPUT_VALUE) {
            c.setCheckBoxValue(true)
        }
        c.model.storeData(e, a);
        c.sendValueUpdate();
        c.setCheckBoxValue(c.model.readData(e) > 0)
    },
    sendValueUpdate: function() {
        var a = this,
            b = a.getValue();
        a.callback(a.id, b)
    },
    setCheckBoxValue: function(b) {
        var a = this;
        a.checkBox.setValue(b);
        a.model.storeData(a.checkBoxId, b)
    },
    setInputValue: function(b) {
        var a = this;
        a.input.setValue(b);
        a.model.storeData(a.inputId, b)
    },
    onUserInputStart: function(a) {
        this.initialInputTarget = this.getSelectedElement(a)
    },
    onUserInputEnd: function(b) {
        var a = this,
            c = this.getSelectedElement(b);
        if (a.initialInputTarget === c) {
            if (c instanceof Interface.utils.ToggleSwitch) {
                c.toggle()
            } else {
                if (c instanceof Interface.utils.DOMInputField) {
                    c.setActive(true)
                }
            }
        }
        a.initialInputTarget = null
    },
    getSelectedElement: function(a) {
        var b = null;
        [this.checkBox, this.input].forEach(function(c) {
            if (Sys.UserInputUtils.isCoordinateTarget(c.getContainer().el, a) && c.enabled) {
                b = c;
                return
            }
        });
        return b
    }
};
Interface.utils.DOMCheckBoxWithInput = Sys.extend(Interface.utils.AbstractCheckBoxWithInput, Interface.utils.DOMCheckBoxWithInput, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBox = {
    CSS: {
        base: "interface-checkBox_base",
        disabled: "disabled",
        label: "interface-checkBox_label",
        button_wrapper: "interface-checkBox_box",
        button_background: "interface-checkBox_background",
        button_handle: "interface-checkBox_handle",
        loadAnimation: ""
    },
    constructor: function() {
        Interface.utils.DOMCheckBox.superclass.constructor.apply(this, arguments)
    }
};
Interface.utils.DOMCheckBox = Sys.extend(Interface.utils.ToggleSwitch, Interface.utils.DOMCheckBox, "Interface.utils.DOMCheckBox");
Sys.ns("Interface.utils");
Interface.utils.DOMInputField = {
    CSS: {
        base: "interface-inputField_base",
        label: "interface-inputField_label",
        input: "interface-inputField_input"
    },
    constructor: function() {
        Interface.utils.DOMInputField.superclass.constructor.apply(this, arguments)
    },
    onUserInputStart: function(a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    onUserInputEnd: function(b) {
        var a = this.wasInitialInputTarget && Sys.UserInputUtils.isCoordinateTarget(this.container.el, b);
        this.setActive(a)
    },
    enable: function() {
        Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
        this.container.removeCls("disabled");
        this.input.el.disabled = false
    },
    disable: function() {
        Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
        this.container.addCls("disabled");
        this.input.el.disabled = true
    },
    getContainer: function() {
        return this.container
    },
    init: function(a) {
        this.setUpDOMStructure(a);
        Interface.utils.DOMInputField.superclass.init.apply(this, arguments);
        this.clearOnFocus = a.clearOnFocus
    },
    setUpDOMStructure: function(b) {
        var c = this,
            a;
        if (Sys.isDefined(b.CSS)) {
            a = Sys.applyPropertiesIf(Sys.applyProperties({}, b.CSS), c.CSS)
        } else {
            a = c.CSS
        }
        c.container = new Sys.Element({
            id: b.id,
            tag: "div",
            cls: a.base
        });
        if (Sys.isDefined(b.label)) {
            c.label = c.container.add(new Sys.Element({
                id: b.id + "_label",
                tag: "span",
                cls: a.label,
                textContent: b.label
            }))
        }
        c.input = c.container.add(new Sys.Element({
            id: b.id + "_input",
            tag: "input",
            cls: a.input
        }));
        c.id = Sys.isDefined(b.id) ? b.id : "DOMInputField";
        c.input.el.onkeyup = c.onKeyUp.bind(c, b.inputFilter);
        c.input.el.onfocus = c.onFocusChanged.bind(c, true);
        c.input.el.onblur = c.onFocusChanged.bind(c, false);
        if (Sys.isDefined(b.blurCallback)) {
            c.blurCallback = b.blurCallback
        } else {
            c.blurCallback = function() {}
        }
    },
    setActive: function(b) {
        var a = this;
        a.active = b;
        if (b && a.enabled) {
            a.container.addCls("active");
            a.input.el.focus();
            if (a.clearOnFocus) {
                a.input.el.value = "";
                a.onKeyUp()
            }
        } else {
            a.container.removeCls("active");
            a.input.el.blur()
        }
    },
    getValue: function(a) {
        if (a) {
            return this.input.el.value.replace(a, "")
        }
        return this.input.el.value
    },
    setValue: function(b) {
        var a = this;
        if (a.input.el.value !== b) {
            a.input.el.value = b
        }
    },
    onFocusChanged: function(b) {
        var a = this;
        if (b) {
            a.fireEvent("request:keyboardManager.addProperty", "disabled", a.id)
        } else {
            a.fireEvent("request:keyboardManager.removeProperty", "disabled", a.id);
            a.blurCallback()
        }
    }
};
Interface.utils.DOMInputField = Sys.extend(Interface.utils.AbstractInputField, Interface.utils.DOMInputField, "Interface.utils.DOMInputField");
Sys.ns("Interface.utils");
Interface.utils.DOMOptionScroller = {
    CSS: {
        base: "interface-DOMOptionScroller_base",
        buttonBase: "interface-DOMOptionScroller_buttonBase",
        buttonUp: "interface-DOMOptionScroller_buttonUp interface-DOMOptionScroller_buttonUp_uri",
        buttonDown: "interface-DOMOptionScroller_buttonDown interface-DOMOptionScroller_buttonDown_uri",
        valuesHolder: "interface-DOMOptionScroller_valuesHolder",
        value: "interface-DOMOptionScroller_value interface-DOMOptionScroller_value_uri",
        wrapper: "interface-DOMOptionScroller_valueWrapper"
    },
    PIXEL_FACTOR: 0.01,
    constructor: function() {
        Interface.utils.DOMOptionScroller.superclass.constructor.apply(this, arguments)
    },
    onUserInputStart: function() {},
    onUserInputEnd: function() {},
    enable: function() {
        Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
        this.container.removeCls("disabled")
    },
    disable: function() {
        Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
        this.container.addCls("disabled")
    },
    getContainer: function() {
        return this.container
    },
    init: function(a) {
        this.setUpDOMStructure(a);
        Interface.utils.DOMOptionScroller.superclass.init.apply(this, arguments)
    },
    setUpDOMStructure: function(b) {
        var d = this,
            a = Sys.applyIf(Sys.apply({}, b.CSS), d.CSS),
            c;
        d.id = b.id || "DOMOptionScroller";
        d.valueChilds = [];
        d.valueButtons = [];
        d.wrapperChilds = [];
        d.avg = 0;
        d.container = new Sys.Element({
            id: d.id,
            tag: "div",
            cls: a.base
        });
        d.downButton = new Interface.utils.DOMButton({
            id: d.id + "_downButton",
            baseCSS: a.buttonBase + " " + a.buttonDown,
            clickCallback: function() {
                d.scroll("down")
            }
        });
        d.downButton.disable("lowerBoundReached");
        d.container.add(d.downButton.getContainer());
        d.values = d.container.add(new Sys.Element({
            id: d.id + "_values",
            tag: "div",
            cls: a.valuesHolder
        }));
        d.valuesScroller = d.values.add(new Sys.Element({
            id: d.id + "_valuesScroller",
            tag: "div",
            style: "position:absolute; height:100%;white-space: nowrap;"
        }));
        d.valuesScroller.el.style[Sys.utils.getPrefixedCSSProperty("transition")] = "transform 100ms";
        Sys.each(b.values, function(h, e) {
            var f, g = false;
            if (Sys.isDefined(b.replaceTextByIndex)) {
                Sys.each(b.replaceTextByIndex, function(i) {
                    if (e === i.index) {
                        f = i.text;
                        if (i.skip) {
                            g = true
                        }
                    }
                })
            }
            if (!g) {
                c = new Interface.utils.DOMButton({
                    id: "value" + h,
                    baseCSS: a.value,
                    textContent: (Sys.isDefined(f) ? f : h),
                    clickCallback: function() {
                        d.callback(h)
                    }
                });
                d.valuesScroller.add(c.getContainer());
                d.valueChilds.push(c.getContainer());
                d.valueButtons.push(c)
            }
        });
        d.upButton = new Interface.utils.DOMButton({
            id: d.id + "_upButton",
            baseCSS: a.buttonBase + " " + a.buttonUp,
            clickCallback: function() {
                d.scroll("up")
            }
        });
        d.container.add(d.upButton.getContainer());
        d.calculateOffsetValues();
        d.valueWidth = b.valueWidth;
        d.scrollOffsetModifier = b.scrollOffsetModifier;
        d.scrollOffset = d.scrollOffsetModifier * b.valueWidth;
        d.currentScrollOffset = 0;
        d.maxScrollOffset = 0;
        d.minScrollOffset = -(((b.values.length - 1) * d.valueWidth) - d.scrollOffset);
        if (d.minScrollOffset >= d.currentScrollOffset) {
            d.upButton.disable("upperBoundReached")
        }
    },
    calculateOffsetValues: function() {
        var b = this,
            a = 0;
        Sys.each(b.valueChilds, function(c) {
            if (c.el.clientWidth > 0) {
                a += c.el.clientWidth
            }
        });
        if (a > 0) {
            b.scrollOffset = (a / b.valueChilds.length) * b.scrollOffsetModifier
        }
        b.totalValueWidth = a
    },
    scroll: function(b) {
        var a = this,
            c = b === "up" ? -1 : 1;
        if (!Sys.isDefined(a.totalValueWidth) || a.tot === 0) {
            a.calculateOffsetValues()
        }
        a.currentScrollOffset = Math.max(Math.min(a.currentScrollOffset + c * a.scrollOffset, a.maxScrollOffset), a.minScrollOffset);
        a.valuesScroller.el.style[Sys.utils.getPrefixedCSSProperty("transform")] = "translate3d(" + a.currentScrollOffset * a.PIXEL_FACTOR + "rem,0,0)";
        if (a.currentScrollOffset === a.minScrollOffset) {
            a.upButton.disable("upperBoundReached")
        } else {
            a.upButton.enable("upperBoundReached")
        }
        if (a.currentScrollOffset === 0) {
            a.downButton.disable("lowerBoundReached")
        } else {
            a.downButton.enable("lowerBoundReached")
        }
    }
};
Interface.utils.DOMOptionScroller = Sys.extend(Interface.utils.AbstractOptionScroller, Interface.utils.DOMOptionScroller, "Interface.utils.DOMOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.DOMButton = {
    BASE_CSS: "DOMButton",
    textContent: "",
    container: undefined,
    renderTo: undefined,
    constructor: function() {
        Interface.utils.DOMButton.superclass.constructor.apply(this, arguments)
    },
    init: function(a) {
        var b = this;
        b.id = a.id;
        b.BASE_CSS = a.baseCSS || b.BASE_CSS;
        b.textContent = a.textContent || b.textContent;
        b.tagType = a.tag || "div";
        b.renderTo = a.renderTo;
        b.setupContainer();
        Interface.utils.DOMButton.superclass.init.apply(b, arguments)
    },
    up: function() {
        Interface.utils.DOMButton.superclass.up.apply(this, arguments);
        this.update()
    },
    down: function() {
        Interface.utils.DOMButton.superclass.down.apply(this, arguments);
        this.update()
    },
    hover: function() {
        Interface.utils.DOMButton.superclass.hover.apply(this, arguments);
        this.update()
    },
    getContainer: function() {
        return this.container
    },
    setupContainer: function() {
        var a = this;
        a.container = new Sys.Element({
            id: a.id,
            tag: a.tagType,
            cls: a.BASE_CSS,
            textContent: a.textContent,
            renderTo: a.renderTo
        })
    },
    isInputTarget: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    update: function() {
        var b = this,
            a = b.container;
        a.removeCSSClass("hidden");
        a.removeCSSClass("disabled");
        a.removeCSSClass("active");
        a.removeCSSClass("hover");
        a.removeCSSClass("down");
        if (b.hasProperty("hidden")) {
            a.addCSSClass("hidden")
        }
        if (b.hasProperty("disabled")) {
            a.addCSSClass("disabled")
        } else {
            if (b.hasProperty("active")) {
                a.addCSSClass("active")
            } else {
                if (b.state === "hover") {
                    a.addCSSClass("hover")
                } else {
                    if (b.state === "down") {
                        a.addCSSClass("down")
                    }
                }
            }
        }
    }
};
Interface.utils.DOMButton = Sys.extend(Interface.AbstractButton, Interface.utils.DOMButton, "Interface.utils.DOMButton");
Sys.ns("Interface.utils");
Interface.utils.DOMScrollableContent = {
    constructor: function(a) {
        Interface.utils.DOMScrollableContent.superclass.constructor.apply(this, arguments)
    },
    setupContainer: function(b) {
        var c = this,
            a = b.snap;
        c.content = b.content;
        c.model = new Core.Model({});
        c.container = new Sys.Element({
            id: c.id + "_container",
            tag: "div",
            cls: c.CSS.base
        });
        c.container.add(c.content);
        c._scroller = new Scroller(c.onScroll.bind(c), {
            scrollingX: false,
            snapping: Sys.isObj(a),
            speedMultiplier: 1.5 / Services.scaling.getScale(),
            scrollingComplete: c.onScrollComplete.bind(c, b.scrollCompleteCallback)
        });
        if (Sys.isObj(a)) {
            c._scroller.setSnapSize(a.width, a.height)
        }
    },
    onScroll: function(c, b) {
        var a = this;
        a.content.el.style[Sys.utils.getPrefixedCSSProperty("transform")] = "translate3d(0," + (-b) + "px,0)";
        if (Sys.isDefined(a.scrollBar)) {
            a.moveScrollIndicator(b)
        }
    },
    onScrollComplete: function(c) {
        var b = this,
            a = b._scroller,
            d = a.getValues().top;
        if (!b.model.isState("scrollingByProxy")) {
            a.scrollTo(0, d, false)
        }
        if (Sys.isDefined(c)) {
            c(d)
        }
    },
    show: function() {
        var a = this;
        a.container.el.style.display = "block";
        a.updateScrollerDimensions();
        if (a.isScrollBarVisible) {
            a.showScrollBar()
        }
    },
    hide: function() {
        this.container.el.style.display = "none";
        this.hideScrollBar()
    },
    enable: function() {
        Interface.utils.DOMScrollableContent.superclass.enable.apply(this, arguments);
        this.updateScrollerDimensions()
    },
    onUserInputStart: function(d) {
        var c = this,
            a = c.model,
            b = c.contentIsScrollable();
        if (b) {
            if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
                a.setState("scrollingByProxy");
                c.onBarIndicatorMove(d)
            } else {
                if (Sys.UserInputUtils.isCoordinateTarget(c.content.el, d)) {
                    a.setState("scrolling");
                    c._scroller.doTouchStart([{
                        pageX: d.x,
                        pageY: d.y
                    }], Date.now())
                }
            }
            if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
                c.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    contentIsScrollable: function() {
        var b = this,
            c = b.container.el.clientHeight,
            a = b.content.el.scrollHeight;
        return c < a + 20
    },
    updateScrollerDimensions: function() {
        var d = this,
            e, c, f, b, a;
        e = d.container.el.clientHeight;
        c = d.content.el.scrollHeight;
        d._scroller.setDimensions(d.container.el.clientWidth, e + 20, d.content.el.scrollWidth, c + 60);
        b = d.container.el.getBoundingClientRect();
        d._scroller.setPosition(b.left + d.container.clientLeft, b.top + d.container.clientTop);
        if (e > 0 && c > 0) {
            a = (e < c + 20)
        }
        if (a) {
            if (!Sys.isDefined(d.scrollBar)) {
                d.addScrollBar()
            }
            d.isScrollBarVisible = true;
            d.showScrollBar();
            f = d.scrollBar.el.clientHeight;
            d.scrollIndicatorHeight = d.scrollIndicator.el.clientHeight;
            d.maxScroll = d._scroller.getScrollMax().top;
            d.scrollBarHeight = f - d.scrollIndicatorHeight
        } else {
            if (Sys.isDefined(d.scrollBar)) {
                d.isScrollBarVisible = false;
                d.hideScrollBar()
            }
        }
    },
    onUserInputMove: function(c) {
        var b = this,
            a = b.contentIsScrollable();
        if (a) {
            if (b.model.isState("scrolling")) {
                b._scroller.doTouchMove([{
                    pageX: c.x,
                    pageY: c.y
                }], Date.now())
            } else {
                if (b.model.isState("scrollingByProxy")) {
                    b.onBarIndicatorMove(c)
                }
            }
        }
    },
    onUserInputEnd: function() {
        var b = this,
            a = b.model,
            c = a.isState("scrolling") || a.isState("scrollingByProxy");
        a.setState("idle");
        if (c) {
            b._scroller.doTouchEnd(Date.now())
        }
    },
    onUserInputScroll: function(g, c) {
        var e = this,
            a = e.model,
            d = Sys.UserInputUtils.isCoordinateTarget(e.content.el, g),
            f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
            b = (d || f) && e.contentIsScrollable();
        if (b) {
            a.setState("scrollingByProxy");
            e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
            if (!a.readData("hasSetDimensions")) {
                e.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    moveScrollIndicator: function(d) {
        var c = this,
            b = c.maxScroll,
            a = Math.round(c.scrollIndicatorHeight / 2);
        if (d < 0) {
            d = 0
        } else {
            if (d > b) {
                d = b
            }
        }
        c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
    },
    onBarIndicatorMove: function(f) {
        var b = this,
            e = Sys.UserInputUtils.getCoordinatesRelativeToElement(f, b.scrollBar.el),
            c = e.y,
            d = b.scrollBarHeight,
            a;
        if (c < 0) {
            c = 0
        } else {
            if (c > d) {
                c = d
            }
        }
        a = Math.round(b.maxScroll * (c / d));
        b._scroller.scrollTo(0, a, true)
    },
    addScrollBar: function() {
        var a = this;
        if (!Sys.isDefined(a.container)) {
            return
        }
        a.maxScroll = 0;
        a.scrollBar = a.container.add(new Sys.Element({
            tag: "div",
            id: a.id + "_scrollbar",
            "class": "interface-scrollableContent_scrollBar"
        }));
        a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-scrollableContent_scrollBarBackground utils_horizontal_center"
        }));
        a.scrollIndicator = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-scrollableContent_scrollBarHandle utils_center"
        }))
    },
    showScrollBar: function() {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "block"
        }
    },
    hideScrollBar: function() {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "none"
        }
    },
    startListeningToUserInput: function() {
        Interface.utils.DOMScrollableContent.superclass.startListeningToUserInput.apply(this, arguments);
        this.addListener("notify:userInputManager.userInputScroll", this.onUserInputScroll)
    },
    stopListeningToUserInput: function() {
        Interface.utils.DOMScrollableContent.superclass.stopListeningToUserInput.apply(this, arguments);
        this.removeListener("notify:userInputManager.userInputScroll")
    },
    scrollTo: function(b) {
        var a = this._scroller;
        a.scrollTo(0, b, false);
        a.options.scrollingComplete(a.getValues().top)
    }
};
Interface.utils.DOMScrollableContent = Sys.extend(Interface.utils.UserInputBase, Interface.utils.DOMScrollableContent, "Interface.utils.DOMScrollableContent");
Sys.ns("Interface");
Interface.SettingsSection = {
    constructor: function() {
        Interface.SettingsSection.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["userInput", "orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            view: Interface.SettingsSectionView,
            controller: Interface.SettingsSectionController
        }
    }
};
Interface.SettingsSection = Sys.extend(Core.Module, Interface.SettingsSection, "Interface.SettingsSection");
Sys.ns("Interface");
Interface.SettingsSectionController = {
    constructor: function() {
        Interface.SettingsSectionController.superclass.constructor.apply(this, arguments);
        this.setUpContent()
    },
    setupEvents: function() {
        var a = this,
            b = {
                "view:addToContainer": a.addViewToContainer,
                "view:removeFromContainer": a.removeViewFromContainer,
                "view:addToNavigator": a.addOptionToNavigator,
                "view:userAction": a.onUserAction,
                "view:disableSetting": a.disableSetting,
                "view:showRequest": a.onShowRequest,
                "view:hideRequest": a.onHideRequest,
                "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
                "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
                "request:enableBasicGamePanel": a.onEnableBasicGamePanel,
                "request:disableBasicGamePanel": a.onDisableBasicGamePanel,
                "notify:featureSplash.showing": a.onFeatureSplashShowing,
                "notify:featureSplash.closed": a.onFeatureSplashClosed
            };
        b["request:" + a.MODULE_NAME + ".show"] = a.onShowRequest;
        b["request:" + a.MODULE_NAME + ".hide"] = a.onHideRequest;
        b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
        b["request:" + a.MODULE_NAME + ".disable"] = a.disable;
        a.on(b)
    },
    setUpContent: function() {
        this.view.setUpContent()
    },
    onShowRequest: function(b) {
        var c = this,
            a = c.model.readData("currentContainer");
        if (!c.model.readData("showing")) {
            if (Sys.isDefined(a)) {
                c.fireEvent("request:" + a + ".openChild", c.MODULE_NAME, b)
            } else {
                c.show(b)
            }
        }
        Services.storage.storeData(c.MODULE_NAME + ".showing", true)
    },
    onHideRequest: function() {
        var b = this,
            a = b.model.readData("currentContainer");
        if (b.model.readData("showing")) {
            if (Sys.isDefined(a)) {
                b.fireEvent("request:" + a + ".closeChild", b.MODULE_NAME)
            } else {
                b.hide()
            }
        }
        Services.storage.storeData(b.MODULE_NAME + ".showing", false)
    },
    addViewToContainer: function(a, c) {
        var d = this,
            b = this.model.readData("currentContainer");
        if (b) {
            d.removeViewFromContainer(b)
        }
        d.model.storeData("currentContainer", a);
        d.addListener("notify:" + a + ".openedChild", d.containerOpenedChild);
        d.addListener("notify:" + a + ".closedChild", d.containerClosedChild);
        d.fireEvent("request:" + a + ".addChild", d.MODULE_NAME, c)
    },
    containerOpenedChild: function(b, a) {
        if (b === this.MODULE_NAME) {
            this.show(a)
        }
    },
    containerClosedChild: function(a) {
        if (a === this.MODULE_NAME) {
            this.hide()
        }
    },
    show: function(a) {
        var b = this;
        if (!b.model.readData("showing")) {
            b.model.storeData("showing", true);
            Services.storage.storeData(b.MODULE_NAME + ".showing", true);
            b.fireEvent("notify:" + b.MODULE_NAME + ".shown");
            b.view.show(a);
            b.startListeningToUserInput()
        }
    },
    hide: function() {
        var a = this;
        if (a.model.readData("showing")) {
            a.model.storeData("showing", false);
            Services.storage.storeData(a.MODULE_NAME + ".showing", false);
            a.fireEvent("notify:" + a.MODULE_NAME + ".hidden");
            a.stopListeningToUserInput();
            a.view.hide()
        }
    },
    removeViewFromContainer: function(a, b) {
        var c = this;
        c.removeListener("notify:" + a + ".openedChild");
        c.removeListener("notify:" + a + ".closedChild");
        c.fireEvent("request:" + a + ".removeChild", c.MODULE_NAME, b)
    },
    addOptionToNavigator: function(a, b) {
        this.fireEvent("request:" + a + ".addChild", this.MODULE_NAME, b)
    },
    onUserAction: function() {},
    onUserInputStart: function() {
        this.view.onUserInputStart.apply(this.view, arguments)
    },
    onUserInputMove: function() {
        this.view.onUserInputMove.apply(this.view, arguments)
    },
    onUserInputEnd: function() {
        this.view.onUserInputEnd.apply(this.view, arguments)
    },
    onUserInputScroll: function() {
        this.view.onUserInputScroll.apply(this.view, arguments)
    },
    enable: function(a) {
        this.model.storeData("disabled", false);
        this.view.enable(a)
    },
    disable: function(a) {
        this.model.storeData("disabled", true);
        this.view.disable(a)
    },
    onPortrait: function() {
        this.model.storeData("hasSetDimensions", false);
        Mixins.orientation.controller.methods.onPortrait.apply(this, arguments)
    },
    onLandscape: function() {
        this.model.storeData("hasSetDimensions", false);
        Mixins.orientation.controller.methods.onLandscape.apply(this, arguments)
    },
    onLeavingIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.view.onLeavingIdleState)) {
            a.view.onLeavingIdleState()
        }
    },
    onEnteringIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.view.onEnteringIdleState)) {
            a.view.onEnteringIdleState()
        }
    },
    onEnableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.view.onEnableBasicGamePanel)) {
            a.view.onEnableBasicGamePanel(b)
        }
    },
    onDisableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
            a.view.onDisableBasicGamePanel(b)
        }
    },
    onFeatureSplashShowing: function() {
        var a = this;
        if (Sys.isDefined(a.view.onFeatureSplashShowing)) {
            a.view.onFeatureSplashShowing()
        }
    },
    onFeatureSplashClosed: function() {
        var a = this;
        if (Sys.isDefined(a.view.onFeatureSplashClosed)) {
            a.view.onFeatureSplashClosed()
        }
    },
    disableSetting: function(a) {
        this.fireEvent("request:settingsManager.disableSetting", a)
    }
};
Interface.SettingsSectionController = Sys.extend(Core.Controller, Interface.SettingsSectionController, "Interface.SettingsSectionController");
Sys.ns("Interface");
Interface.SettingsSectionModel = {
    constructor: function() {
        Interface.SettingsSectionModel.superclass.constructor.apply(this, arguments)
    },
    initData: function(b) {
        var c = this,
            d = b.defaultValue,
            a = Sys.isDefined(b.silent) ? b.silent : true;
        if (b.settingsManager) {
            if (b.localStorage && !b.ignoreLocalStorageValue && Services.localStorageManager.hasData(b.key)) {
                d = Sys.utils.parseValue(Services.localStorageManager.readData(b.key))
            }
            Services.settingsManager.storeSetting(b.key, d, b.localStorage, a)
        }
        c.storeData(b.key, d)
    },
    setupData: function() {
        Services.storage.storeData(this.MODULE_NAME + ".showing", false)
    }
};
Interface.SettingsSectionModel = Sys.extend(Core.Model, Interface.SettingsSectionModel, "Interface.SettingsSectionModel");
Sys.ns("Interface");
Interface.SettingsSectionView = {
    SCROLL_BAR_CSS: "interface-settingsSection_scrollBar",
    SCROLL_INDICATOR_CSS: "interface-settingsSection_scrollIndicator utils_center",
    DISABLE_BUTTON_DURING_SPIN: true,
    ENABLED_ONLY_IN_BASIC_GAME: false,
    DISABLE_BUTTON_DURING_FEATURE_SPLASH: true,
    LANDSCAPE_HEIGHT: 0,
    PORTRAIT_HEIGHT: 0,
    constructor: function() {
        Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        this.container = new Sys.Element({
            tag: "div"
        })
    },
    addContainerToSettings: function() {},
    addScrolling: function() {
        var a = this;
        if (Sys.isDefined(a.container) && Sys.isDefined(a.container.parent)) {
            a._wrapper = a.container.parent
        } else {
            return
        }
        a._scroller = new Scroller(a.onScroll.bind(a), {
            scrollingX: false,
            speedMultiplier: 1.5 / Services.scaling.getScale()
        })
    },
    onScroll: function(c, b) {
        var a = this;
        a.container.el.style[Sys.utils.getPrefixedCSSProperty("transform")] = "translate3d(0," + (-b) + "px,0)";
        if (Sys.isDefined(a.scrollBar)) {
            a.moveScrollIndicator(b)
        }
    },
    show: function() {
        var a = this;
        a.container.el.style.display = "block";
        a.updateScrollerDimensions();
        if (a.isScrollBarVisible) {
            a.showScrollBar()
        }
        if (!a.model.readData("disabled")) {
            a.callFunctionOnSubComponents("startListeningToUserInput")
        }
    },
    hide: function() {
        this.container.el.style.display = "none";
        this.hideScrollBar();
        this.callFunctionOnSubComponents("stopListeningToUserInput")
    },
    enable: function() {},
    disable: function() {},
    adaptToOrientation: function() {
        var a = this;
        Mixins.orientation.view.methods.adaptToOrientation.apply(this, arguments);
        clearTimeout(a.orientationAdaptationTimeout);
        a.orientationAdaptationTimeout = setTimeout(function() {
            a.updateScrollerDimensions()
        }, 50)
    },
    onUserInputStart: function(d) {
        var c = this,
            a = c.model,
            b = c.contentIsScrollable() && !c.userInputOnSubControl(d);
        if (b) {
            if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
                a.setState("scrollingByProxy");
                c.onBarIndicatorMove(d)
            } else {
                if (Sys.UserInputUtils.isCoordinateTarget(c.container.el, d)) {
                    a.setState("scrolling");
                    c._scroller.doTouchStart([{
                        pageX: d.x,
                        pageY: d.y
                    }], Date.now())
                }
            }
            if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
                c.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    userInputOnSubControl: function(d) {
        var b = this,
            a = b.container.el.querySelectorAll("[data-input]"),
            c = false;
        Sys.each(a, function(e) {
            if (Sys.UserInputUtils.isCoordinateTarget(e, d)) {
                c = true
            }
        });
        return c
    },
    contentIsScrollable: function() {
        var b = this,
            c = b._wrapper.el.clientHeight,
            a = b.container.el.scrollHeight;
        return c + 40 < a
    },
    updateScrollerDimensions: function() {
        var e = this,
            f, d, g, c, a, b = Utils.Platform.getOrientation();
        if (!Sys.isDefined(e._wrapper)) {
            return
        }
        if (b === Utils.Platform.LANDSCAPE && this.LANDSCAPE_HEIGHT === 0) {
            this.LANDSCAPE_HEIGHT = e._wrapper.el.clientHeight
        }
        if (b === Utils.Platform.PORTRAIT && this.PORTRAIT_HEIGHT === 0) {
            this.PORTRAIT_HEIGHT = e._wrapper.el.clientHeight
        }
        f = b === Utils.Platform.LANDSCAPE ? this.LANDSCAPE_HEIGHT : this.PORTRAIT_HEIGHT;
        d = e.container.el.scrollHeight;
        e._scroller.setDimensions(e._wrapper.el.clientWidth, f + 20, e.container.el.scrollWidth, d + 40);
        c = e._wrapper.el.getBoundingClientRect();
        e._scroller.setPosition(c.left + e._wrapper.clientLeft, c.top + e._wrapper.clientTop);
        if (f > 0 && d > 0) {
            a = (f + 40 < d)
        }
        if (a) {
            if (!Sys.isDefined(e.scrollBar)) {
                e.addScrollBar()
            }
            e.isScrollBarVisible = true;
            e.showScrollBar();
            g = e.scrollBar.el.clientHeight;
            e.scrollIndicatorHeight = e.scrollIndicator.el.clientHeight;
            e.maxScroll = e._scroller.getScrollMax().top;
            e.scrollBarHeight = g - e.scrollIndicatorHeight
        } else {
            if (Sys.isDefined(e.scrollBar)) {
                e.isScrollBarVisible = false;
                e.hideScrollBar()
            }
        }
    },
    onUserInputMove: function(b) {
        var a = this;
        if (a.model.isState("scrolling")) {
            a._scroller.doTouchMove([{
                pageX: b.x,
                pageY: b.y
            }], Date.now())
        } else {
            if (a.model.isState("scrollingByProxy")) {
                a.onBarIndicatorMove(b)
            }
        }
    },
    onUserInputEnd: function() {
        if (this.model.isState("scrolling")) {
            this._scroller.doTouchEnd(Date.now())
        }
        this.model.setState("idle")
    },
    onUserInputScroll: function(g, c) {
        var e = this,
            a = e.model,
            d = Sys.UserInputUtils.isCoordinateTarget(e.container.el, g),
            f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
            b = (d || f) && e.contentIsScrollable();
        if (b) {
            a.setState("scrollingByProxy");
            e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
            if (!a.readData("hasSetDimensions")) {
                e.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    callFunctionOnSubComponents: function(c, a) {
        var b = this;
        if (!b.model.readData("disabled")) {
            Sys.each(b.subComponents, function(d) {
                if (d) {
                    d[c].apply(d, a)
                }
            })
        }
    },
    moveScrollIndicator: function(d) {
        var c = this,
            b = c.maxScroll,
            a = Math.round(c.scrollIndicatorHeight / 2);
        if (d < 0) {
            d = 0
        } else {
            if (d > b) {
                d = b
            }
        }
        c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
    },
    onBarIndicatorMove: function(e) {
        var b = this,
            f = Sys.UserInputUtils.getCoordinatesRelativeToElement(e, b.scrollBar.el),
            c = f.y,
            d = b.scrollBarHeight,
            a;
        if (c < 0) {
            c = 0
        } else {
            if (c > d) {
                c = d
            }
        }
        a = Math.round(b.maxScroll * (c / d));
        b._scroller.scrollTo(0, a, true)
    },
    addScrollBar: function() {
        var a = this;
        if (!Sys.isDefined(a._wrapper)) {
            return
        }
        a.maxScroll = 0;
        a.scrollBar = a._wrapper.add(new Sys.Element({
            tag: "div",
            id: a.MODULE_NAME + "_scrollbar",
            "class": a.SCROLL_BAR_CSS
        }));
        a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-settingsSection_scrollBarBackground utils_horizontal_center"
        }));
        a.scrollIndicator = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": a.SCROLL_INDICATOR_CSS
        }))
    },
    showScrollBar: function() {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "block"
        }
    },
    hideScrollBar: function() {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "none"
        }
    },
    onEnteringIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.removeCls("disabled");
            a.abstractButton.enable("notInIdleState")
        }
    },
    onLeavingIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable("notInIdleState")
        }
    },
    onEnableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.abstractButton.enable(b);
            if (!a.abstractButton.hasProperty("disabled") && !a.abstractButton.hasProperty("hidden")) {
                a.menuButton.removeCls("disabled")
            }
        }
    },
    onDisableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable(b)
        }
    },
    onFeatureSplashShowing: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable("featureSplashShowing")
        }
    },
    onFeatureSplashClosed: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.removeCls("disabled");
            a.abstractButton.enable("featureSplashShowing")
        }
    }
};
Interface.SettingsSectionView = Sys.extend(Core.View, Interface.SettingsSectionView, "Interface.SettingsSectionView");
Sys.ns("Interface");
Interface.StandAloneSettingsSectionView = {
    BASE_CSS: "interface-standAloneSettingsSection",
    BACKGROUND_CSS: {
        top: "interface-standAloneSettingsSection_backgroundTop interface-standAloneSettingsSectionTop_uri",
        title: "interface-standAloneSettingsSection_title",
        bottom: "interface-standAloneSettingsSection_backgroundBottom interface-standAloneSettingsSectionBottom_uri",
        arrow: "interface-standAloneSettingsSection_backgroundArrow interface-standAloneSettingsSectionArrow_uri",
        middle: "interface-standAloneSettingsSectionMiddle interface-standAloneSettingsSectionMiddle_uri"
    },
    ARROW_LEFT_VALUE: "0.00rem",
    DIVIDER_CSS: "interface-standAloneSettingsSection_divider interface-standAloneSettingsSectionDivider_uri",
    CLOSE_BUTTON_CSS: "interface-standAloneSettingsSection_closeButton",
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button",
    CHECKBOX_CSS: {
        base: "interface-standAloneSettingsSectionContainer_checkBox",
        disabled: "interface-standAloneSettingsSectionContainer_checkBox_disabled",
        label: "interface-standAloneSettingsSectionContainer_checkBox_label",
        button_wrapper: "interface-standAloneSettingsSectionContainer_checkBox_wrapper",
        button_background: "interface-standAloneSettingsSectionContainer_checkBox_default",
        button_handle: "interface-standAloneSettingsSectionContainer_checkBox_checked"
    },
    RENDER_TARGET: "gameWrapper",
    TITLE: "Placeholder Header",
    ORDER: -1,
    constructor: function() {
        Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
    },
    getDivider: function() {
        return new Sys.Element({
            tag: "div",
            cls: this.DIVIDER_CSS
        })
    },
    setUpContent: function() {
        var a = this;
        a.wrapper = new Sys.Element({
            id: a.MODULE_NAME,
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.container = new Sys.Element({
            id: a.MODULE_NAME,
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.setupBackground();
        a.setupCloseButton();
        a.setUpMenuButton()
    },
    setupBackground: function() {
        var c = this,
            d = c.wrapper.add(new Sys.Element({
                id: "backgroundTop",
                tag: "div",
                cls: c.BACKGROUND_CSS.top
            })),
            a = c.wrapper.add(new Sys.Element({
                id: "backgroundMiddle",
                tag: "div",
                cls: c.BACKGROUND_CSS.middle
            })),
            b = c.wrapper.add(new Sys.Element({
                id: "backgroundBottom",
                tag: "div",
                cls: c.BACKGROUND_CSS.bottom
            }));
        d.add(new Sys.Element({
            id: "title",
            tag: "span",
            cls: c.BACKGROUND_CSS.title,
            textContent: c.getTitle()
        }));
        c.top = d;
        b.add(new Sys.Element({
            id: "backgroundArrow",
            tag: "div",
            cls: c.BACKGROUND_CSS.arrow,
            style: "left:" + c.ARROW_LEFT_VALUE + ";"
        }));
        c.container = a
    },
    getTitle: function() {
        return Services.languageManager.getText(this.TITLE)
    },
    setupCloseButton: function() {
        var a = this;
        a.closeButton = new Interface.utils.DOMButton({
            id: "closeButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:hideRequest"),
            hoverCallback: function() {
                a.top.addCls("hover")
            },
            upCallback: function() {
                a.top.removeCls("hover")
            }
        });
        a.container.add(a.closeButton.getContainer())
    },
    setUpMenuButton: function() {
        var a = this;
        a.menuButton = new Interface.utils.DOMButton({
            id: a.MODULE_NAME + "SettingsButton",
            baseCSS: a.MENU_BUTTON_CSS,
            clickCallback: a.onButtonClick.bind(a)
        });
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
            order: a.ORDER,
            element: a.menuButton.getContainer()
        })
    },
    onButtonClick: function() {
        var a = this.model.readData("showing") ? "hide" : "show";
        this.fireEvent("view:" + a + "Request")
    },
    show: function() {
        this.wrapper.el.style.display = "block";
        this.menuButton.addProperty("active", "sectionShowing")
    },
    hide: function() {
        this.wrapper.el.style.display = "none";
        this.menuButton.removeProperty("active", "sectionShowing")
    },
    enable: function(a) {
        this.menuButton.enable(a)
    },
    disable: function(a) {
        this.menuButton.disable(a)
    },
    onUserInputStart: function() {},
    onUserInputEnd: function() {},
    onEnteringIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.enable("notInIdleState")
        }
    },
    onLeavingIdleState: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.disable("notInIdleState")
        }
    },
    onEnableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.enable(b)
        }
    },
    onDisableBasicGamePanel: function(b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.disable(b)
        }
    },
    onFeatureSplashShowing: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.disable("featureSplashShowing")
        }
    },
    onFeatureSplashClosed: function() {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.enable("featureSplashShowing")
        }
    }
};
Interface.StandAloneSettingsSectionView = Sys.extend(Interface.SettingsSectionView, Interface.StandAloneSettingsSectionView, "Interface.StandAloneSettingsSectionView");
Sys.ns("Interface");
Interface.CashField = {
    constructor: function() {
        Interface.CashField.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["orientation"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.CashFieldModel,
            controller: Interface.CashFieldController,
            view: Interface.CashFieldBaseView
        }
    }
};
Interface.CashField = Sys.extend(Core.Module, Interface.CashField, "Interface.CashField");
Sys.ns("Interface");
Interface.CashFieldModel = {
    constructor: function() {
        Interface.CashFieldModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var b = this,
            a = Resources.readData("gameServerInitResponse");
        if (a.playforfun) {
            b.storeData("funPlay", true)
        } else {
            b.storeData("funPlay", false)
        }
    },
    processServerResponse: function(a) {
        var b = this;
        b.checkAndSetState(a);
        b.storeWins(a)
    },
    checkAndSetState: function(a) {
        var b = this;
        if (Sys.isDefined(a.freeRoundsLeft)) {
            if (!b.isState("freerounds")) {
                b.setState("freerounds")
            }
        } else {
            if ((a.nextaction === "freespin" && a.clientaction !== "init")) {
                if (!b.isState("freespin")) {
                    b.setState("freespin")
                }
            } else {
                if (a.clientaction === "init" && Sys.isDefined(a.freespins)) {
                    if (!b.isState("freespinRestore")) {
                        b.setState("freespinRestore")
                    }
                } else {
                    if (a.nextaction === "respin" && a.clientaction !== "init") {
                        if (!b.isState("respin")) {
                            b.setState("respin")
                        }
                    } else {
                        if (a.clientaction === "respin" && a.nextaction === "spin") {
                            if (!b.isState("respinLast")) {
                                b.setState("respinLast")
                            }
                        } else {
                            if (a.clientaction === "init" && a.nextaction === "respin" && !Sys.isDefined(a.freespins)) {
                                if (!b.isState("respinRestore")) {
                                    b.setState("respinRestore")
                                }
                            } else {
                                if (a.clientaction === "freespin" || (a.clientaction === "freespin") && a.nextaction === "spin") {
                                    if (!b.isState("freespinLast")) {
                                        b.setState("freespinLast")
                                    }
                                } else {
                                    if (!b.isState("basic")) {
                                        b.setState("basic")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    resetWins: function() {
        this.storeData("basicWinValues", {
            cents: 0,
            centsTotal: 0
        });
        this.storeData("freespinWinValues", {
            totalWinCents: 0
        })
    },
    storeWins: function(a) {
        var b = this;
        if (Sys.isDefined(a.wins)) {
            b.storeData("basicWinValues", {
                cents: a.wins.cents || 0,
                centsTotal: a.wins.centsTotal || 0
            });
            Services.storage.storeData("cashField.winInCents", a.wins.centsTotal)
        }
        if (Sys.isDefined(a.wins)) {
            b.storeData("freespinWinValues", {
                totalWinCents: a.wins.centsTotal || 0
            })
        }
        if (Sys.isDefined(a.freeRoundsLeft)) {
            b.storeData("freeroundValues", {
                left: a.freeRoundsLeft,
                totalWin: a.freeRoundsWinTot
            });
            b.storeData("basicWinValues", {
                cents: a.freeRoundsWinTot || 0,
                centsTotal: a.freeRoundsWinTot || 0
            })
        }
    },
    setBetValues: function(a) {
        this.storeData("betValues", a)
    },
    setBalanceValues: function(a) {
        this.storeData("balanceValues", a)
    }
};
Interface.CashFieldModel = Sys.extend(Core.Model, Interface.CashFieldModel, "Interface.CashFieldModel");
Sys.ns("Interface");
Interface.CashFieldController = {
    TOGGLE_SEQUENCE: [{
        action: "creditBetWin",
        displayDuration: 10000
    }, {
        action: "funPlay",
        displayDuration: 3000
    }],
    constructor: function() {
        Interface.CashFieldController.superclass.constructor.apply(this, arguments);
        this.dispatchAppendToRequest()
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringIdleState": this.updateAllAndStartToggling.bind(this, "idle"),
            "notify:stateHandler.enteringSpinningState": this.onSpinningState,
            "notify:stateHandler.enteringBeforeLoaderCloseState": this.updateAllAndStartToggling.bind(this, "beforeLoaderClose"),
            "notify:settingsWindow.open": this.onSettingsWindowOpened,
            "notify:settingsWindow.closed": this.startToggling,
            "notify:serverManager.serverErrorReceived": this.onServerErrorReceived,
            "notify:responseParser.gameConfigurationParsed": this.model.storeWins.bind(this.model),
            "notify:moneyManager.betChanged": this.onBetChanged,
            "notify:moneyManager.balanceChanged": this.onBalanceChanged,
            "notify:standardWin.presentationComplete": this.updateCreditAndWin.bind(this, "idle"),
            "request:cashField.showWin": this.updateCreditAndWin.bind(this, "winPresentation"),
            "request:cashField.showBasicCashValues": this.setSpecifiedStateAndToggle.bind(this, "basic"),
            "notify:freeRounds.ended": this.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": this.onFreeRoundsReInit,
            "notify:responseParser.responseParsed": this.onServerResponse
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    dispatchAppendToRequest: function() {
        this.fireEvent("request:balanceDisplay.appendChild", this.view.getCashDisplayConfig())
    },
    onBetChanged: function(a) {
        var b = this;
        b.model.setBetValues(a);
        b.view.updateValue("bet", b.model.readData("betValues").playerBetFormatted)
    },
    onBalanceChanged: function(a) {
        this.model.setBalanceValues(a);
        this.view.updateValue("credit", a.playerBalanceFormatted);
        this.notifyBalanceChanged(a.playerBalanceCents)
    },
    onFreeRoundsEnded: function() {
        this.setSpecifiedStateAndToggle("basic")
    },
    setSpecifiedStateAndToggle: function(a) {
        if (typeof a === "string") {
            this.model.setState(a);
            this.updateAllAndStartToggling(a)
        }
    },
    onFreeRoundsReInit: function(a) {
        this.model.processServerResponse(a);
        this.updateAllAndStartToggling("freerounds")
    },
    onSpinningState: function() {
        this[this.model.getState() + "UpdateCreditValue"]();
        this.resetWinValue()
    },
    onServerErrorReceived: function() {
        var b = this,
            a = b.model.getState();
        b.model.resetWins();
        b[a + "UpdateWinValues"](a)
    },
    updateCreditAndWin: function(a) {
        var b = this,
            d = b.model.getState(),
            c = Services.moneyManager.getBalanceCents();
        b[d + "UpdateCreditValue"](c);
        b[d + "UpdateWinValues"](a);
        b.notifyBalanceChanged(c)
    },
    notifyBalanceChanged: function(a) {
        this.fireEvent("notify:cashField.update", a)
    },
    updateAllAndStartToggling: function(a) {
        this.updateCreditAndWin(a);
        this.startToggling()
    },
    onFreespinOutro: function() {
        var a = this.model.getState();
        this[a + "UpdateCreditValue"](Services.moneyManager.getBalanceCents());
        this[a + "UpdateWinValues"]("freespinOutro")
    },
    basicUpdateWinValues: function() {
        this.updateBasicWinValue();
        this.view.showSubComponent("creditBetWin")
    },
    freespinUpdateWinValues: function() {
        this.updateFreespinWinValue()
    },
    freespinRestoreUpdateWinValues: function() {
        this.updateFreespinWinValue()
    },
    freespinLastUpdateWinValues: function() {
        this.updateFreespinWinValue()
    },
    respinUpdateWinValues: function() {
        this.updateRespinWinValue()
    },
    respinUpdateCreditValue: function() {},
    respinLastUpdateWinValues: function() {
        this.updateRespinWinValue()
    },
    respinLastUpdateCreditValue: function(a) {
        this.basicUpdateCreditValue(a)
    },
    freeroundsUpdateCreditValue: function() {
        this.view.showSubComponent("freeRounds")
    },
    freeroundsUpdateWinValues: function(b) {
        var c = this,
            d = c.model.readData("freeroundValues").left,
            a = c.model.readData("freeroundValues").totalWin;
        c.view.updateValue("freeRoundTotalWin", a);
        if (b !== "winPresentation") {
            c.view.updateValue("freeRoundLeft", d.toString())
        }
        this.view.showSubComponent("freeRounds")
    },
    freespinUpdateCreditValue: function() {},
    freespinRestoreUpdateCreditValue: function(b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    },
    respinRestoreUpdateCreditValue: function(b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    },
    respinRestoreUpdateWinValues: function() {
        this.updateRespinWinValue()
    },
    freespinLastUpdateCreditValue: function(a) {
        this.basicUpdateCreditValue(a)
    },
    basicUpdateCreditValue: function(b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    },
    updateBasicWinValue: function() {
        var a = this.model.readData("basicWinValues");
        if (a.cents) {
            this.view.updateWinValue(a.cents)
        }
    },
    updateFreespinWinValue: function() {
        var a = this.model.readData("freespinWinValues");
        if (a.totalWinCents) {
            this.view.updateWinValue(a.totalWinCents)
        }
    },
    updateRespinWinValue: function() {
        var a = this.model.readData("basicWinValues");
        if (a.centsTotal) {
            this.view.updateWinValue(a.centsTotal)
        }
    },
    resetWinValue: function() {
        if (this.model.isState("basic") || this.model.isState("respinLast") || this.model.isState("freespinLast")) {
            this.view.updateWinValue(0)
        }
    },
    onSettingsWindowOpened: function() {
        var a = this;
        clearTimeout(a.toggleTimeout);
        if (a.model.isState("freerounds")) {
            a.view.showSubComponent("freeRounds")
        } else {
            a.view.showSubComponent("creditBetWin", true)
        }
    },
    startToggling: function() {
        var a = this;
        if (a.model.readData("funPlay") === true) {
            clearTimeout(a.toggleTimeout);
            a.model.storeData("nextToggleIndex", 0);
            a.showNextInToggleSequence()
        }
    },
    showNextInToggleSequence: function() {
        var c = this,
            b = c.TOGGLE_SEQUENCE,
            d = c.model.readData("nextToggleIndex"),
            a = b[d];
        c.model.storeData("nextToggleIndex", (d + 1) % b.length);
        c.view.showSubComponent(a.action, true);
        c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
    }
};
Interface.CashFieldController = Sys.extend(Core.Controller, Interface.CashFieldController, "Interface.CashFieldController");
Sys.ns("Interface");
Interface.CashFieldBaseView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base",
        PORTRAIT: "interface-cashField_portrait",
        LANDSCAPE: "interface-cashField_landscape",
        SUB_COMPONENT: "interface-cashField_subComponent"
    },
    RESOLUTION: Environment.determineResolution().resolution,
    SCREEN_SIZE: Utils.Platform.getViewportOuterSize(),
    FIRST_CHILD: false,
    constructor: function() {
        Interface.CashFieldBaseView.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Interface.CashFieldBaseView.superclass.init.apply(a, arguments);
        a.displays = a.getDisplayConfig();
        a.getLocalText = function(b) {
            return Services.languageManager.getText(b)
        };
        a.getFormattedCentsValue = function(b, c) {
            return Services.moneyManager.formatMoneyCurrencySign(b, c)
        };
        a.constructDOMElements()
    },
    showSubComponent: function(b, d) {
        var c = this,
            a = c.model.readData("currentlyShowingElement");
        if ((!c.model.readData("funPlay") && a !== c[b]) || (a !== c[b] && c.model.readData("funPlay") && d)) {
            if (Sys.isDefined(a)) {
                c.hideElement(a)
            }
            c.showElement(c[b]);
            c.model.storeData("currentlyShowingElement", c[b])
        }
    },
    hideElement: function(a) {
        a.el.style.visibility = "hidden"
    },
    showElement: function(a) {
        a.el.style.visibility = "visible"
    },
    getDisplayConfig: function() {
        var a = this;
        return {
            credit: {
                wrapper: a.creditWrapper,
                displayID: "credit",
                textID: Language.Keys.cashColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            bet: {
                wrapper: a.betWrapper,
                displayID: "bet",
                textID: Language.Keys.betColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            win: {
                wrapper: a.winWrapper,
                displayID: "win",
                textID: Language.Keys.winColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            funPlay: {
                wrapper: a.funPlayWrapper,
                displayID: "funPlay",
                textID: Language.Keys.playingForFun,
                display: {}
            },
            freeRoundLeft: {
                wrapper: a.freeRoundLeftWrapper,
                displayID: "freeRoundLeft",
                textID: Language.Keys.freeRoundsLeftColon,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            freeRoundTotalWin: {
                wrapper: a.freeRoundTotalWinWrapper,
                displayID: "freeRoundTotalWin",
                textID: Language.Keys.totalWinColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            }
        }
    },
    getCashDisplayConfig: function() {
        return this.cashDisplay
    },
    constructDOMElements: function() {
        var b = this,
            a = b.displays;
        b.cashDisplay = new Sys.Element({
            tag: "div",
            cls: b.CSS_CLASSES.BASE
        });
        b.creditBetWin = new Sys.Element({
            tag: "div",
            cls: b.CSS_CLASSES.SUB_COMPONENT,
            style: "visibility:hidden;"
        });
        b.freeRounds = new Sys.Element({
            tag: "div",
            cls: b.CSS_CLASSES.SUB_COMPONENT,
            style: "visibility:hidden;"
        });
        b.funPlay = new Sys.Element({
            tag: "div",
            cls: b.CSS_CLASSES.SUB_COMPONENT,
            style: "visibility:hidden;"
        });
        b.constructElement(a.credit);
        b.constructElement(a.bet);
        b.constructElement(a.win);
        b.constructElement(a.funPlay);
        b.constructElement(a.freeRoundLeft);
        b.constructElement(a.freeRoundTotalWin);
        b.creditBetWin.add(a.credit.wrapper);
        b.creditBetWin.add(a.bet.wrapper);
        b.creditBetWin.add(a.win.wrapper);
        b.updateWinValue(0);
        b.cashDisplay.add(b.creditBetWin);
        b.freeRounds.add(a.freeRoundLeft.wrapper);
        b.freeRounds.add(a.freeRoundTotalWin.wrapper);
        b.cashDisplay.add(b.freeRounds);
        b.funPlay.add(a.funPlay.wrapper);
        b.cashDisplay.add(b.funPlay)
    },
    constructTextElement: function(b, f, g) {
        var d = this,
            e = [],
            c, a;
        if (b.contains("{0}")) {
            a = d.getTextStringOrder(b);
            Sys.each(a, function(h) {
                if (typeof h === "string") {
                    e.push(c = new Sys.Element({
                        tag: "span",
                        cls: "text"
                    }));
                    c.el.textContent = h
                } else {
                    if (Sys.isNumber(h)) {
                        e.push(c = new Sys.Element({
                            tag: "span",
                            cls: "text value"
                        }));
                        c.el.textContent = f || "";
                        g.valueElement = c
                    }
                }
            })
        } else {
            e.push(c = new Sys.Element({
                tag: "span",
                cls: "text"
            }));
            c.el.textContent = b
        }
        return e
    },
    constructTextValueWrapper: function() {
        var b = "margin-right:2%;",
            a = "margin-left:2%;";
        return new Sys.Element({
            tag: "div",
            cls: "wrapper",
            style: b + a
        })
    },
    constructElement: function(f) {
        var e = this,
            d, c = (!e.debug) ? e.getLocalText(f.textID) : e.worstCaseSpec[f.displayID].text,
            a = (!e.debug) ? f.value : e.worstCaseSpec[f.displayID].value,
            b = e.constructTextValueWrapper();
        f.wrapper = new Sys.Element({
            tag: "span"
        });
        f.wrapper.addCls("inline");
        f.wrapper.addCls("field");
        f.wrapper.addCls(f.displayID);
        d = e.constructTextElement(c, a, f);
        Sys.each(d, function(g) {
            b.add(g)
        });
        f.wrapper.add(b)
    },
    updateValue: function(b, a) {
        a = (Sys.isNumber(a)) ? this.getFormattedCentsValue(a) : a;
        if (this.displays[b].valueElement.el) {
            this.displays[b].valueElement.el.textContent = a
        }
    },
    updateWinValue: function(a) {
        var b = this;
        if (a >= 0) {
            a = b.getFormattedCentsValue(a)
        } else {}
        if (b.displays.win.valueElement.el) {
            b.displays.win.valueElement.el.textContent = a
        }
    },
    onPortrait: function() {
        var b = this,
            a = b.CSS_CLASSES,
            c = b.cashDisplay;
        c.addCls(a.PORTRAIT);
        c.removeCls(a.LANDSCAPE)
    },
    onLandscape: function() {
        var b = this,
            a = b.CSS_CLASSES,
            c = b.cashDisplay;
        c.addCls(a.LANDSCAPE);
        c.removeCls(a.PORTRAIT)
    },
    getTextStringOrder: function(e) {
        var b = [],
            d = /(\{\d+\})/g,
            a = e.split(d),
            c;
        Sys.each(a, function(f) {
            if (f.match(/\{\d+\}/)) {
                c = f.substring(1, f.length - 1);
                b.push(Sys.utils.toInt(c))
            } else {
                if (e.length > 0) {
                    b.push(f)
                }
            }
        });
        return b
    }
};
Interface.CashFieldBaseView = Sys.extend(Core.View, Interface.CashFieldBaseView, "Interface.CashFieldBaseView");
Sys.ns("Interface");
Interface.CashFieldMobileView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_mobile",
        PORTRAIT: "interface-cashField_portrait_mobile",
        LANDSCAPE: "interface-cashField_landscape",
        SUB_COMPONENT: "interface-cashField_subComponent"
    },
    constructor: function() {
        Interface.CashFieldMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldMobileView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldMobileView, "Interface.CashFieldMobileView");
Sys.ns("Interface");
Interface.CashFieldTabletView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_tablet",
        PORTRAIT: "interface-cashField_portrait interface-cashField_portrait interface-cashField_tablet",
        LANDSCAPE: "interface-cashField_landscape interface-cashField_landscape interface-cashField_tablet",
        SUB_COMPONENT: "interface-cashField_subComponent"
    },
    constructor: function() {
        Interface.CashFieldTabletView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldTabletView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldTabletView, "Interface.CashFieldTabletView");
Sys.ns("Interface");
Interface.CashFieldDesktopView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_desktop interface-cashField_desktop_uri",
        PORTRAIT: "",
        LANDSCAPE: "",
        SUB_COMPONENT: "interface-cashField_subComponent"
    },
    constructor: function() {
        Interface.CashFieldDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldDesktopView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldDesktopView, "Interface.CashFieldDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsField = {
    constructor: function() {
        Interface.Slots.CoinsField.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["orientation"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.Slots.CoinsFieldModel,
            controller: Interface.Slots.CoinsFieldController,
            view: Interface.Slots.CoinsFieldBaseView
        }
    }
};
Interface.Slots.CoinsField = Sys.extend(Core.Module, Interface.Slots.CoinsField, "Interface.Slots.CoinsField");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldModel = {
    WIN_UP_TO: "[MAX COIN WIN]",
    constructor: function() {
        Interface.Slots.CoinsFieldModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("gameMode", "BASIC")
    },
    processServerResponse: function(b) {
        var a = this;
        if (Sys.isDefined(b.wins)) {
            if (Sys.isDefined(b.wins.coinsTotal)) {
                a.storeData("totalWin", b.wins.coinsTotal)
            } else {
                a.storeData("totalWin", "")
            }
            if (Sys.isDefined(b.wins.coins)) {
                a.storeData("win", b.wins.coins)
            } else {
                a.storeData("win", 0)
            }
            if (Sys.isDefined(b.wins.freespins)) {
                a.storeData("additionalFreeSpins", b.wins.freespins)
            } else {
                a.storeData("additionalFreeSpins", 0)
            }
        }
        if (Sys.isDefined(b.freespins) && Sys.isDefined(b.freespins.left)) {
            a.storeData("freeSpinsLeft", b.freespins.left)
        } else {
            a.storeData("freeSpinsLeft", 0)
        }
    },
    setWinToTotalWin: function() {
        this.storeData("win", this.readData("totalWin"))
    },
    getBetText: function() {
        return Services.moneyManager.getBetCoins()
    },
    getBalanceText: function() {
        return Services.moneyManager.getBalanceCoins()
    },
    getWinText: function() {
        var a = this.readData("win");
        return a === 0 ? "" : a
    },
    getProgressiveWinText: function() {
        return this.readData("win")
    },
    getTotalWinText: function() {
        return this.readData("totalWin")
    },
    getTotalWinCountUpValues: function() {
        var b = this.readData("win"),
            a = this.readData("totalWin");
        return {
            from: a - b,
            to: a
        }
    },
    getFreeSpinsLeftText: function() {
        return this.readData("freeSpinsLeft")
    },
    getAdditionalFreeSpinsWonText: function() {
        return this.readData("additionalFreeSpins")
    },
    getWinUpToText: function() {
        return this.WIN_UP_TO
    }
};
Interface.Slots.CoinsFieldModel = Sys.extend(Core.Model, Interface.Slots.CoinsFieldModel, "Interface.Slots.CoinsFieldModel");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldController = {
    TOGGLE_SEQUENCE: [{
        action: "showWin",
        displayDuration: 3000
    }, {
        action: "showBalanceAndBet",
        displayDuration: 3000
    }, {
        action: "showWinUpTo",
        displayDuration: 3000
    }, {
        action: "showBalanceAndBet",
        displayDuration: 3000
    }],
    constructor: function() {
        Interface.Slots.CoinsFieldController.superclass.constructor.apply(this, arguments);
        this.view.setupView()
    },
    setupEvents: function() {
        this.on({
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "notify:stateHandler.enteringBeforeLoaderCloseState": this.onBeforeLoaderClose,
            "notify:stateHandler.enteringIdleState": this.onEnteringIdleState,
            "notify:stateHandler.enteringFreeSpinIntroState": this.onEnteringFreeSpinIntroState,
            "notify:stateHandler.enteringSpinningState": this.onEnteringSpinningState,
            "notify:moneyManager.betChanged": this.onInfoChanged,
            "notify:settingsWindow.open": this.onSettingsWindowOpened,
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:gameModeChanged": this.onGameModeChanged,
            "request:coinsField.showWin": this.onShowWinRequest,
            "request:coinsField.showNormalWin": this.onShowNormalWinRequest,
            "request:coinsField.showProgressiveWin": this.onShowProgressiveWinRequest,
            "request:coinsField.showFreeSpinsLeft": this.showFreeSpinsLeft,
            "request:coinsField.showAdditionalFreeSpinsWon": this.showAdditionalFreeSpinsWon,
            "request:coinsField.countUp": this.view.countUpProgressiveWin.bind(this.view),
            "view:appendToGameFooter": this.onAppendToGameFooter,
            "view:setCountUpCallback": this.onSetCountUpCallback,
            "view:startCountUp": this.onStartCountUp,
            "view:stopCountUp": this.onStopCountUp,
            "view:countUpComplete": this.onCountUpComplete
        })
    },
    onAppendToGameFooter: function(a) {
        this.fireEvent("request:balanceDisplay.appendChild", a)
    },
    onSetCountUpCallback: function(a) {
        this.fireEvent("request:coinsFieldCountUp.setCallback", a)
    },
    onStartCountUp: function(a) {
        this.fireEvent("request:coinsFieldCountUp.start", a)
    },
    onStopCountUp: function() {
        this.fireEvent("request:coinsFieldCountUp.stop")
    },
    onCountUpComplete: function() {
        this.fireEvent("notify:coinsField.countUpComplete")
    },
    initAnimations: function() {
        if (typeof this.view.initAnimations === "function") {
            this.view.initAnimations()
        }
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    onBeforeLoaderClose: function() {
        this.showBalanceAndBet()
    },
    onEnteringIdleState: function() {
        var a = this;
        if (a.model.readData("showProgressiveWinDisplay")) {
            a.model.storeData("showProgressiveWinDisplay", false);
            a.model.setWinToTotalWin()
        }
        if (a.model.readData("hasPlayedInitialRound")) {
            a.startToggling()
        } else {
            a.showBalanceAndBet()
        }
    },
    onEnteringSpinningState: function() {
        var a = this;
        clearTimeout(a.toggleTimeout);
        a.model.storeData("hasPlayedInitialRound", true);
        a.model.storeData("win", "");
        if (a.model.readData("showProgressiveWinDisplay")) {
            a.showProgressiveWin()
        } else {
            a.showBalanceAndBet()
        }
    },
    onEnteringFreeSpinIntroState: function() {
        this.view.onEnteringFreeSpinIntroState()
    },
    onInfoChanged: function() {
        this.view.showBalanceAndBet()
    },
    onSettingsWindowOpened: function() {
        clearTimeout(this.toggleTimeout);
        this.showBalanceAndBet()
    },
    onShowWinRequest: function() {
        if (this.model.readData("showProgressiveWinDisplay")) {
            this.showProgressiveWin()
        } else {
            this.showWin()
        }
    },
    onShowNormalWinRequest: function() {
        var a = this.model;
        if (a.readData("showProgressiveWinDisplay")) {
            a.storeData("showProgressiveWinDisplay", false);
            a.setWinToTotalWin()
        }
        this.showWin()
    },
    onShowProgressiveWinRequest: function(a) {
        this.model.storeData("showProgressiveWinDisplay", true);
        this.showProgressiveWin(a)
    },
    showBalanceAndBet: function() {
        this.view.showBalanceAndBet()
    },
    showWin: function() {
        this.view.showWin()
    },
    showProgressiveWin: function(a) {
        if (a) {
            this.model.storeData("win", "")
        }
        this.view.showProgressiveWin()
    },
    showFreeSpinsLeft: function() {
        this.view.showFreeSpinsLeft()
    },
    showAdditionalFreeSpinsWon: function() {
        this.view.showAdditionalFreeSpinsWon()
    },
    startToggling: function() {
        this.model.storeData("nextToggleIndex", 0);
        this.showNextInToggleSequence()
    },
    showNextInToggleSequence: function() {
        var c = this,
            b = c.TOGGLE_SEQUENCE,
            d = c.model.readData("nextToggleIndex"),
            a = b[d];
        c.model.storeData("nextToggleIndex", (d + 1) % b.length);
        c.view[a.action]();
        c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
    },
    onGameModeChanged: function(a) {
        this.model.storeData("gameMode", a);
        this.view.onGameModeChanged(a)
    }
};
Interface.Slots.CoinsFieldController = Sys.extend(Core.Controller, Interface.Slots.CoinsFieldController, "Interface.Slots.CoinsFieldController");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldBaseView = {
    BASE_CSS: "interface-coinsField_base",
    BACKGROUND_URI: "interface-coinsField_uri",
    PORTRAIT_CSS: "interface-coinsField_portrait",
    LANDSCAPE_CSS: "interface-coinsField_landscape",
    SUB_COMPONENT_CSS: "interface-coinsField_subComponent",
    constructor: function() {
        Interface.Slots.CoinsFieldBaseView.superclass.constructor.apply(this, arguments)
    },
    setupView: function() {
        var d = this,
            g = 0,
            f = "<span class='number'></span>",
            e = "<div class='number' style='display: inline-block; text-align: left; min-width: 3em;'></div>",
            b = "<span class='number'>" + d.model.getWinUpToText() + "</span>",
            c = "margin-right:2%;",
            a = "margin-left:2%;";
        d.container = new Sys.Element({
            id: "coinsField",
            tag: "div",
            cls: d.BASE_CSS + " " + d.BACKGROUND_URI
        });
        d.betAndBalance = d.container.add(new Sys.Element({
            id: "coinsField_betAndBalance",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.balanceDisplay = d.betAndBalance.add(new Sys.Element({
            id: "coinsField_betAndBalance_balanceDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.coinsColonVar).replace("{0}", f),
            style: c
        }));
        d.betDisplay = d.betAndBalance.add(new Sys.Element({
            id: "coinsField_betAndBalance_betDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.betColonVar).replace("{0}", f),
            style: a
        }));
        d.balanceCoinsElement = d.balanceDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.betCoinsElement = d.betDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.win = d.container.add(new Sys.Element({
            id: "coinsField_win",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.winCoinsElement = d.win.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.youWon = d.container.add(new Sys.Element({
            id: "coinsField_youWon",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.youWonCoins).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.youWonCoinsElement = d.youWon.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.progressiveWin = d.container.add(new Sys.Element({
            id: "coinsField_progressiveWin",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.progressiveWinDisplay = d.progressiveWin.add(new Sys.Element({
            id: "coinsField_progressiveWin_winDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", e),
            style: c
        }));
        d.totalWinDisplay = d.progressiveWin.add(new Sys.Element({
            id: "coinsField_progressiveWin_totalWinDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.totalWinColonVar).replace("{0}", e),
            style: a
        }));
        d.progressiveWinCoinsElement = d.progressiveWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
        d.totalWinCoinsElement = d.totalWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
        d.freeSpinsLeft = d.container.add(new Sys.Element({
            id: "coinsField_freeSpinsLeft",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.freeSpinsLeftColonVar).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.freeSpinsLeftNumberElement = d.freeSpinsLeft.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.additionalFreeSpinsWon = d.container.add(new Sys.Element({
            id: "coinsField_additionalFreeSpinsWon",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.additonalFreeSpinsWon).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.additionalFreeSpinsNumberElement = d.additionalFreeSpinsWon.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.winUpTo = d.container.add(new Sys.Element({
            id: "coinsField_winUpTo",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.winUpTo).replace("{0}", b),
            style: "visibility:hidden; z-index:" + g + ";"
        }));
        d.fireEvent("view:appendToGameFooter", d.container)
    },
    showBalanceAndBet: function() {
        var a = this;
        a.betCoinsElement.textContent = a.model.getBetText();
        a.balanceCoinsElement.textContent = a.model.getBalanceText();
        a.show(a.betAndBalance)
    },
    showWin: function() {
        var a = this,
            b = a.model.getWinText();
        if (b > 0) {
            a.youWonCoinsElement.textContent = b;
            a.show(a.youWon)
        } else {
            a.winCoinsElement.textContent = b;
            a.show(a.win)
        }
    },
    showProgressiveWin: function() {
        var a = this;
        a.fireEvent("view:stopCountUp");
        a.progressiveWinCoinsElement.textContent = a.model.getProgressiveWinText();
        a.totalWinCoinsElement.textContent = a.model.getTotalWinText();
        a.show(a.progressiveWin)
    },
    countUpCallback: function(a) {
        this.totalWinCoinsElement.textContent = a
    },
    countUpProgressiveWin: function(c) {
        var b = this,
            a = b.model.getTotalWinCountUpValues();
        if (!b.model.readData("hasRegisteredCallback")) {
            b.fireEvent("view:setCountUpCallback", b.countUpCallback.bind(b));
            b.model.storeData("hasRegisteredCallback", true)
        }
        a.duration = c;
        a.fireEventsOnValue = [{
            value: a.to,
            event: "view:countUpComplete",
            scope: b
        }];
        b.progressiveWinCoinsElement.textContent = b.model.getProgressiveWinText();
        b.fireEvent("view:startCountUp", a)
    },
    showFreeSpinsLeft: function() {
        var a = this;
        a.freeSpinsLeftNumberElement.textContent = a.model.getFreeSpinsLeftText();
        a.show(a.freeSpinsLeft)
    },
    showAdditionalFreeSpinsWon: function() {
        var a = this;
        a.additionalFreeSpinsNumberElement.textContent = a.model.getAdditionalFreeSpinsWonText();
        a.show(a.additionalFreeSpinsWon)
    },
    showWinUpTo: function() {
        this.show(this.winUpTo)
    },
    show: function(b) {
        var c = this,
            a = c.model.readData("currentlyShowingElement");
        if (a !== b) {
            if (Sys.isDefined(a)) {
                c.hideElement(a)
            }
            c.showElement(b);
            c.model.storeData("currentlyShowingElement", b)
        }
    },
    hideElement: function(a) {
        a.el.style.visibility = "hidden"
    },
    showElement: function(a) {
        a.el.style.visibility = "visible"
    },
    onEnteringFreeSpinIntroState: function() {},
    onGameModeChanged: function() {}
};
Interface.Slots.CoinsFieldBaseView = Sys.extend(Core.View, Interface.Slots.CoinsFieldBaseView, "Interface.Slots.CoinsFieldBaseView");
Sys.ns("interface.Slots");
Interface.Slots.CoinsFieldMobileView = {
    BASE_CSS: "interface-coinsField_base interface-coinsField_mobile",
    PORTRAIT_CSS: "interface-coinsField_portrait_mobile",
    LANDSCAPE_CSS: "interface-coinsField_landscape_mobile",
    constructor: function() {
        Interface.Slots.CoinsFieldMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.Slots.CoinsFieldMobileView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldMobileView, "Interface.Slots.CoinsFieldMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldDesktopView = {
    GAME_MODES: ["BASIC", "FREESPIN"],
    BASIC_BET_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 160,
            y: 615,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    BASIC_BET_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 160,
            y: 643,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    BASIC_BALANCE_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 1071,
            y: 615,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    BASIC_BALANCE_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 1071,
            y: 643,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    BASIC_BACKGROUND: {
        image: "keypadBackground",
        position: {
            x: 7,
            y: 606,
            width: 1265,
            height: 84
        }
    },
    FREESPIN_BET_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 25,
            y: 656,
            width: 100,
            height: 20
        },
        alignment: {
            horizontal: "right",
            vertical: false
        }
    },
    FREESPIN_BET_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 133,
            y: 656,
            width: 267,
            height: 20
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    FREESPIN_BALANCE_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 1000,
            y: 656,
            width: 100,
            height: 20
        },
        alignment: {
            horizontal: "right",
            vertical: false
        }
    },
    FREESPIN_BALANCE_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 1107,
            y: 656,
            width: 267,
            height: 20
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    FREESPIN_WIN_LABEL: {
        font: "15px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 530,
            y: 580,
            width: 120,
            height: 40
        },
        alignment: {
            horizontal: "right",
            vertical: true
        }
    },
    FREESPIN_WIN_VALUE: {
        font: "22px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 663,
            y: 580,
            width: 150,
            height: 40
        },
        alignment: {
            horizontal: "left",
            vertical: true
        }
    },
    FREESPIN_TOTAL_WIN_LABEL: {
        font: "15px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 530,
            y: 623,
            width: 120,
            height: 40
        },
        alignment: {
            horizontal: "right",
            vertical: true
        }
    },
    FREESPIN_TOTAL_WIN_VALUE: {
        font: "22px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 663,
            y: 623,
            width: 150,
            height: 40
        },
        alignment: {
            horizontal: "left",
            vertical: true
        }
    },
    FREESPIN_BACKGROUND: {
        image: "keypadFreeSpinBackground",
        position: {
            x: 429,
            y: 567,
            width: 421,
            height: 114
        }
    },
    constructor: function() {
        Interface.Slots.CoinsFieldDesktopView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function() {
        var a = this;
        a.initBackground();
        a.initTexts();
        a.onGameModeChanged("BASIC")
    },
    initBackground: function() {
        var h = this,
            c = h.getKeypadLayering(),
            g = new Animation.List({}),
            a = {},
            b = h.GAME_MODES,
            e, d, f, j;
        for (d = -1, f = b.length; ++d < f;) {
            e = b[d];
            j = h[e + "_BACKGROUND"].position;
            a[b[d]] = new Animation.Item({
                top: j.y,
                left: j.x,
                width: j.width,
                height: j.height,
                depth: c["background_" + e.toLowerCase()],
                image: h[e + "_BACKGROUND"].image
            });
            g.add(a[b[d]])
        }
        Game.stage.view.addToRenderLoop(g);
        h.backgroundItems = a
    },
    getKeypadLayering: function() {
        return Layering.Game.Slots.Keypad
    },
    getMainTypes: function() {
        var a = this;
        return {
            BET: {
                LABEL: {
                    defaultMode: "FREESPIN",
                    content: function() {
                        return Services.languageManager.getText(Language.Keys.machinetext_bet)
                    }
                },
                VALUE: {
                    defaultMode: "FREESPIN",
                    content: function() {
                        return a.model.getBetText()
                    }
                }
            },
            BALANCE: {
                LABEL: {
                    defaultMode: "FREESPIN",
                    content: function() {
                        return Services.languageManager.getText(Language.Keys.machinetext_coins)
                    }
                },
                VALUE: {
                    defaultMode: "FREESPIN",
                    content: function() {
                        return a.model.getBalanceText()
                    }
                }
            },
            WIN: {
                LABEL: {
                    modes: ["FREESPIN"],
                    defaultMode: "FREESPIN",
                    content: function() {
                        return Services.languageManager.getText(Language.Keys.winColon_uc)
                    }
                },
                VALUE: {
                    modes: ["FREESPIN"],
                    defaultMode: "FREESPIN",
                    content: function() {
                        return a.model.getWinText()
                    }
                }
            },
            TOTAL_WIN: {
                LABEL: {
                    modes: ["FREESPIN"],
                    defaultMode: "FREESPIN",
                    content: function() {
                        return Services.languageManager.getText(Language.Keys.totalWinColon_uc)
                    }
                },
                VALUE: {
                    modes: ["FREESPIN"],
                    defaultMode: "FREESPIN",
                    content: function() {
                        return a.model.getTotalWinText()
                    }
                }
            }
        }
    },
    initTexts: function() {
        var f = this,
            g = new Animation.List({}),
            d = f.GAME_MODES,
            a = d.length,
            e = {},
            c, b;
        for (b = -1; ++b < a;) {
            c = d[b];
            e[c] = f.getTextsForGameMode(c, g)
        }
        f.textItems = e;
        f.updateTexts();
        Game.stage.view.addToRenderLoop(g)
    },
    getTextsForGameMode: function(k, f) {
        var h = this,
            b = h.getKeypadLayering(),
            g = h.getMainTypes(),
            j = Object.keys(g),
            d = j.length,
            a = {},
            e, c;
        for (c = -1; ++c < d;) {
            e = j[c];
            a[e] = h.createTextItems(e, g[e], b[e.toLowerCase()], f, k)
        }
        return a
    },
    createTextItems: function(j, f, s, o, k) {
        var q = this,
            c = {},
            l, b, a, g, h, t = Object.keys(f),
            n = t.length,
            e, r, p, d, m;
        for (m = -1; ++m < n;) {
            e = t[m];
            l = f[e];
            b = Sys.isDefined(l.defaultMode) ? l.defaultMode : false;
            a = k + "_" + j + "_" + e;
            g = b + "_" + j + "_" + e;
            r = Sys.isDefined(q[a]) ? q[a].position : q[g].position;
            h = q.getAlignment(a, g);
            if (Sys.isObj(l) && Sys.isArray(l.modes)) {
                if (l.modes.contains(k)) {
                    l = l.content
                } else {
                    continue
                }
            }
            p = this.initTextItem(r.width, r.height, r.x, r.y, s, b, h);
            d = (typeof l === "function") ? l : l.content;
            c[e] = {
                item: p,
                valueFunction: d
            };
            o.add(p);
            p.stop()
        }
        return c
    },
    updateTexts: function() {
        var d = this,
            c = d.GAME_MODES,
            e = d.model.readData("gameMode"),
            a = c.length,
            b;
        if (Sys.isDefined(d.textItems)) {
            for (b = -1; ++b < a;) {
                d.updateMainTypesTexts(d.textItems[c[b]], e, (c[b] === e))
            }
        }
    },
    updateMainTypesTexts: function(a, d, b) {
        var g = Object.keys(a),
            f = g.length,
            e, c;
        for (c = -1; ++c < f;) {
            e = g[c];
            this.updateSubTypeTexts(a[e], d, b, e)
        }
    },
    updateSubTypeTexts: function(h, j, f, e) {
        var n = this,
            k = Object.keys(h),
            r = k.length,
            p, m, q, b, g, a, d, c, o, l;
        for (g = -1; ++g < r;) {
            p = k[g];
            m = h[p];
            q = m.item;
            b = q.prop;
            a = j + "_" + e + "_" + p;
            d = b.customProps.defaultMainType + "_" + e + "_" + p;
            c = (Sys.isDefined(n[a]) ? n[a].font : n[d].font);
            o = (Sys.isDefined(n[a]) ? n[a].fillstyle : n[d].fillstyle);
            l = n.getAlignment(a, d);
            if (f) {
                n.updateTextItem(q, m.valueFunction.call(n), c, o, l);
                if (!q.prop.running) {
                    q.play()
                }
            } else {
                q.stop()
            }
        }
    },
    initTextItem: function(a, i, g, f, c, h, d) {
        var e = this,
            b = e.getInMemoryCanvas(a, i);
        if (Sys.isDefined(d)) {
            b.ctx.textAlign = d.horizontal
        }
        return new Animation.Item({
            top: f,
            left: g,
            width: a,
            height: i,
            depth: c,
            image: b.canvas,
            customProps: {
                inMemCanvas: b,
                defaultMainType: h,
                alignment: d
            }
        })
    },
    updateTextItem: function(l, b, c, k, e, i) {
        var a = l.prop,
            h = Sys.isDefined(e) ? e : {
                horizontal: "left",
                vertical: false
            },
            g = h.horizontal === "right" ? a.width : 0,
            d = a.customProps.inMemCanvas,
            f = Animation.utils.text.measureText(b.toString(), c, 0, d.ctx).height / 2,
            j = Sys.isDefined(i) ? i : 20;
        d.ctx.clearRect(0, 0, d.canvas.width, d.canvas.height);
        Animation.utils.text.wrapCanvasText(b.toString(), c, g, f, a.width, j, [{
            fillStyle: k,
            drawType: "fill"
        }], d.ctx, h.vertical)
    },
    getInMemoryCanvas: function(d, a) {
        var c = document.createElement("canvas"),
            b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {
            canvas: c,
            ctx: b
        }
    },
    showBalanceAndBet: function() {
        this.updateTexts()
    },
    showWin: function() {
        this.updateTexts()
    },
    onGameModeChanged: function(g) {
        var f = this,
            b = f.backgroundItems,
            d = f.GAME_MODES,
            c, e, a;
        for (c = -1, a = d.length; ++c < a;) {
            e = b[d[c]];
            if (d[c] === g) {
                e.play()
            } else {
                e.stop()
            }
        }
        this.updateTexts()
    },
    showProgressiveWin: function() {
        this.updateTexts()
    },
    getAlignment: function(b, a) {
        var c = this;
        return Sys.isDefined(c[b]) ? c[b].alignment : c[a].alignment
    },
    countUpCallback: function() {},
    countUpProgressiveWin: function() {
        this.fireEvent("view:countUpComplete")
    },
    showFreeSpinsLeft: function() {},
    showAdditionalFreeSpinsWon: function() {},
    showWinUpTo: function() {},
    show: function() {},
    hideElement: function() {},
    showElement: function() {},
    setupView: function() {}
};
Interface.Slots.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldDesktopView, "Interface.Slots.CoinsFieldDesktopView");
Sys.ns("Interface");
Interface.SettingsWindow = {
    constructor: function() {
        Interface.SettingsWindow.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SettingsWindowController,
            model: Interface.SettingsWindowModel,
            view: Interface.SettingsWindowBaseView
        }
    },
    getMixinDependencies: function() {
        return ["orientation"]
    }
};
Interface.SettingsWindow = Sys.extend(Core.Module, Interface.SettingsWindow, "Interface.SettingsWindow");
Sys.ns("Interface");
Interface.SettingsWindowController = {
    constructor: function() {
        Interface.SettingsWindowController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "view:opened": a.opened,
            "view:close": a.onCloseRequest,
            "view:closed": a.closed,
            "request:settingsWindow.open": a.onOpenRequest,
            "request:settingsWindow.close": a.onCloseRequest,
            "request:settingsWindow.openChild": a.onOpenChildRequest,
            "request:settingsWindow.closeChild": a.onCloseChildRequest,
            "request:settingsWindow.addChild": a.addChild,
            "request:settingsWindow.removeChild": a.removeChild,
            "request:settingsWindow.activateChild": a.activateChild,
            "request:settingsWindow.deactivateChild": a.deactivateChild
        })
    },
    onOpenRequest: function() {
        var a = this;
        if (!a.model.readData("open")) {
            a.open(this.model.readData("currentlyShowingChild"))
        }
    },
    onOpenChildRequest: function(d, a) {
        var b = this,
            c = b.model.isActiveChild(d);
        if (c) {
            if (!b.model.readData("open")) {
                b.open(d, a)
            } else {
                b.openChild(d, a)
            }
        }
    },
    onCloseRequest: function() {
        var a = this;
        if (a.model.readData("open")) {
            a.close()
        }
    },
    onCloseChildRequest: function(b) {
        var a = this;
        if (b === a.model.readData("currentlyShowingChild")) {
            a.close()
        }
    },
    open: function(c, a) {
        var b = this;
        b.model.storeData("open", true);
        b.view.open();
        if (Sys.isDefined(c)) {
            b.openChild(c, a)
        }
    },
    openChild: function(a, c) {
        var d = this,
            b = d.model.readData("currentlyShowingChild");
        if (b !== a) {
            d.model.storeData("currentlyShowingChild", a);
            d.closeChild(b)
        }
        d.fireEvent("notify:settingsWindow.openedChild", a, c);
        d.view.showChild(a)
    },
    close: function() {
        var a = this;
        a.model.storeData("open", false);
        a.closeChild(a.model.readData("currentlyShowingChild"));
        a.view.close()
    },
    closeChild: function(a) {
        this.fireEvent("notify:settingsWindow.closedChild", a)
    },
    opened: function() {
        this.fireEvent("notify:settingsWindow.open")
    },
    closed: function() {
        this.fireEvent("notify:settingsWindow.closed")
    },
    addChild: function(b, a) {
        this.model.addChild(b, a);
        this.view.addChild(a)
    },
    removeChild: function(a) {
        this.view.removeChild(a);
        this.model.removeChild(a)
    },
    activateChild: function(a) {
        this.model.activateChild(a)
    },
    deactivateChild: function(a) {
        this.model.deactivateChild(a)
    }
};
Interface.SettingsWindowController = Sys.extend(Core.Controller, Interface.SettingsWindowController, "Interface.SettingsWindowController");
Sys.ns("Interface");
Interface.SettingsWindowModel = {
    constructor: function() {
        Interface.SettingsWindowModel.superclass.constructor.apply(this, arguments)
    },
    addChild: function(c, a) {
        var b = this.readData("children");
        if (!Sys.isDefined(b[c])) {
            b[c] = {
                active: true,
                config: a
            }
        }
    },
    removeChild: function(a) {
        delete this.readData("children")[a]
    },
    isActiveChild: function(a) {
        var b = this.readData("children")[a];
        return Sys.isDefined(b) && b.active
    },
    getChildConfig: function(a) {
        return this.readData("children")[a].config
    },
    activateChild: function(a) {
        var b = this.readData("children")[a];
        if (!Sys.isDefined(b)) {
            b.active = true
        }
    },
    deactivateChild: function(a) {
        var b = this.readData("children")[a];
        if (!Sys.isDefined(b)) {
            b.active = false
        }
    },
    setupData: function() {
        this.storeData("children", {});
        this.storeData("open", false)
    }
};
Interface.SettingsWindowModel = Sys.extend(Core.Model, Interface.SettingsWindowModel, "Interface.SettingsWindowModel");
Sys.ns("Interface");
Interface.SettingsWindowBaseView = {
    BASE_CSS: "interface-settingsWindow_base",
    PORTRAIT_CSS: "interface-settingsWindow_portrait",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape",
    HEADER_CSS: "interface-settingsWindow_header interface-settingsSection_subSection_uri",
    CONTENT_CSS: "interface-settingsWindow_content",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.SettingsWindowBaseView.superclass.constructor.apply(this, arguments)
    },
    open: function() {
        this.container.el.style.display = "block";
        this.fireEvent("view:opened")
    },
    close: function() {
        this.container.el.style.display = "none";
        this.fireEvent("view:closed")
    },
    adaptToOrientation: function(a) {
        this.setStyle(a)
    },
    addChild: function(a) {
        this.content.add(a.content)
    },
    removeChild: function(a) {
        this.content.remove(this.model.getChildConfig(a).content)
    },
    showChild: function(a) {
        if (Utils.Platform.isPortrait()) {
            this.open()
        }
        this.setTitle(this.model.getChildConfig(a).title)
    },
    init: function() {
        var a = this;
        Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
        a.closeAnimation = {};
        a.openAnimation = {};
        a.setupDOMStructure()
    },
    setupDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "settingsWindow",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET
        });
        a.header = a.container.add(new Sys.Element({
            id: "settingsWindowHeader",
            tag: "div",
            cls: a.HEADER_CSS
        }));
        a.content = a.container.add(new Sys.Element({
            id: "settingsWindowContent",
            tag: "div",
            cls: a.CONTENT_CSS
        }))
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:childAdded": a.addChild,
            "model:childRemoved": a.removeChild,
            "model:showChild": a.showChild
        })
    },
    removeAnimations: function() {
        var a = this;
        if (Sys.isDefined(a.openAnimation.LANDSCAPE)) {
            a.openAnimation.LANDSCAPE.removeAnimation(a.container.el)
        }
        if (Sys.isDefined(a.openAnimation.PORTRAIT)) {
            a.openAnimation.PORTRAIT.removeAnimation(a.container.el)
        }
    },
    setTitle: function(a) {
        this.header.el.textContent = a
    }
};
Interface.SettingsWindowBaseView = Sys.extend(Core.View, Interface.SettingsWindowBaseView, "Interface.SettingsWindowBaseView");
Sys.ns("Interface");
Interface.SettingsWindowMobileView = {
    PORTRAIT_CSS: "interface-settingsWindow_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape_mobile",
    constructor: function() {
        Interface.SettingsWindowMobileView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function(a) {
        Interface.SettingsWindowMobileView.superclass.adaptToOrientation.call(this, a);
        this.setHeight(a)
    },
    setHeight: function(a) {
        if (Utils.Platform.isPortrait(a)) {
            this.container.el.style.height = (Environment.determineResolution().resolution.height + Environment.getSpaceBelowGame()) + "px"
        } else {
            this.container.el.style.height = ""
        }
    }
};
Interface.SettingsWindowMobileView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowMobileView, "Interface.SettingsWindowMobileView");
Sys.ns("Interface");
Interface.SettingsWindowDesktopView = {
    BASE_CSS: "interface-settingsWindow_base",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape_desktop",
    CLOSE_BUTTON_CSS: "interface-settingsWindow_desktop_closeButton interface-settingsWindow_closeButton_uri",
    constructor: function() {
        Interface.SettingsWindowDesktopView.superclass.constructor.apply(this, arguments)
    },
    setupDOMStructure: function() {
        var a = this;
        Interface.SettingsWindowDesktopView.superclass.setupDOMStructure.apply(a, arguments);
        a.closeButton = new Interface.utils.DOMButton({
            id: "settingsWindowCloseButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:close"),
            enabled: false
        });
        a.container.add(a.closeButton.getContainer())
    },
    open: function() {
        Interface.SettingsWindowDesktopView.superclass.open.apply(this, arguments);
        this.closeButton.enable("sectionClosed")
    },
    close: function() {
        Interface.SettingsWindowDesktopView.superclass.close.apply(this, arguments);
        this.closeButton.disable("sectionClosed")
    }
};
Interface.SettingsWindowDesktopView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowDesktopView, "Interface.SettingsWindowDesktopView");
Sys.ns("Interface");
Interface.SettingsMenu = {
    constructor: function() {
        Interface.SettingsMenu.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SettingsMenuController,
            model: Interface.SettingsMenuModel,
            view: Interface.SettingsMenuBaseView
        }
    },
    getMixinDependencies: function() {
        return ["userInput", "orientation"]
    }
};
Interface.SettingsMenu = Sys.extend(Core.Module, Interface.SettingsMenu, "Interface.SettingsMenu");
Sys.ns("Interface");
Interface.SettingsMenuController = {
    constructor: function() {
        Interface.SettingsMenuController.superclass.constructor.apply(this, arguments);
        this.deactivatedAtSpinStart = true
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:settingsMenu.open": a.onOpenRequest,
            "request:settingsMenu.close": a.onCloseRequest,
            "request:settingsMenu.addChild": a.addChild,
            "request:settingsMenu.removeChild": a.removeChild,
            "request:settingsMenu.activateChild": a.activateChild,
            "request:settingsMenu.deactivateChild": a.deactivateChild,
            "notify:stateHandler.enteringIdleState": a.activateChildrenAfterSpin,
            "notify:stateHandler.leavingIdleState": a.deactivateChildrenDuringSpin,
            "notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderFinished,
            "view:contentChanged": a.onContentChangedInView,
            "view:contentClosed": a.onContentClosedInView
        })
    },
    onBeforeLoaderFinished: function() {
        var a = this;
        a.model.storeData("loaderFinished", true);
        if (!a.model.readData("determinedChildSize")) {
            a.view.onBeforeLoaderFinished()
        }
    },
    onModulesFinishedLoading: function() {
        if (this.model.readData("alwaysOpen") === true) {
            this.open()
        }
    },
    onOpenRequest: function(a) {
        var e = this,
            b = e.model.readData("open"),
            d = e.view.canOpenWithoutSelection(),
            c = e.model.readData("lastSelectedChild"),
            f = Sys.isDefined(c);
        if (!f) {
            c = e.model.readData("defaultChild");
            f = Sys.isDefined(c)
        }
        if (!b && (d || (a && f))) {
            e.open();
            if (a && f) {
                e.select(c)
            }
        }
    },
    onCloseRequest: function() {
        var a = this;
        if (a.model.readData("open")) {
            a.close();
            a.deselectCurrentChild()
        }
    },
    open: function() {
        var a = this;
        a.startListeningToUserInput();
        a.model.storeData("open", true);
        a.view.open();
        a.fireEvent("notify:settingsMenu.open")
    },
    close: function() {
        var a = this;
        a.stopListeningToUserInput();
        a.view.close();
        a.model.storeData("open", false);
        a.fireEvent("notify:settingsMenu.closed")
    },
    select: function(a) {
        this.view.selectChildByName(a)
    },
    deselectCurrentChild: function() {
        this.view.deselectCurrentChild()
    },
    addChild: function(c, a) {
        var b = this;
        b.addListener("notify:" + c + ".shown", b.onChildOpened.bind(b, c));
        b.addListener("notify:" + c + ".hidden", b.onChildClosed.bind(b, c));
        b.model.addChild(c, a);
        b.view.addChild(c)
    },
    onChildOpened: function(a) {
        if (!this.model.readData("open")) {
            this.open()
        }
        this.select(a)
    },
    onChildClosed: function(a) {
        if (this.model.readData("currentlySelectedChild") === a) {
            this.deselectCurrentChild()
        }
    },
    removeChild: function(b) {
        var a = this;
        a.removeListener("notify:" + b + ".shown");
        a.removeListener("notify:" + b + ".hidden");
        a.view.removeChild(b);
        a.model.removeChild(b)
    },
    activateChild: function(a) {
        this.model.activateChild(a)
    },
    deactivateChild: function(a) {
        this.model.deactivateChild(a)
    },
    activateChildrenAfterSpin: function() {
        this.model.storeData("inIdleState", true);
        if (this.deactivatedAtSpinStart) {
            this.deactivatedAtSpinStart = false;
            this.toggleChildrenDuringSpin(true)
        }
    },
    deactivateChildrenDuringSpin: function() {
        this.model.storeData("inIdleState", false);
        this.deactivatedAtSpinStart = true;
        this.toggleChildrenDuringSpin(false)
    },
    toggleChildrenDuringSpin: function(e) {
        var a = this.model.getChildrenDisabledDuringSpins(),
            d = a.length,
            c = (e) ? "activateChild" : "deactivateChild",
            b;
        for (b = -1; ++b < d;) {
            a[b].active = (e && a[b].active);
            this.view[c](a[b])
        }
    },
    onPortrait: function() {
        this.view.onPortrait()
    },
    onLandscape: function() {
        this.view.onLandscape()
    },
    onUserInputStart: function(a) {
        if (this.model.readData("open")) {
            this.view.onUserInputStart(a)
        }
    },
    onUserInputMove: function(a) {
        if (this.model.readData("open")) {
            this.view.onUserInputMove(a)
        }
    },
    onUserInputEnd: function(a) {
        if (this.model.readData("open")) {
            this.view.onUserInputEnd(a)
        }
    },
    onContentChangedInView: function(a) {
        this.model.storeData("currentlySelectedChild", a);
        if (typeof a === "string") {
            this.fireEvent("request:" + a + ".show")
        }
    },
    onContentClosedInView: function(c) {
        var b = this,
            a = b.model;
        a.storeData("lastSelectedChild", c);
        if (a.readData("currentlySelectedChild") === c) {
            a.storeData("currentlySelectedChild", undefined);
            if (!b.view.canOpenWithoutSelection()) {
                b.close()
            }
        }
        if (typeof c === "string") {
            b.fireEvent("request:" + c + ".hide")
        }
    }
};
Interface.SettingsMenuController = Sys.extend(Core.Controller, Interface.SettingsMenuController, "Interface.SettingsMenuController");
Sys.ns("Interface");
Interface.SettingsMenuModel = {
    constructor: function() {
        Interface.SettingsMenuModel.superclass.constructor.apply(this, arguments)
    },
    addChild: function(f, c) {
        var e = this,
            d = e.readData("children"),
            b = e.readData("disableDuringSpin"),
            a = Sys.isDefined(c) ? c : {};
        if (!Sys.isDefined(d[f])) {
            d[f] = {
                name: f,
                active: false,
                order: a.order,
                accessibleDuringSpins: a.accessibleDuringSpins,
                toggleOnSelection: (a.toggleOnSelection === true)
            };
            if (Sys.isDefined(a.isDefault) && a.isDefault) {
                e.storeData("defaultChild", f)
            }
            if (!Sys.isDefined(a.accessibleDuringSpins) || !a.accessibleDuringSpins) {
                b.push(d[f])
            }
        }
    },
    removeChild: function(e) {
        var d = this.readData("children"),
            c = d[e],
            a = this.readData("disableDuringSpin"),
            b = a.indexOf(c);
        if (!Sys.isDefined(c)) {
            if (b >= 0) {
                a.splice(b, 1)
            }
            delete(d[e])
        }
    },
    activateChild: function(d) {
        var b = this,
            a = b.readData("children")[d],
            c = b.getChildrenDisabledDuringSpins();
        if (Sys.isDefined(a)) {
            if (c.contains(a)) {
                a.accessibleDuringSpins = true;
                c = c.splice(c.indexOf(a), 1);
                b.storeData("disableDuringSpin", c)
            }
            a.active = true;
            b.fireEvent("model:childActivated", a)
        }
    },
    deactivateChild: function(d) {
        var b = this,
            a = b.readData("children")[d],
            c = b.getChildrenDisabledDuringSpins();
        if (Sys.isDefined(a)) {
            if (!c.contains(a)) {
                a.accessibleDuringSpins = false;
                c.push(a);
                b.storeData("disableDuringSpin", c)
            }
            a.active = false;
            b.fireEvent("model:childDeactivated", a)
        }
    },
    getChildrenDisabledDuringSpins: function() {
        return this.readData("disableDuringSpin")
    },
    setupData: function() {
        var a = this;
        a.storeData("children", {});
        a.storeData("disableDuringSpin", []);
        a.storeData("status", "closed");
        if (Platform.isDesktopDevice) {
            a.storeData("alwaysOpen", true)
        }
    }
};
Interface.SettingsMenuModel = Sys.extend(Core.Model, Interface.SettingsMenuModel, "Interface.SettingsMenuModel");
Sys.ns("Interface");
Interface.SettingsMenuBaseView = {
    BASE_CSS: "interface-settingsMenu_base",
    PORTRAIT_CSS: "interface-settingsMenu_portrait",
    LANDSCAPE_CSS: "interface-settingsMenu_landscape",
    CHILDREN_CSS: "interface-settingsMenu_children",
    CHILD_CSS: "interface-settingsMenu_child_base",
    RENDER_TARGET: "gameWrapper",
    START_INDEX: 2,
    CAN_OPEN_WITHOUT_SELECTION: false,
    constructor: function() {
        Interface.SettingsMenuBaseView.superclass.constructor.apply(this, arguments)
    },
    open: function() {
        var c = this,
            b = c.childElements.getChildren().length,
            a = Utils.Platform.getOrientation();
        c.container.el.style.display = "block";
        if (b > 0 && c.totalChildWidth === 0) {
            c.adaptToOrientation(a)
        }
    },
    canOpenWithoutSelection: function() {
        return this.CAN_OPEN_WITHOUT_SELECTION
    },
    close: function() {
        this.container.el.style.display = "none"
    },
    onUserInputStart: function(c) {
        var b = this,
            a = Sys.UserInputUtils.isCoordinateTarget(b.container.el, c);
        if (a) {
            b.distanceSinceUserInputStart = 0;
            b.prevX = c.x;
            b.scroller.doTouchStart([{
                pageX: c.x,
                pageY: c.y
            }], Date.now())
        }
        b.wasInitialInputTarget = a;
        if (a && !b.shouldScroll) {
            b.onUserInputEnd(c)
        }
    },
    onUserInputMove: function(b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            a.distanceSinceUserInputStart += Math.abs(a.prevX - b.x);
            a.prevX = b.x;
            a.scroller.doTouchMove([{
                pageX: b.x,
                pageY: b.y
            }], Date.now())
        }
    },
    onUserInputEnd: function(d) {
        var c = this,
            e, b, a;
        if (c.wasInitialInputTarget) {
            c.scroller.doTouchEnd(Date.now());
            if (c.distanceSinceUserInputStart < 10) {
                a = Sys.UserInputUtils.getCoordinatesRelativeToElement(d, c.childElements.el).x;
                b = c.getIndexFromPosition(a);
                e = c.getChildFromElement(c.childElements.getChildren()[b]);
                if (Sys.isDefined(e) && e.name === c.model.readData("currentlySelectedChild")) {
                    if (e.toggleOnSelection) {
                        c.deselectCurrentChild()
                    }
                    c.snapToIndex(b)
                } else {
                    c.selectChild(e, b)
                }
            }
        }
        c.wasInitialInputTarget = false
    },
    selectChildByName: function(a) {
        var b = this,
            c = b.model.readData("children")[a];
        if (a !== b.model.readData("currentlySelectedChild") && Sys.isDefined(c)) {
            b.selectChild(c, b.getChildIndex(c))
        }
    },
    deselectCurrentChild: function() {
        var b = this,
            a = b.model.readData("children"),
            c = a[b.model.readData("currentlySelectedChild")];
        if (Sys.isDefined(c)) {
            b.deselectChild(c)
        }
    },
    adaptToOrientation: function(c) {
        var f = this,
            d, g, b, e, a;
        f.setStyle(c);
        setTimeout(function() {
            d = f.model.readData("children");
            g = d[f.model.readData("currentlySelectedChild")];
            b = f.getChildIndex(g);
            e = f.scrollerWrapper.el.clientWidth;
            f.determineChildSize();
            if (Object.keys(d).length > 0 && f.totalChildWidth === 0) {
                return
            }
            f.menuWidth = e;
            f.scroller.setPosition(Math.round(Math.abs(e - f.totalChildWidth)), 0);
            f.scroller.setDimensions(e, 10, f.totalChildWidth + e - f.childWidth, 10);
            if (f.totalChildWidth > e) {
                a = b >= 0 ? b * f.childWidth : f.START_INDEX * f.childWidth;
                f.toggleFade(true);
                f.padding = Math.round((e - f.childWidth) / 2);
                f.shouldScroll = true;
                f.useScrollOffset = true;
                f.childElements.el.style.left = 0;
                f.scroller.scrollTo(a, 0, false)
            } else {
                f.toggleFade(false);
                f.padding = 0;
                f.useScrollOffset = false;
                f.scroller.scrollTo(0, 0, false);
                f.childElements.el.style.left = Math.round((e - f.totalChildWidth) / 2) + "px";
                f.shouldScroll = false
            }
        }, 0)
    },
    selectChild: function(d, a) {
        var c = this,
            b = c.model.readData("children")[c.model.readData("currentlySelectedChild")];
        d.element.addCls("selected");
        c.snapToIndex(a);
        c.fireEvent("view:contentChanged", d.name);
        if (Sys.isDefined(b)) {
            c.deselectChild(b)
        }
    },
    deselectChild: function(a) {
        a.element.removeCls("selected");
        this.fireEvent("view:contentClosed", a.name)
    },
    snapToIndex: function(a) {
        this.scroller.scrollTo(Math.round(a * this.childWidth), 0, true)
    },
    getIndexFromPosition: function(a) {
        var c = Math.floor(a / this.childWidth),
            b = this.childElements.getChildren().length;
        if (c < 0) {
            c = 0
        } else {
            if (c >= b) {
                c = b - 1
            }
        }
        return c
    },
    init: function() {
        var a = this;
        Interface.SettingsMenuBaseView.superclass.init.apply(a, arguments);
        a.childWidth = 0;
        a.totalChildWidth = 0;
        a.menuWidth = 0;
        a.distanceSinceUserInputStart = 0;
        a.closeAnimation = {};
        a.openAnimation = {};
        a.padding = 0;
        a.prevX = 0;
        a.x = 0;
        a.useScrollOffset = false;
        a.shouldScroll = true;
        a.setupDOMStructure()
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:childActivated": a.activateChild,
            "model:childDeactivated": a.deactivateChild
        })
    },
    toggleFade: function(a) {
        var b = (a) ? "block" : "none";
        this.leftFade.el.style.display = b;
        this.rightFade.el.style.display = b
    },
    determineChildSize: function() {
        var c = this,
            e = c.childElements.getChildren(),
            d = e.length,
            a, b;
        if (d === 0) {
            return
        }
        b = Math.ceil(Math.ceil(e[0].getBoundingClientRect().width) * (1 / Services.scaling.getScale()));
        a = b * d;
        if (c.totalChildWidth !== a) {
            c.childElements.el.style.width = a + "px"
        }
        c.totalChildWidth = a;
        c.childWidth = b
    },
    addChild: function(b) {
        var d = this,
            e = d.model.readData("children")[b],
            c = this.createChild(e.name),
            a = d.getNextClosestSibling(e);
        e.left = d.childWidth * e.order;
        e.element = c;
        if (Sys.isDefined(a)) {
            d.childElements.addBefore(c, a.element)
        } else {
            d.childElements.add(c)
        }
        d.determineChildSize()
    },
    removeChild: function(a) {
        var b = this,
            c = b.model.readData("children")[a];
        if (Sys.isDefined(c)) {
            b.childElements.remove(c.element);
            b.determineChildSize()
        }
    },
    activateChild: function(a) {
        a.element.removeCls("deactivated")
    },
    deactivateChild: function(a) {
        a.element.addCls("deactivated")
    },
    setupDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET
        });
        a.touchArea = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_touchArea"
        }));
        a.leftFade = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_leftFade interface-settingsMenu_fade_uri"
        }));
        a.rightFade = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_rightFade interface-settingsMenu_fade_uri"
        }));
        a.scrollerWrapper = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_scrollerWrapper"
        }));
        a.childElements = a.scrollerWrapper.add(new Sys.Element({
            tag: "ul",
            cls: a.CHILDREN_CSS
        }));
        a.scroller = new Scroller(a.scrollCallback.bind(a), {
            scrollingY: false,
            speedMultiplier: 1.5 / Services.scaling.getScale()
        })
    },
    scrollCallback: function(d, c) {
        var a = this,
            b = (a.useScrollOffset) ? ((a.menuWidth - a.childWidth) / 2) : 0;
        if (a.shouldScroll) {
            a.childElements.el.style[Sys.utils.getPrefixedCSSProperty("transform")] = "translate(" + Math.round(-d + b) + "px, " + (-c) + "px)";
            a.x = -d
        }
    },
    createChild: function(c) {
        var b = this,
            a = new Sys.Element({
                tag: "li",
                cls: b.CHILD_CSS
            });
        a.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_child_image interface-settingsMenu_child_" + c + "_uri"
        }));
        return a
    },
    onPortrait: function() {
        this.adaptToOrientation("PORTRAIT")
    },
    onLandscape: function() {
        this.adaptToOrientation("LANDSCAPE")
    },
    getChildIndex: function(a) {
        if (Sys.isDefined(a)) {
            return this.childElements.getChildren().indexOf(a.element.el)
        }
        return -1
    },
    getChildFromElement: function(b) {
        var a = this.model.readData("children"),
            c;
        Sys.iterate(a, function(d, e) {
            if (e.element.el === b) {
                c = e;
                return false
            }
            return undefined
        });
        return c
    },
    getNextClosestSibling: function(c) {
        var b = this.model.readData("children"),
            a;
        Sys.iterate(b, function(d, e) {
            if (e !== c && (e.order > c.order && (!Sys.isDefined(a) || e.order < a.order))) {
                a = e
            }
        });
        return a
    },
    onBeforeLoaderFinished: function() {}
};
Interface.SettingsMenuBaseView = Sys.extend(Core.View, Interface.SettingsMenuBaseView, "Interface.SettingsMenuBaseView");
Sys.ns("Interface");
Interface.SettingsMenuMobileView = {
    PORTRAIT_CSS: "interface-settingsMenu_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsMenu_landscape_mobile",
    constructor: function() {
        Interface.SettingsMenuMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SettingsMenuMobileView = Sys.extend(Interface.SettingsMenuBaseView, Interface.SettingsMenuMobileView, "Interface.SettingsMenuMobileView");
Sys.ns("Interface");
Interface.DesktopSettingsMenu = {
    constructor: function() {
        Interface.DesktopSettingsMenu.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.DesktopSettingsMenuController,
            view: Interface.DesktopSettingsMenuView
        }
    }
};
Interface.DesktopSettingsMenu = Sys.extend(Core.Module, Interface.DesktopSettingsMenu, "Interface.DesktopSettingsMenu");
Sys.ns("Interface");
Interface.DesktopSettingsMenuController = {
    constructor: function() {
        Interface.DesktopSettingsMenuController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:desktopSettingsMenu.addChild": a.view.addChild.bind(a.view),
            "request:desktopSettingsMenu.removeChild": a.view.removeChild.bind(a.view)
        })
    }
};
Interface.DesktopSettingsMenuController = Sys.extend(Core.Controller, Interface.DesktopSettingsMenuController, "Interface.DesktopSettingsMenuController");
Sys.ns("Interface");
Interface.DesktopSettingsMenuView = {
    BASE_CSS: "interface-desktopSettingsMenu_base",
    CHILDREN_CSS: "interface-settingsMenu_children",
    CHILD_CSS: "interface-settingsMenu_child_desktop",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.DesktopSettingsMenuView.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Interface.DesktopSettingsMenuView.superclass.init.apply(a, arguments);
        a.childWidth = 0;
        a.setupDOMStructure();
        a.children = {}
    },
    setupDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET
        });
        a.childElements = a.container.add(new Sys.Element({
            tag: "ul",
            cls: a.CHILDREN_CSS
        }))
    },
    addChild: function(c, b) {
        var d = this,
            e = d.createListItem(b.element),
            a;
        b.element = e;
        a = d.getNextClosestSibling(b);
        d.children[c] = b;
        if (Sys.isDefined(a)) {
            d.childElements.addBefore(e, a.element)
        } else {
            d.childElements.add(e)
        }
    },
    createListItem: function(a) {
        var c = this,
            b = new Sys.Element({
                tag: "li",
                cls: c.CHILD_CSS
            });
        b.add(a);
        return b
    },
    getNextClosestSibling: function(b) {
        var c = this.children,
            a;
        Sys.iterate(c, function(d, e) {
            if (e !== b && (e.order > b.order && (!Sys.isDefined(a) || e.order < a.order))) {
                a = e
            }
        });
        return a
    },
    removeChild: function(a) {
        var b = this,
            c = b.children[a];
        if (Sys.isDefined(c)) {
            b.childElements.remove(c.element)
        }
    }
};
Interface.DesktopSettingsMenuView = Sys.extend(Core.View, Interface.DesktopSettingsMenuView, "Interface.DesktopSettingsMenuView");
Sys.ns("Interface");
Interface.SettingsButton = {
    constructor: function() {
        Interface.SettingsButton.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SettingsButtonController,
            model: Interface.SettingsButtonModel,
            view: Interface.SettingsButtonBaseView
        }
    },
    getMixinDependencies: function() {
        return [{
            userInput: {
                listenToUserInput: true
            }
        }, "orientation", "properties"]
    }
};
Interface.SettingsButton = Sys.extend(Core.Module, Interface.SettingsButton, "Interface.SettingsButton");
Sys.ns("Interface");
Interface.SettingsButtonController = {
    TOGGLE_DELAY: 500,
    constructor: function() {
        Interface.SettingsButtonController.superclass.constructor.apply(this, arguments);
        this.lastToggleOccured = 0
    },
    setupEvents: function() {
        this.on({
            "request:settingsButton.enable": this.enable,
            "request:settingsButton.disable": this.disable,
            "notify:stateHandler.enteringIdleState": this.enable.bind(this, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": this.disable.bind(this, "notInIdleState"),
            "notify:settingsMenu.open": this.onSettingsMenuOpened,
            "notify:settingsMenu.closed": this.onSettingsMenuClosed
        })
    },
    enable: function(a) {
        this.model.removeProperty("disabledByOtherModule", a);
        if (!this.model.hasProperty("disabledByOtherModule")) {
            this.view.enable();
            this.model.storeData("disabled", false)
        }
    },
    disable: function(a) {
        if (!this.model.hasProperty("disabledByOtherModule")) {
            this.view.disable();
            this.model.storeData("disabled", true);
            if (this.model.readData("status") === "open") {
                this.close()
            }
        }
        this.model.addProperty("disabledByOtherModule", a)
    },
    open: function() {
        this.fireEvent("request:settingsMenu.open", true);
        this.model.storeData("status", "open");
        this.view.adaptToOrientation(Utils.Platform.getOrientation())
    },
    close: function() {
        this.fireEvent("request:settingsMenu.close");
        this.model.storeData("status", "closed");
        this.view.adaptToOrientation(Utils.Platform.getOrientation())
    },
    onSettingsMenuOpened: function() {
        this.model.storeData("status", "open");
        this.view.adaptToOrientation(Utils.Platform.getOrientation())
    },
    onSettingsMenuClosed: function() {
        this.model.storeData("status", "closed");
        this.view.adaptToOrientation(Utils.Platform.getOrientation())
    },
    onUserInputStart: function(a) {
        this.view.onUserInputStart(a)
    },
    onUserInputEnd: function(b) {
        var a = (Date.now() - this.lastToggleOccured) < this.TOGGLE_DELAY;
        if (this.model.readData("disabled") || a || !this.view.checkHit(b)) {
            return
        }
        if (this.model.readData("status") === "open") {
            this.close()
        } else {
            this.open()
        }
        this.lastToggleOccured = Date.now()
    }
};
Interface.SettingsButtonController = Sys.extend(Core.Controller, Interface.SettingsButtonController, "Interface.SettingsButtonController");
Sys.ns("Interface");
Interface.SettingsButtonModel = {
    constructor: function() {
        Interface.SettingsButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("status", "closed");
        this.storeData("disabled", true)
    }
};
Interface.SettingsButtonModel = Sys.extend(Core.Model, Interface.SettingsButtonModel, "Interface.SettingsButtonModel");
Sys.ns("Interface");
Interface.SettingsButtonBaseView = {
    BASE_BUTTON_CSS: "interface-settingsButton_baseButton",
    OPEN_URI: "interface-settingsButton_open_uri",
    CLOSED_URI: "interface-settingsButton_closed_uri",
    DISABLE_CSS: "interface-buttonDisable",
    PORTRAIT_CSS: "interface-settingsButton_portrait",
    LANDSCAPE_CSS: "interface-settingsButton_landscape",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.SettingsButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function(a) {
        this.setStyle(a)
    },
    enable: function() {
        this.container.removeCls(this.DISABLE_CSS)
    },
    disable: function() {
        this.container.addCls(this.DISABLE_CSS)
    },
    onUserInputStart: function(a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    checkHit: function(b) {
        var a = false;
        if (this.wasInitialInputTarget) {
            a = Sys.UserInputUtils.isCoordinateTarget(this.container.el, b)
        }
        this.wasInitialInputTarget = false;
        return a
    },
    init: function() {
        var a = this;
        Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
        a.previousCSS = "";
        a.wasInitialInputTarget = false;
        a.setupDOMStructure()
    },
    setStyle: function(b) {
        var c = this,
            a = c.model.readData("status").toUpperCase();
        Mixins.orientation.view.methods.setStyle.apply(c, arguments);
        if (a === "OPEN") {
            c.container.replaceCSSClass(c.CLOSED_URI, c.OPEN_URI)
        } else {
            if (a === "CLOSED") {
                c.container.replaceCSSClass(c.OPEN_URI, c.CLOSED_URI)
            }
        }
    },
    setupDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            cls: a.BASE_BUTTON_CSS + " " + a.CLOSED_URI + " " + a.DISABLE_CSS,
            renderTo: a.RENDER_TARGET
        })
    }
};
Interface.SettingsButtonBaseView = Sys.extend(Core.View, Interface.SettingsButtonBaseView, "Interface.SettingsButtonBaseView");
Sys.ns("Interface");
Interface.SettingsButtonMobileView = {
    PORTRAIT_CSS: "interface-settingsButton_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsButton_landscape_mobile",
    BACKGROUND_CSS: "interface-settingsButton_background",
    constructor: function() {
        Interface.SettingsButtonMobileView.superclass.constructor.apply(this, arguments)
    },
    setStyle: function(a) {
        Interface.SettingsButtonMobileView.superclass.setStyle.apply(this, arguments);
        if (a === "PORTRAIT") {
            this.background.el.style.display = "block"
        } else {
            this.background.el.style.display = "none"
        }
    },
    setupDOMStructure: function() {
        var a = this;
        Interface.SettingsButtonMobileView.superclass.setupDOMStructure.apply(a, arguments);
        a.background = new Sys.Element({
            tag: "div",
            id: "settingsButtonBackground",
            "class": a.BACKGROUND_CSS,
            renderTo: a.RENDER_TARGET
        })
    }
};
Interface.SettingsButtonMobileView = Sys.extend(Interface.SettingsButtonBaseView, Interface.SettingsButtonMobileView, "Interface.SettingsButtonMobileView");
Sys.ns("Interface");
Interface.BetSettings = {
    constructor: function() {
        Interface.BetSettings.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["userInput"],
            desktop: ["userInput", "properties"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.BetSettingsController,
            model: Interface.BetSettingsModel,
            view: Interface.BetSettingsBaseView
        }
    }
};
Interface.BetSettings = Sys.extend(Interface.SettingsSection, Interface.BetSettings, "Interface.BetSettings");
Sys.ns("Interface");
Interface.BetSettingsController = {
    constructor: function() {
        Interface.BetSettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a;
        Interface.BetSettingsController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "notify:moneyManager.betChanged": this.view.update.bind(this.view),
            "notify:settingsManager.settingChanged": this.onSettingChanged,
            "notify:stateHandler.enteringIdleState": this.enable.bind(this, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": this.disable.bind(this, "notInIdleState"),
            "notify:gameModeChanged": this.onGameModeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "notify:stateHandler.enteringspinTypeRespinRestoreState": this.disable.bind(this, "notInIdleState"),
            "request:betSettings.hideCashDisplay": this.view.hideCashDisplay.bind(this.view),
            "request:betSettings.showCashDisplay": this.view.showCashDisplay.bind(this.view),
            "request:enableBasicGamePanel": this.enable,
            "request:disableBasicGamePanel": this.disable,
            "request:betSettings.enable": this.enable,
            "request:betSettings.disable": this.disable,
            "notify:freeRounds.ended": this.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": this.onFreeRoundsReInit
        });
        a = !this.model.readData("inFreerounds");
        this.fireEvent("request:settingsManager.storeData", "betLevel", this.model.readData("betLevel"), a);
        this.fireEvent("request:settingsManager.storeData", "denomination", this.model.readData("denomination"), a)
    },
    initAnimations: function() {
        if (typeof this.view.initAnimations === "function") {
            this.view.initAnimations()
        }
    },
    onFreeRoundsEnded: function() {
        this.model.setupData();
        this.view.reInitSelectorBars();
        this.view.showCashDisplay()
    },
    onFreeRoundsReInit: function() {
        this.model.setupData();
        this.view.reInitSelectorBars()
    },
    onGameModeChanged: function(b) {
        var a = this;
        if (b === "BASIC") {
            a.view.showSelectors();
            a.view.hideFreespinLabels()
        } else {
            a.view.hideSelectors();
            a.view.showFreespinLabels()
        }
    },
    onSettingChanged: function(a, b) {
        if (a === "betLevel" || a === "denomination") {
            this.model.storeData(a, b)
        }
    },
    onUserAction: function(c, b) {
        var a, d = b;
        if (c === "betLevelChanged") {
            a = "betLevel"
        } else {
            if (c === "coinValueChanged") {
                a = "denomination";
                d = this.model.getDenomination(d)
            }
        }
        if (Sys.isDefined(a)) {
            this.fireEvent("request:settingsManager.storeData", a, d, !this.model.readData("inFreerounds"))
        }
    },
    enable: function(a) {
        this.model.storeData("disabled", false);
        this.view.enable(a)
    },
    disable: function(a) {
        this.model.storeData("disabled", true);
        this.view.disable(a)
    }
};
Interface.BetSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.BetSettingsController, "Interface.BetSettingsController");
Sys.ns("Interface");
Interface.BetSettingsModel = {
    constructor: function() {
        Interface.BetSettingsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var k = this,
            b = Services.localStorageManager.readData("ignoreInitialBet") || false,
            h = Resources.readData("gameServerInitResponseObject"),
            g = h.betlevel.standard,
            a = h.denomination.standard,
            d = h.betlevel.all,
            j = h.denomination.all,
            l = [],
            o, n, f = false,
            m, e, c;
        Interface.BetSettingsModel.superclass.setupData.apply(k, arguments);
        if (!Sys.isArray(d)) {
            d = [d]
        }
        if (!Sys.isArray(j)) {
            j = [j]
        }
        k.storeData("inFreerounds", Sys.utils.toInt(h.freeRoundsLeft) > 0);
        if (!Sys.isArray(h.denomination.all)) {
            h.denomination.all = [h.denomination.all]
        }
        o = k.getCustomCoinValues(h.denomination.all);
        n = k.getInitialBetChanges(o, h.betlevel.all);
        if (!k.readData("inFreerounds") && o && n) {
            j = o;
            if (!b) {
                f = true;
                Services.localStorageManager.storeData("ignoreInitialBet", true.toString())
            }
        }
        for (e = 0; e < j.length; e++) {
            l.push(k.getCoinValue(j[e]))
        }
        if (Services.localStorageManager.hasData("betLevel")) {
            m = Number(Services.localStorageManager.readData("betLevel"))
        }
        if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.betlevel)) {
            g = h.bet.betlevel
        } else {
            if (f && n.defaultBetLevel) {
                g = n.defaultBetLevel
            } else {
                if (Sys.isNumber(m) && d.contains(m)) {
                    g = m
                }
            }
        }
        if (Services.localStorageManager.hasData("denomination")) {
            m = Number(Services.localStorageManager.readData("denomination"))
        }
        if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.denomination)) {
            a = h.bet.denomination
        } else {
            if (f && n.defaultCoinValue) {
                a = n.defaultCoinValue
            } else {
                if (Sys.isNumber(m) && j.contains(m)) {
                    a = m
                }
            }
        }
        c = [{
            key: "betLevels",
            defaultValue: d,
            settingsManager: false,
            localStorage: false
        }, {
            key: "updatableBetLevels",
            defaultValue: (d.length > 1),
            settingsManager: false,
            localStorage: false
        }, {
            key: "coinValues",
            defaultValue: l,
            settingsManager: false,
            localStorage: false
        }, {
            key: "updatableCoinValues",
            defaultValue: (l.length > 1),
            settingsManager: false,
            localStorage: false
        }, {
            key: "betLevel",
            defaultValue: g,
            settingsManager: true,
            ignoreLocalStorageValue: true,
            localStorage: !k.readData("inFreerounds"),
            silent: false
        }, {
            key: "denomination",
            defaultValue: a,
            settingsManager: true,
            ignoreLocalStorageValue: true,
            localStorage: !k.readData("inFreerounds"),
            silent: false
        }];
        c.forEach(k.initData, k)
    },
    getCustomCoinValues: function(g) {
        var f = this,
            b = Resources.readData("queryData"),
            h, a, d, e = [],
            c;
        if (!Sys.isDefined(g) || !Sys.isDefined(b["customConfiguration.coinValues"])) {
            return null
        }
        a = f.decodeDataString(b["customConfiguration.coinValues"]);
        if (a.trim().length === 0) {
            return null
        }
        h = a.split(",");
        for (c = 0; c < h.length; c++) {
            d = parseInt(h[c], 10);
            if (g.indexOf(d) === -1) {
                return null
            }
            e.push(d)
        }
        return e.sort(function(j, i) {
            return j - i
        })
    },
    getInitialBetChanges: function(b, e) {
        var a = Resources.readData("queryData"),
            d = parseInt(a["customConfiguration.defaultBetLevel"], 10),
            c = parseInt(a["customConfiguration.defaultCoinValue"], 10);
        if (!Sys.isArray(b) || !Sys.isArray(e) || e.indexOf(d) === -1 || b.indexOf(c) === -1) {
            return null
        }
        return {
            defaultBetLevel: d,
            defaultCoinValue: c
        }
    },
    decodeDataString: function(a) {
        if (a.match(/%/)) {
            return decodeURIComponent(a)
        }
        return a
    },
    storeData: function(a, b) {
        Interface.BetSettingsModel.superclass.storeData.call(this, a, b);
        if (a === "denomination") {
            Interface.BetSettingsModel.superclass.storeData.call(this, "coinValue", this.getCoinValue(b))
        }
    },
    getDenomination: function(a) {
        return a * 100
    },
    getCoinValue: function(a) {
        return a / 100
    }
};
Interface.BetSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.BetSettingsModel, "Interface.BetSettingsModel");
Sys.ns("Interface");
Interface.BetSettingsBaseView = {
    BASE_CSS: "tab interface-betSettings_base",
    SECTION_CSS: "interface-settingsSection_subSection",
    PORTRAIT_CSS: "interface-betSettings_portrait",
    LANDSCAPE_CSS: "interface-betSettings_landscape",
    constructor: function() {
        Interface.BetSettingsBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var b = this,
            a = b.model;
        b.subComponents = [];
        b.container = new Sys.Element({
            id: "BetSettings",
            tag: "div",
            cls: b.BASE_CSS
        });
        b.betDisplays = b.container.add(new Sys.Element({
            tag: "ul",
            "class": "interface-betSettings_betDisplays"
        }));
        b.betInCashDisplay = b.betDisplays.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
            textContent: Services.languageManager.getText(Language.Keys.betInCash)
        }));
        b.betInCashValue = b.betInCashDisplay.add(new Sys.Element({
            tag: "div",
            textContent: "0",
            "class": "interface-betSettings_displayValue"
        }));
        b.betInCoinsDisplay = b.betDisplays.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
            textContent: Services.languageManager.getText(Language.Keys.betInCoins)
        }));
        b.betInCoinsValue = b.betInCoinsDisplay.add(new Sys.Element({
            tag: "div",
            textContent: "0",
            "class": "interface-betSettings_displayValue"
        }));
        b.settings = b.container.add(new Sys.Element({
            tag: "ul",
            "class": "interface-settingsSection_dynamicSliderPosition_container"
        }));
        b.betLevelText = b.settings.add(new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.betLevel)
        }));
        if (!a.readData("updatableBetLevels")) {
            b.betLevelText.el.style.opacity = 0.5
        }
        b.betLevelSlider = b.createBetLevelSlider(a.readData("betLevels"));
        b.betLevelSliderContainer = new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        });
        b.settings.add(b.betLevelSliderContainer).add(b.betLevelSlider.getContainer());
        if (a.readData("updatableBetLevels")) {
            b.subComponents.push(b.betLevelSlider)
        }
        b.coinValueText = b.settings.add(new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.coinValue)
        }));
        if (!a.readData("updatableCoinValues")) {
            b.coinValueText.el.style.opacity = 0.5
        }
        b.coinValueSlider = b.createCoinValueSlider(a.readData("coinValues"));
        b.coinValueSliderContainer = new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        });
        b.settings.add(b.coinValueSliderContainer).add(b.coinValueSlider.getContainer());
        if (a.readData("updatableCoinValues")) {
            b.subComponents.push(b.coinValueSlider)
        }
        b.portraitInformation = b.container.add(new Sys.Element({
            tag: "ul",
            "class": "interface-betSettings_portraitInfo"
        }));
        b.cashBalanceText = b.portraitInformation.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_portraitInfo_label",
            textContent: Services.languageManager.getText(Language.Keys.cashColon)
        }));
        b.cashBalanceValue = b.portraitInformation.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_portraitInfo_numbers"
        }));
        b.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.betSettings_uc),
            content: b.container
        });
        b.fireEvent("view:addToNavigator", "settingsMenu", {
            order: 3,
            isDefault: true
        });
        b.addScrolling();
        if (!b.model.readData("disabled")) {
            b.enable()
        }
        b.update()
    },
    createBetLevelSlider: function(b) {
        var a = b;
        if (!this.model.readData("updatableBetLevels") && a.length === 1) {
            a = [b[0], ""]
        }
        return new Interface.utils.Slider({
            id: "betSettingsBetLevelSlider",
            values: a,
            callback: this.onSliderValueChange.bind(this, "betLevelChanged"),
            showLabels: true
        })
    },
    createCoinValueSlider: function(b) {
        var a = b;
        if (!this.model.readData("updatableCoinValues") && a.length === 1) {
            a = [b[0], ""]
        }
        return new Interface.utils.Slider({
            id: "betSettingsCoinValueSlider",
            values: a,
            callback: this.onSliderValueChange.bind(this, "coinValueChanged"),
            showLabels: true
        })
    },
    onSliderValueChange: function(b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function() {
        var a = this;
        a.callFunctionOnSubComponents("enable");
        a.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
    },
    disable: function() {
        this.callFunctionOnSubComponents("disable")
    },
    show: function() {
        Interface.BetSettingsBaseView.superclass.show.apply(this, arguments);
        this.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
    },
    hideCashDisplay: function() {
        this.portraitInformation.el.style.display = "none"
    },
    showCashDisplay: function() {
        this.portraitInformation.el.style.display = "block"
    },
    update: function() {
        var c = this,
            a = c.model,
            b = Services.moneyManager;
        if (a.readData("updatableBetLevels")) {
            c.betLevelSlider.setValue(c.model.readData("betLevel"), true)
        }
        if (a.readData("updatableCoinValues")) {
            c.coinValueSlider.setValue(c.model.readData("coinValue"), true)
        }
        c.betInCashValue.el.textContent = b.formatMoneyCurrencySign(b.getBetCents());
        c.betInCoinsValue.el.textContent = b.getBetCoins();
        c.cashBalanceValue.el.textContent = b.formatMoneyCurrencySign(b.getBalanceCents())
    },
    hideSelectors: function() {},
    showSelectors: function() {},
    showFreespinLabels: function() {},
    hideFreespinLabels: function() {},
    removeSelectorFromContainer: function(a, b) {
        b.remove(a.getContainer())
    },
    addSelectorToContainer: function(a, b) {
        b.add(a.getContainer())
    },
    reInitSelectorBars: function() {
        var b = this.model.readData("betLevels"),
            a = this.model.readData("coinValues");
        this.removeSelectorFromContainer(this.betLevelSlider, this.betLevelSliderContainer);
        this.removeSelectorFromContainer(this.coinValueSlider, this.coinValueSliderContainer);
        this.betLevelSlider = this.createBetLevelSlider(b);
        this.coinValueSlider = this.createCoinValueSlider(a);
        if (this.model.readData("updatableBetLevels")) {
            this.betLevelText.el.style.opacity = 1;
            if (!Sys.contains(this.subComponents, this.betLevelSlider)) {
                this.subComponents.push(this.betLevelSlider)
            }
        }
        if (this.model.readData("updatableCoinValues")) {
            this.coinValueText.el.style.opacity = 1;
            if (!Sys.contains(this.subComponents, this.coinValueSlider)) {
                this.subComponents.push(this.coinValueSlider)
            }
        }
        this.addSelectorToContainer(this.betLevelSlider, this.betLevelSliderContainer);
        this.addSelectorToContainer(this.coinValueSlider, this.coinValueSliderContainer);
        this.update();
        if (!this.model.readData("disabled")) {
            this.enable()
        }
    }
};
Interface.BetSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.BetSettingsBaseView, "Interface.BetSettingsBaseView");
Sys.ns("Interface");
Interface.BetSettingsDesktopView = {
    GAME_MODES: ["BASIC", "FREESPIN"],
    BASIC_BETLEVEL_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)"
    },
    BASIC_BETLEVEL_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)"
    },
    BASIC_COINVALUE_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)"
    },
    BASIC_COINVALUE_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)"
    },
    FREESPIN_BETLEVEL_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)",
        position: {
            x: 210,
            y: 641,
            width: 100,
            height: 20
        },
        alignment: {
            horizontal: "right",
            vertical: false
        }
    },
    FREESPIN_BETLEVEL_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)",
        position: {
            x: 315,
            y: 641,
            width: 267,
            height: 20
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    FREESPIN_COINVALUE_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)",
        position: {
            x: 877,
            y: 641,
            width: 100,
            height: 20
        },
        alignment: {
            horizontal: "right",
            vertical: false
        }
    },
    FREESPIN_COINVALUE_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)",
        position: {
            x: 982,
            y: 641,
            width: 267,
            height: 20
        },
        alignment: {
            horizontal: "left",
            vertical: false
        }
    },
    BETLEVEL_VALUE_SELECTOR_BASE_POSITION: {
        x: 264,
        y: 629
    },
    COINVALUE_VALUE_SELECTOR_BASE_POSITION: {
        x: 889,
        y: 629
    },
    VALUE_SELECTOR_POSITION_OFFSET_LABEL: {
        x: 0,
        y: -18
    },
    VALUE_SELECTOR_POSITION_OFFSET_VALUE: {
        x: 0,
        y: 9
    },
    VALUE_SELECTOR_RIGHT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_LEFT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_HANDLE_POSITION_OFFSET: undefined,
    VALUE_SELECTOR_HANDLE_DIMENSIONS: undefined,
    VALUE_SELECTOR_HANDLE_COLLISION_BOX: {
        LEFT: {
            xOffset: 7,
            yOffset: 7,
            width: 28,
            height: 37
        },
        RIGHT: {
            xOffset: 9,
            yOffset: 7,
            width: 28,
            height: 37
        }
    },
    VALUE_SELECTOR_BAR_BACKGROUND: undefined,
    VALUE_SELECTOR_BAR_BACKGROUND_DISABLED: undefined,
    VALUE_SELECTOR_BAR_FILL: undefined,
    VALUE_SELECTOR_BAR_FILL_DISABLED: undefined,
    VALUE_SELECTOR_BAR_DIMENSIONS: undefined,
    VALUE_SELECTOR_BAR_POSITIONS_OFFSET: undefined,
    constructor: function() {
        Interface.BetSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function() {
        var a = this;
        a.betLevelLabel = Services.languageManager.getText(Language.Keys.level);
        a.coinValueLabel = Services.languageManager.getText(Language.Keys.machinetext_coinvalue);
        a.keyPadLayering = Layering.Game.Slots.Keypad;
        a.itemList = new Animation.List({});
        a.enabled = true;
        a.initSelectors();
        a.initFreespinItems();
        a.update()
    },
    updateValueItem: function(a, e, c) {
        var f = a.prop,
            b = f.customProps.inMemCanvas.ctx,
            d;
        b.clearRect(0, 0, f.width, f.height);
        d = Animation.utils.text.measureText(e, c.font, 0, b);
        Animation.utils.text.performOperations(e, c.font, 0, d.height / 2, [{
            fillStyle: c.fillstyle,
            drawType: "fill"
        }], b)
    },
    initSelectors: function() {
        var c = this,
            b = c.keyPadLayering,
            a;
        a = c.model.readData("coinValues").map(function(d) {
            return Sys.utils.numberToFixedDigits(d, 3)
        });
        c.selectors = {
            betLevelSelector: new Interface.utils.CanvasValueSelector({
                id: "betLevelSelector",
                x: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("betLevels"),
                callback: c.onValueChange.bind(c, "betLevelChanged"),
                disabled: !c.model.readData("updatableBetLevels"),
                label: Services.languageManager.getText(Language.Keys.level),
                fontLabel: c.BASIC_BETLEVEL_LABEL.font,
                fontValue: c.BASIC_BETLEVEL_VALUE.font,
                fillstyleLabel: c.BASIC_BETLEVEL_LABEL.fillstyle,
                fillstyleValue: c.BASIC_BETLEVEL_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            }),
            coinValueSelector: new Interface.utils.CanvasValueSelector({
                id: "coinValueSelector",
                x: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("coinValues"),
                valueNames: a,
                callback: c.onValueChange.bind(c, "coinValueChanged"),
                disabled: !c.model.readData("updatableCoinValues"),
                label: Services.languageManager.getText(Language.Keys.machinetext_coinvalue),
                fontLabel: c.BASIC_COINVALUE_LABEL.font,
                fontValue: c.BASIC_COINVALUE_VALUE.font,
                fillstyleLabel: c.BASIC_COINVALUE_LABEL.fillstyle,
                fillstyleValue: c.BASIC_COINVALUE_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            })
        }
    },
    reInitSelectorBars: function() {
        Sys.iterate(this.selectors, function(b, a) {
            a.destroy()
        });
        this.initSelectors();
        this.update()
    },
    initFreespinItems: function() {
        var a = this;
        a.betLevelLabelItem = a.initTextItem(a.betLevelLabel, a.FREESPIN_BETLEVEL_LABEL, a.keyPadLayering.betLevelSelector);
        a.betLevelValueItem = a.initTextItem(a.model.readData("betLevel"), a.FREESPIN_BETLEVEL_VALUE, a.keyPadLayering.betLevelSelector);
        a.coinValueLabelItem = a.initTextItem(a.coinValueLabel, a.FREESPIN_COINVALUE_LABEL, a.keyPadLayering.betLevelSelector);
        a.coinValueValueItem = a.initTextItem(a.model.readData("coinValue"), a.FREESPIN_COINVALUE_VALUE, a.keyPadLayering.betLevelSelector);
        a.itemList.addItems([a.betLevelLabelItem, a.betLevelValueItem, a.coinValueLabelItem, a.coinValueValueItem]);
        Game.stage.view.addToRenderLoop(a.itemList);
        a.itemList.stop()
    },
    initTextItem: function(h, c, g) {
        var d = this,
            b = c.position,
            f = d.getInMemoryCanvas(b.width, b.height),
            a = c.alignment.horizontal === "right" ? c.position.width : 0,
            e;
        if (Sys.isDefined(c.alignment)) {
            f.ctx.textAlign = c.alignment.horizontal
        }
        e = Animation.utils.text.measureText(h, c.font, 0, f.ctx);
        Animation.utils.text.performOperations(h, c.font, a, e.height / 2, [{
            fillStyle: c.fillstyle,
            drawType: "fill"
        }], f.ctx);
        return new Animation.Item({
            top: b.y,
            left: b.x,
            width: b.width,
            height: b.height,
            depth: g,
            image: f.canvas,
            customProps: {
                inMemCanvas: f
            }
        })
    },
    getInMemoryCanvas: function(d, a) {
        var c = document.createElement("canvas"),
            b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {
            canvas: c,
            ctx: b
        }
    },
    onValueChange: function(b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    setUpContent: function() {},
    onSliderValueChange: function(b, a) {},
    enable: function(d) {
        var c = this,
            b = c.model.readData("updatableBetLevels"),
            a = c.model.readData("updatableCoinValues");
        c.enabled = true;
        Sys.iterate(c.selectors, function(e) {
            if ((e === "betLevelSelector" && b) || (e === "coinValueSelector" && a)) {
                c.selectors[e].enable(d)
            }
        });
        c.update()
    },
    disable: function(d) {
        var c = this,
            b = c.model.readData("updatableBetLevels"),
            a = c.model.readData("updatableCoinValues");
        c.enabled = false;
        Sys.iterate(c.selectors, function(e) {
            if ((e === "betLevelSelector" && b) || (e === "coinValueSelector" && a)) {
                c.selectors[e].disable(d)
            }
        })
    },
    hideSelectors: function() {
        this.disable("BetSettings");
        Sys.iterate(this.selectors, function(b, a) {
            a.hide("BetSettings")
        })
    },
    showSelectors: function() {
        this.enable("BetSettings");
        Sys.iterate(this.selectors, function(b, a) {
            a.show("BetSettings")
        })
    },
    showFreespinLabels: function() {
        this.itemList.play()
    },
    hideFreespinLabels: function() {
        this.itemList.stop()
    },
    update: function() {
        var b = this,
            a = b.model;
        if (Sys.isDefined(b.selectors) && this.enabled) {
            if (a.readData("updatableBetLevels")) {
                b.selectors.betLevelSelector.update(b.model.readData("betLevel"));
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.selectors.coinValueSelector.update(b.model.readData("coinValue"));
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
        if (Sys.isDefined(b.coinValueValueItem && b.betLevelValueItem)) {
            if (a.readData("updatableBetLevels")) {
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
    },
    hideCashDisplay: function() {},
    showCashDisplay: function() {}
};
Interface.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsBaseView, Interface.BetSettingsDesktopView, "Interface.BetSettingsDesktopView");
Sys.ns("Interface");
Interface.GameHistory = {
    constructor: function() {
        Interface.GameHistory.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.GameHistoryController,
            model: Interface.GameHistoryModel,
            view: Interface.GameHistoryBaseView
        }
    }
};
Interface.GameHistory = Sys.extend(Interface.SettingsSection, Interface.GameHistory, "Interface.GameHistory");
Sys.ns("Interface");
Interface.GameHistoryController = {
    constructor: function() {
        Interface.GameHistoryController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Interface.GameSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:gameHistory.open": a.openGameHistory,
            "view:gameHistory.open": a.openGameHistory
        })
    },
    onUserAction: function(a) {
        if (a === "goToHistory") {
            this.openGameHistory()
        }
    },
    openGameHistory: function() {
        var a = Sys.utils.sanitizeURL(Resources.readData("historyUrl"));
        this.openWindow(a)
    },
    openWindow: function(a) {
        window.open(a, "gameHistory").focus()
    }
};
Interface.GameHistoryController = Sys.extend(Interface.SettingsSectionController, Interface.GameHistoryController, "Interface.GameHistoryController");
Sys.ns("Interface");
Interface.GameHistoryModel = {
    constructor: function() {
        Interface.GameHistoryModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponse") || {};
        if (a.playforfun) {
            this.storeData("disabled", true)
        } else {
            if (Sys.isDefined(a.historybutton) && !a.historybutton) {
                this.storeData("removed", true)
            }
        }
    }
};
Interface.GameHistoryModel = Sys.extend(Core.Model, Interface.GameHistoryModel, "Interface.GameHistoryModel");
Sys.ns("Interface");
Interface.GameHistoryBaseView = {
    BASE_CSS: "tab interface-gameHistory_base",
    PORTRAIT_CSS: "interface-gameHistory_portrait",
    LANDSCAPE_CSS: "interface-gameHistory_landscape",
    BUTTON_BASE_CSS: "button interface-gameHistory_button",
    BUTTON_DISABLED_CSS: "interface-gameHistory_buttonDisabled",
    BUTTON_PRESSED_CSS: "interface-gameHistory_buttonPressed",
    constructor: function() {
        Interface.GameHistoryBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "gameHistory",
            tag: "div",
            cls: a.BASE_CSS
        });
        a.text = a.container.add(new Sys.Element({
            id: "gameHistoryDisabledText",
            tag: "div",
            style: "margin-top: 10%;"
        }));
        a.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
        a.button = new Interface.utils.Button({
            id: "gameHistoryButton",
            CSS: {
                base: a.BUTTON_BASE_CSS,
                disabled: a.BUTTON_DISABLED_CSS
            }
        });
        a.container.add(a.button.getContainer());
        a.button.setText(Services.languageManager.getText(Language.Keys.gameHistory));
        if (a.model.readData("disabled")) {
            a.disable()
        }
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameHistory_uc),
            content: a.container
        });
        if (!a.model.readData("removed")) {
            a.fireEvent("view:addToNavigator", "settingsMenu", {
                order: 5
            })
        }
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    enable: function() {
        this.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
        this.button.enable()
    },
    disable: function() {
        this.text.el.textContent = Services.languageManager.getText(Language.Keys.historyNotAvailable);
        this.button.disable()
    },
    onUserInputStart: function(b) {
        var a = this;
        if (!a.model.readData("disabled") && Sys.UserInputUtils.isCoordinateTarget(a.button.getContainer().getEl(), b)) {
            a.model.storeData("buttonPressed", true);
            a.container.addCls(a.PRESSED_CSS)
        }
    },
    onUserInputEnd: function(c) {
        var b = this,
            a = this.model.readData("buttonPressed");
        b.model.storeData("buttonPressed", false);
        b.container.removeCls(this.PRESSED_CSS);
        if (a && Sys.UserInputUtils.isCoordinateTarget(b.button.getContainer().getEl(), c)) {
            b.fireEvent("view:gameHistory.open")
        }
    }
};
Interface.GameHistoryBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameHistoryBaseView, "Interface.GameHistoryBaseView");
Sys.ns("Interface");
Interface.GameRules = {
    constructor: function() {
        Interface.GameRules.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return [{
            userInput: {
                inputEvents: ["start", "end", "cancel", "move", "scroll"]
            }
        }, "orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.GameRulesController,
            model: Interface.GameRulesModel,
            view: Interface.GameRulesBaseView
        }
    }
};
Interface.GameRules = Sys.extend(Interface.SettingsSection, Interface.GameRules, "Interface.GameRules");
Sys.ns("Interface");
Interface.GameRulesController = {
    constructor: function() {
        Interface.GameRulesController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var b = this,
            a = b.model.readData("gameRulesURL");
        Interface.GameRulesController.superclass.setupEvents.apply(b, arguments);
        b.on({
            "notify:stateHandler.enteringspinTypeRespinRestoreState": b.view.disableButton.bind(b.view),
            "view:gameRules.open": b.openGameRulesURL
        });
        if (Sys.isGcmEnabled || (typeof a !== "undefined" && (a === "undefined" || a === ""))) {
            b.removeListener("view:addToNavigator")
        }
    },
    show: function() {
        var a = this;
        if (!a.model.readData("hasLoadedGameRules") && !a.model.isState("fetchingGameRules") && typeof a.model.readData("gameRulesURL") === "undefined") {
            a.model.setState("fetchingGameRules");
            a.fetchGameRules()
        }
        Interface.GameRulesController.superclass.show.apply(a, arguments)
    },
    fetchGameRules: function() {
        var b = this,
            a = new Sys.Deferred();
        a.when(Sys.utils.httpGet({
            url: b.model.readData("templateURL")
        }), Sys.utils.httpGet({
            url: b.model.readData("textURL")
        }), Sys.utils.httpGet({
            url: b.model.readData("manifestURL")
        })).fail(b.onRulesLoadingFailed, b).done(b.onRulesPartsFetched, b)
    },
    onRulesPartsFetched: function(c, b, a) {
        this.model.processGameRules(c, b, a);
        this.view.updateContent()
    },
    onRulesLoadingFailed: function() {},
    openGameRulesURL: function() {
        var a = this.model.readData("gameRulesURL");
        if (Platform.isMobileDevice || Platform.isTabletDevice) {
            window.location.href = a
        } else {
            if (Platform.isDesktopDevice) {
                window.open(a, "gameRules").focus()
            }
        }
    }
};
Interface.GameRulesController = Sys.extend(Interface.SettingsSectionController, Interface.GameRulesController, "Interface.GameRulesController");
Sys.ns("Interface");
Interface.GameRulesModel = {
    constructor: function() {
        Interface.GameRulesModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var h = this,
            c = Resources.readData("config"),
            b = c.gameRules,
            j = c.gameRulesPath,
            e = Resources.readData("language"),
            l = Resources.readData("queryData"),
            d = l.gameId,
            f = l.jurisdictionCode,
            a = "../",
            g, i, k;
        d = d.replace(/_sw$/, "");
        if (Sys.isDefined(b)) {
            if (Platform.isDesktopDevice) {
                d = (d.indexOf("netent_") > -1) ? "netent_" + b.desktop : b.desktop
            } else {
                d = (d.indexOf("netent_") > -1) ? "netent_" + b.touch : b.touch
            }
        }
        Interface.GameRulesModel.superclass.setupData.apply(this, arguments);
        if (j) {
            i = a + j + "META-INF/MANIFEST.MF";
            g = a + j + "templates/" + d + "." + e.lang + ".html";
            if (f) {
                k = d + "." + f + "." + e.lang + ".html";
                g = a + j + "templates/" + k
            }
        } else {
            g = a + "gamerules/template/" + d + ".template";
            i = a + "gamerules/META-INF/MANIFEST.MF";
            h.storeData("textURL", a + "gamerules/rules/" + e.lang + "/rulestext.xml")
        }
        h.storeData("templateURL", g);
        h.storeData("manifestURL", i);
        h.storeData("hasLoadedGameRules", false);
        if (typeof l.gameRulesURL !== "undefined") {
            h.storeData("gameRulesURL", l.gameRulesURL)
        }
    },
    processGameRules: function(f, c, b) {
        var e = (Resources.readData("config") || {}).gameRulesPath,
            d, a;
        if (!e) {
            d = this.parseTextsToObject(c.responseText);
            a = this.insertTextsInTemplate(f.responseText, d);
            a = this.removeNoncharacters(a);
            a = this.addTimestamp(a, b)
        } else {
            a = this.alterImagePaths(f.responseText)
        }
        a = this.removeLinkTags(a);
        this.storeData("content", a);
        this.storeData("hasLoadedGameRules", true);
        this.setState("idle")
    },
    alterImagePaths: function(a) {
        return a.replace(/src="..\/([\w/.-]*)"/g, "src='../gamerules/$1'")
    },
    parseTextsToObject: function(d) {
        var a = {},
            b = /<ds.+name="([\w\d-]+)"[^>]*>(.+)<\/ds>/g,
            c = document.createElement("div");
        d.replace(b, function(g, e, f) {
            c.innerHTML = f;
            a[e] = c.textContent
        });
        return a
    },
    insertTextsInTemplate: function(b, a) {
        var c = b.replace(/<#([\w\d-]+)#\/>/g, function(d, e) {
            if (a[e]) {
                return a[e]
            } else {
                if (Services.languageManager.hasText(e)) {
                    return Services.languageManager.getText(e)
                }
            }
            return "[rules string '" + e + "' not found]"
        });
        return c
    },
    removeLinkTags: function(a) {
        return a.replace(/<link.+>/g, "")
    },
    addTimestamp: function(a, b) {
        var c = this.parseDateFromManifest(b);
        return a + "<p id='manifest_timestamp' style='margin-top:10px;'>" + c + "</p>"
    },
    removeNoncharacters: function(a) {
        return decodeURIComponent(encodeURIComponent(a).replace(/%EF%BF%BF/g, ""))
    },
    parseDateFromManifest: function(b) {
        var a = this.checkIfRegExpMatch(b.response),
            c;
        b.responseText.replace(a, function(f, d, e) {
            c = d + " " + e + " (UTC)"
        });
        return c
    },
    checkIfRegExpMatch: function(c) {
        var b, a;
        b = /Git-CommitTime:\s([\d\-]+)[T\s]([\d:]+)/;
        a = /Subversion-(?:Commited)?Date: ([\d\-]+)T([\d:]+)/;
        return b.test(c) ? b : a
    }
};
Interface.GameRulesModel = Sys.extend(Core.Model, Interface.GameRulesModel, "Interface.GameRulesModel");
Sys.ns("Interface");
Interface.GameRulesBaseView = {
    BASE_CSS: "tab interface-gameRules_base",
    PORTRAIT_CSS: "interface-gameRules_portrait",
    LANDSCAPE_CSS: "interface-gameRules_landscape",
    RULES_WRAPPER_CSS: "interface-gameRules_rulesWrapper",
    LOADER_CSS: "interface-gameRules_rulesLoader",
    LOADER_URI: "interface-smallSpinner_uri",
    BUTTON_BASE_CSS: "button interface-gameRules_button",
    RULES_URL_WRAPPER_CSS: "interface-gameRules_rulesURLWrapper",
    constructor: function() {
        Interface.GameRulesBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var b = this,
            a = b.model.readData("gameRulesURL");
        b.container = new Sys.Element({
            id: "gameRules",
            tag: "div",
            cls: b.BASE_CSS
        });
        if (typeof a !== "undefined" && (a === "undefined" || a === "")) {
            return
        }
        if (typeof a !== "undefined") {
            b.setUpGameRulesURL()
        } else {
            b.rulesWrapper = b.container.add(new Sys.Element({
                id: "gameRules_rules",
                tag: "div",
                cls: b.RULES_WRAPPER_CSS
            }));
            b.rulesLoader = new Sys.Element({
                tag: "div",
                cls: b.LOADER_CSS + " " + b.LOADER_URI
            })
        }
        b.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameRules_uc),
            content: b.container
        });
        b.fireEvent("view:addToNavigator", "settingsMenu", {
            order: 4
        });
        b.addScrolling();
        if (!b.model.readData("disabled")) {
            b.enable()
        }
        b.hide()
    },
    setUpGameRulesURL: function() {
        var a = this;
        a.rulesWrapper = a.container.add(new Sys.Element({
            id: "gameRules_rulesURLWrapper",
            tag: "div",
            cls: a.RULES_URL_WRAPPER_CSS
        }));
        a.button = new Interface.utils.Button({
            id: "gameRulesButton",
            CSS: {
                base: a.BUTTON_BASE_CSS
            },
            label: Services.languageManager.getText(Language.Keys.gameRules_uc),
            enabled: true,
            clickCallback: function() {
                a.fireEvent("view:gameRules.open")
            }
        });
        a.rulesWrapper.add(a.button.getContainer());
        a.container.add(a.rulesWrapper)
    },
    updateContent: function() {
        var a = this;
        a.rulesWrapper.remove(a.rulesLoader);
        a.rulesWrapper.el.innerHTML = a.model.readData("content");
        a.updateScrollerDimensions()
    },
    show: function() {
        Interface.GameRulesBaseView.superclass.show.apply(this, arguments);
        if (this.model.isState("fetchingGameRules") && this.model.readData("gameRulesURL") === undefined) {
            this.rulesWrapper.add(this.rulesLoader)
        }
    },
    enable: function() {},
    disable: function() {},
    disableButton: function() {
        if (Sys.isDefined(this.abstractButton)) {
            this.abstractButton.disable("notInIdleState")
        }
    }
};
Interface.GameRulesBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameRulesBaseView, "Interface.GameRulesBaseView");
Sys.ns("Interface");
Interface.GameRulesDesktopView = {
    BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameRules_icon_uri",
    WRAPPER_CSS: "tab interface-settingsWindow_content",
    ENABLED_ONLY_IN_BASIC_GAME: true,
    constructor: function() {
        Interface.GameRulesDesktopView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var a = this;
        a.containerWrapper = new Sys.Element({
            id: "containerWrapper",
            tag: "div",
            cls: a.WRAPPER_CSS
        });
        a.container = a.containerWrapper.add(new Sys.Element({
            id: "gameRules",
            tag: "div",
            cls: a.BASE_CSS
        }));
        a.rulesWrapper = a.container.add(new Sys.Element({
            id: "gameRules_rules",
            tag: "div",
            cls: a.RULES_WRAPPER_CSS
        }));
        a.rulesLoader = new Sys.Element({
            tag: "div",
            cls: a.LOADER_CSS + " " + a.LOADER_URI
        });
        a.createButton();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameRules_uc),
            content: a.containerWrapper
        });
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
            order: 4,
            element: a.menuButton
        });
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    createButton: function() {
        var b = this,
            a = b.model.readData("gameRulesURL");
        b.menuButton = new Sys.Element({
            id: "gameRulesButton",
            tag: "div",
            cls: b.BUTTON_CSS
        });
        b.abstractButton = new Interface.AbstractButton({
            dimensions: b.menuButton.el,
            clickCallback: function() {
                if (typeof a !== "undefined" && a !== "undefined" && a !== "") {
                    b.fireEvent("view:gameRules.open");
                    return
                }
                if (!b.model.readData("showing")) {
                    b.fireEvent("view:showRequest")
                } else {
                    b.fireEvent("view:hideRequest")
                }
            },
            hoverCallback: function() {
                b.menuButton.addCls("hover")
            },
            upCallback: function() {
                b.menuButton.removeCls("hover")
            }
        })
    },
    hide: function() {
        this.containerWrapper.el.style.display = "none";
        Interface.GameRulesDesktopView.superclass.hide.apply(this, arguments)
    },
    show: function() {
        this.containerWrapper.el.style.display = "block";
        Interface.GameRulesDesktopView.superclass.show.apply(this, arguments)
    },
    disableButton: function() {
        this.abstractButton.disable("notInIdleState")
    }
};
Interface.GameRulesDesktopView = Sys.extend(Interface.GameRulesBaseView, Interface.GameRulesDesktopView, "Interface.GameRulesDesktopView");
Sys.ns("Interface");
Interface.Paytable = {
    constructor: function() {
        Interface.Paytable.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["userInput", "orientation"],
            desktop: ["userInput"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.PaytableController,
            model: Interface.PaytableModel,
            view: Interface.PaytableBaseView
        }
    }
};
Interface.Paytable = Sys.extend(Interface.SettingsSection, Interface.Paytable, "Interface.Paytable");
Sys.ns("Interface");
Interface.PaytableController = {
    constructor: function() {
        Interface.PaytableController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        Interface.PaytableController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "request:paytable.forward": this.onForwardRequest,
            "request:paytable.backward": this.onBackwardRequest,
            "notify:responseParser.paytableResponseParsed": this.onPaytableResponse,
            "view:pageSwitch": this.fireEvent.bind(this, "notify:paytable.pageSwitched"),
            "notify:gameModeChanged": this.onGameModeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        if (typeof this.view.initAnimations === "function") {
            this.view.initAnimations()
        }
    },
    setUpContent: function() {
        this.fireEvent("request:serverManager.sendAction", "paytable", "notify:responseParser.paytableResponseParsed")
    },
    onPaytableResponse: function(a) {
        this.model.processPaytableResponse(a);
        this.view.setUpContent()
    },
    onShowRequest: function(a) {
        var b = this;
        if (!b.model.readData("showing")) {
            Interface.PaytableController.superclass.onShowRequest.apply(b, arguments)
        } else {
            b.view.show(a)
        }
    },
    onForwardRequest: function() {
        if (this.model.readData("showing")) {
            this.view.showNextPage()
        }
    },
    onBackwardRequest: function() {
        if (this.model.readData("showing")) {
            this.view.showPreviousPage()
        }
    },
    onGameModeChanged: function(a) {
        if (Sys.isDefined(this.view.showButton) && Sys.isDefined(this.view.hideButton)) {
            if (a === "BASIC") {
                this.view.showButton()
            } else {
                this.view.hideButton()
            }
        }
    }
};
Interface.PaytableController = Sys.extend(Interface.SettingsSectionController, Interface.PaytableController, "Interface.PaytableController");
Sys.ns("Interface");
Interface.PaytableModel = {
    constructor: function() {
        Interface.PaytableModel.superclass.constructor.apply(this, arguments)
    },
    setNumberOfPages: function(a) {
        Services.storage.storeData("paytable.numberOfPages", a)
    },
    setCurrentPage: function(a) {
        Services.storage.storeData("paytable.currentPage", a)
    },
    processPaytableResponse: function(a) {
        var b = this,
            c = a.pt,
            d = {};
        Sys.iterate(c, function(f, e) {
            b.parseGameMode(f, e, d)
        });
        b.storeData("paytableInfo", d)
    },
    parseGameMode: function(c, a, e) {
        var d = this,
            b = {
                scatterWins: {},
                betlineWins: {}
            };
        Sys.iterate(a.comp, function(f, g) {
            d.parsePaytableComponent(f, g, b)
        });
        e[a.id] = b
    },
    parsePaytableComponent: function(b, d, a) {
        var g = d.symbol,
            c = d.type + "Wins",
            f = d.n,
            e;
        if (d.type !== "scatter" && d.type !== "betline") {
            return
        }
        if (!Sys.isDefined(a[c][g])) {
            a[c][g] = {
                freeSpins: [],
                betMultiplier: []
            }
        }
        e = a[c][g];
        e.freeSpins[f] = d.freespins;
        e.betMultiplier[f] = d.multi
    },
    getCondensedInfo: function(b, a, c, f) {
        var h = this.readData("paytableInfo")[f || "basic"][c || "betlineWins"][b][a || "betMultiplier"],
            d = 1,
            i = 0,
            g = h[0],
            e = [];
        for (; d < h.length; d++) {
            if (h[d] !== g) {
                e.push({
                    from: i,
                    to: d - 1,
                    value: g
                });
                i = d;
                g = h[d]
            }
        }
        e.push({
            from: i,
            to: d - 1,
            value: g
        });
        return e
    },
    setupData: function() {
        var a = Game.stage.model.getCurrentReelGroupConfiguration();
        this.storeData("symbolWidth", a.symbolWidth);
        this.storeData("symbolHeight", a.symbolHeight);
        Services.storage.storeData("paytable.showing", false)
    }
};
Interface.PaytableModel = Sys.extend(Core.Model, Interface.PaytableModel, "Interface.PaytableModel");
Sys.ns("Interface");
Interface.PaytableBaseView = {
    BASE_CSS: "tab interface-paytable_base",
    PORTRAIT_CSS: "interface-paytable_portrait",
    LANDSCAPE_CSS: "interface-paytable_landscape",
    SECTION_CSS: "interface-paytable_section interface-settingsSection_subSection",
    SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
    HEADING_CSS: "interface-paytable_heading",
    SECTIONS: ["SymbolValues", "Betlines", "Disclaimer"],
    HIGH_WIN: {
        COLOR: "",
        SYMBOLS: []
    },
    MEDIUM_WIN: {
        COLOR: "",
        SYMBOLS: []
    },
    LOW_WIN: {
        COLOR: "",
        SYMBOLS: []
    },
    DISCLAIMER_STRINGS: [Language.Keys.paytable_highest, Language.Keys.paytable_betLineWinsLeftToRightOnly, Language.Keys.paytable_voidAllPays, Language.Keys.paytable_extraInfo],
    constructor: function() {
        Interface.PaytableBaseView.superclass.constructor.apply(this, arguments);
        this.setupContainer();
        this.sectionElements = {}
    },
    setupContainer: function() {
        this.container = new Sys.Element({
            id: "paytable",
            tag: "div",
            cls: this.BASE_CSS
        })
    },
    setUpContent: function() {
        var a = this;
        a.model.setNumberOfPages(1);
        a.model.setCurrentPage(1);
        a.createSections();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.paytable_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {
            order: 3
        });
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    showNextPage: function() {},
    showPreviousPage: function() {},
    createSections: function() {
        var c = this,
            d = c.SECTIONS,
            a = d.length,
            b;
        for (b = -1; ++b < a;) {
            if (typeof c["create" + d[b]] === "function") {
                c["create" + d[b]]()
            }
        }
    },
    createSymbolValues: function() {
        var a = this,
            b = new Sys.Element({
                tag: "div",
                "class": a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
            });
        b.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText(Language.Keys.paytable_symbolPayout),
            "class": a.HEADING_CSS + " utils_center_text"
        }));
        if (a.HIGH_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.HIGH_WIN.SYMBOLS, a.HIGH_WIN.COLOR))
        }
        if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR))
        }
        if (a.LOW_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR))
        }
        a.sectionElements.SymbolValues = b;
        a.container.add(b)
    },
    createSymbolSubSection: function(d, c) {
        var f = this,
            b = new Sys.Element({
                tag: "table",
                "class": "interface-paytable_symbols"
            }),
            a = d.length,
            g, e;
        for (e = -1; ++e < a;) {
            if (e % 2 === 0) {
                g = b.add(new Sys.Element({
                    tag: "tr"
                }))
            }
            f.appendSymbolContainer(g, d[e], c)
        }
        return b
    },
    appendSymbolContainer: function(a, d, e, b, f, l) {
        var j = Resources.readData("animationImages"),
            o = this.model.readData("symbolHeight"),
            c = a.add(new Sys.Element({
                tag: "td",
                style: "min-height: " + o + "px; text-align: center;"
            })),
            h = this.model.getCondensedInfo(d, b, f, l).sort(function(p, i) {
                return i.from - p.from
            }),
            k = h.length,
            n, m, g;
        if (Sys.isDefined(j[d])) {
            c.el.appendChild(j[d])
        }
        n = a.add(new Sys.Element({
            tag: "td",
            style: "min-height: " + o + "px;"
        })).add(new Sys.Element({
            tag: "ul",
            "class": "interface-paytable_symbolValues"
        }));
        for (g = -1; ++g < k;) {
            m = h[g];
            if (Sys.isDefined(m.value)) {
                n.add(new Sys.Element({
                    tag: "li",
                    textContent: m.from,
                    style: "width: 33%; color: " + e + ";"
                }));
                n.add(new Sys.Element({
                    tag: "li",
                    textContent: m.value,
                    style: "width: 66%;"
                }))
            }
        }
    },
    createBetlines: function() {
        var b = this,
            a = Resources.readData("animationImages"),
            c = new Sys.Element({
                tag: "div",
                "class": b.SECTION_CSS + " utils_center_text " + b.SECTION_SEPARATOR_URI
            });
        c.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText(Language.Keys.paytable_winningBetLinesHeading),
            "class": b.HEADING_CSS
        }));
        if (Sys.isObj(a) && Sys.isDefined(a.betlines)) {
            c.el.appendChild(a.betlines)
        }
        b.sectionElements.Betlines = c;
        b.container.add(c)
    },
    createDisclaimer: function() {
        var c = this,
            d = new Sys.Element({
                tag: "div",
                "class": c.SECTION_CSS + " utils_center_text " + c.SECTION_SEPARATOR_URI
            }),
            a = c.DISCLAIMER_STRINGS,
            e = a.length,
            b;
        for (b = -1; ++b < e;) {
            d.add(new Sys.Element({
                tag: "div",
                textContent: Services.languageManager.getText(a[b])
            }))
        }
        c.sectionElements.Disclaimer = d;
        c.container.add(d)
    }
};
Interface.PaytableBaseView = Sys.extend(Interface.SettingsSectionView, Interface.PaytableBaseView, "Interface.PaytableBaseView");
Sys.ns("Interface");
Interface.PaytableDesktopView = {
    BASE_CSS: "tab interface-paytableDesktop_base",
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 50,
            y: 623,
            width: 52,
            height: 52
        },
        buttonImages: {
            up: "paytableButtonUp",
            down: "paytableButtonDown",
            hover: "paytableButtonOver",
            disabled: "paytableButtonDisabled"
        }
    },
    constructor: function() {
        Interface.PaytableDesktopView.superclass.constructor.apply(this, arguments)
    },
    show: function(b) {
        var c = this,
            a = c.navigation.getCurrentCardIndex();
        Interface.PaytableDesktopView.superclass.show.apply(c, arguments);
        if (Sys.isNumber(b) && b > 0 && b <= c.SECTIONS.length) {
            a = b - 1
        }
        c.navigation.selectCard(a);
        c.navigation.enable(c.MODULE_NAME)
    },
    hide: function() {
        var c = this,
            e, d, a, b;
        Interface.PaytableDesktopView.superclass.hide.apply(c, arguments);
        e = c.SECTIONS;
        d = c.sectionElements;
        a = e.length;
        for (b = -1; ++b < a;) {
            d[e[b]].el.style.display = "none"
        }
        c.navigation.disable(c.MODULE_NAME)
    },
    showNextPage: function() {
        this.navigation.next()
    },
    showPreviousPage: function() {
        this.navigation.previous()
    },
    enable: function(a) {
        if (this.animationsReady) {
            this.button.enable(a)
        }
    },
    disable: function(a) {
        if (this.animationsReady) {
            this.button.disable(a)
        }
    },
    setUpContent: function() {
        var a = this;
        a.model.setNumberOfPages(a.SECTIONS.length);
        a.model.setCurrentPage(1);
        a.createSections();
        a.createNavigation();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.paytable_uc),
            content: a.container
        });
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    createNavigation: function() {
        var a = this;
        a.navigation = new Interface.utils.CardNavigation({
            id: "paytableNavigation",
            numCards: this.SECTIONS.length,
            selectionCallback: a.onCardSelection.bind(a),
            closeCallback: a.onCloseCallback.bind(a),
            arrowLabels: {
                next: "Next",
                previous: "Previous"
            }
        });
        a.subComponents = [a.navigation];
        a.container.add(a.navigation.getArrows());
        a.container.add(a.navigation.getIndicators())
    },
    onCardSelection: function(b, e, a) {
        var c = this,
            d;
        c.hideSection(e);
        c.showSection(b);
        c.model.setCurrentPage(b + 1);
        if (b !== e) {
            d = (b > e) ? "forward" : "backward";
            if (a) {
                d = (b < e) ? "forward" : "backward"
            }
            c.fireEvent("view:pageSwitch", d)
        }
    },
    onCloseCallback: function() {
        this.fireEvent("view:hideRequest")
    },
    showSection: function(a) {
        this.sectionElements[this.SECTIONS[a]].el.style.display = "block"
    },
    hideSection: function(a) {
        this.sectionElements[this.SECTIONS[a]].el.style.display = "none"
    },
    showButton: function() {
        if (this.animationsReady) {
            this.button.show("buttonHideRequest");
            this.hidden = false
        }
    },
    hideButton: function() {
        if (this.animationsReady) {
            this.button.hide("buttonHideRequest");
            this.hidden = true
        }
    },
    enableButton: function() {
        if (!this.hidden) {
            this.button.enable("buttonDisableRequest")
        }
    },
    disableButton: function() {
        if (!this.hidden) {
            this.button.disable("buttonDisableRequest")
        }
    },
    initAnimations: function() {
        var b = this,
            a = Sys.applyProperties({
                clickCallback: b.onButtonClick.bind(b)
            }, b.KEYPAD_BUTTON_CONFIG);
        if (Sys.isDefined(a.buttonLabel)) {
            a.buttonLabel.depth = Layering.Game.Slots.Keypad.paytable.label
        }
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.paytable.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.paytable.button
        }
        b.button = new Interface.utils.CanvasButton(a);
        b.button.id = "paytable";
        b.animationsReady = true
    },
    onButtonClick: function() {
        if (!this.model.readData("showing")) {
            this.fireEvent("view:showRequest")
        } else {
            this.fireEvent("view:hideRequest")
        }
    },
    shouldBeHiddenByUserInput: function() {
        return false
    },
    onDisableBasicGamePanel: function() {
        this.disable("disableBasicGamePanel")
    },
    onEnableBasicGamePanel: function() {
        this.enable("disableBasicGamePanel")
    },
    onScroll: function() {}
};
Interface.PaytableDesktopView = Sys.extend(Interface.PaytableBaseView, Interface.PaytableDesktopView, "Interface.PaytableDesktopView");
Sys.ns("Interface");
Interface.SpinSettingsBase = {
    constructor: function() {
        Interface.SpinSettingsBase.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SpinSettingsBaseController,
            model: Interface.SpinSettingsBaseModel,
            view: Core.View
        }
    }
};
Interface.SpinSettingsBase = Sys.extend(Interface.SettingsSection, Interface.SpinSettingsBase, "Interface.SpinSettingsBase");
Sys.ns("Interface");
Interface.SpinSettingsBaseController = {
    constructor: function() {
        Interface.SpinSettingsBaseController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Interface.SpinSettingsBaseController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:spinSettings.showStopIfFreeSpinsWon": a.showStopIfFreeSpinsWon,
            "request:spinSettings.showStopIfAutoplayingBonusGameWon": a.showStopIfAutoplayingBonusGameWon,
            "request:spinSettings.startAutoPlay": a.onStartAutoPlay,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:settingsManager.settingEnabled": a.onSettingEnabled,
            "notify:settingsManager.settingDisabled": a.onSettingDisabled,
            "notify:settingsManager.settingLocked": a.onSettingLocked,
            "notify:settingsManager.unlockSetting": a.onSettingUnlocked,
            "notify:moneyManager.betChanged": a.onBetChanged,
            "notify:stateHandler.enteringSetupGameState": a.checkIfAutoplayDisabled
        })
    },
    onStartAutoPlay: function() {
        if (this.canStartAutoplay()) {
            this.fireEvent("request:autoPlayer.start")
        } else {
            this.showWarningDialog()
        }
    },
    checkIfAutoplayDisabled: function() {
        var b = this,
            a = b.model.getAutoplaySpinsArray();
        if (a.length === 1 && (a[0] < 5 || a[0] > 1000)) {
            b.fireEvent("request:settingsManager.disableSetting", "autoPlayNrSpins");
            b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0);
            b.fireEvent("request:settingsManager.lockSetting", "autoPlayNrSpins", b.MODULE_NAME)
        }
    },
    onSettingChanged: function(a, c) {
        var b = this;
        if (a === "autoPlayNrSpins") {
            if (c === 0) {
                c = b.model.getAutoplaySpinsArray()[0]
            }
            b.model.storeData(a, c);
            b.view.update()
        }
    },
    onBetChanged: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        if (a > 0 && !this.canStartAutoplay()) {
            this.showWarningDialog()
        }
    },
    canStartAutoplay: function() {
        var e = Services.moneyManager.getBetCents(),
            b = this.model.readData("isRestrictedMode"),
            c = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy"),
            d = this.model.readData("freeRoundsActive"),
            a = e <= c;
        if (b || c > 0) {
            return d || a
        }
        return true
    },
    onSettingDisabled: function(a) {
        this.view.removeSetting(a)
    },
    onSettingEnabled: function() {},
    onSettingLocked: function(a) {
        this.view.lockSetting(a)
    },
    onSettingUnlocked: function(a) {
        this.view.unlockSetting(a)
    },
    onUserAction: function(a, b) {
        this.model.storeData(a, b);
        if (a === "autoPlayNrSpins" && isNaN(Number(b))) {
            b = 0
        }
        this.fireEvent("request:settingsManager.storeData", a, b)
    },
    showWarningDialog: function() {
        var b = this,
            a = Services.languageManager;
        if (Platform.isDesktopDevice) {
            b.fireEvent("request:dialogWindow.showDialog", {
                title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
                text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarning),
                buttons: [{
                    text: a.getText(Language.Keys.btn_ok),
                    action: function() {
                        b.fireEvent("notify:dialogBoxClosed", {
                            name: "spinSettingsAutoplayWarning",
                            button: "ok"
                        })
                    }
                }]
            })
        } else {
            b.fireEvent("request:dialogWindow.showDialog", {
                title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
                text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarningTouch),
                buttons: [{
                    text: a.getText(Language.Keys.btn_close),
                    action: function() {
                        b.fireEvent("notify:dialogBoxClosed", {
                            name: "spinSettingsAutoplayWarning",
                            button: "close"
                        });
                        b.fireEvent("request:autoPlayer.stop")
                    }
                }, {
                    text: a.getText(Language.Keys.btn_ok),
                    action: function() {
                        b.fireEvent("notify:dialogBoxClosed", {
                            name: "spinSettingsAutoplayWarning",
                            button: "ok"
                        });
                        b.fireEvent("request:spinSettings.openAdvancedSettingKeyboard", "stopAutoplayIfBalanceDecreasedBy")
                    }
                }]
            })
        }
    },
    showStopIfFreeSpinsWon: function() {},
    showStopIfAutoplayingBonusGameWon: function() {}
};
Interface.SpinSettingsBaseController = Sys.extend(Interface.SettingsSectionController, Interface.SpinSettingsBaseController, "Interface.SpinSettingsBaseController");
Sys.ns("Interface");
Interface.SpinSettingsBaseModel = {
    AUTOPLAY_SPINS: [0, 10, 25, 50, 100, 250, 500, 750, 1000],
    constructor: function() {
        Interface.SpinSettingsBaseModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var d = this,
            b = Resources.readData("gameServerInitResponseObject").autoplay,
            a, c;
        if (typeof b !== "undefined" && ((b === 0 || d.validateSingleAutoPlayValue(b) || d.validateAutoplayArray(b)))) {
            if (!Array.isArray(b)) {
                b = [b]
            } else {
                b = b.slice()
            }
            if (!b.contains(0)) {
                b = [0].concat(b)
            }
            b.sort(function(f, e) {
                return f - e
            })
        } else {
            b = d.AUTOPLAY_SPINS
        }
        a = [{
            key: "autoPlayNrSpins",
            defaultValue: b[0],
            settingsManager: true,
            localStorage: false
        }, {
            key: "autoplaySpinsArray",
            defaultValue: b,
            settingsManager: false,
            localStorage: false
        }];
        a.forEach(d.initData, d);
        Services.storage.storeData("spinSettings.autoplayRoundsAvailable", b.slice(1));
        Interface.SpinSettingsBaseModel.superclass.setupData.apply(this, arguments);
        c = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
        this.storeData("isRestrictedMode", c);
        this.storeData("dontSetupAutoplay", b.length === 1 && b[0] === 0)
    },
    validateAutoplayArray: function(a) {
        var b = true,
            c = a.length;
        if (Array.isArray(a) && c > 0 && c < 9) {
            b = !a.some(function(d) {
                var e = parseInt(d, 10);
                return (e && !isNaN(e)) && (e < 5 || e > 1000)
            })
        } else {
            b = false
        }
        return b
    },
    validateSingleAutoPlayValue: function(a) {
        var b = true,
            c = Sys.utils.toInt(a);
        if (Array.isArray(a) || isNaN(c) || c < 5 || c > 1000) {
            b = false
        }
        return b
    },
    getAutoplaySpinsArray: function() {
        return this.readData("autoplaySpinsArray")
    },
    hasAutoplayCeased: function() {
        return this.readData("dontSetupAutoplay")
    }
};
Interface.SpinSettingsBaseModel = Sys.extend(Interface.SettingsSectionModel, Interface.SpinSettingsBaseModel, "Interface.SpinSettingsBaseModel");
Sys.ns("Interface");
Interface.SpinSettings = {
    constructor: function() {
        Interface.SpinSettings.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SpinSettingsController,
            model: Interface.SpinSettingsModel,
            view: Interface.SpinSettingsView
        }
    }
};
Interface.SpinSettings = Sys.extend(Interface.SpinSettingsBase, Interface.SpinSettings, "Interface.SpinSettings");
Sys.ns("Interface");
Interface.SpinSettingsModel = {
    setupData: function() {
        var b = this,
            a = [{
                key: "stopAutoplayIfBalanceDecreasedBy",
                defaultValue: false,
                settingsManager: true,
                localStorage: true
            }, {
                key: "leftHandMode",
                defaultValue: false,
                settingsManager: true,
                localStorage: true
            }, {
                key: "quickSpin",
                defaultValue: false,
                settingsManager: true,
                localStorage: true
            }, {
                key: "stopAutoplayIfFreeSpinWon",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }, {
                key: "stopAutoplayIfAutoplayingBonusGameWon",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }, {
                key: "stopAutoplayIfWinExceeds",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }];
        Interface.SpinSettingsModel.superclass.setupData.apply(this, arguments);
        a.forEach(b.initData, b)
    }
};
Interface.SpinSettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.SpinSettingsModel, "Interface.SpinSettingsModel");
Sys.ns("Interface");
Interface.SpinSettingsController = {
    constructor: function() {
        Interface.SpinSettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Interface.SpinSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:spinSettings.openAdvancedSettingKeyboard": a.openAdvancedSettingsKeyboard,
            "notify.dialogWindow.showingDialog": a.onShowingDialog,
            "view:autoPlaySliderEnd": a.userInteractionEnded,
            "notify:freeRounds.started": a.view.onFreeRoundsStateChange.bind(a.view, true),
            "notify:freeRounds.ended": a.view.onFreeRoundsStateChange.bind(a.view, false)
        })
    },
    userInteractionEnded: function(c) {
        var b = this,
            a = b.model.readData("isRestrictedMode");
        if (a === true && c > 0) {
            b.fireEvent("request:userInputManager.activateExclusivity", "spinSettings.addingValue");
            b.addValueToLossLimit()
        }
    },
    onBetChanged: function(a) {
        var b = this;
        Interface.SpinSettingsController.superclass.onBetChanged.apply(b, arguments);
        if (b.view.advancedSettings && b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy) {
            b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy.setMinValue(a.playerBetCents > 0 ? a.playerBetCents : undefined)
        }
    },
    onUserAction: function(c, e) {
        var d = this,
            b = d.model.readData("isRestrictedMode"),
            a = d.model.readData("freeRoundsActive") || false;
        Interface.SpinSettingsController.superclass.onUserAction.apply(this, arguments);
        if (c === "leftHandMode" || c === "quickSpin") {
            Services.localStorageManager.storeData(c, e.toString())
        }
        if (c === "autoPlayNrSpins") {
            this.enableAdvancedSettings(e)
        }
        if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
            Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
        }
    },
    enableAdvancedSettings: function(d) {
        var c = this,
            a = c.model.readData("isRestrictedMode"),
            e = c.model.readData("freeRoundsActive"),
            b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy") || 0;
        d = Sys.isDefined(d) ? d : 0;
        if (d > 0) {
            c.view.showAdvancedSettings();
            c.view.enableAdvancedSettings()
        } else {
            c.view.hideAdvancedSettings();
            c.view.disableAdvancedSettings()
        }
        if (a === true && !e && b === 0) {
            c.view.disableAdvancedSettings()
        }
    },
    onSettingChanged: function(c, e) {
        var d = this,
            b = d.model.readData("isRestrictedMode"),
            a = d.model.readData("freeRoundsActive") || false;
        Interface.SpinSettingsController.superclass.onSettingChanged.apply(d, arguments);
        if (c === "quickSpin") {
            d.model.storeData(c, e);
            d.view.update()
        }
        if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
            Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
        }
    },
    showStopIfAutoplayingBonusGameWon: function() {
        this.view.showStopIfAutoplayingBonusGameWon()
    },
    openAdvancedSettingsKeyboard: function(b) {
        var a = this;
        a.fireEvent("request:settingsWindow.openChild", "spinSettings");
        a.view.openAdvancedSetting(b)
    },
    addValueToLossLimit: function() {
        var c = this,
            b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy"),
            a = c.model.readData("freeRoundsActive");
        if ((!b || b === 0) && !a) {
            setTimeout(function() {
                c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
                c.view.openAdvancedSetting("stopAutoplayIfBalanceDecreasedBy");
                c.view.enableAdvancedSettings()
            }, 1000)
        } else {
            c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
            c.view.enableAdvancedSettings()
        }
    },
    onShowingDialog: function() {
        if (this.model.readData("showing")) {
            this.fireEvent("request:keyboard.cancel")
        }
    }
};
Interface.SpinSettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.SpinSettingsController, "Interface.SpinSettingsController");
Sys.ns("Interface");
Interface.SpinSettingsView = {
    BASE_CSS: "tab interface-spinSettings_base",
    PORTRAIT_CSS: "interface-spinSettings_portrait",
    LANDSCAPE_CSS: "interface-spinSettings_landscape",
    SECTION_CSS: "interface-settingsSection_subSection",
    SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
    AUTOPLAY_SETTINGS_CSS: "interface-spinSettings_autoPlayContainer",
    AUTO_PLAY_ADDVALUE: "ifCashDecreasesByAddValue",
    AUTOPLAYING_BONUS_GAME_LABEL: Language.Keys.autoplay_setting_ifFBonusIsStarted,
    FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
    ADVANCED_AUTOPLAY_SETTINGS: {
        stopAutoplayTitle: {
            labelOCTKey: Language.Keys.autoplay_setting_stopAutoPlay,
            type: "settingGroupTitle"
        },
        stopAutoplayIfBalanceDecreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            infoOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesByInfoTouch,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfWinExceeds: {
            labelOCTKey: Language.Keys.autoplay_setting_ifWinExeeds,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfBalanceIncreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashIncreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfFreeSpinWon: {
            type: "ToggleSwitch",
            titleOCTKey: Language.Keys.stopIfFreeSpins,
            defaultValue: false
        }
    },
    constructor: function() {
        Interface.SpinSettingsView.superclass.constructor.apply(this, arguments);
        this.lockedControllers = []
    },
    setUpContent: function() {
        var a = this,
            b;
        a.container = new Sys.Element({
            id: "spinSettings",
            tag: "div",
            cls: a.BASE_CSS
        });
        a.autoplayContainer = a.container.add(new Sys.Element({
            id: "spinSettings_autoplaySettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.AUTOPLAY_SETTINGS_CSS
        }));
        a.numberOfAutoPlaysSetting = a.autoplayContainer.add(new Sys.Element({
            id: "nrOfAutoplaySpins",
            tag: "ul",
            "class": "interface-settingsSection_dynamicSliderPosition_container"
        }));
        a.nrOfSpinsText = a.numberOfAutoPlaysSetting.add(new Sys.Element({
            id: "nrAutoPlaySpinsLabel",
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay)
        }));
        a.nrAutoPlaySpins = new Interface.utils.Slider({
            id: "nrAutoPlaySpinsSlider",
            values: a.model.getAutoplaySpinsArray(),
            callback: a.onSettingsControllerChanged.bind(a, "autoPlayNrSpins"),
            endCallback: a.fireEvent.bind(a, "view:autoPlaySliderEnd"),
            showLabels: true
        });
        a.advancedAutoplaySettings = a.autoplayContainer.add(new Sys.Element({
            id: "advancedAutoplaySettings",
            tag: "div",
            cls: "interface-autoPlay_advancedSettings_container",
            transitionend: this.updateScrollerDimensions.bind(this)
        }));
        a.initAdvancedAutoplaySettings();
        a.numberOfAutoPlaysSetting.add(new Sys.Element({
            id: "nrAutoPlaySpinsSliderWrapper",
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        })).add(a.nrAutoPlaySpins.getContainer());
        a.stopIfAutoplayingBonusGameWon = new Interface.utils.ToggleSwitch({
            id: "stopIfAutoplayingBonusGameWon",
            title: Services.languageManager.getText(a.AUTOPLAYING_BONUS_GAME_LABEL),
            callback: a.onSettingsControllerChanged.bind(a, "stopAutoplayIfAutoplayingBonusGameWon")
        });
        b = a.stopIfAutoplayingBonusGameWon.getContainer();
        a.stopIfAutoplayingBonusGameWonOriginalDisplay = b.el.style.display;
        b.el.style.display = "none";
        a.autoplayContainer.add(b);
        a.quickSpinContainer = a.container.add(new Sys.Element({
            id: "spinSettings_quickSpinSettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
        }));
        a.quickSpin = new Interface.utils.ToggleSwitch({
            id: "quickSpinOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_quickSpinGame),
            callback: a.onSettingsControllerChanged.bind(a, "quickSpin")
        });
        a.quickSpinContainer.add(a.quickSpin.getContainer());
        a.spinButtonPositionContainer = a.container.add(new Sys.Element({
            id: "spinSettings_spinButtonPositionSettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
        }));
        a.swedenPlugin = Resources.readData("queryData") ? Resources.readData("queryData").enableDefaultSwedenButtons : false;
        if (!a.swedenPlugin) {
            a.spinButtonPosition = new Interface.utils.ToggleSwitch({
                id: "spinButtonPositionLeftRight",
                title: Services.languageManager.getText(Language.Keys.setting_leftHandMode),
                callback: a.onSettingsControllerChanged.bind(a, "leftHandMode")
            });
            a.spinButtonPositionContainer.add(a.spinButtonPosition.getContainer())
        }
        a.addContainerToSettings();
        a.subComponents = [a.quickSpin, a.nrAutoPlaySpins, a.spinButtonPosition];
        a.update();
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    addContainerToSettings: function() {
        var a = this;
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.spinSettings_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {
            order: 2
        })
    },
    initAdvancedAutoplaySettings: function() {
        var b = this,
            d = b.advancedAutoplaySettings,
            a = Services.languageManager,
            c;
        b.advancedSettings = {};
        Sys.iterate(b.ADVANCED_AUTOPLAY_SETTINGS, function(f, e) {
            if (f === "stopAutoplayIfBalanceDecreasedBy") {
                c = Services.moneyManager.getBetCents()
            } else {
                c = undefined
            }
            if (e.type === "interactiveContainer") {
                b.advancedSettings[f] = new Interface.utils.InteractiveContainer({
                    title: a.getText(e.labelOCTKey),
                    info: a.hasText(e.infoOCTKey) ? a.getText(e.infoOCTKey) : "",
                    buttonText: a.hasText(e.buttonTextOCTKey) ? a.getText(e.buttonTextOCTKey) : "",
                    id: "advancedSetting-" + f,
                    cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
                    callback: b.onSettingsControllerChanged.bind(b, f),
                    minValue: c
                })
            } else {
                if (e.type === "ToggleSwitch") {
                    b.advancedSettings[f] = new Interface.utils.ToggleSwitch({
                        title: a.getText(e.titleOCTKey),
                        id: "advanceSetting-" + f,
                        cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
                        callback: b.onSettingsControllerChanged.bind(b, f)
                    })
                } else {
                    if (e.type === "settingGroupTitle") {
                        b.advancedSettings[f] = new Interface.utils.GroupTitle({
                            title: a.getText(e.labelOCTKey),
                            id: "advanceSetting-" + f,
                            cls: b.SECTION_CSS,
                            CSS: {
                                disabled: ""
                            }
                        })
                    }
                }
            }
            d.add(b.advancedSettings[f].getContainer())
        })
    },
    showAdvancedSettings: function() {
        this.advancedAutoplaySettings.el.style["max-height"] = "16rem"
    },
    hideAdvancedSettings: function() {
        this.advancedAutoplaySettings.el.style["max-height"] = "0"
    },
    enableAdvancedSettings: function() {
        var a = this;
        Sys.iterate(a.advancedSettings, function(c, d) {
            var b = a.model.readData("freeRoundsActive");
            if (!b || (b && a.FREEROUND_ACTIVE_CONTROLS.contains(c))) {
                d.enable()
            }
        })
    },
    disableAdvancedSettings: function() {
        var a = this;
        Sys.iterate(a.advancedSettings, function(b, c) {
            c.disable()
        })
    },
    openAdvancedSetting: function(a) {
        var b = this.advancedSettings[a];
        if (Sys.isDefined(b)) {
            b.click()
        } else {}
    },
    onSettingsControllerChanged: function(b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function() {
        var a = this;
        a.model.storeData("disabled", false);
        a.callFunctionOnSubComponents("enable");
        Sys.each(a.lockedControllers, function(b) {
            b.disable()
        });
        if (a.nrAutoPlaySpins.getValue() !== a.model.getAutoplaySpinsArray()[0]) {
            a.stopIfAutoplayingBonusGameWon.enable();
            a.enableAdvancedSettings()
        }
    },
    disable: function() {
        var a = this;
        a.callFunctionOnSubComponents("disable");
        a.stopIfAutoplayingBonusGameWon.disable();
        a.disableAdvancedSettings();
        a.spinButtonPosition.enable();
        a.model.storeData("disabled", true)
    },
    update: function() {
        var c = this,
            b = c.model.readData.bind(c.model),
            a = !b("disabled"),
            d = b("autoPlayNrSpins");
        c.nrAutoPlaySpins.setValue(d);
        c.advancedSettings.stopAutoplayIfFreeSpinWon.toggle(b("stopAutoplayIfFreeSpinWon"));
        c.stopIfAutoplayingBonusGameWon.toggle(b("stopAutoplayIfAutoplayingBonusGameWon"));
        c.quickSpin.toggle(b("quickSpin"));
        if (c.spinButtonPosition) {
            c.spinButtonPosition.toggle(b("leftHandMode"))
        }
        if (d === c.model.getAutoplaySpinsArray()[0]) {
            c.stopIfAutoplayingBonusGameWon.toggle(false);
            c.stopIfAutoplayingBonusGameWon.disable();
            Sys.iterate(c.ADVANCED_AUTOPLAY_SETTINGS, function(f, e) {
                c.advancedSettings[f].setValue(e.defaultValue)
            })
        } else {
            if (a && !c.stopIfAutoplayingBonusGameWon.isEnabled()) {
                c.stopIfAutoplayingBonusGameWon.enable()
            }
        }
    },
    showStopIfAutoplayingBonusGameWon: function() {
        this.stopIfAutoplayingBonusGameWon.getContainer().el.style.display = this.stopIfAutoplayingBonusGameWonOriginalDisplay
    },
    removeSetting: function(a) {
        var b = this;
        if (a === "quickSpin") {
            b.container.remove(b.quickSpinContainer)
        } else {
            if (a === "autoPlayNrSpins") {
                b.container.remove(b.autoplayContainer)
            }
        }
    },
    lockSetting: function(a) {
        var c = this,
            b;
        if (a === "autoPlayNrSpins") {
            b = c.nrAutoPlaySpins;
            c.nrOfSpinsText.el.style.opacity = "0.5"
        } else {
            if (a === "quickSpin") {
                b = c.quickSpin
            }
        }
        if (b) {
            b.disable();
            if (!c.lockedControllers.contains(b)) {
                c.lockedControllers.push(b)
            }
        }
    },
    unlockSetting: function(a) {
        var c = this,
            b;
        if (a === "autoPlayNrSpins") {
            b = c.nrAutoPlaySpins;
            c.nrOfSpinsText.el.style.opacity = ""
        } else {
            if (a === "quickSpin") {
                b = c.quickSpin
            }
        }
        if (b) {
            if (!c.model.readData("disabled")) {
                b.enable()
            }
            if (c.lockedControllers.contains(b)) {
                c.lockedControllers.splice(c.lockedControllers.indexOf(b), 1)
            }
        }
    },
    resetAutoPlay: function() {},
    reduceCounter: function() {},
    sortControls: function(b) {
        var c = this,
            a = b || [],
            d = c.advancedSettings.stopAutoplayIfBalanceDecreasedBy.container;
        if (c.model.readData("freeRoundsActive")) {
            a.forEach(function(e) {
                c.advancedAutoplaySettings.addBefore(e, d)
            })
        } else {
            a.forEach(function(e) {
                c.advancedAutoplaySettings.add(e, d)
            })
        }
    },
    toggleFreeRoundControls: function(b) {
        var c = this,
            a = b || [],
            d = [];
        Sys.iterate(c.advancedSettings, function(e, f) {
            if (!a.contains(e)) {
                if (c.model.readData("freeRoundsActive")) {
                    f.disable()
                } else {
                    f.enable()
                }
            } else {
                d.push(c.advancedAutoplaySettings.remove(f.container))
            }
        });
        c.sortControls(d)
    },
    onFreeRoundsStateChange: function(b) {
        var c = this,
            a = c.FREEROUND_ACTIVE_CONTROLS;
        c.model.storeData("freeRoundsActive", b);
        c.toggleFreeRoundControls(a)
    }
};
Interface.SpinSettingsView = Sys.extend(Interface.SettingsSectionView, Interface.SpinSettingsView, "Interface.SpinSettingsView");
Sys.ns("Interface");
Interface.AutoplaySettings = {
    constructor: function() {
        Interface.AutoplaySettings.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["userInput"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Interface.AutoplaySettingsModel,
            view: Interface.AutoplaySettingsView,
            controller: Interface.AutoplaySettingsController
        }
    }
};
Interface.AutoplaySettings = Sys.extend(Interface.SpinSettingsBase, Interface.AutoplaySettings, "Interface.AutoplaySettings");
Sys.ns("Interface");
Interface.AutoplaySettingsController = {
    constructor: function() {
        Interface.AutoplaySettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        if (this.model.hasAutoplayCeased()) {
            return
        }
        Interface.AutoplaySettingsController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "notify:stateHandler.enteringIdleState": this.onEnteringIdleState,
            "notify:autoPlayer.reduceCounter": this.view.reduceCounter.bind(this.view),
            "notify:autoPlayer.starting": this.view.onAutoplayStarting.bind(this.view),
            "notify:freeRounds.started": this.view.onFreeRoundsStateChange.bind(this.view, true),
            "notify:freeRounds.ended": this.view.onFreeRoundsStateChange.bind(this.view, false),
            "request:autoplaySettings.close": this.onHideRequest,
            "request:closeOpenWindows": this.onHideRequest,
            "request:autoplaySettings.toggle": this.toggle,
            "request:enableBasicGamePanel": this.view.enableKeypadButton.bind(this.view),
            "request:disableBasicGamePanel": this.view.disableKeypadButton.bind(this.view),
            "notify:gameModeChanged": this.onGameModeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations,
            "view:startAutoPlay": this.onStartAutoPlay,
            "view:stopAutoPlay": this.onStopAutoPlay,
            "view:autoPlayActive": this.onAutoPlayActive
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onStartAutoPlay: function() {
        var a = this;
        if (a.canStartAutoplay()) {
            a.fireEvent("request:autoPlayer.start")
        } else {
            a.resetAutoPlay();
            a.showWarningDialog()
        }
    },
    onEnteringIdleState: function() {
        var a = this;
        Interface.AutoplaySettingsController.superclass.onEnteringIdleState.apply(a, arguments);
        if (a.model.readData("autoPlayNrSpins") === 0) {
            a.view.resetAutoPlay();
            a.model.storeData("autoPlayActive", false)
        }
    },
    onShowRequest: function() {
        var a = this;
        if (!a.model.readData("disabled")) {
            a.fireEvent("request:gameSettings.close");
            Interface.AutoplaySettingsController.superclass.onShowRequest.apply(this, arguments)
        }
    },
    onAutoPlayActive: function() {
        this.model.storeData("autoPlayActive", true);
        this.view.update()
    },
    onStopAutoPlay: function() {
        this.fireEvent("request:autoPlayer.stop")
    },
    toggle: function() {
        if (this.model.readData("showing")) {
            this.onHideRequest()
        } else {
            this.onShowRequest()
        }
    },
    onSettingDisabled: function(a) {
        this.view.hideSetting(a)
    },
    onSettingEnabled: function(a) {
        this.view.showSetting(a)
    },
    onSettingChanged: function(a, b) {
        Interface.AutoplaySettingsController.superclass.onSettingChanged.apply(this, arguments);
        this.view.advancedListChanged(a, b)
    },
    onSettingLocked: function(a) {
        if (a === "autoPlayNrSpins") {
            this.onHideRequest();
            this.disable("autoplayLocked");
            this.view.disableKeypadButton("autoplayLocked")
        }
    },
    onSettingUnlocked: function(a) {
        if (a === "autoPlayNrSpins") {
            this.enable("autoplayLocked");
            this.view.enableKeypadButton("autoplayLocked")
        }
    },
    onGameModeChanged: function(a) {
        if (a === "BASIC") {
            this.view.showKeypadButton("gameModeNotBasic")
        } else {
            this.view.hideKeypadButton("gameModeNotBasic")
        }
    },
    showStopIfFreeSpinsWon: function() {
        var a = this;
        a.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfFreeSpinWon")
    },
    showStopIfAutoplayingBonusGameWon: function() {
        this.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfAutoplayingBonusGameWon")
    },
    resetAutoPlay: function() {
        this.view.resetAutoPlay();
        this.model.storeData("autoPlayActive", false);
        this.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
    }
};
Interface.AutoplaySettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.AutoplaySettingsController, "Interface.AutoplaySettingsController");
Sys.ns("Interface");
Interface.AutoplaySettingsView = {
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-autoplaySettings_icon_uri interface-autoplaySettings-menuButton",
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 437,
            y: 613,
            width: 143,
            height: 72
        },
        buttonImages: {
            up: "autoPlayButtonUp",
            down: "autoPlayButtonDown",
            hover: "autoPlayButtonOver",
            disabled: "autoPlayButtonDisabled"
        },
        buttonLabel: {
            width: 107,
            height: 54,
            text: Language.Keys.btn_autoplay,
            font: "24px NetentStandardUI",
            lineHeight: 24,
            alignment: "center",
            color: "#000000",
            breakOn: "<br>"
        }
    },
    ADVANCED_TOGGLE_CSS: {
        base: "interface-standAloneSettingsSectionToggle_base",
        disabled: "interface-standAloneSettingsSectionToggle_disabled",
        button_wrapper: "interface-standAloneSettingsSectionToggle_wrapper",
        label: "interface-standAloneSettingsSectionToggle_label interface-spinSettings_autoPlayAdvancedToggle_label",
        button_handle: "interface-standAloneSettingsSectionToggle_handle",
        button_background: "interface-standAloneSettingsSectionToggle_background",
        open: "advancedOpen",
        closed: "advancedClosed"
    },
    RESTRICTED_CONFIG_CONTROLS: [],
    FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayOnAnyWin", "stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
    ADVANCED_CONFIG_CONTROLS: [{
        id: "stopAutoplayOnAnyWin",
        label: Language.Keys.autoplay_setting_onAnyWin,
        type: "checkbox"
    }, {
        id: "stopAutoplayIfFreeSpinWon",
        label: Language.Keys.autoplay_setting_ifFreeSpinsIsStarted,
        type: "checkbox",
        disabled: true
    }, {
        id: "stopAutoplayIfAutoplayingBonusGameWon",
        label: Language.Keys.autoplay_setting_ifFBonusIsStarted,
        type: "checkbox",
        disabled: true
    }, {
        id: "stopAutoplayIfWinExceeds",
        label: Language.Keys.autoplay_setting_ifWinExeeds,
        type: "checkbox",
        withInput: {
            label: undefined
        }
    }, {
        id: "stopAutoplayIfBalanceIncreasedBy",
        label: Language.Keys.autoplay_setting_ifCashIncreasesBy,
        type: "checkbox",
        withInput: {
            label: undefined
        }
    }, {
        id: "stopAutoplayIfBalanceDecreasedBy",
        label: Language.Keys.autoplay_setting_ifCashDecreasesBy,
        type: "checkbox",
        withInput: {
            label: undefined
        }
    }],
    ARROW_LEFT_VALUE: "0.54rem",
    RENDER_TARGET: "gameWrapper",
    DISABLE_BUTTON_DURING_SPIN: false,
    ORDER: 3,
    TITLE: Language.Keys.autoplay,
    constructor: function() {
        Interface.AutoplaySettingsView.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var b = this,
            a;
        Interface.AutoplaySettingsView.superclass.init.apply(b, arguments);
        b.selectedAutoplayTarget = undefined;
        b.isActive = false;
        b.keypadPendingDisable = [];
        if (b.model.readData("isRestrictedModeEnabled") === true) {
            a = Sys.find(b.ADVANCED_CONFIG_CONTROLS, function(c) {
                return c.id === "stopAutoplayIfBalanceDecreasedBy"
            });
            b.RESTRICTED_CONFIG_CONTROLS.push(a);
            if (b.ADVANCED_CONFIG_CONTROLS.indexOf(a) >= 0) {
                b.ADVANCED_CONFIG_CONTROLS.splice(b.ADVANCED_CONFIG_CONTROLS.indexOf(a), 1)
            }
        }
    },
    setUpContent: function() {
        var a = this;
        if (a.model.hasAutoplayCeased()) {
            return
        }
        Interface.AutoplaySettingsView.superclass.setUpContent.apply(a, arguments);
        a.setupAutoPlayContainer(a.container)
    },
    initAnimations: function() {
        var a = this;
        if (a.model.hasAutoplayCeased()) {
            return
        }
        this.setUpKeypadButton()
    },
    setupAutoPlayContainer: function() {
        var a = this;
        a.autoplaySettingsWrapper = a.container.add(new Sys.Element({
            id: "autoplaySettings",
            tag: "div",
            cls: "interface-spinSettings_autoplaySettings_wrapper"
        }));
        if (a.model.readData("isRestrictedModeEnabled") === true) {
            a.setupRestrictedAutoPlayContainer()
        }
        a.setupAdvancedAutoPlayContainer();
        a.setUpAutoplaySpinsSelector();
        a.setUpAutoplayStopControls()
    },
    toggleAdvancedSettings: function() {
        this.advancedSettingsWrapper.toggleClass("advancedSettingsOpen")
    },
    setupAdvancedAutoPlayContainer: function() {
        var c = this,
            a = new Sys.Element({
                id: "advancedAutoplaySettings",
                tag: "div",
                cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
            }),
            b = Services.moneyManager.getCurrencyIsoName();
        c.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
            if (Sys.isDefined(d.withInput)) {
                d.withInput.label = b
            }
        });
        c.advancedToggle = new Interface.utils.ToggleSwitch({
            id: "advancedAutoplaySettingsToggle",
            title: Services.languageManager.getText(Language.Keys.autoplay_advancedSettings),
            CSS: c.ADVANCED_TOGGLE_CSS,
            enabled: true,
            callback: c.toggleAdvancedSettings.bind(c)
        });
        a.add(c.advancedToggle.getContainer());
        a.add(c.setupResetButton());
        a.add(c.setupStopAutoPlaySection());
        a.add(c.getDivider());
        c.advancedSettingsWrapper = a;
        c.container.addAsFirst(a);
        c.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
            c.fireEvent("view:userAction", d.id, false);
            if (Sys.isDefined(d.disabled)) {
                c.hideSetting(d.id);
                c.fireEvent("view:disableSetting", d.id)
            }
        })
    },
    setupRestrictedAutoPlayContainer: function() {
        var c = this,
            a = new Sys.Element({
                id: "restrictedAutoplaySettings",
                tag: "div",
                cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
            }),
            b = Services.moneyManager.getCurrencyIsoName();
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function(d) {
            if (Sys.isDefined(d.withInput)) {
                d.withInput.label = b
            }
        });
        c.restrictedWrapper = a.add(c.setupRestrictedStopAutoPlaySection());
        a.add(c.getDivider());
        c.container.addAsFirst(a);
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function(d) {
            c.fireEvent("view:userAction", d.id, false);
            if (Sys.isDefined(d.disabled)) {
                c.hideSetting(d.id);
                c.fireEvent("view:disableSetting", d.id)
            }
        })
    },
    setupStopAutoPlaySection: function() {
        var a = this,
            c = new Sys.Element({
                id: "advancedSettings",
                tag: "div",
                cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListWrapper"
            }),
            b = new Interface.utils.DOMControlList({
                id: "autoplaySettingsStoppedList",
                controls: a.ADVANCED_CONFIG_CONTROLS,
                callback: a.advancedListChanged.bind(a)
            });
        c.add(new Sys.Element({
            id: "advancedSettingsListHeader",
            tag: "div",
            cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListHeader",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_stopAutoPlay)
        }));
        a.advancedList = b;
        c.add(b.getContainer());
        return c
    },
    setupRestrictedStopAutoPlaySection: function() {
        var b = this,
            a, d = new Sys.Element({
                id: "restrictedSettings",
                tag: "div"
            }),
            c = new Interface.utils.DOMControlList({
                id: "autoplaySettingsRestrictedStoppedList",
                controls: b.RESTRICTED_CONFIG_CONTROLS,
                callback: b.advancedListChanged.bind(b)
            });
        b.restrictedAdvancedList = c;
        a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
        a.checkBox.setValue(true, true);
        a.checkBox.lock("autoplay");
        d.add(c.getContainer());
        d.add(new Sys.Element({
            id: "restrictedSettings_info",
            tag: "div",
            cls: "interface-spinSettings_autoplayStopControls_info",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_setting_ifCashDecreasesByInfo)
        }));
        return d
    },
    advancedListChanged: function(b, d) {
        var c = this,
            a = false;
        c.fireEvent("view:userAction", b, d);
        c.ADVANCED_CONFIG_CONTROLS.forEach(function(e) {
            if (Services.settingsManager.getSetting(e.id) !== false) {
                a = true
            }
        });
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function(e) {
            if (Services.settingsManager.getSetting(e.id) !== false) {
                a = true
            }
        });
        if (a) {
            c.advancedToggle.getContainer().addCls("sectionActive");
            c.showResetButton()
        } else {
            c.advancedToggle.getContainer().removeCls("sectionActive");
            c.hideResetButton()
        }
    },
    setupResetButton: function() {
        var a = this;
        a.resetButton = new Interface.utils.DOMButton({
            id: "autoplaySettingsReset",
            textContent: Services.languageManager.getText(Language.Keys.reset),
            clickCallback: a.resetSettings.bind(a),
            baseCSS: "interface-desktopControls_Button_small interface-interface-desktopControls_Button_small_uri interface-spinSettings_autoplayStopControls_resetButton"
        });
        a.hideResetButton();
        return a.resetButton.getContainer()
    },
    showResetButton: function() {
        this.resetButton.show(this.MODULE_NAME)
    },
    hideResetButton: function() {
        this.resetButton.hide(this.MODULE_NAME)
    },
    hideSetting: function(a) {
        this.advancedList.hide(a)
    },
    showSetting: function(a) {
        this.advancedList.show(a)
    },
    resetSettings: function() {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function(b) {
            a.advancedList.update(b.id, false);
            a.advancedListChanged(b.id, false)
        });
        a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
            a.restrictedAdvancedList.update(b.id, false);
            a.advancedListChanged(b.id, false)
        });
        a.resetAutoPlay();
        a.fireEvent("view:stopAutoPlay")
    },
    setUpAutoplaySpinsSelector: function() {
        var b = this,
            d = "[Off]",
            c = new Sys.Element({
                id: "autoplaySelectorWrapper",
                tag: "div",
                cls: "interface-spinSettings_autoplaySelector_wrapper"
            }),
            a = {
                id: "autoplaySelector",
                values: b.model.getAutoplaySpinsArray(),
                CSS: {
                    base: "interface-spinSettings_autoplaySelector_base",
                    buttonBase: "interface-spinSettings_autoplaySelector_buttonBase",
                    buttonUp: "interface-DOMOptionScroller_buttonUp_uri",
                    buttonDown: "interface-DOMOptionScroller_buttonDown_uri",
                    valuesHolder: "interface-spinSettings_autoplaySelector_valuesHolder",
                    value: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri interface-spinSettings_button",
                    wrapper: "interface-spinSettings_autoplaySelector_valueWrapper"
                },
                callback: function(e) {
                    b.fireEvent("view:userAction", "autoPlayNrSpins", Sys.utils.toInt(e));
                    b.disableAdvancedControls();
                    b.disableRestrictedControls();
                    b.fireEvent("view:startAutoPlay")
                },
                scrollOffsetModifier: 3,
                valueWidth: 50,
                replaceTextByIndex: [{
                    index: 0,
                    text: d,
                    skip: true
                }]
            };
        c.add(new Sys.Element({
            id: "topLabel",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_numberSpins)
        }));
        b.selector = new Interface.utils.DOMOptionScroller(a);
        c.add(b.selector.getContainer());
        c.add(new Sys.Element({
            id: "topLabel",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_panelStartText)
        }));
        b.autoplaySettingsWrapper.add(c)
    },
    onAutoplayStarting: function() {
        this.fireEvent("view:autoPlayActive")
    },
    selectorCallbackFunction: function(a) {
        var b = this;
        if (a.element === b.selectedAutoplayTarget) {
            return false
        } else {
            if (!Sys.isDefined(b.selectedAutoplayTarget)) {
                a.element.style.opacity = "0.7";
                b.selectedAutoplayTarget = a.element;
                return true
            } else {
                if (a !== b.selectedAutoplayTarget) {
                    b.selectedAutoplayTarget.style.opacity = "1";
                    a.element.style.opacity = "0.7";
                    b.selectedAutoplayTarget = a.element;
                    return true
                }
            }
        }
        return false
    },
    deSelectAutoPlayTarget: function() {
        if (Sys.isDefined(this.selectedAutoplayTarget)) {
            this.selectedAutoplayTarget.style.opacity = "1";
            this.selectedAutoplayTarget = undefined
        }
    },
    setUpAutoplayStopControls: function() {
        var a = this,
            c = new Sys.Element({
                id: "autoplayStopControls",
                tag: "div",
                cls: "interface-spinSettings_autoplayStopControls_wrapper"
            }),
            b = new Sys.Element({
                id: "autoplayStopControlsHeader",
                tag: "div",
                cls: "interface-spinSettings_autoplayStopControls_header",
                textContent: Services.languageManager.getText(Language.Keys.spinsLeftText, [Services.languageManager.getText(Language.Keys.autoSpins)])
            });
        a.spinsLeftCounter = new Sys.Element({
            id: "autoplayStopControlsSpinsCounter",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri",
            textContent: "0"
        });
        a.stopButton = new Interface.utils.DOMButton({
            id: "autoplayStopControlsStopButton",
            baseCSS: "interface-desktopControls_Button interface-spinSettings_autoplayStopControls_stopButton interface-interface-desktopControls_Button_uri",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_stopText),
            clickCallback: a.fireEvent.bind(a, "view:stopAutoPlay")
        });
        c.add(b);
        c.add(a.spinsLeftCounter);
        c.add(a.stopButton.getContainer());
        a.container.add(c)
    },
    setUpKeypadButton: function() {
        var b = this,
            a = Sys.applyProperties({
                clickCallback: b.onButtonClick.bind(b)
            }, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.autoPlay.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.autoPlay.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.autoPlay.button
        }
        b.keypadButton = new Interface.utils.CanvasButton(a);
        b.keypadPendingDisable.forEach(b.keypadButton.disable.bind(b.keypadButton));
        delete b.keypadPendingDisable
    },
    update: function() {
        var b = this,
            a = b.model.readData("autoPlayNrSpins"),
            c = b.model.readData("autoPlayActive");
        if (c && a > 0) {
            b.spinsLeftCounter.el.textContent = a;
            b.container.addCls("autoplayActive");
            b.menuButton.getContainer().el.textContent = a;
            b.menuButton.getContainer().addCls("autoplayActive");
            b.menuButton.addProperty("active", "autoplayActive");
            b.isActive = true
        } else {
            b.resetAutoPlay()
        }
    },
    reduceCounter: function(c) {
        var b = this,
            a = c !== 0 ? c : "";
        b.spinsLeftCounter.el.textContent = a;
        b.menuButton.getContainer().el.textContent = a
    },
    resetAutoPlay: function() {
        var a = this;
        if (a.isActive) {
            a.container.removeCls("autoplayActive");
            a.menuButton.removeProperty("active", "autoplayActive");
            a.menuButton.getContainer().removeCls("autoplayActive");
            a.menuButton.getContainer().el.textContent = "";
            a.isActive = false;
            a.deSelectAutoPlayTarget()
        }
        a.enableRestrictedControls();
        a.enableAdvancedControls()
    },
    enableKeypadButton: function(c) {
        var b = this,
            a;
        if (!c) {
            c = "keypadDisabled"
        }
        if (Sys.isDefined(b.keypadButton)) {
            b.keypadButton.enable(c)
        } else {
            a = b.keypadPendingDisable.indexOf(c);
            if (a >= 0) {
                b.keypadPendingDisable.splice(a, 1)
            }
        }
    },
    disableKeypadButton: function(b) {
        var a = this;
        if (!b) {
            b = "keypadDisabled"
        }
        if (Sys.isDefined(a.keypadButton)) {
            a.keypadButton.disable(b)
        } else {
            if (!a.keypadPendingDisable.contains(b)) {
                a.keypadPendingDisable.push(b)
            }
        }
    },
    showKeypadButton: function(a) {
        if (Sys.isDefined(this.keypadButton)) {
            this.keypadButton.show(a)
        }
    },
    hideKeypadButton: function(a) {
        if (Sys.isDefined(this.keypadButton)) {
            this.keypadButton.hide(a)
        }
    },
    toggleFreeRoundControls: function(b) {
        var c = this,
            a = b || [];
        Sys.each(c.ADVANCED_CONFIG_CONTROLS, function(d) {
            if (!a.contains(d.id)) {
                if (c.model.readData("freeRoundsActive")) {
                    c.advancedList.disable(d.id)
                } else {
                    c.advancedList.enable(d.id)
                }
            }
        })
    },
    onFreeRoundsStateChange: function(b) {
        var c = this,
            a = c.FREEROUND_ACTIVE_CONTROLS;
        c.model.storeData("freeRoundsActive", b);
        c.toggleFreeRoundControls(a);
        c.toggleRestrictedControls()
    },
    toggleRestrictedControls: function() {
        var b = this,
            c = b.model.readData("freeRoundsActive"),
            a;
        if (b.model.readData("isRestrictedModeEnabled")) {
            a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
            if (c) {
                b.model.storeData("isRestrictedMode", false);
                a.checkBox.unlock("autoplay");
                a.checkBox.setValue(false, false);
                b.restrictedAdvancedList.disable("stopAutoplayIfBalanceDecreasedBy");
                a.checkBox.lock("autoplay");
                b.restrictedAdvancedList.hide("stopAutoplayIfBalanceDecreasedBy");
                b.restrictedWrapper.addCSSClass("hide")
            } else {
                b.model.storeData("isRestrictedMode", true);
                b.restrictedAdvancedList.enable("stopAutoplayIfBalanceDecreasedBy");
                a.checkBox.unlock("autoplay");
                a.checkBox.setValue(true, true);
                b.restrictedAdvancedList.show("stopAutoplayIfBalanceDecreasedBy");
                b.restrictedWrapper.removeCSSClass("hide")
            }
        }
    },
    disableAdvancedControls: function() {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function(b) {
            if (Sys.isDefined(b.withInput)) {
                a.advancedList.disable(b.id)
            }
        })
    },
    enableAdvancedControls: function() {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function(d) {
            var c = a.model.readData("freeRoundsActive"),
                b = !c && Sys.isDefined(d.withInput),
                e = c && d.withInput && a.FREEROUND_ACTIVE_CONTROLS.contains(d.id);
            if (b || e) {
                a.advancedList.enable(d.id)
            }
        })
    },
    disableRestrictedControls: function() {
        var a = this;
        a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
            a.restrictedAdvancedList.disable(b.id)
        })
    },
    enableRestrictedControls: function() {
        var a = this;
        if (!a.model.readData("freeRoundsActive")) {
            a.RESTRICTED_CONFIG_CONTROLS.forEach(function(b) {
                a.restrictedAdvancedList.enable(b.id)
            })
        }
    }
};
Interface.AutoplaySettingsView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.AutoplaySettingsView, "Interface.AutoplaySettingsView");
Sys.ns("Interface");
Interface.AutoplaySettingsModel = {
    constructor: function() {
        Interface.AutoplaySettingsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var b = this,
            a = [{
                key: "stopAutoplayOnAnyWin",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }, {
                key: "stopAutoplayIfBalanceIncreasedBy",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }, {
                key: "stopAutoplayIfWinExceeds",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }, {
                key: "stopAutoplayIfBalanceDecreasedBy",
                defaultValue: false,
                settingsManager: true,
                localStorage: false
            }];
        Interface.AutoplaySettingsModel.superclass.setupData.apply(b, arguments);
        b.storeData("isRestrictedModeEnabled", b.readData("isRestrictedMode"));
        a.forEach(b.initData, b)
    }
};
Interface.AutoplaySettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.AutoplaySettingsModel, "Interface.AutoplaySettingsModel");
Sys.ns("Interface");
Interface.GameSettings = {
    constructor: function() {
        Interface.GameSettings.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.GameSettingsController,
            model: Interface.GameSettingsModel,
            view: Interface.GameSettingsDesktopView
        }
    }
};
Interface.GameSettings = Sys.extend(Interface.SettingsSection, Interface.GameSettings, "Interface.GameSettings");
Sys.ns("Interface");
Interface.GameSettingsController = {
    LOCAL_STORAGE_SETTINGS: ["showFeatureSplash", "quickSpin", "showIntroMovie", "spacebarToSpin"],
    constructor: function() {
        Interface.GameSettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:settingsManager.settingChanged": a.view.update.bind(a.view),
            "notify:settingsManager.settingDisabled": a.view.hideSetting.bind(a.view),
            "notify:settingsManager.settingEnabled": a.view.showSetting.bind(a.view),
            "notify:settingsManager.settingLocked": a.view.disableSetting.bind(a.view),
            "notify:settingsManager.settingUnlocked": a.view.enableSetting.bind(a.view),
            "notify:stateHandler.leavingIdleState": a.hide,
            "request:gameSettings.close": a.onHideRequest,
            "request:closeOpenWindows": a.onHideRequest,
            "request:gameSettings.toggle": a.onToggle,
            "view:gameHistoryClicked": a.onGameHistoryClicked,
            "view:gameHistory.open": a.passAsRequestEvent
        });
        Interface.GameSettingsController.superclass.setupEvents.apply(a, arguments)
    },
    onUserAction: function(b, d) {
        var c = this,
            a = false;
        if (c.LOCAL_STORAGE_SETTINGS.contains(b)) {
            a = true
        }
        this.fireEvent("request:settingsManager.storeData", b, d, a)
    },
    onShowRequest: function() {
        var a = this;
        a.fireEvent("request:autoplaySettings.close");
        Interface.GameSettingsController.superclass.onShowRequest.apply(a, arguments)
    },
    onGameHistoryClicked: function() {
        if (this.model.readData("historyRemoved") || this.model.readData("historyDisabled")) {
            return
        }
        Sys.utils.openURL(Resources.readData("historyUrl"), "gameHistory")
    },
    onToggle: function() {
        var a = this;
        if (a.model.readData("showing")) {
            a.hide()
        } else {
            a.show()
        }
    },
    passAsRequestEvent: function() {
        this.fireEvent("request:gameHistory.open")
    }
};
Interface.GameSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.GameSettingsController, "Interface.GameSettingsController");
Sys.ns("Interface");
Interface.GameSettingsModel = {
    constructor: function() {
        Interface.GameSettingsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var d = this,
            a = [{
                key: "showFeatureSplash",
                defaultValue: true,
                settingsManager: true,
                localStorage: true
            }, {
                key: "quickSpin",
                defaultValue: false,
                settingsManager: true,
                localStorage: true
            }, {
                key: "showIntroMovie",
                defaultValue: true,
                settingsManager: true,
                localStorage: true
            }, {
                key: "spacebarToSpin",
                defaultValue: false,
                settingsManager: true,
                localStorage: true
            }],
            c = Resources.readData("gameServerInitResponse"),
            b = Resources.readData("queryData").skipIntro;
        a.forEach(d.initData, d);
        if (c.playforfun) {
            d.storeData("historyDisabled", true)
        } else {
            if (typeof c.historybutton !== "undefined" && !c.historybutton) {
                d.storeData("historyRemoved", true)
            }
        }
        if (typeof b === "boolean") {
            d.storeData("introMovieRemoved", b || false)
        }
    }
};
Interface.GameSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.GameSettingsModel, "Interface.GameSettingsModel");
Sys.ns("Interface");
Interface.GameSettingsDesktopView = {
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameSettings_icon_uri",
    DISABLE_BUTTON_DURING_SPIN: false,
    SETTINGS_CONTROLS: [{
        id: "quickSpin",
        label: Language.Keys.setting_quickSpinGame,
        type: "checkbox"
    }, {
        id: "showFeatureSplash",
        label: Language.Keys.setting_introScreeGame,
        type: "checkbox"
    }, {
        id: "showIntroMovie",
        label: Language.Keys.setting_introGame,
        type: "checkbox"
    }, {
        id: "spacebarToSpin",
        label: Language.Keys.setting_spaceSpin,
        type: "checkbox"
    }],
    TITLE: Language.Keys.gameSettingsPanelLabel,
    ARROW_LEFT_VALUE: "0.05rem",
    ORDER: 1,
    constructor: function() {
        Interface.GameSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var a = this;
        Interface.GameSettingsDesktopView.superclass.setUpContent.apply(a, arguments);
        if (a.model.readData("introMovieRemoved")) {
            a.SETTINGS_CONTROLS.forEach(function(c, b) {
                if (c.id === "showIntroMovie") {
                    a.SETTINGS_CONTROLS.splice(b, 1)
                }
            })
        }
        a.settingsList = new Interface.utils.DOMControlList({
            id: "gameSettingsSettingsList",
            controls: a.SETTINGS_CONTROLS,
            callback: a.fireEvent.bind(a, "view:userAction")
        });
        a.SETTINGS_CONTROLS.forEach(function(b) {
            a.settingsList.update(b.id, a.model.readData(b.id))
        });
        a.container.add(a.settingsList.getContainer());
        if (!(a.model.readData("historyRemoved") || a.model.readData("historyDisabled"))) {
            a.container.add(a.createGameHistoryButton())
        }
    },
    update: function(a, b) {
        this.settingsList.update(a, b)
    },
    hideSetting: function(a) {
        this.settingsList.hide(a)
    },
    showSetting: function(a) {
        this.settingsList.show(a)
    },
    disableSetting: function(a) {
        this.settingsList.disable(a)
    },
    enableSetting: function(a) {
        this.settingsList.enable(a)
    },
    createGameHistoryButton: function() {
        var a = this;
        a.historyButton = new Interface.utils.DOMButton({
            id: "gameHistoryButton",
            baseCSS: "interface-desktopControls_Button_small interface-desktopGameHistoryButton preventUserSelect interface-interface-desktopControls_Button_small_uri",
            clickCallback: a.openGameHistory.bind(a),
            textContent: Services.languageManager.getText(Language.Keys.gameHistory)
        });
        return a.historyButton.getContainer()
    },
    openGameHistory: function() {
        this.fireEvent("view:gameHistory.open")
    }
};
Interface.GameSettingsDesktopView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.GameSettingsDesktopView, "Interface.GameSettingsDesktopView");
Sys.ns("Interface");
Interface.SoundSettings = {
    constructor: function() {
        Interface.SoundSettings.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["userInput", "orientation"],
            desktop: [{
                userInput: {
                    inputEvents: ["start", "end", "cancel", "move", "hover"],
                    listenToUserInput: true
                }
            }]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SoundSettingsController,
            model: Interface.SoundSettingsModel,
            view: Interface.SoundSettingsBaseView
        }
    }
};
Interface.SoundSettings = Sys.extend(Interface.SettingsSection, Interface.SoundSettings, "Interface.SoundSettings");
Sys.ns("Interface");
Interface.SoundSettingsController = {
    constructor: function() {
        Interface.SoundSettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:soundSettings.enableVibrationSetting": a.onEnableVibrationSetting,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:audioPlayer.loadingSound": a.view.startSoundLoading.bind(a.view),
            "notify:audioPlayer.soundLoaded": a.view.soundLoadedStopLoader.bind(a.view),
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.checkVolumeLevel,
            "view:toggleSound": a.toggleSound
        });
        Interface.SoundSettingsController.superclass.setupEvents.apply(a, arguments)
    },
    onUserAction: function(a, b) {
        switch (a) {
            case "audioOn":
                Services.settingsManager.storeSetting("volume", b ? this.model.getPreviousVolume() : 0, true);
                break;
            case "volume":
                Services.settingsManager.storeSetting("volume", b, true);
                break;
            case "vibrationOn":
                Services.settingsManager.storeSetting("vibration", b, true);
                break;
            default:
        }
    },
    onEnableVibrationSetting: function() {
        this.view.addVibrationToggle()
    },
    onUserInputHover: function(a) {
        this.view.onUserInputHover(a)
    },
    onSettingChanged: function(a, b) {
        if (a === "volume") {
            this.view.update(b);
            if (b > 0) {
                this.model.storeData("previousVolume", b)
            }
        } else {
            if (a === "vibration") {
                this.view.updateVibration(b)
            }
        }
    },
    checkVolumeLevel: function() {
        var a = Services.settingsManager.getSetting("volume");
        this.view.update(a)
    }
};
Interface.SoundSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.SoundSettingsController, "Interface.SoundSettingsController");
Sys.ns("Interface");
Interface.SoundSettingsModel = {
    constructor: function() {
        Interface.SoundSettingsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = this;
        a.initData({
            key: "volume",
            defaultValue: Platform.resourceBundle.preloadAudio ? 1 : 0,
            settingsManager: true,
            localStorage: Platform.resourceBundle.preloadAudio
        });
        a.initData({
            key: "vibration",
            defaultValue: false,
            settingsManager: true,
            localStorage: true
        });
        a.storeData("previousVolume", 1)
    },
    getPreviousVolume: function() {
        var a = this.readData("previousVolume");
        if (!Sys.isDefined(a)) {
            a = 1
        }
        return a
    }
};
Interface.SoundSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.SoundSettingsModel, "Interface.SoundSettingsModel");
Sys.ns("Interface");
Interface.SoundSettingsBaseView = {
    BASE_CSS: "tab interface-soundSettings_base",
    PORTRAIT_CSS: "interface-soundSettings_portrait",
    LANDSCAPE_CSS: "interface-soundSettings_landscape",
    SECTION_CSS: "utils_empty interface-settingsSection_subSection",
    LOAD_ANIMATION_CSS: "interface-smallSpinner_uri",
    constructor: function() {
        Interface.SoundSettingsBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "userSettings",
            tag: "div",
            cls: a.BASE_CSS
        });
        a.audioOnOffContainer = a.container.add(new Sys.Element({
            id: "soundSettings_soundSettings",
            tag: "div",
            cls: a.SECTION_CSS
        }));
        a.audioOnOff = new Interface.utils.ToggleSwitch({
            id: "audioOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_gameSound),
            callback: a.onSettingsControllerChanged.bind(a, "audioOn")
        });
        a.audioOnOffContainer.add(a.audioOnOff.getContainer());
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.soundSettings_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {
            order: 1
        });
        a.subComponents = [a.audioOnOff];
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    addVibrationToggle: function() {
        var a = this;
        a.vibrationOnOffContainer = a.container.add(new Sys.Element({
            id: "soundSettings_soundSettings",
            tag: "div",
            cls: a.SECTION_CSS
        }));
        a.vibrationOnOff = new Interface.utils.ToggleSwitch({
            id: "vibrationOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_gameVibration),
            callback: a.onSettingsControllerChanged.bind(a, "vibrationOn")
        });
        a.vibrationOnOffContainer.add(a.vibrationOnOff.getContainer());
        a.subComponents.push(a.vibrationOnOff);
        a.vibrationOnOff.enable();
        a.updateVibration(Services.settingsManager.getSetting("vibration"))
    },
    onSettingsControllerChanged: function(b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function() {
        this.callFunctionOnSubComponents("enable")
    },
    disable: function() {
        this.callFunctionOnSubComponents("disable")
    },
    update: function(a) {
        this.audioOnOff.toggle(a > 0)
    },
    updateVibration: function(a) {
        this.vibrationOnOff.toggle(a)
    },
    startSoundLoading: function() {
        var a = this;
        a.audioOnOff.displayLoadAnimation();
        a.disable();
        a.update(Services.settingsManager.getSetting("volume"))
    },
    soundLoadedStopLoader: function() {
        this.enable();
        this.update(Services.settingsManager.getSetting("volume"));
        this.audioOnOff.hideLoadAnimation()
    }
};
Interface.SoundSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.SoundSettingsBaseView, "Interface.SoundSettingsBaseView");
Sys.ns("Interface");
Interface.SoundSettingsDesktopView = {
    WRAPPER_CSS: "interface-soundSettingsDesktop_sliderWrapper",
    BASE_CSS: "interface-soundSettingsDesktop_sliderBase interface-standAloneSettingsSectionMiddle_uri",
    BUTTON_CSS: "interface-desktopSettingsMenu_button interface-soundSettings_audioOn_icon_uri",
    BUTTON_OFF_CSS: "interface-soundSettings_audioOff_icon_uri",
    LOAD_ANIMATION_CSS: "interface-soundSettingsDesktop_spinner interface-smallSpinner_uri hidden",
    CLOSE_ANIMATION_CSS: "interface-soundSettingsDesktop_closeTransition",
    constructor: function() {
        Interface.SoundSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    addVibrationToggle: function() {},
    onUserInputStart: function(a) {},
    onUserInputMove: function() {},
    onUserInputEnd: function(a) {},
    onUserInputHover: function(b) {
        var a = this;
        if (Sys.UserInputUtils.isCoordinateTarget(a.container.el, b) || Sys.UserInputUtils.isCoordinateTarget(a.menuButton.el, b)) {
            a.menuButton.addCls("hover");
            a.open()
        } else {
            a.menuButton.removeCls("hover");
            a.close()
        }
    },
    show: function() {
        this.open()
    },
    hide: function() {
        this.close()
    },
    open: function() {
        var a = this;
        a.wrapper.removeCls(a.CLOSE_ANIMATION_CSS);
        a.isOpen = true;
        if (!a.model.readData("disabled")) {
            a.volume.enable()
        }
    },
    close: function() {
        var a = this;
        a.wrapper.addCls(a.CLOSE_ANIMATION_CSS);
        if (a.volume) {
            a.volume.disable()
        }
        a.isOpen = false
    },
    setUpContent: function() {
        var a = this;
        a.wrapper = new Sys.Element({
            id: "soundSettingsWrapper",
            tag: "div",
            cls: a.WRAPPER_CSS,
            renderTo: "gameWrapper"
        });
        a.container = a.wrapper.add(new Sys.Element({
            id: "soundSettings",
            tag: "div",
            cls: a.BASE_CSS
        }));
        a.menuButton = new Sys.Element({
            id: "soundSettingsButton",
            tag: "div",
            cls: a.BUTTON_CSS
        });
        a.abstractButton = new Interface.AbstractButton({
            dimensions: a.menuButton.el,
            clickCallback: a.toggle.bind(a)
        });
        a.volume = new Interface.utils.VerticalSlider({
            id: "soundVolumeSlider",
            minValue: 0,
            maxValue: 1,
            valueStep: 0.05,
            startValue: Services.settingsManager.getSetting("volume"),
            callback: a.fireEvent.bind(a, "view:userAction", "volume"),
            ascendingGrowth: true,
            showDisplay: false,
            callbackOnlyOnEndEvent: false
        });
        a.loadAnimation = a.container.add(new Sys.Element({
            id: "soundSettings_loadAnimation",
            tag: "div",
            cls: a.LOAD_ANIMATION_CSS
        }));
        a.container.add(a.volume.getContainer());
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
            order: 1,
            element: a.menuButton
        });
        a.update(Services.settingsManager.getSetting("volume"));
        a.hide()
    },
    toggle: function() {
        this.fireEvent("view:userAction", "audioOn", Services.settingsManager.getSetting("volume") === 0)
    },
    enable: function() {
        var a = this;
        a.abstractButton.enable("sectionDisabled");
        a.volume.enable()
    },
    disable: function() {
        var a = this;
        a.abstractButton.disable("sectionDisabled");
        a.volume.disable()
    },
    startSoundLoading: function() {
        this.disable();
        this.loadAnimation.el.style.display = "block"
    },
    soundLoadedStopLoader: function() {
        this.enable();
        this.loadAnimation.el.style.display = "none"
    },
    update: function(b) {
        var a = this;
        if (!a.volume.enabled) {
            a.enable()
        }
        a.menuButton.removeCls(a.BUTTON_OFF_CSS);
        if (!(b > 0)) {
            a.menuButton.addCls(a.BUTTON_OFF_CSS)
        }
        a.volume.moveSlider(b)
    },
    removeSetting: function() {}
};
Interface.SoundSettingsDesktopView = Sys.extend(Core.View, Interface.SoundSettingsDesktopView, "Interface.SoundSettingsDesktopView");
Sys.ns("Core");
Core.Trigger = {
    constructor: function() {
        Core.Trigger.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.TriggerModel,
            controller: Core.TriggerController
        }
    }
};
Core.Trigger = Sys.extend(Core.Module, Core.Trigger, "Core.Trigger");
Resources.storeData("triggerScripts", {});
Sys.ns("Core");
Core.TriggerController = {
    constructor: function() {
        Core.TriggerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:platform.visibilityChanged": this.onPageVisibilityChanged,
            "notify:moduleLoader.finishedLoadingModules": this.onFinishedLoadingModules,
            "notify:audioPlayer.soundPlayable": this.onSoundReady
        })
    },
    onFinishedLoadingModules: function() {
        var a = Resources.readData("config") || {};
        if (Utils.Platform.isWebAudioAPISupported() && a.enableWADE) {
            this.fireEvent("request:audioPlayer.disableEventInteractions")
        }
        this.fireEvent("notify:trigger.ready")
    },
    onSoundReady: function() {
        this.model.storeData("audioReady", true)
    },
    onPageVisibilityChanged: function(a) {},
    registerTrigger: function(d, a, c) {
        var b = this;
        this.addListener(d, function() {
            b.executeTrigger.apply(b, [d].concat(Array.prototype.slice.call(arguments)))
        });
        this.model.registerTrigger(d, a, c)
    },
    executeTrigger: function(g) {
        var c = this.model.getScriptsLinkedToTrigger(g),
            e = Array.prototype.slice.call(arguments, 1),
            b, d, f, a;
        if (!Utils.Platform.isWebAudioAPISupported() || !this.model.readData("audioReady")) {
            return
        }
        for (f = 0, a = c.length; f < a; f++) {
            d = c[f];
            b = this.determineExecutionEnvironment(g, d.type);
            d.script.apply(b.scope, e)
        }
    },
    listTriggers: function() {
        return Object.keys(this.model.getTriggers())
    },
    listLinkedTriggers: function() {
        return this.model.getLinkedTriggers()
    },
    getTriggerDescription: function(a) {
        return this.model.getTriggerDescription(a)
    },
    getScript: function(a) {
        return Resources.readData("triggerScripts")[a].script.toString()
    },
    getScriptsLinkedToTrigger: function(a) {
        return this.model.getScriptsLinkedToTrigger(a)
    },
    getScriptNamesLinkedToTrigger: function(a) {
        return this.model.getScriptNamesLinkedToTrigger(a)
    },
    linkScriptToTrigger: function(b, a) {
        this.model.linkScriptToTrigger(b, a)
    },
    unlinkScriptAndTrigger: function(b, a) {
        this.model.unlinkScriptAndTrigger(b, a)
    },
    determineExecutionEnvironment: function(c, b) {
        var a = {
            args: []
        };
        switch (b) {
            case "audio":
                a.scope = Audio.Engine;
                break;
            case "animation":
                a.scope = {};
                break;
            default:
                a.scope = [this.model.getTriggerScope(c)]
        }
        return a
    }
};
Core.TriggerController = Sys.extend(Core.Controller, Core.TriggerController, "Core.TriggerController");
Sys.ns("Core");
Core.TriggerModel = {
    constructor: function() {
        Core.TriggerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("triggers", {});
        this.storeData("scriptLookup", this.initializeScriptLookup())
    },
    initializeScriptLookup: function() {
        var b = Resources.readData("triggerScripts") || {},
            a = Object.keys(b),
            h = a.length,
            f = {},
            g, d, e, c;
        for (e = -1; ++e < h;) {
            g = a[e];
            d = b[g];
            for (c = -1; ++c < d.usedOn.length;) {
                if (!Sys.isDefined(f[d.usedOn[c]])) {
                    f[d.usedOn[c]] = []
                }
                f[d.usedOn[c]].push(g)
            }
        }
        return f
    },
    registerTrigger: function(a, c, b) {
        this.readData("triggers")[a] = {
            description: b,
            defaultScope: c
        }
    },
    getTriggers: function() {
        return this.readData("triggers")
    },
    hasTrigger: function(a) {
        return this.readData("triggers").hasOwnProperty(a)
    },
    getLinkedTriggers: function() {
        return Object.keys(this.readData("scriptLookup"))
    },
    getTriggerDescription: function(b) {
        var a = this.readData("triggers")[b];
        return Sys.isObj(a) ? a.description : null
    },
    getTriggerScope: function(b) {
        var a = this.readData("triggers")[b];
        return Sys.isObj(a) ? a.defaultScope : null
    },
    getScriptNamesLinkedToTrigger: function(a) {
        return this.readData("scriptLookup")[a] || []
    },
    getScriptsLinkedToTrigger: function(b) {
        var c = Resources.readData("triggerScripts"),
            a = this.getScriptNamesLinkedToTrigger(b);
        return a.map(function(d) {
            return c[d]
        })
    },
    linkScriptToTrigger: function(c, a) {
        var b = this.readData("scriptLookup");
        if (!Sys.isArray(b[a])) {
            b[a] = []
        }
        if (!b[a].contains(c)) {
            b[a].push(c)
        }
        this.storeData("scriptLookup", b)
    },
    unlinkScriptAndTrigger: function(e, a) {
        var d = this.readData("scriptLookup"),
            c = d[a],
            b;
        if (Sys.isArray(c)) {
            b = c.indexOf(e);
            if (b >= 0) {
                c.splice(b, 1)
            }
        }
        this.storeData("scriptLookup", d)
    }
};
Core.TriggerModel = Sys.extend(Core.Model, Core.TriggerModel, "Core.TriggerModel");
(function(a) {
    var b = "buttonSounds";
    a.buttonUp = {
        usedOn: ["notify:button.up", "notify:spinButton.up"],
        type: "audio",
        script: function() {
            this.play(b, "buttonUp")
        }
    };
    a.buttonDown = {
        usedOn: ["notify:button.down", "notify:spinButton.down"],
        type: "audio",
        script: function() {
            this.play(b, "buttonDown")
        }
    };
    a.buttonHover = {
        usedOn: ["notify:button.hover", "notify:spinButton.hover", "notify:paytableClose.hover", "notify:paytableIndicator_0.hover", "notify:paytableIndicator_1.hover", "notify:paytableIndicator_2.hover", "notify:paytableNext.hover", "notify:paytablePrevious.hover"],
        type: "audio",
        script: function(c) {
            if (!c) {
                this.play(b, "buttonHover")
            }
        }
    };
    a.buttonClick = {
        usedOn: ["notify:button.click"],
        type: "audio",
        script: function() {
            this.play(b, "buttonClick")
        }
    };
    a.spinButtonClick = {
        usedOn: ["notify:spinButton.clicked"],
        type: "audio",
        script: function() {
            this.play(b, "spinButtonClick")
        }
    };
    a.sliderIncrease = {
        usedOn: [],
        type: "audio",
        script: function() {}
    };
    a.sliderDecrease = {
        usedOn: [],
        type: "audio",
        script: function() {}
    };
    a.paytableFlip = {
        usedOn: ["notify:paytableNext.click", "notify:paytablePrevious.click", "notify:paytableIndicator_0.click", "notify:paytableIndicator_1.click", "notify:paytableIndicator_2.click"],
        type: "audio",
        script: function() {}
    };
    a.paytableButtonDown = {
        usedOn: ["notify:paytableClose.down"],
        type: "audio",
        script: function() {}
    };
    a.paytableButtonUp = {
        usedOn: ["notify:paytableClose.up"],
        type: "audio",
        script: function() {}
    };
    a.paytableButtonClick = {
        usedOn: ["notify:paytableClose.click"],
        type: "audio",
        script: function() {}
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
    var c = "nearWin",
        d = "spinSounds",
        b = function(e) {
            var f = this.getGroup(e);
            if (Sys.isDefined(f)) {
                f.fadeIn({
                    duration: 0.1
                })
            }
        };
    a.reelSpin = {
        usedOn: ["notify:spin.spinAnimationStarted"],
        type: "audio",
        script: function(e) {
            b.call(this, d);
            this.play(d, "reelSpin")
        }
    };
    a.reelBounceStart = {
        usedOn: ["notify:spin.reelStopBouncingStarted"],
        type: "audio",
        script: function() {
            b.call(this, d);
            this.play(d, "reelBounce")
        }
    };
    a.reelStop = {
        usedOn: ["notify:spin.reelStopStarted"],
        type: "audio",
        script: function(e) {
            b.call(this, d);
            this.play(d, "reelStop")
        }
    };
    a.spinComplete = {
        usedOn: ["notify:spin.spinAnimationComplete"],
        type: "audio",
        script: function() {
            var e = this.getGroup(c),
                f = this.getGroup(d);
            if (Sys.isDefined(e)) {
                e.fadeOut({
                    duration: 1
                })
            }
            if (Sys.isDefined(f)) {
                f.fadeOut({
                    duration: 0.5
                })
            }
        }
    };
    a.quickStop = {
        usedOn: ["notify:quickStopper.quickStop"],
        type: "audio",
        script: function() {}
    };
    a.scatterHit = {
        usedOn: ["notify:reelStopAnimations.symbolsToAnimate"],
        type: "audio",
        script: function(f, e) {
            b.call(this, d);
            this.play(d, "scatterHit")
        }
    };
    a.nearWin = {
        usedOn: ["notify:spin.nearWinStarted"],
        type: "audio",
        script: function() {
            b.call(this, c);
            this.play(c, "nearWin")
        }
    };
    a.nearWinFail = {
        usedOn: [],
        type: "audio",
        script: function() {
            var e = this.getGroup(c);
            if (Sys.isDefined(e)) {
                e.fadeOut({
                    duration: 1
                })
            }
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
    var c = "winPresentation",
        d = "main",
        b;
    a.standardWinStartAudio = {
        usedOn: ["notify:standardWin.startPresentation"],
        type: "audio",
        script: function(e) {
            var f = this.getGroup(c);
            if (Sys.isDefined(f)) {
                f.fadeIn({
                    duration: 0.1
                })
            }
            switch (e) {
                case "smallWin":
                    a.smallWin.script.call(this);
                    break;
                case "mediumWin":
                    a.mediumWin.script.call(this);
                    break;
                case "largeWin":
                    a.largeWin.script.call(this);
                    break;
                default:
            }
        }
    };
    a.countUpAborted = {
        usedOn: ["notify:standardWin.countupAborted"],
        type: "audio",
        script: function() {
            this.getGroup(d).fadeIn({
                duration: 0.5
            })
        }
    };
    a.stopWinSound = {
        usedOn: ["notify:standardWin.countupAborted", "notify:stateHandler.leavingStandardWinPresentationState"],
        type: "audio",
        script: function() {
            var e = this.getGroup(c);
            if (Sys.isDefined(e)) {
                e.fadeOut({
                    duration: 0.5
                })
            }
        }
    };
    a.smallWin = {
        usedOn: [],
        type: "audio",
        script: function() {
            var f = Resources.readData("audioConfig").clips,
                e = f.main.smallWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "smallWin")
        }
    };
    a.mediumWin = {
        usedOn: [],
        type: "audio",
        script: function() {
            var f = Resources.readData("audioConfig").clips,
                e = f.main.mediumWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "mediumWin")
        }
    };
    a.largeWin = {
        usedOn: [],
        type: "audio",
        script: function() {
            var f = Resources.readData("audioConfig").clips,
                e = f.main.largeWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "largeWin")
        }
    };
    a.bigWinStart = {
        usedOn: ["notify:stateHandler.enteringBigWinState"],
        type: "audio",
        script: function() {
            var f = this,
                e, g = this.getGroup(c);
            if (Sys.isDefined(g)) {
                g.fadeIn({
                    duration: 0.1
                })
            }
            b = true;
            a.ambienceGeneralStop.script.call(this);
            f.play(c, "bigWinStart");
            f.play(c, "bigWinLoop", {
                loop: true
            });
            e = f.startMetronome("bigWin", {
                bpm: 123
            });
            e.at(4, 4).stop(c);
            e.at(4, 4).play(c, "bigWinEnd", {
                offset: 0.6
            });
            e.at(4, 4).then(function() {
                f.stopMetronome("bigWin");
                b = false
            })
        }
    };
    a.bigWinLoop = {
        usedOn: ["notify:stateHandler.enteringBigWinState"],
        type: "audio",
        script: function() {}
    };
    a.bigWinCountUpEnd = {
        usedOn: ["notify:bigWin.showTotalInCountUp"],
        type: "audio",
        script: function() {
            if (b) {
                this.stop(c);
                this.play(c, "bigWinEnd", {
                    offset: 2.7
                })
            }
        }
    };
    a.bigWinEnd = {
        usedOn: ["notify:stateHandler.leavingBigWinState"],
        type: "audio",
        script: function() {
            this.getGroup(c).fadeOut({
                duration: 2
            });
            a.ambienceGeneralStart.script.call(this)
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function(a) {
    var c = "main",
        b = false;
    a.globalSettings = {
        usedOn: ["notify:settingsManager.settingChanged"],
        type: "audio",
        script: function(d, e) {
            if (d === "volume") {
                this.setVolume(e)
            }
        }
    };
    a.volumeRestore = {
        usedOn: ["notify:stateHandler.leavingSetupGameState"],
        type: "audio",
        script: function() {
            var d = Services.settingsManager.getSetting("volume");
            this.setVolume(d)
        }
    };
    a.soundLoaded = {
        usedOn: ["notify:audioPlayer.soundLoaded"],
        type: "audio",
        script: function() {
            var d;
            if (Services.storage.readData("IntroMovie.showing") === true) {
                return
            }
            d = Services.storage.readData("playModeManager.modes");
            if (d.indexOf("basic") > -1) {
                a.ambienceGeneralStart.script.call(this)
            } else {
                if (d.indexOf("freespin") > -1) {
                    a.ambienceFreeSpinStart.script.call(this)
                }
            }
        }
    };
    a.ambienceGeneralStart = {
        usedOn: ["notify:stateHandler.leavingShowingIntroMovieState"],
        type: "audio",
        script: function() {
            var d = b ? "freeSpin" : "ambienceGeneral";
            this.stop(c);
            this.play(c, d, {
                loop: true
            })
        }
    };
    a.ambienceGeneralStop = {
        usedOn: ["notify:stateHandler.enteringShowingIntroMovieState"],
        type: "audio",
        script: function() {
            this.stop(c)
        }
    };
    a.ambienceFreeSpinStart = {
        usedOn: ["notify:stateHandler.enteringFreeSpinIntroState"],
        type: "audio",
        script: function() {
            b = true;
            a.ambienceGeneralStart.script.call(this)
        }
    };
    a.ambienceFreeSpinStop = {
        usedOn: ["notify:stateHandler.leavingFreeSpinOutroState"],
        type: "audio",
        script: function() {
            b = false;
            a.ambienceGeneralStart.script.call(this)
        }
    };
    a.freeSpinCountdown = {
        usedOn: ["notify:stateHandler.enteringCountDownFreespinsState"],
        type: "audio",
        script: function() {}
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
Sys.ns("Core");
Core.SlowRequestAnimation = {
    constructor: function() {
        Core.SlowRequestAnimation.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.SlowRequestAnimationModel,
            view: Core.SlowRequestAnimationView,
            controller: Core.SlowRequestAnimationController
        }
    },
    getMixinDependencies: function() {
        return ["orientation"]
    }
};
Core.SlowRequestAnimation = Sys.extend(Core.Module, Core.SlowRequestAnimation, "Core.SlowRequestAnimation");
Sys.ns("Core");
Core.SlowRequestAnimationModel = {
    constructor: function() {
        Core.SlowRequestAnimationModel.superclass.constructor.apply(this, arguments);
        this.initModel()
    },
    initModel: function() {
        var a = this;
        a.storeData("timeConfig", {
            between: 300,
            slowConnectionTime: 10000,
            slowDialogTime: 30000
        });
        a.storeData("activeStack", []);
        a.storeData("requestConfig", a.getRequestConfig());
        a.storeData("dialogShowing", false);
        a.setState("idle")
    },
    updateActiveStack: function(d) {
        var c = this,
            a = this.readData("activeStack"),
            b = a.indexOf(d);
        if (b > -1) {
            a.splice(b, 1);
            c.storeData("activeStack", a)
        }
        return a
    },
    pushActive: function(c) {
        var b = this,
            a = b.readData("activeStack");
        a.push(c);
        b.storeData("activeStack", a)
    },
    getRequestConfig: function() {
        return ["spin", "drop", "freespin", "respin", "freespininit", "initbonus", "bonusaction"]
    },
    removeSlowTimeout: function() {
        var a = this.readData("slowTimeout");
        if (a) {
            clearTimeout(a);
            this.removeData("slowTimeout")
        }
    },
    removeDialogTimeout: function() {
        var a = this.readData("dialogTimeout");
        if (a) {
            this.storeData("dialogShowing", false);
            clearTimeout(a);
            this.removeData("dialogTimeout")
        }
    },
    getSlowConnectionTimeout: function() {
        return this.readData("slowTimeout")
    },
    getDialogTimeout: function() {
        return this.readData("dialogTimeout")
    },
    storeDialogTimeout: function(a) {
        var b = this,
            c = b.readData("dialogTimeout");
        if (c) {
            clearTimeout(c);
            b.storeData("dialogTimeout", a)
        } else {
            b.storeData("dialogTimeout", a)
        }
    },
    storeSlowConnectionTimeout: function(a) {
        var b = this,
            c = b.readData("slowTimeout");
        if (c) {
            clearTimeout(c);
            b.storeData("slowTimeout", a)
        } else {
            b.storeData("slowTimeout", a)
        }
    }
};
Core.SlowRequestAnimationModel = Sys.extend(Core.Model, Core.SlowRequestAnimationModel, "Core.SlowRequestAnimationModel");
Sys.ns("Core");
Core.SlowRequestAnimationController = {
    constructor: function() {
        Core.SlowRequestAnimationController.superclass.constructor.apply(this, arguments);
        this.initController()
    },
    initController: function() {
        var a = this;
        a.on({
            "view:showDialog": a.onShowDialog,
            "view:dialogContinue": a.onDialogContinueOption,
            "view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
            "view:dialogBoxClosed": a.onDialogBoxClosed,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
            "notify:serverManager.actionRequestSent": a.onServerRequest,
            "notify:serverManager.actionRequestError": a.tryToHideAnimation,
            "notify:serverManager.slowRequest": a.onSlowResponse,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "request:slowRequestAnimation.show": a.showSpinnerAnimation,
            "request:slowRequestAnimation.hide": a.hideSpinnerAnimation
        })
    },
    onLoaderClose: function() {
        this.view.initView()
    },
    onShowDialog: function(a) {
        var b = this;
        b.fireEvent("request:dialogWindow.showDialog", a);
        b.model.storeData("dialogShowing", true)
    },
    animationRequested: function() {
        var a = this;
        if (a.model.isState("active")) {
            a.view.display({
                modal: false
            });
            a.model.setState("running")
        }
    },
    showSpinnerAnimation: function() {
        this.fireEvent("request:userInputManager.activateExclusivity", "slowRequestAnimation");
        this.view.addOverlay();
        this.view.showSpinner()
    },
    hideSpinnerAnimation: function() {
        this.fireEvent("request:userInputManager.deactivateExclusivity", "slowRequestAnimation");
        this.view.removeOverlay();
        this.view.hideSpinner()
    },
    onServerRequest: function(b) {
        var a = this;
        if (a.model.readData("requestConfig").contains(b) && a.model.isState("idle")) {
            a.model.setState("active");
            a.model.pushActive(b)
        }
    },
    onSlowResponse: function() {
        this.animationRequested()
    },
    onServerResponse: function(a) {
        if ((Sys.isDefined(a) && Sys.isDefined(a.clientaction))) {
            this.tryToHideAnimation(a.clientaction)
        }
    },
    tryToHideAnimation: function(d) {
        var c = this,
            b = c.model,
            a;
        if (b.isState("running") || b.isState("active")) {
            a = b.updateActiveStack(d);
            if (a.length > 0) {} else {
                if (c.model.readData("dialogShowing")) {
                    c.fireEvent("request:dialogWindow.closeCurrentDialog")
                }
                c.view.hideWrapper();
                c.view.resetSlowMessage();
                c.view.resetDialogMessage(false);
                b.setState("idle")
            }
        }
    },
    onDialogContinueOption: function() {
        this.view.resetDialogMessage(true)
    },
    onDialogBoxClosed: function(a) {
        this.fireEvent("notify:dialogBoxClosed", a)
    }
};
Core.SlowRequestAnimationController = Sys.extend(Core.Controller, Core.SlowRequestAnimationController, "Core.SlowRequestAnimationController");
Sys.ns("Core.Slots");
Core.SlowRequestAnimationView = {
    BASE_CSS: "interface-slowRequestAnimation _base",
    PORTRAIT_CSS: "interface-slowRequestAnimation _portrait",
    LANDSCAPE_CSS: "interface-slowRequestAnimation _landscape",
    PIXEL_FACTOR: 0.01,
    constructor: function() {
        Core.SlowRequestAnimationView.superclass.constructor.apply(this, arguments)
    },
    initView: function() {
        var a = this;
        a.hasOverlay = false;
        a.setupElements()
    },
    removeOverlay: function() {
        var b = this,
            a = b.getLayoutConfig().background,
            c = b.getLayoutConfig().animation;
        b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
        b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
        b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
        b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
        b.background.el.style.borderRadius = "0";
        b.background.el.style.zIndex = 340;
        b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
        b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
        b.hasOverlay = false
    },
    addOverlay: function() {
        var b = this,
            a = b.getLayoutConfig().overlayConfig.background,
            c = b.getLayoutConfig().overlayConfig.animation;
        b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
        b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
        b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
        b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
        b.background.el.style.borderRadius = "0";
        b.background.el.style.zIndex = 340;
        b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
        b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
        b.hasOverlay = true
    },
    onPortrait: function() {
        var a = this;
        Mixins.orientation.view.methods.onPortrait.call(a);
        if (a.hasOverlay) {
            a.addOverlay()
        }
    },
    onLandscape: function() {
        var a = this;
        Mixins.orientation.view.methods.onLandscape.call(a);
        if (a.hasOverlay) {
            a.addOverlay()
        }
    },
    getLayoutConfig: function() {
        var a = {
                width: 960,
                height: 540
            },
            b = Environment.determineResolution().virtualResolution.height;
        return {
            overlayConfig: {
                background: {
                    top: 0 - Environment.getSpaceAboveGame(),
                    left: 0,
                    width: a.width,
                    height: b / Services.scaling.getScale() + Environment.getSpaceBelowGame()
                },
                animation: {
                    top: (b - 310) / 2 + Environment.getSpaceAboveGame(),
                    left: a.width / 2 - (210 / 2)
                }
            },
            wrapper: {
                top: 0,
                left: 0
            },
            background: {
                top: (a.height / 2) - (180 / 2),
                left: (a.width / 2) - (210 / 2),
                width: 210,
                height: 180
            },
            animation: {
                top: (a.height / 2) - (180 / 2),
                left: (a.width / 2) - (376 / 2),
                width: 210,
                height: 180
            },
            textArea: {
                top: 130,
                left: 0,
                width: 0,
                height: 80
            },
            guiArea: {
                top: 410,
                left: 0,
                width: 0,
                height: 100
            }
        }
    },
    setupBackgroundArea: function(c) {
        var b = this,
            a = c || b.getLayoutConfig();
        return new Sys.Element({
            tag: "div",
            id: "slowRequestAnimation",
            cls: "slowRequestAnimation background",
            style: "top:" + a.background.top * b.PIXEL_FACTOR + "rem;left:" + a.background.left * b.PIXEL_FACTOR + "rem;width:" + a.background.width * b.PIXEL_FACTOR + "rem;height:" + a.background.height * b.PIXEL_FACTOR + "rem;"
        })
    },
    getDialogConfig: function() {
        var a = this;
        return {
            slowDialog: {
                title: Services.languageManager.getText(Language.Keys.connectionQualityPoor),
                text: Services.languageManager.getText(Language.Keys.slowConnection),
                buttons: [{
                    text: Services.languageManager.getText(Language.Keys.btn_casino),
                    action: function() {
                        a.fireEvent("view:dialogBoxClosed", {
                            name: "slowRequestAnimation",
                            button: "home"
                        });
                        Sys.utils.goToLobby("9")
                    }
                }, {
                    text: Services.languageManager.getText(Language.Keys.btn_continue),
                    action: function() {
                        a.fireEvent("view:dialogBoxClosed", {
                            name: "slowRequestAnimation",
                            button: "continue"
                        });
                        a.fireEvent("view:dialogContinue")
                    }
                }]
            }
        }
    },
    setupAnimationArea: function(c) {
        var b = this,
            a = c || this.getLayoutConfig();
        return new Sys.Element({
            tag: "div",
            cls: "slowRequestAnimation loadAnimation animation slowRequestAnimation_uri",
            style: "width:" + a.animation.width * b.PIXEL_FACTOR + "rem;height:" + a.animation.height * b.PIXEL_FACTOR + "rem;"
        })
    },
    setupTextArea: function(c) {
        var b = this,
            d, a = c || this.getLayoutConfig();
        b.textSpan = new Sys.Element({
            tag: "span",
            textContent: Services.languageManager.getText(Language.Keys.slowConnection)
        });
        d = new Sys.Element({
            tag: "div",
            cls: "slowRequestAnimation text hide",
            style: "left:" + a.textArea.left * b.PIXEL_FACTOR + "rem;width:100%;min-height:" + a.textArea.height * b.PIXEL_FACTOR + "rem;"
        });
        d.add(b.textSpan);
        return d
    },
    setupElements: function() {
        var b = this,
            a = b.getLayoutConfig();
        b.wrapper = new Sys.Element({
            tag: "div",
            id: "slowRequestAnimation",
            cls: "slowRequestAnimation wrapper hide",
            style: "top:" + a.wrapper.top * b.PIXEL_FACTOR + "rem;left:" + a.wrapper.left * b.PIXEL_FACTOR + "rem;width: 100%;height: 100%;",
            renderTo: "gameWrapper"
        });
        b.background = b.setupBackgroundArea(a);
        b.animation = b.setupAnimationArea(a);
        b.textArea = b.setupTextArea(a);
        b.background.add(b.animation);
        b.wrapper.add(b.background);
        b.wrapper.add(b.textArea);
        b.container = b.wrapper;
        b.fireEvent("view:setSafeArea", "slowRequestAnimation", {
            element: b.container.getEl()
        })
    },
    setupRequestDialogTimeout: function() {
        var b = this,
            c, a = b.model.readData("timeConfig").slowDialogTime;
        c = setTimeout(function() {
            b.requestSlowDialog()
        }, a);
        b.model.storeDialogTimeout(c)
    },
    requestSlowDialog: function() {
        var b = this,
            a = b.getDialogConfig().slowDialog;
        if (b.model.isState("running")) {
            b.hideSpinner();
            b.hideText();
            b.fireEvent("view:showDialog", a)
        }
    },
    onShowSlowConnection: function() {
        this.showText()
    },
    display: function(a) {
        var c = this,
            d, b;
        if (a.modal) {
            c.wrapper.addCls("modal")
        }
        c.wrapper.removeCls("hide");
        if (!a.modal) {
            b = c.model.readData("timeConfig").slowConnectionTime;
            d = setTimeout(function() {
                c.onShowSlowConnection();
                c.setupRequestDialogTimeout()
            }, b);
            c.model.storeSlowConnectionTimeout(d)
        }
        return true
    },
    resetSlowMessage: function() {
        var a = this,
            b = a.model.getSlowConnectionTimeout();
        if (b) {
            a.model.removeSlowTimeout();
            a.hideText()
        }
    },
    resetDialogMessage: function(a) {
        var b = this,
            c = b.model.getDialogTimeout();
        if (c) {
            b.model.removeDialogTimeout();
            if (a && b.model.isState("running")) {
                b.showSpinner();
                b.showText();
                b.setupRequestDialogTimeout()
            }
        }
    },
    showSpinner: function() {
        this.wrapper.removeCls("hide")
    },
    hideSpinner: function() {
        this.hideWrapper()
    },
    hideWrapper: function() {
        this.wrapper.addCls("hide")
    },
    hideText: function() {
        this.textArea.addCls("hide")
    },
    showText: function() {
        this.textArea.removeCls("hide")
    }
};
Core.SlowRequestAnimationView = Sys.extend(Core.View, Core.SlowRequestAnimationView, "Core.SlowRequestAnimationView");
Sys.ns("Core");
Core.SlowRequestAnimationDesktopView = {
    constructor: function() {
        Core.SlowRequestAnimationDesktopView.superclass.constructor.apply(this, arguments)
    },
    setupRequestDialogTimeout: function() {}
};
Core.SlowRequestAnimationDesktopView = Sys.extend(Core.SlowRequestAnimationView, Core.SlowRequestAnimationDesktopView, "Core.SlowRequestAnimationDesktopView");
Sys.ns("Interface");
Interface.HomeButton = {
    constructor: function() {
        Interface.HomeButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation", {
            userInput: {
                listenToUserInput: true
            }
        }]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.HomeButtonController,
            model: Core.Model,
            view: Interface.HomeButtonBaseView
        }
    }
};
Interface.HomeButton = Sys.extend(Core.Module, Interface.HomeButton, "Interface.HomeButton");
Sys.ns("Interface");
Interface.HomeButtonController = {
    constructor: function() {
        Interface.HomeButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Interface.HomeButtonController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
            "notify:settingsMenu.open": a.view.hide.bind(a.view),
            "notify:settingsMenu.closed": a.view.show.bind(a.view),
            "request:homeButton.hidePermanently": a.hidePermanently
        })
    },
    onLoaderClose: function() {
        var a = this;
        a.view.show();
        a.view.setFullscreenSafeArea()
    },
    hidePermanently: function() {
        this.model.storeData("hiddenPermanently", true);
        this.view.hide()
    },
    onUserInputStart: function(a) {
        if (this.view.isInputTarget(a)) {
            this.model.storeData("activeInputTarget", true)
        }
    },
    onUserInputEnd: function(c) {
        var b = this,
            a = Resources.readData("lobbyUrl");
        if (b.model.readData("activeInputTarget")) {
            if (b.view.isInputTarget(c)) {
                if (Sys.isDefined(a) && a !== "") {
                    b.fireEvent("request:slowRequestAnimation.show")
                }
                Sys.utils.goToLobby("0")
            }
        }
        b.model.storeData("activeInputTarget", false)
    }
};
Interface.HomeButtonController = Sys.extend(Core.Controller, Interface.HomeButtonController, "Interface.HomeButtonController");
Sys.ns("Interface");
Interface.HomeButtonBaseView = {
    BASE_BUTTON_CSS: "interface-homeButton_baseButton",
    PORTRAIT_CSS: "interface-homeButton_portraitBase",
    LANDSCAPE_CSS: "interface-homeButton_landscapeBase",
    URI_BUTTON: "interface-homeButton_button_uri",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.HomeButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function(a) {
        this.setStyle(a)
    },
    init: function() {
        var a = this;
        Interface.HomeButtonBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "homeButton",
            tag: "div",
            cls: a.BASE_BUTTON_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display: none;"
        })
    },
    setFullscreenSafeArea: function() {
        var a = this;
        a.fireEvent("view:setSafeArea", "homeButton", {
            element: a.container.getEl()
        })
    },
    show: function() {
        var b = this,
            a = b.container;
        if (!b.model.readData("hiddenPermanently")) {
            a.el.style.display = "block";
            if (!a.hasCls(b.URI_BUTTON)) {
                a.addCls(b.URI_BUTTON)
            }
        }
    },
    hide: function() {
        this.container.el.style.display = "none"
    },
    isInputTarget: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    setStyle: function(a) {
        var c = this,
            d = a + "_CSS",
            b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(c[d])) {
            c.container.removeCls(c[b]);
            c.container.addCls(c[d])
        }
    }
};
Interface.HomeButtonBaseView = Sys.extend(Core.View, Interface.HomeButtonBaseView, "Interface.HomeButtonBaseView");
Sys.ns("Interface");
Interface.HomeButtonMobileView = {
    PORTRAIT_CSS: "interface-homeButton_portraitBase_mobile",
    LANDSCAPE_CSS: "interface-homeButton_landscapeBase_mobile",
    constructor: function() {
        Interface.HomeButtonMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.HomeButtonMobileView = Sys.extend(Interface.HomeButtonBaseView, Interface.HomeButtonMobileView, "Interface.HomeButtonMobileView");
Sys.ns("Interface");
Interface.SoundOnOffButton = {
    constructor: function() {
        Interface.SoundOnOffButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation", {
            userInput: {
                listenToUserInput: true
            }
        }, {
            properties: {
                updateOnStartup: true
            }
        }]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SoundOnOffButtonController,
            model: Core.Model,
            view: Interface.SoundOnOffButtonBaseView
        }
    }
};
Interface.SoundOnOffButton = Sys.extend(Core.Module, Interface.SoundOnOffButton, "Interface.SoundOnOffButton");
Sys.ns("Interface");
Interface.SoundOnOffButtonController = {
    constructor: function() {
        Interface.SoundOnOffButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:audioPlayer.loadingSound": a.loadingSound,
            "notify:audioPlayer.soundLoaded": a.soundFinishedLoading,
            "notify:settingsMenu.open": a.onSettingsMenuOpened,
            "notify:settingsMenu.closed": a.onSettingsMenuClosed,
            "notify:settingsManager.settingChanged": a.onSettingChanged
        })
    },
    loadingSound: function() {
        this.model.storeData("soundIsLoading", true);
        this.addProperty("soundLoading", this.MODULE_NAME)
    },
    soundFinishedLoading: function() {
        this.model.storeData("soundIsLoading", false);
        this.removeProperty("soundLoading", this.MODULE_NAME)
    },
    onSettingsMenuOpened: function() {
        this.addProperty("hidden", "settingsMenuOpen")
    },
    onSettingsMenuClosed: function() {
        this.removeProperty("hidden", "settingsMenuOpen")
    },
    onUserInputStart: function(a) {
        if (this.model.readData("soundIsLoading")) {
            return
        }
        this.model.storeData("isInputTarget", this.view.isTarget(a))
    },
    onUserInputEnd: function(a) {
        if (this.model.readData("soundIsLoading")) {
            return
        }
        if (this.view.isTarget(a) && this.model.readData("isInputTarget")) {
            Services.settingsManager.storeSetting("volume", Services.settingsManager.getSetting("volume") > 0 ? 0 : 1)
        }
    },
    onSettingChanged: function(a) {
        if (a === "volume") {
            this.updateAppearance()
        }
    },
    updateAppearance: function() {
        this.view.update()
    }
};
Interface.SoundOnOffButtonController = Sys.extend(Core.Controller, Interface.SoundOnOffButtonController, "Interface.SoundOnOffButtonController");
Sys.ns("Interface");
Interface.SoundOnOffButtonBaseView = {
    BASE_BUTTON_CSS: "interface-soundOnOffButton_baseButton",
    PORTRAIT_CSS: "interface-soundOnOffButton_portrait",
    LANDSCAPE_CSS: "interface-soundOnOffButton_landscape",
    ON_URI: "interface-soundOnOffButton_on_uri",
    OFF_URI: "interface-soundOnOffButton_off_uri",
    LOADING_URI: "interface-smallSpinner_uri",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.SoundOnOffButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function(a) {
        this.setStyle(a)
    },
    init: function() {
        var a = this;
        Interface.SoundOnOffButtonBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "soundOnOffButton",
            tag: "div",
            cls: a.BASE_BUTTON_CSS,
            renderTo: a.RENDER_TARGET
        })
    },
    isTarget: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    setStyle: function(a) {
        var c = this,
            d = a + "_CSS",
            b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(c[d])) {
            c.container.removeCls(c[b]);
            c.container.addCls(c[d])
        }
    },
    update: function() {
        var c = this,
            b = c.model,
            a = c.container;
        if (b.hasProperty("hidden")) {
            a.el.style.display = "none"
        } else {
            a.el.style.display = "block"
        }
        a.removeCSSClass(c.ON_URI);
        a.removeCSSClass(c.OFF_URI);
        a.removeCSSClass(c.LOADING_URI);
        if (b.hasProperty("soundLoading")) {
            a.addCSSClass(c.LOADING_URI)
        } else {
            if (Services.settingsManager.getSetting("volume") > 0) {
                a.addCSSClass(c.ON_URI)
            } else {
                a.addCSSClass(c.OFF_URI)
            }
        }
    }
};
Interface.SoundOnOffButtonBaseView = Sys.extend(Core.View, Interface.SoundOnOffButtonBaseView, "Interface.SoundOnOffButtonBaseView");
Sys.ns("Interface");
Interface.SoundOnOffButtonMobileView = {
    PORTRAIT_CSS: "interface-soundOnOffButton_portrait_mobile",
    LANDSCAPE_CSS: "interface-soundOnOffButton_landscape_mobile",
    constructor: function() {
        Interface.SoundOnOffButtonMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SoundOnOffButtonMobileView = Sys.extend(Interface.SoundOnOffButtonBaseView, Interface.SoundOnOffButtonMobileView, "Interface.SoundOnOffButtonMobileView");
Sys.ns("Interface");
Interface.AutoPlayButton = {
    constructor: function() {
        Interface.AutoPlayButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return {
            fallback: ["orientation", "userInput", "properties"],
            desktop: [{
                userInput: {
                    inputEvents: ["start", "end", "cancel", "move", "hover"]
                }
            }, "properties"]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.AutoPlayButtonController,
            model: Interface.AutoPlayButtonModel,
            view: Interface.AutoPlayButtonBaseView
        }
    }
};
Interface.AutoPlayButton = Sys.extend(Core.Module, Interface.AutoPlayButton, "Interface.AutoPlayButton");
Sys.ns("Interface");
Interface.AutoPlayButtonController = {
    constructor: function() {
        Interface.AutoPlayButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        if (this.model.hasAutoplayCeased()) {
            return
        }
        Interface.AutoPlayButtonController.superclass.setupEvents.apply(this, arguments);
        this.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.onBeforeLoaderClose,
            "notify:stateHandler.leavingIdleState": this.hide,
            "notify:stateHandler.enteringIdleState": this.show,
            "notify:settingsManager.settingChanged": this.onSettingChanged,
            "notify:settingsManager.settingDisabled": this.settingDisabled,
            "notify:settingsManager.settingLocked": this.settingLocked,
            "notify:freeRounds.ended": this.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": this.onReInitResponse,
            "view:settingChangedLocally": this.onSettingChangedLocally,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onSettingChanged: function(a, c) {
        var b = this,
            d = b.model.readData("isFreerounds");
        if (a === "autoPlayNrSpins") {
            this.view.changeSetting(a, c);
            if (c !== 0 && this.model.readData("restrictedModeEnabled") && !d) {
                this.fireEvent("request:spinSettings.show")
            }
        }
    },
    onSettingChangedLocally: function(a, b) {
        this.fireEvent("request:settingsManager.storeData", a, b)
    },
    settingDisabled: function(a) {
        if (a === "autoPlayNrSpins") {
            this.view.disable()
        }
    },
    settingLocked: function(a) {
        if (a === "autoPlayNrSpins") {
            this.view.locked()
        }
    },
    onBeforeLoaderClose: function() {
        var a = this;
        if (a.view.dispatchAddToContainerRequest()) {
            a.view.show()
        } else {
            a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "autoPlay")
        }
    },
    onFreeRoundsEnded: function() {
        if (this.model.readData("restrictedModeEnabled")) {
            this.model.storeData("isFreerounds", false);
            this.checkAndSetAvailability()
        }
    },
    onReInitResponse: function(b) {
        var a;
        if (this.model.readData("restrictedModeEnabled")) {
            a = b.freeRoundsLeft;
            this.model.storeData("isFreerounds", a && a > 0);
            this.checkAndSetAvailability()
        }
    },
    checkAndSetAvailability: function() {
        var a = this.model.readData("isFreerounds");
        if (!a) {
            this.view.disable();
            this.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "autoPlay")
        } else {
            this.view.dispatchAddToContainerRequest();
            this.view.enable();
            this.fireEvent("request:quickSettingsMenu.addAndEnableSetting", "autoPlay")
        }
    }
};
Interface.AutoPlayButtonController = Sys.extend(Interface.SettingsSectionController, Interface.AutoPlayButtonController, "Interface.AutoPlayButtonController");
Sys.ns("Interface");
Interface.AutoPlayButtonModel = {
    DEFAULT_NUMBER_OF_ROUNDS: 50,
    constructor: function() {
        Interface.AutoPlayButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var f = this,
            e = Resources.readData("gameServerInitResponseObject"),
            a = e.autoplay,
            h = f.DEFAULT_NUMBER_OF_ROUNDS,
            c = e.freeRoundsLeft,
            d, g, b;
        f.storeData("isFreerounds", typeof c !== "undefined" && c > 0);
        if (typeof a !== "undefined" && (f.validateSingleAutoPlayValue(a) || f.validateAutoplayArray(a))) {
            if (!Array.isArray(a)) {
                d = a
            } else {
                d = a[0];
                for (b = 1; b < a.length; b++) {
                    g = Math.abs(h - d) - Math.abs(h - a[b]);
                    if (g > 0 || (g === 0 && a[b] > d)) {
                        d = a[b]
                    }
                }
            }
        } else {
            d = h
        }
        f.storeData("roundsToTrigger", d);
        Interface.AutoPlayButtonModel.superclass.setupData.apply(this, arguments);
        f.storeData("restrictedModeEnabled", f.readData("isRestrictedMode"));
        if (f.readData("isRestrictedMode")) {
            f.storeData("isRemovedAndDisabled", true)
        }
    },
    initData: function() {}
};
Interface.AutoPlayButtonModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.AutoPlayButtonModel, "Interface.AutoPlayButtonModel");
Sys.ns("Interface");
Interface.AutoPlayButtonBaseView = {
    BASE_CSS: "interface-autoPlayButton_baseContainer",
    PORTRAIT_CSS: "interface-autoPlayButton_portraitBase",
    LANDSCAPE_CSS: "interface-autoPlayButton_landscapeBase",
    PRESSED_CSS: "interface-autoPlayButton_pressedBase",
    TOGGLE_BASE_CSS: "interface-autoPlayToggle_base",
    TOGGLE_BUTTON_WRAPPER_CSS: "interface-autoPlayToggle_buttonWrapper",
    TOGGLE_BUTTON_BACKGROUND_CSS: "",
    TOGGLE_BUTTON_HANDLE_CSS: "",
    NUMBER_DISPLAY_CSS: "interface-autoPlayButton_numberDisplay",
    TARGET_CONTAINER: "quickSettingsMenu",
    constructor: function() {
        Interface.AutoPlayButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    changeSetting: function(b, d) {
        var c = this,
            a = true;
        if (b === "autoPlayNrSpins") {
            if (d === 0) {
                a = false;
                c.showNumberDisplay()
            }
            if (a !== c.button.isOn()) {
                c.sliderShown = a;
                c.button.toggle(a, true);
                if (a === true) {
                    c.hideNumberDisplay()
                }
            }
        }
    },
    setUpContent: function() {
        var a = this;
        if (a.model.hasAutoplayCeased()) {
            return
        }
        a.container = new Sys.Element({
            id: "autoPlayButton",
            tag: "div",
            cls: a.BASE_CSS,
            style: "visibility:hidden;"
        });
        a.button = new Interface.utils.ToggleSwitch({
            id: "autoplayQuickSettingsButton",
            CSS: {
                base: a.TOGGLE_BASE_CSS,
                button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
                button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
                button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
            },
            enabled: true,
            callback: a.onSwitchToggled.bind(a)
        });
        a.numberDisplay = new Sys.Element({
            tag: "div",
            "class": a.NUMBER_DISPLAY_CSS,
            textContent: a.model.readData("roundsToTrigger")
        });
        a.container.add(a.button.getContainer());
        a.container.add(a.numberDisplay)
    },
    dispatchAddToContainerRequest: function() {
        var a = this,
            b = a.model.readData("isFreerounds");
        if (a.model.readData("restrictedModeEnabled") && !b) {
            return false
        }
        a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {
            content: a.container
        });
        return true
    },
    onSwitchToggled: function(b) {
        var a = this;
        if (b) {
            a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", a.model.readData("roundsToTrigger"));
            a.hideNumberDisplay()
        } else {
            a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", 0);
            a.showNumberDisplay()
        }
    },
    show: function() {
        var a = this;
        a.container.el.style.visibility = "visible";
        a.button.enable()
    },
    hide: function() {
        var a = this;
        a.container.el.style.visibility = "hidden";
        a.button.disable()
    },
    press: function() {
        this.button.addCls(this.PRESSED_CSS)
    },
    release: function() {
        this.button.removeCls(this.PRESSED_CSS)
    },
    disable: function() {
        this.fireEvent("view:removeFromContainer", this.TARGET_CONTAINER, {
            content: this.container
        })
    },
    enable: function() {
        var a = this;
        a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {
            content: a.container
        })
    },
    locked: function() {
        this.disable()
    },
    showNumberDisplay: function() {
        this.numberDisplay.el.style.display = "block"
    },
    hideNumberDisplay: function() {
        this.numberDisplay.el.style.display = "none"
    },
    onUserInputStart: function(a) {
        this.wasInitialTarget = Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)
    },
    onUserInputMove: function() {},
    onUserInputEnd: function(a) {
        if (this.wasInitialTarget && Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)) {
            this.button.toggle()
        }
    },
    hideButton: function() {},
    showButton: function() {},
    initAnimations: function() {}
};
Interface.AutoPlayButtonBaseView = Sys.extend(Core.View, Interface.AutoPlayButtonBaseView, "Interface.AutoPlayButtonBaseView");
Sys.ns("Interface");
Interface.QuickSpinButton = {
    constructor: function() {
        Interface.QuickSpinButton.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.QuickSpinButtonController,
            model: Interface.QuickSpinButtonModel,
            view: Interface.QuickSpinButtonBaseView
        }
    }
};
Interface.QuickSpinButton = Sys.extend(Core.Module, Interface.QuickSpinButton, "Interface.QuickSpinButton");
Sys.ns("Interface");
Interface.QuickSpinButtonController = {
    constructor: function() {
        Interface.QuickSpinButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        Interface.QuickSpinButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:stateHandler.leavingIdleState": a.view.hide.bind(a.view),
            "notify:stateHandler.enteringIdleState": a.view.show.bind(a.view),
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:settingsManager.settingDisabled": a.settingDisabled,
            "view:settingChangedLocally": a.onSettingChangedLocally
        })
    },
    onSettingChanged: function(a, b) {
        if (a === "quickSpin") {
            this.view.changeSetting(a, b)
        }
    },
    onSettingChangedLocally: function(a, b) {
        this.fireEvent("request:settingsManager.storeData", a, b)
    },
    settingDisabled: function(a) {
        var b = this;
        if (a === "quickSpin") {
            b.model.storeData("isRemovedAndDisabled", true);
            b.view.disable()
        }
    },
    onBeforeLoaderClose: function() {
        var a = this;
        if (a.view.dispatchAddToContainerRequest()) {
            a.view.show()
        } else {
            a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "quickSpin")
        }
    }
};
Interface.QuickSpinButtonController = Sys.extend(Interface.SettingsSectionController, Interface.QuickSpinButtonController, "Interface.QuickSpinButtonController");
Sys.ns("Interface");
Interface.QuickSpinButtonModel = {
    constructor: function() {
        Interface.QuickSpinButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Services.localStorageManager.hasData("quickSpin") && Services.localStorageManager.readData("quickSpin") === "true";
        this.storeData("quickSpin", a);
        Services.settingsManager.storeSetting("quickSpin", a, false, false)
    }
};
Interface.QuickSpinButtonModel = Sys.extend(Core.Model, Interface.QuickSpinButtonModel, "Interface.QuickSpinButtonModel");
Sys.ns("Interface");
Interface.QuickSpinButtonBaseView = {
    BASE_CSS: "interface-quickSpinButton_baseContainer",
    PORTRAIT_CSS: "interface-quickSpinButton_portraitBase",
    LANDSCAPE_CSS: "interface-quickSpinButton_landscapeBase",
    PRESSED_CSS: "interface-quickSpinButton_pressedBase",
    TOGGLE_BASE_CSS: "interface-quickSpinToggle_base",
    TOGGLE_BUTTON_WRAPPER_CSS: "interface-quickSpinToggle_buttonWrapper",
    TOGGLE_BUTTON_BACKGROUND_CSS: "",
    TOGGLE_BUTTON_HANDLE_CSS: "",
    TARGET_CONTAINER: "quickSettingsMenu",
    constructor: function() {
        Interface.QuickSpinButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    changeSetting: function(a, b) {
        if (a === "quickSpin" && b !== this.button.isOn()) {
            this.button.toggle(b, true)
        }
    },
    setUpContent: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "quickSpinButton",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "visibility:hidden;"
        });
        a.button = new Interface.utils.ToggleSwitch({
            id: "quickSpinQuickSettingsButton",
            CSS: {
                base: a.TOGGLE_BASE_CSS,
                button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
                button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
                button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
            },
            enabled: true,
            callback: a.onSwitchToggled.bind(a, "quickSpin")
        });
        a.container.add(a.button.getContainer());
        a.button.toggle(a.model.readData("quickSpin"))
    },
    dispatchAddToContainerRequest: function() {
        var a = this;
        if (!a.model.readData("isRemovedAndDisabled")) {
            a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {
                content: a.container
            });
            return true
        }
        return false
    },
    onSwitchToggled: function(a, b) {
        this.fireEvent("view:settingChangedLocally", a, b)
    },
    show: function() {
        this.button.enable();
        this.container.el.style.visibility = "visible"
    },
    hide: function() {
        this.container.el.style.visibility = "hidden";
        this.button.disable()
    },
    disable: function() {
        var a = this;
        a.fireEvent("view:removeFromContainer", a.TARGET_CONTAINER, {
            content: a.container
        })
    },
    press: function() {
        this.button.addCls(this.PRESSED_CSS)
    },
    release: function() {
        this.button.removeCls(this.PRESSED_CSS)
    }
};
Interface.QuickSpinButtonBaseView = Sys.extend(Core.View, Interface.QuickSpinButtonBaseView, "Interface.QuickSpinButtonBaseView");
Sys.ns("Interface");
Interface.BalanceDisplay = {
    constructor: function() {
        Interface.BalanceDisplay.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.BalanceDisplayController,
            view: Interface.BalanceDisplayBaseView
        }
    }
};
Interface.BalanceDisplay = Sys.extend(Core.Module, Interface.BalanceDisplay, "Interface.BalanceDisplay");
Sys.ns("Interface");
Interface.BalanceDisplayModel = {
    constructor: function() {
        Interface.BalanceDisplayModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {}
};
Interface.BalanceDisplayModel = Sys.extend(Core.Model, Interface.BalanceDisplayModel, "Interface.BalanceDisplayModel");
Sys.ns("Interface");
Interface.BalanceDisplayController = {
    constructor: function() {
        Interface.BalanceDisplayController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:balanceDisplay.appendChild": this.appendChild,
            "request:balanceDisplay.addClass": this.view.addClass.bind(this.view),
            "request:balanceDisplay.removeClass": this.view.removeClass.bind(this.view),
            "notify:stateHandler.leavingBeforeLoaderCloseState": this.handleBeforeLoaderClose
        })
    },
    handleBeforeLoaderClose: function() {
        if (Sys.isGcmEnabled) {
            this.fireEvent("notify:loader.closed")
        }
    },
    appendChild: function(a) {
        this.view.addChild(a)
    }
};
Interface.BalanceDisplayController = Sys.extend(Core.Controller, Interface.BalanceDisplayController, "Interface.BalanceDisplayController");
Sys.ns("Interface");
Interface.BalanceDisplayBaseView = {
    BASE_CSS: "interface-balanceDisplay_base",
    PORTRAIT_CSS: "interface-balanceDisplay_portrait",
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape",
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.BalanceDisplayBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function(a) {
        this.setStyle(a)
    },
    init: function() {
        this.constructDOMElement()
    },
    constructDOMElement: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "gameFooter",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET
        })
    },
    addClass: function(a) {
        this.container.addCls(a)
    },
    removeClass: function(a) {
        this.container.removeCls(a)
    },
    addChild: function(b) {
        var a = this;
        a.container.add(b)
    }
};
Interface.BalanceDisplayBaseView = Sys.extend(Core.View, Interface.BalanceDisplayBaseView, "Interface.BalanceDisplayBaseView");
Sys.ns("interface");
Interface.BalanceDisplayMobileView = {
    PORTRAIT_CSS: "interface-balanceDisplay_portrait_mobile",
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape_mobile",
    constructor: function() {
        Interface.BalanceDisplayMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.BalanceDisplayMobileView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayMobileView, "Interface.BalanceDisplayMobileView");
Sys.ns("Interface");
Interface.BalanceDisplayDesktopView = {
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape_desktop",
    constructor: function() {
        Interface.BalanceDisplayDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.BalanceDisplayDesktopView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayDesktopView, "Interface.BalanceDisplayDesktopView");
Sys.ns("Interface");
Interface.SystemClock = {
    constructor: function() {
        Interface.SystemClock.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.SystemClockController,
            model: Interface.SystemClockModel,
            view: Interface.SystemClockBaseView
        }
    }
};
Interface.SystemClock = Sys.extend(Core.Module, Interface.SystemClock, "Interface.SystemClock");
Sys.ns("Interface");
Interface.SystemClockController = {
    constructor: function() {
        Interface.SystemClockController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:systemClock.enableInMode": a.view.show.bind(a.view),
            "request:systemClock.show": a.view.show.bind(a.view),
            "request:systemClock.hide": a.view.show.bind(a.hide)
        })
    }
};
Interface.SystemClockController = Sys.extend(Core.Controller, Interface.SystemClockController, "Interface.SystemClockController");
Sys.ns("Interface");
Interface.SystemClockModel = {
    constructor: function() {
        Interface.SystemClockModel.superclass.constructor.apply(this, arguments)
    },
    getTime: function() {
        var a = new Date();
        return {
            hours: a.getHours(),
            minutes: a.getMinutes()
        }
    }
};
Interface.SystemClockModel = Sys.extend(Core.Model, Interface.SystemClockModel, "Interface.SystemClockModel");
Sys.ns("Interface");
Interface.SystemClockBaseView = {
    BASE_CSS: "interface-systemClock_base",
    PORTRAIT_POSITION: {
        ABOVE_GAME: true,
        TOP: 0.05,
        LEFT: 0.5
    },
    LANDSCAPE_POSITION: {
        BOTTOM: 0,
        LEFT: 0.055
    },
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.SystemClockBaseView.superclass.constructor.apply(this, arguments)
    },
    init: function() {
        var a = this;
        Interface.SystemClockBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "systemClock",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.hours = document.createElement("span");
        a.container.el.appendChild(a.hours);
        a.colon = document.createElement("span");
        a.colon.textContent = ":";
        a.container.el.appendChild(a.colon);
        a.minutes = document.createElement("span");
        a.container.el.appendChild(a.minutes);
        a.showColon = true
    },
    updateTime: function() {
        var c = this,
            d = c.model.getTime(),
            a = d.hours,
            b = d.minutes;
        if (a < 10) {
            a = "0" + a
        }
        if (b < 10) {
            b = "0" + b
        }
        c.hours.textContent = a;
        c.minutes.textContent = b;
        c.colon.style.visibility = c.showColon ? "visible" : "hidden";
        c.showColon = !c.showColon;
        c.ticker = setTimeout(function() {
            c.updateTime()
        }, 1000)
    },
    show: function() {
        this.container.el.style.display = "block";
        this.updateTime()
    },
    hide: function() {
        this.container.el.style.display = "none";
        clearTimeout(this.ticker)
    }
};
Interface.SystemClockBaseView = Sys.extend(Core.View, Interface.SystemClockBaseView, "Interface.SystemClockBaseView");
Sys.ns("Interface");
Interface.SystemClockTabletView = {
    PORTRAIT_POSITION: {
        BOTTOM: 0,
        LEFT: 0.055
    },
    constructor: function() {
        Interface.SystemClockTabletView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SystemClockTabletView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockTabletView, "Interface.SystemClockTabletView");
Sys.ns("Interface");
Interface.SystemClockDesktopView = {
    PORTRAIT_POSITION: undefined,
    LANDSCAPE_POSITION: undefined,
    constructor: function() {
        Interface.SystemClockDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SystemClockDesktopView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockDesktopView, "Interface.SystemClockDesktopView");
Sys.ns("Interface");
Interface.NetEntLogo = {
    constructor: function() {
        Interface.NetEntLogo.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.NetEntLogoController,
            view: Interface.NetEntLogoBaseView
        }
    }
};
Interface.NetEntLogo = Sys.extend(Core.Module, Interface.NetEntLogo, "Interface.NetEntLogo");
Sys.ns("Interface");
Interface.NetEntLogoController = {
    constructor: function() {
        Interface.NetEntLogoController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:netEntLogo.show": this.onShow,
            "request:netEntLogo.hide": this.onHide
        })
    },
    onShow: function() {
        this.view.show()
    },
    onHide: function() {
        this.view.hide()
    }
};
Interface.NetEntLogoController = Sys.extend(Core.Controller, Interface.NetEntLogoController, "Interface.NetEntLogoController");
Sys.ns("Interface");
Interface.NetEntLogoBaseView = {
    BASE_CSS: "interface-netEntLogo_base interface-netEntLogo_uri",
    PORTRAIT_POSITION: {
        BELOW_GAME: true,
        BOTTOM: 0.01,
        LEFT: 0.5
    },
    LANDSCAPE_POSITION: {
        BOTTOM: 0,
        RIGHT: 0.04
    },
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        Interface.NetEntLogoBaseView.superclass.constructor.apply(this, arguments);
        this.container = new Sys.Element({
            id: "netEntLogo",
            tag: "div",
            cls: this.BASE_CSS,
            renderTo: this.RENDER_TARGET
        })
    },
    show: function() {
        this.container.getEl().style.display = "block"
    },
    hide: function() {
        this.container.getEl().style.display = "none"
    }
};
Interface.NetEntLogoBaseView = Sys.extend(Core.View, Interface.NetEntLogoBaseView, "Interface.NetEntLogoBaseView");
Sys.ns("Interface");
Interface.QuickSettingsMenu = {
    constructor: function() {
        Interface.QuickSettingsMenu.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Interface.QuickSettingsMenuController,
            model: Interface.QuickSettingsMenuModel,
            view: Interface.QuickSettingsMenuBaseView
        }
    },
    getMixinDependencies: function() {
        return [{
            userInput: {
                listenToUserInput: true
            }
        }, "orientation", "properties"]
    }
};
Interface.QuickSettingsMenu = Sys.extend(Core.Module, Interface.QuickSettingsMenu, "Interface.QuickSettingsMenu");
Sys.ns("Interface");
Interface.QuickSettingsMenuController = {
    constructor: function() {
        Interface.QuickSettingsMenuController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.eventToUseWhenActive = {
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingBeforeLoaderCloseState,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState.bind(a, true),
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:spinButton.shown": a.show,
            "notify:spinButton.hidden": a.hide,
            "notify:spinButton.pressed": a.onSpinButtonPress,
            "notify:spinButton.released": a.onSpinButtonRelease.bind(a, true),
            "notify:settingsManager.settingChanged": a.onSettingsChanged
        };
        a.on({
            "request:quickSettingsMenu.addChild": a.addChild,
            "request:quickSettingsMenu.removeChild": a.removeChild,
            "request:quickSettingsMenu.externalActivate": a.onExternalActivate,
            "request:quickSettingsMenu.externalDeactivate": a.onExternalDeactivate,
            "request:quickSettingsMenu.movePosition": a.onMovePositionRequest,
            "request:quickSettingsMenu.removeAndDisableSetting": a.onRemoveAndDisableSetting,
            "request:quickSettingsMenu.addAndEnableSetting": a.onAddAndEnableSetting,
            "notify:autoPlayer.starting": a.onExternalDeactivate.bind(a, "autoplay"),
            "notify:autoPlayer.stopped": a.onExternalActivate.bind(a, "autoplay")
        });
        a.on(a.eventToUseWhenActive)
    },
    onMovePositionRequest: function(a) {
        this.view.moveSettingPosition(a)
    },
    onLeavingBeforeLoaderCloseState: function() {
        this.model.storeData("activated", false);
        this.view.deactivate()
    },
    disableMenu: function() {
        var d = this,
            c = d.eventToUseWhenActive,
            e = Object.keys(c),
            b = e.length,
            a;
        for (a = -1; ++a < b;) {
            d.removeListener(e[a])
        }
        d.model.storeData("activated", false);
        d.hide()
    },
    enableMenu: function() {
        var a = this;
        if (!a.model.readData("activated")) {
            a.on(a.eventToUseWhenActive);
            a.model.storeData("activated", true);
            a.show()
        }
    },
    getChildCount: function() {
        return Object.keys(this.view.children).length
    },
    addChild: function(c, a) {
        var b = this;
        b.view.addChild(c, a);
        if (b.getChildCount() > 0) {
            b.enableMenu()
        }
    },
    removeChild: function(e, b) {
        var c = this,
            d = c.getChildCount(),
            a;
        c.view.removeChild(e, b);
        a = c.getChildCount();
        if (d !== a && a <= 0) {
            c.disableMenu()
        }
    },
    onExternalDeactivate: function(a) {
        this.addProperty("externalDeactivated", a);
        this.hide()
    },
    onExternalActivate: function(b) {
        var a = this;
        a.removeProperty("externalDeactivated", b);
        if (a.model.readData("status") !== "open") {
            a.show(true)
        }
    },
    onSpinButtonPress: function() {
        if (this.model.readData("activated")) {
            this.hide()
        }
    },
    onSpinButtonRelease: function(a) {
        if (this.model.readData("activated")) {
            this.show(a)
        }
    },
    onEnteringIdleState: function(a) {
        if (this.getChildCount() === 0) {
            this.disableMenu();
            return
        }
        this.model.storeData("activated", true);
        this.show(a)
    },
    onLeavingIdleState: function() {
        this.model.storeData("activated", false);
        this.hide()
    },
    hide: function() {
        var a = this;
        a.model.storeData("hidden", true);
        a.view.deactivate();
        if (a.model.readData("status") === "open") {
            a.view.close();
            a.model.storeData("status", "close");
            a.fireEvent("request:spinButton.removeProperty", "visibleOnInput", a.MODULE_NAME)
        }
    },
    show: function(a) {
        var b = this;
        if (!b.model.hasProperty("externalDeactivated")) {
            b.model.storeData("hidden", false);
            if (b.model.readData("activated")) {
                b.view.activate(a)
            }
        }
    },
    onUserInputStart: function(a) {
        if (this.view.isInputTarget(a) && this.model.readData("activated")) {
            this.model.storeData("activeInputTarget", true)
        }
    },
    onUserInputMove: function(a) {},
    onUserInputEnd: function(c) {
        var b = this,
            a = b.model.readData("status");
        if (a === "open" && (b.view.isInputTarget(c) || !b.view.isContainer(c))) {
            b.view.close();
            b.model.storeData("status", "close");
            b.fireEvent("request:spinButton.removeProperty", "visibleOnInput", b.MODULE_NAME)
        } else {
            if (b.view.isInputTarget(c) && b.model.readData("activeInputTarget")) {
                b.view.open();
                b.model.storeData("status", "open");
                b.fireEvent("notify:quickSettingsMenu." + b.model.readState);
                b.fireEvent("request:spinButton.addProperty", "visibleOnInput", b.MODULE_NAME)
            }
        }
        b.model.storeData("activeInputTarget", false)
    },
    onSettingsChanged: function(a, b) {
        if (a === "leftHandMode") {
            this.view.positionMenu(b)
        }
    },
    onRemoveAndDisableSetting: function(a) {
        this.view.removeAndDisableSetting(a)
    },
    onAddAndEnableSetting: function(a) {
        this.view.addAndEnableSetting(a)
    }
};
Interface.QuickSettingsMenuController = Sys.extend(Core.Controller, Interface.QuickSettingsMenuController, "Interface.QuickSettingsMenuController");
Sys.ns("Interface");
Interface.QuickSettingsMenuModel = {
    PROPERTIES: {
        externalDeactivated: []
    },
    constructor: function() {
        Interface.QuickSettingsMenuModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var c = this,
            a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true",
            b = Resources.readData("gameServerInitResponseObject").autoplay;
        c.storeData("children", {});
        c.storeData("disableDuringSpin", []);
        c.storeData("status", "close");
        c.storeData("leftHandMode", a);
        c.storeData("preventDrawAutoplay", b === 0)
    }
};
Interface.QuickSettingsMenuModel = Sys.extend(Core.Model, Interface.QuickSettingsMenuModel, "Interface.QuickSettingsMenuModel");
Sys.ns("Interface");
Interface.QuickSettingsMenuBaseView = {
    BASE_CSS: "interface-quickSettingsMenu_base",
    PORTRAIT_CSS: "interface-quickSettingsMenu_portrait",
    LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape",
    LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_portrait_uri",
    LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
    PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_portrait",
    LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_portrait",
    SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
    ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
    LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_portrait",
    ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
    ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
    ICON_URI: "interface-quickSettingsMenu_icon_uri",
    BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
    LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_portrait",
    AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
    AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
    LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_portrait",
    QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
    QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
    BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
    LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_portrait_base",
    CHILD_CSS: "interface-quickSettingsMenu_child_base",
    PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_portrait",
    LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    HANDLE_CSS: "interface-quickSettingsMenu_handle",
    LANDSCAPE_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    PORTRAIT_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_portrait",
        close: "interface-quickSettingsMenu_handle_portrait"
    },
    MENU_LEFT_SIDE_CSS: "interface-quickSettingsMenu_left",
    HANDLE_LEFT_SIDE_CSS: "interface-quickSettingsMenu_handle_left",
    PORTRAIT_POSITION: {
        BELOW_GAME: true,
        TOP: 0.4,
        MIN_TOP: 825,
        LEFT: 0.3994
    },
    PORTRAIT_SIZE: {
        HEIGHT: 0.55,
        WIDTH: 0.28
    },
    LANDSCAPE_CLOSEDSIZE: "0.00rem",
    LANDSCAPE_FRONTSTARTPOS: "-0.64rem",
    LANDSCAPE_FRONTENDPOS: "-0.24rem",
    LANDSAPE_BACKSTARTPOS: "0.00rem",
    LANDSCAPE_BACKENDPOS: "0.50rem",
    LANDSCAPE_OPENSIZE: "2.70rem",
    RENDER_TARGET: "gameWrapper",
    PIXEL_FACTOR: 0.01,
    constructor: function() {
        Interface.QuickSettingsMenuBaseView.superclass.constructor.apply(this, arguments)
    },
    moveSettingPosition: function(a) {
        var b = this;
        if (Sys.isDefined(a)) {
            if (typeof a.orientation === "string" && a.orientation.toLowerCase() === "portrait") {
                if (Sys.isDefined(a.vertical)) {
                    b.PORTRAIT_POSITION.TOP = b.PORTRAIT_POSITION.TOP + a.vertical
                }
                if (Utils.Platform.isLandscape()) {
                    b.onLandscape()
                } else {
                    b.onPortrait()
                }
            }
        }
    },
    open: function(b) {
        var c = this,
            a = Utils.Platform.getOrientation();
        c["open" + a](b);
        c.icon.replaceCSSClass(c.ICON_CLOSE_CSS, c.ICON_OPEN_CSS)
    },
    openLANDSCAPE: function(d) {
        var e = this,
            b = e.model.readData("status"),
            a = d || e.getNewStatus(b),
            f = e.LANDSCAPE_HANDLE_CSS,
            c = e.animations.LANDSCAPE;
        e.back.el.style.display = "block";
        e.childrenContainer.el.style.display = "block";
        if (b !== a) {
            e.handle.replaceCSSClass(f[b], f[a])
        }
        Sys.iterate(e.children, function(g) {
            c.openChild.run(e.children[g].el)
        });
        c.open.run(e.container.el);
        c.openFront.run(e.front.el);
        c.openBack.run(e.back.el)
    },
    openPORTRAIT: function() {
        var a = this;
        a.childrenContainer.el.style.display = "none";
        a.front.el.style.left = "";
        Sys.iterate(a.children, function(b) {
            a.children[b].el.style.opacity = 1
        });
        a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_CLOSE, a.AUTOPLAY_SLIDE_OPEN);
        a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_CLOSE, a.QUICKSPIN_SLIDE_OPEN)
    },
    getNewStatus: function(a) {
        if (Utils.Platform.getOrientation() === this.currentOrientation) {
            return (a === "close") ? "open" : "close"
        }
        return a
    },
    close: function() {
        var b = this,
            a = Utils.Platform.getOrientation();
        b["close" + a](a);
        b.icon.replaceCSSClass(b.ICON_OPEN_CSS, b.ICON_CLOSE_CSS)
    },
    closeLANDSCAPE: function() {
        var d = this,
            a = d.model.readData("status"),
            c = (a === "close") ? "open" : "close",
            b = d.animations.LANDSCAPE;
        d.handle.replaceCSSClass(d.LANDSCAPE_HANDLE_CSS[a], d.LANDSCAPE_HANDLE_CSS[c]);
        Sys.iterate(d.children, function(e) {
            b.closeChild.run(d.children[e].el)
        });
        b.close.run(d.container.el);
        b.closeFront.run(d.front.el);
        b.closeBack.run(d.back.el)
    },
    closePORTRAIT: function() {
        var a = this;
        a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_OPEN, a.AUTOPLAY_SLIDE_CLOSE);
        a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_OPEN, a.QUICKSPIN_SLIDE_CLOSE)
    },
    activate: function(c) {
        var b = this,
            a = Utils.Platform.getOrientation();
        if (b.model.readData("hidden")) {
            return
        }
        if (!b.model.readData("animationReady")) {
            b.setupAnimations()
        }
        b.container.el.style.display = "block";
        b.childrenContainer.el.style.display = "none";
        b.back.el.style.display = "none";
        b.handle.el.style.display = "block";
        if (c) {
            b.animations[a].activate.run(b.container.el)
        }
    },
    deactivate: function() {
        var b = this,
            a = Sys.utils.getPrefixedCSSProperty("animation");
        b.childrenContainer.el.style.display = "none";
        b.handle.el.style.display = "none";
        b.container.el.style.display = "none";
        b.container.el.style[a] = "none";
        b.front.el.style[a] = "none"
    },
    isInputTarget: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.handle.el, a)
    },
    isContainer: function(a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    init: function() {
        var a = this;
        Interface.QuickSettingsMenuBaseView.superclass.init.apply(a, arguments);
        a.setupDOMStructure();
        a.children = {}
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "model:childAdded": a.addChild,
            "model:childRemoved": a.removeChild,
            "model:childActivated": a.activateChild,
            "model:childDeactivated": a.deactivateChild
        })
    },
    addChild: function(e, b) {
        var d = this,
            a = Utils.Platform.getOrientation(),
            c = b.content;
        c.addCls(d.CHILD_CSS);
        c.addCls(d[a + "_CHILD_CSS"]);
        d.append(e, c, a);
        d.children[e] = c
    },
    append: function(d, c, a) {
        var b = this;
        if (a === "LANDSCAPE") {
            b.childrenContainer.add(c)
        } else {
            if (d === "autoPlayButton") {
                b.autoPlaySlide.add(c)
            } else {
                if (d === "quickSpinButton") {
                    b.quickSpinSlide.add(c)
                }
            }
        }
    },
    removeChild: function(d, b) {
        var c = this,
            a = Utils.Platform.getOrientation();
        if (a === "LANDSCAPE" && Sys.isObj(b)) {
            c.childrenContainer.remove(b.content)
        } else {
            if (d === "autoPlayButton" && Sys.isObj(b)) {
                c.autoPlaySlide.remove(b.content)
            } else {
                if (d === "quickSpinButton") {
                    c.quickSpinSlide.remove(b.content)
                }
            }
        }
        delete c.children[d]
    },
    onPortrait: function() {
        var d = this,
            b = d.model.readData("status"),
            c = Sys.utils.getPrefixedCSSProperty("animation"),
            a = Sys.isDefined(d.animations) && d.model.readData("activated");
        if (Utils.Platform.getOrientation() !== this.currentOrientation) {
            d.adaptToOrientation("PORTRAIT");
            if (a) {
                d.container.el.style[c] = "none";
                setTimeout(function() {
                    d.animations.PORTRAIT.activate.run(d.container.el)
                }, 0)
            }
            Sys.iterate(d.children, function(e) {
                d.children[e].el.style[c] = "none"
            });
            d[b + "PORTRAIT"]();
            d.currentOrientation = "PORTRAIT"
        }
        d.front.el.style.left = "";
        d.setPosition("PORTRAIT");
        d.container.el.style.top = (Sys.utils.toInt(d.container.el.style.top) + 70) * d.PIXEL_FACTOR + "rem";
        d.setHandlePostion()
    },
    onLandscape: function() {
        var e = this,
            b = e.model.readData("status"),
            d = Sys.utils.getPrefixedCSSProperty("animation"),
            c = e.getNewStatus(b),
            a = Sys.isDefined(e.animations) && e.model.readData("activated");
        if (Utils.Platform.getOrientation() !== this.currentOrientation) {
            e.adaptToOrientation("LANDSCAPE");
            if (a) {
                e.container.el.style[d] = "none";
                setTimeout(function() {
                    if (b === "close") {
                        e.animations.LANDSCAPE.activate.run(e.container.el);
                        e.back.el.style.display = "none"
                    } else {
                        e.childrenContainer.el.style.display = "block";
                        e.open(c)
                    }
                    e.animations.LANDSCAPE[b + "Front"].run(e.front.el);
                    e.animations.LANDSCAPE[b + "Back"].run(e.back.el)
                }, 0)
            }
            this.currentOrientation = "LANDSCAPE"
        }
    },
    adaptToOrientation: function(b) {
        var d = this,
            c = (b === "LANDSCAPE") ? "PORTRAIT" : "LANDSCAPE",
            a = d.model.readData("status");
        d.setStyle(b);
        d.resetPosition();
        Sys.iterate(d.updateOnOrientation, function(e, f) {
            d[e].replaceCSSClass(d[c + f], d[b + f])
        });
        d.handle.replaceCSSClass(d[c + "_HANDLE_CSS"][a], d[b + "_HANDLE_CSS"][a]);
        d.moveChildren(d[c + "_CHILD_CSS"], d[b + "_CHILD_CSS"], b);
        if (d.model.readData("activated") === true) {
            d.activate()
        } else {
            d.deactivate()
        }
    },
    setHandlePostion: function() {
        var b = this,
            a = b.handle.el.style,
            c = b.container.el.style;
        a.top = c.top;
        a.bottom = c.bottom;
        a.left = c.left;
        a.right = c.right
    },
    moveChildren: function(c, d, a) {
        var b = this;
        Sys.iterate(b.children, function(e) {
            b.children[e].replaceCSSClass(c, d);
            if (a === "LANDSCAPE") {
                b.childrenContainer.add(b.children[e])
            } else {
                if (e === "autoPlayButton") {
                    b.autoPlaySlide.add(b.children[e])
                } else {
                    if (e === "quickSpinButton") {
                        b.quickSpinSlide.add(b.children[e])
                    }
                }
            }
        })
    },
    resetPosition: function() {
        var e = this,
            f = e.container.el.style,
            a = e.handle.el.style,
            d = e.front.el.style,
            c = Sys.utils.getPrefixedCSSProperty("animation"),
            g = ["top", "left", "bottom", "right", "width", "height", "opacity"],
            b;
        f[c] = "none";
        d[c] = "none";
        for (b = -1; ++b < g.length;) {
            f[g[b]] = "";
            a[g[b]] = ""
        }
    },
    setupDOMStructure: function() {
        var c = this,
            a = Utils.Platform.getOrientation(),
            b = Resources.readData("queryData").enableDefaultSwedenButtons;
        c.container = new Sys.Element({
            tag: "div",
            cls: c.BASE_CSS + " " + c.LANDSCAPE_BG_URI,
            renderTo: c.RENDER_TARGET
        });
        c.handle = new Sys.Element({
            tag: "div",
            cls: c.HANDLE_CSS + " " + c[a + "_HANDLE_CSS"].close,
            renderTo: c.RENDER_TARGET
        });
        c.front = new Sys.Element({
            tag: "div",
            cls: c[a + "_FRONT_CSS"] + " " + c.SLIDER_BUTTON_URI
        });
        c.back = new Sys.Element({
            tag: "div",
            cls: c[a + "_BACK_CSS"] + " " + c.LANDSCAPE_BG_URI
        });
        c.icon = new Sys.Element({
            tag: "div",
            cls: c.ICON_BASE_CSS + " " + c[a + "_ICON_CSS"] + " " + c.ICON_CLOSE_CSS + " " + c.ICON_URI
        });
        c.childrenContainer = new Sys.Element({
            tag: "div",
            cls: c.BASE_CHILDREN_CSS + " " + c[a + "_CHILDREN_CSS"]
        });
        c.autoPlaySlide = new Sys.Element({
            tag: "div",
            cls: c.BASE_SLIDE_CSS + " " + c[a + "_AUTOPLAY_SLIDE_CSS"] + " " + c.AUTOPLAY_SLIDE_CLOSE + " " + c.PORTRAIT_BG_URI
        });
        c.quickSpinSlide = new Sys.Element({
            tag: "div",
            cls: c.BASE_SLIDE_CSS + " " + c[a + "_QUICKSPIN_SLIDE_CSS"] + " " + c.QUICKSPIN_SLIDE_CLOSE + " " + c.PORTRAIT_BG_URI
        });
        c.updateOnOrientation = {
            front: "_FRONT_CSS",
            back: "_BACK_CSS",
            icon: "_ICON_CSS",
            autoPlaySlide: "_AUTOPLAY_SLIDE_CSS",
            quickSpinSlide: "_QUICKSPIN_SLIDE_CSS",
            childrenContainer: "_CHILDREN_CSS"
        };
        c.container.add(c.front);
        c.front.add(c.icon);
        c.container.add(c.back);
        c.container.add(c.childrenContainer);
        if (!c.model.readData("preventDrawAutoplay")) {
            c.container.add(c.autoPlaySlide)
        }
        c.container.add(c.quickSpinSlide);
        if (b) {
            c.positionMenu(false)
        } else {
            c.positionMenu(c.model.readData("leftHandMode"))
        }
    },
    setupAnimations: function() {
        var a = this;
        a.animations = {};
        a.setupLandscapeAnimations();
        a.setupPortraitAnimation();
        a.model.storeData("animationReady", true)
    },
    setupLandscapeAnimations: function() {
        var l = this,
            h = l.LANDSCAPE_CLOSEDSIZE,
            j = l.LANDSCAPE_FRONTSTARTPOS,
            d = l.LANDSCAPE_FRONTENDPOS,
            n = l.LANDSAPE_BACKSTARTPOS,
            k = l.LANDSCAPE_BACKENDPOS,
            g = l.LANDSCAPE_OPENSIZE,
            f = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openFrontLandscape",
                frames: {
                    "0%": {
                        left: j
                    },
                    "100%": {
                        left: d
                    }
                },
                duration: 50,
                delay: 4,
                fillMode: "both"
            }),
            o = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeFrontLandscape",
                frames: {
                    "0%": {
                        left: d
                    },
                    "100%": {
                        left: j
                    }
                },
                duration: 124,
                delay: 126,
                fillMode: "both"
            }),
            c = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openBackLandscape",
                frames: {
                    "0%": {
                        width: n
                    },
                    "100%": {
                        width: k
                    }
                },
                duration: 5,
                delay: 45,
                fillMode: "both"
            }),
            e = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeBackLandscape",
                frames: {
                    "0%": {
                        width: k
                    },
                    "100%": {
                        width: n
                    }
                },
                duration: 20,
                delay: 109,
                fillMode: "both"
            }),
            p = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openAnimationLandscape",
                frames: {
                    "0%": {
                        width: h
                    },
                    "100%": {
                        width: g
                    }
                },
                duration: 250,
                fillMode: "both"
            }),
            m = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeAnimationLandscape",
                frames: {
                    "0%": {
                        width: g
                    },
                    "100%": {
                        width: h
                    }
                },
                duration: 250,
                fillMode: "both"
            }),
            i = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_activateLandscape",
                frames: {
                    "0%": {
                        width: "0.00rem"
                    },
                    "100%": {
                        width: h
                    }
                },
                duration: 100,
                fillMode: "both"
            }),
            a = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemInLandscape",
                frames: {
                    "0%": {
                        opacity: 0,
                        visibility: "visible"
                    },
                    "100%": {
                        opacity: 1
                    }
                },
                duration: 150,
                delay: 200,
                fillMode: "both"
            }),
            b = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemOutLandscape",
                frames: {
                    "0%": {
                        opacity: 1
                    },
                    "100%": {
                        opacity: 0,
                        visibility: "hidden"
                    }
                },
                duration: 50,
                fillMode: "both"
            });
        l.animations.LANDSCAPE = {
            open: p,
            close: m,
            openChild: a,
            closeChild: b,
            activate: i,
            openFront: f,
            closeFront: o,
            openBack: c,
            closeBack: e
        }
    },
    setupPortraitAnimation: function() {
        var a = this,
            b = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_activatePortrait",
                frames: {
                    "0%": {
                        height: "0.00rem"
                    },
                    "100%": {
                        height: "1.60rem"
                    }
                },
                duration: 200,
                fillMode: "both"
            });
        a.animations.PORTRAIT = {
            activate: b
        }
    },
    positionMenu: function(b) {
        var c = this,
            d = c.handle,
            a = c.container;
        if (b) {
            d.addCSSClass(c.HANDLE_LEFT_SIDE_CSS);
            a.addCSSClass(c.MENU_LEFT_SIDE_CSS)
        } else {
            d.removeCSSClass(c.HANDLE_LEFT_SIDE_CSS);
            a.removeCSSClass(c.MENU_LEFT_SIDE_CSS)
        }
    },
    removeSettingSlide: function(a) {
        this.container.remove(a)
    },
    removeAndDisableSetting: function(a) {
        var b = this;
        a += "Slide";
        if (b.hasOwnProperty(a)) {
            b.removeSettingSlide(b[a])
        }
    },
    addSettingSlide: function(a) {
        this.container.add(a)
    },
    addAndEnableSetting: function(a) {
        a += "Slide";
        if (this.hasOwnProperty(a)) {
            this.addSettingSlide(this[a])
        }
    }
};
Interface.QuickSettingsMenuBaseView = Sys.extend(Core.View, Interface.QuickSettingsMenuBaseView, "Interface.QuickSettingsMenuBaseView");
Sys.ns("Interface");
Interface.QuickSettingsMenuTabletView = {
    BASE_CSS: "interface-quickSettingsMenu_base",
    PORTRAIT_CSS: "interface-quickSettingsMenu_landscape",
    LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape_tablet",
    LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape_tablet",
    PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
    LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    HANDLE_CSS: "interface-quickSettingsMenu_handle",
    SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
    ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
    LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
    ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
    ICON_URI: "interface-quickSettingsMenu_icon_uri",
    BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
    LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
    AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
    LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
    QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
    BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
    LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    CHILD_CSS: "interface-quickSettingsMenu_child_base",
    PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    LANDSCAPE_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape_tablet",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    PORTRAIT_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    LANDSCAPE_FRONTSTARTPOS: "-1.06rem",
    LANDSAPE_BACKSTARTPOS: "-0.40rem",
    moveChildren: function() {},
    append: function(c, b) {
        var a = this;
        a.childrenContainer.add(b)
    },
    updateStyle: function() {
        var a = this;
        a.resetPosition()
    },
    setHandlePostion: function() {},
    openPORTRAIT: function() {
        var c = this,
            a = c.model.readData("status"),
            b = c.getNewStatus(a);
        c.back.el.style.display = "block";
        c.childrenContainer.el.style.display = "block";
        Sys.iterate(c.children, function(d) {
            c.animations.PORTRAIT.openChild.run(c.children[d].el)
        });
        c.handle.replaceCSSClass(c.PORTRAIT_HANDLE_CSS[a], c.PORTRAIT_HANDLE_CSS[b]);
        c.animations.PORTRAIT.open.run(c.container.el);
        c.animations.PORTRAIT.openFront.run(c.front.el);
        c.animations.PORTRAIT.openBack.run(c.back.el)
    },
    closePORTRAIT: function(c) {
        var d = this,
            a = d.model.readData("status"),
            b = (a === "close") ? "open" : "close";
        Sys.iterate(d.children, function(e) {
            d.animations.PORTRAIT.closeChild.run(d.children[e].el)
        });
        d.handle.replaceCSSClass(d.PORTRAIT_HANDLE_CSS[a], d.PORTRAIT_HANDLE_CSS[b]);
        d.animations[c].close.run(d.container.el);
        d.animations[c].closeFront.run(d.front.el);
        d.animations[c].closeBack.run(d.back.el)
    },
    onPortrait: function() {
        var d = this,
            b = d.model.readData("status"),
            c = Sys.utils.getPrefixedCSSProperty("animation"),
            a = Sys.isDefined(d.animations) && d.model.readData("activated");
        if (Utils.Platform.getOrientation() !== this.currentOrientation) {
            d.adaptToOrientation("PORTRAIT");
            if (a) {
                d.container.el.style[c] = "none";
                if (b === "close") {
                    d.animations.PORTRAIT.activate.run(d.container.el);
                    d.back.el.style.display = "none"
                } else {
                    d.childrenContainer.el.style.display = "block";
                    d.open()
                }
                d.animations.PORTRAIT[b + "Front"].run(d.front.el);
                d.animations.PORTRAIT[b + "Back"].run(d.back.el)
            }
            d.currentOrientation = "PORTRAIT"
        }
    },
    setupPortraitAnimation: function() {
        var i = this,
            f = "0.00rem",
            h = "-0.64rem",
            d = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openFrontPortrait",
                frames: {
                    "0%": {
                        left: h
                    },
                    "100%": {
                        left: "-0.24rem"
                    }
                },
                duration: 50,
                delay: 4,
                fillMode: "both"
            }),
            k = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeFrontPortrait",
                frames: {
                    "0%": {
                        left: "-0.24rem"
                    },
                    "100%": {
                        left: h
                    }
                },
                duration: 124,
                delay: 126,
                fillMode: "both"
            }),
            c = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openBackPortrait",
                frames: {
                    "0%": {
                        width: "0.00rem"
                    },
                    "100%": {
                        width: "0.50rem"
                    }
                },
                duration: 5,
                delay: 40,
                fillMode: "both"
            }),
            e = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeBackPortrait",
                frames: {
                    "0%": {
                        width: "0.50rem"
                    },
                    "100%": {
                        width: "0.00rem"
                    }
                },
                duration: 20,
                delay: 111,
                fillMode: "both"
            }),
            l = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openAnimationPortrait",
                frames: {
                    "0%": {
                        width: f
                    },
                    "100%": {
                        width: "2.70rem"
                    }
                },
                duration: 250,
                fillMode: "both"
            }),
            j = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeAnimationPortrait",
                frames: {
                    "0%": {
                        width: "2.70rem"
                    },
                    "100%": {
                        width: f
                    }
                },
                duration: 250,
                fillMode: "both"
            }),
            g = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_activatePortrait",
                frames: {
                    "0%": {
                        width: "0.00rem"
                    },
                    "100%": {
                        width: f
                    }
                },
                duration: 100,
                fillMode: "both"
            }),
            a = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemInPortrait",
                frames: {
                    "0%": {
                        opacity: 0
                    },
                    "100%": {
                        opacity: 1
                    }
                },
                duration: 100,
                delay: 125,
                fillMode: "both"
            }),
            b = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemOutLPortrait",
                frames: {
                    "0%": {
                        opacity: 1
                    },
                    "100%": {
                        opacity: 0
                    }
                },
                duration: 50,
                fillMode: "both"
            });
        i.animations.PORTRAIT = {
            open: l,
            close: j,
            openChild: a,
            closeChild: b,
            activate: g,
            openFront: d,
            closeFront: k,
            openBack: c,
            closeBack: e
        }
    }
};
Interface.QuickSettingsMenuTabletView = Sys.extend(Interface.QuickSettingsMenuBaseView, Interface.QuickSettingsMenuTabletView, "Interface.QuickSettingsMenuTabletView");
Sys.ns("Operations");
Operations.Base = {
    constructor: function() {
        this.operation = "base"
    },
    performAction: function(l, k) {
        var g = this,
            d = g.operation,
            b = l.prop.operations[d],
            j = g.getCurrentOperationStep(l, d),
            f = b[j],
            h = j + 1,
            c = b.length,
            i, a, e = 1;
        Animation.utils.increaseTimeBuffer(l, g.operation, k);
        a = l.prop.operations[d].timeBuffer;
        if (c > h) {
            i = b[h];
            if (a >= i.time) {
                g.handleCallback(f);
                g.handleEvents(f);
                g.restoreCallbackOnIterations(f);
                j = g.getNewKeyFrameIndex(l, i);
                f = b[j];
                h = j + 1;
                if (c > h) {
                    i = b[h]
                } else {
                    i = f;
                    e = 0
                }
            }
            g.handleCallback(f);
            g.handleEvents(f);
            g.calculate(l, b.timeBuffer, f, i);
            return e
        }
        return 0
    },
    calculate: function(e, d, b, a) {
        var c = this;
        c.time = c.calculateTime(d, b, a);
        c.from = b.value;
        c.to = a.value
    },
    updateProperties: function() {},
    applyDefaultValuesToOperation: function() {},
    handleCallback: function(a) {
        var b = a.callback;
        if (Sys.isDefined(b) && !a.callbackCompleted) {
            b.callbackFunction.apply(b.scope, b.args);
            a.callbackCompleted = true
        }
    },
    handleEvents: function(c) {
        var b = c.fireEvent,
            a = Game.stage.view.animationManager.renderLoopEndEvents;
        if (Sys.isDefined(b) && !c.eventFired) {
            a.push(b);
            c.eventFired = true
        }
    },
    restoreEventOnIterations: function(a) {
        var b = a.fireEvent;
        if (Sys.isDefined(b) && Sys.isDefined(b.iterations)) {
            if (!Sys.isDefined(b.remainingIterations)) {
                b.remainingIterations = b.iterations
            }
            b.remainingIterations--;
            if (b.remainingIterations > 0) {
                a.eventFired = false;
                a.callbackCompleted = false
            }
        }
    },
    restoreCallbackOnIterations: function(a) {
        var b = a.callback;
        if (Sys.isDefined(b) && b.looping === true) {
            a.callbackCompleted = false
        }
    },
    getCurrentOperationStep: function(c, b) {
        var a = c.prop.operationSteps;
        if (!a[b]) {
            a[b] = 0
        }
        return a[b]
    },
    calculateTime: function(d, b, a) {
        var e = d - b.time,
            c = a.time - b.time;
        return c !== 0 ? e / c : 1
    },
    getNewKeyFrameIndex: function(i, f) {
        var e = this,
            j = i.prop,
            a = f.goTo,
            b = Sys.isDefined(a) ? e.getIterations(f) : false,
            g = e.operation,
            c = j.operations[g],
            h = j.operationSteps[g],
            d;
        if (Sys.isDefined(a) && (b > 1)) {
            Animation.utils.setTimeBuffer(i, g, c[a].time);
            e.restoreEventOnIterations(c[a]);
            d = a;
            e.handleEvents(f)
        } else {
            d = h + 1
        }
        j.operationSteps[g] = d;
        return d
    },
    getIterations: function(a) {
        if (Sys.isDefined(a.iterations)) {
            if (!Sys.isDefined(a.remainingIterations)) {
                a.remainingIterations = a.iterations
            }
            return --a.remainingIterations
        }
        return 2
    },
    applyDefaultValuesToItem: function() {}
};
Operations.Base = Sys.extend(Sys.Observable, Operations.Base, "Operations.Base");
Sys.ns("Operations");
Operations.ColorBlend = {
    constructor: function() {
        Operations.ColorBlend.superclass.constructor.call(this);
        this.operation = "colorBlend"
    },
    calculate: function(f, e, c, a) {
        var d = this,
            b = {
                r: 0,
                g: 0,
                b: 0
            };
        Operations.ColorBlend.superclass.calculate(f, e, c, a);
        Sys.iterate(b, function(g) {
            b[g] = Sys.utils.toInt(Animation.utils.getInterpolationValue(d.from[g], d.to[g], d.time))
        });
        f.prop.color = b
    },
    updateProperties: function(b, a) {
        a.globalAlpha = b.prop.opacity;
        b.prop.reset = true
    },
    applyDefaultValuesToItem: function(a) {
        if (!Sys.isDefined(a.prop.color)) {
            a.prop.color = {}
        }
    },
    calculateColorSupport: function(b, a) {
        return {
            r: ((a.value.r - b.value.r) / 2) + b.value.r,
            g: ((a.value.g - b.value.g) / 2) + b.value.g,
            b: ((a.value.b - b.value.b) / 2) + b.value.b
        }
    }
};
Operations.ColorBlend = Sys.extend(Operations.Base, Operations.ColorBlend, "Operations.ColorBlend");
Sys.ns("Operations");
Operations.Fade = {
    constructor: function() {
        Operations.Fade.superclass.constructor.call(this);
        this.operation = "fade"
    },
    calculate: function(g, f, b, a) {
        var e = this,
            d, c;
        Operations.Fade.superclass.calculate(g, f, b, a);
        if (Sys.isDefined(b.support)) {
            d = b.support;
            c = "bezier"
        }
        g.prop.ownOpacity = Animation.utils.getInterpolationValue(e.from, e.to, e.time, {
            support: d,
            type: c
        })
    },
    applyDefaultValuesToItem: function(a) {
        if (!Sys.isNumber(a.prop.opacity)) {
            a.prop.opacity = 1
        }
    }
};
Operations.Fade = Sys.extend(Operations.Base, Operations.Fade, "Operations.Fade");
Sys.ns("Operations");
Operations.Orbit = {
    constructor: function() {
        Operations.Orbit.superclass.constructor.call(this);
        this.operation = "orbit"
    },
    calculate: function(e, d, b, a) {
        var c = this;
        Operations.Orbit.superclass.calculate(e, d, b, a);
        e.prop.rotation = Animation.utils.getInterpolationValue(c.from, c.to, c.support, c.time)
    },
    updateProperties: function(c, a) {
        var b = c.prop,
            d = b.rotation - 90;
        b.left = (Sys.Math.cos(d) * b.radius) + b.center.left - b.width / 2;
        b.top = (Sys.Math.sin(d) * b.radius) + b.center.top - b.height / 2
    },
    applyDefaultValuesToItem: function(a) {
        var b = a.prop;
        if (!Sys.isNumber(b.rotation)) {
            b.rotation = 0
        }
        if (!Sys.isNumber(b.radius)) {
            b.radius = 0
        }
        if (!Sys.isDefined(b.center)) {
            b.center = {
                left: 0,
                top: 0
            }
        }
    }
};
Operations.Orbit = Sys.extend(Operations.Base, Operations.Orbit, "Operations.Orbit");
Sys.ns("Operations");
Operations.Path = {
    constructor: function(a) {
        Operations.Path.superclass.constructor.call(this);
        this.operation = "path"
    },
    calculate: function(d, c, b, a) {
        Operations.Path.superclass.calculate(d, c, b, a);
        d.prop.path.push({
            left: d.prop.left,
            top: d.prop.top
        })
    },
    updateProperties: function(c, a) {
        var h = c.prop,
            g = c.prop.path,
            f = g[0].top,
            e = g[0].left,
            b = g[g.length - 1].top,
            d = g[g.length - 1].left;
        h.width = Sys.utils.toInt(Math.abs(d - e) + h.lineHeight);
        h.height = Sys.utils.toInt(Math.abs(b - f) + h.lineWidth);
        h.left = Sys.utils.toInt(e - (h.lineHeight / 2));
        h.top = Sys.utils.toInt(b - (h.lineWidth / 2))
    },
    applyDefaultValuesToItem: function(a) {
        var b = a.prop;
        if (!Sys.isNumber(b.lineHeight)) {
            b.lineHeight = 0
        }
        if (!Sys.isNumber(b.lineWidth)) {
            b.lineWidth = 0
        }
        if (!Sys.isDefined(b.path)) {
            b.path = []
        }
    }
};
Operations.Path = Sys.extend(Operations.Base, Operations.Path, "Operations.Path");
Sys.ns("Operations");
Operations.Rotate = {
    constructor: function() {
        Operations.Rotate.superclass.constructor.call(this);
        this.operation = "rotate"
    },
    calculate: function(g, f, b, a) {
        var e = this,
            d, c;
        Operations.Rotate.superclass.calculate(g, f, b, a);
        if (Sys.isDefined(b.support)) {
            d = b.support;
            c = "bezier";
            if (Sys.isArray(d) && d.length === 2) {
                c = "cubic"
            }
        }
        g.prop.rotation = Animation.utils.getInterpolationValue(e.from, e.to, e.time, {
            support: d,
            type: c
        })
    },
    applyDefaultValuesToItem: function(a) {
        if (!Sys.isNumber(a.prop.rotation)) {
            a.prop.rotation = 0
        }
    }
};
Operations.Rotate = Sys.extend(Operations.Base, Operations.Rotate, "Operations.Rotate");
Sys.ns("Operations");
Operations.Scale = {
    constructor: function() {
        Operations.Scale.superclass.constructor.call(this);
        this.operation = "scale"
    },
    calculate: function(l, c, a, f) {
        var k = this,
            g = a.value.scaleX,
            e = a.value.scaleY,
            i = f.value.scaleX,
            h = f.value.scaleY,
            d, b, j;
        k.time = k.calculateTime(c, a, f);
        if (Sys.isDefined(a.value.width)) {
            g = a.value.width / l.prop.width;
            i = f.value.width / l.prop.width
        }
        if (Sys.isDefined(a.value.height)) {
            e = a.value.height / l.prop.height;
            h = f.value.height / l.prop.height
        }
        if (Sys.isDefined(a.support)) {
            d = a.support.scaleX;
            b = a.support.scaleY;
            j = "bezier"
        }
        l.prop.scaleX = Animation.utils.getInterpolationValue(g, i, k.time, {
            support: d,
            type: j
        });
        l.prop.scaleY = Animation.utils.getInterpolationValue(e, h, k.time, {
            support: b,
            type: j
        })
    }
};
Operations.Scale = Sys.extend(Operations.Base, Operations.Scale, "Operations.Scale");
Sys.ns("Operations");
Operations.Translate = {
    constructor: function() {
        Operations.Translate.superclass.constructor.call(this);
        this.operation = "translate"
    },
    calculate: function(l, d, a, e) {
        var h = this,
            k = Animation.utils,
            j = a.value.left,
            m = a.value.top,
            f = e.value.left,
            i = e.value.top,
            c, b, g;
        h.time = h.calculateTime(d, a, e);
        if (Sys.isDefined(a.support)) {
            c = a.support.left;
            b = a.support.top;
            g = "bezier";
            if (Sys.isArray(c) && c.length === 2) {
                g = "cubic"
            }
        }
        l.prop.left = k.getInterpolationValue(j, f, h.time, {
            support: c,
            type: g
        });
        l.prop.top = k.getInterpolationValue(m, i, h.time, {
            support: b,
            type: g
        })
    },
    applyDefaultValuesToOperation: function(c) {
        var f = c.prop,
            b = f.operations[this.operation],
            e = b.length,
            d, a;
        for (a = -1; ++a < e;) {
            d = b[a];
            if (!Sys.isNumber(d.value.left)) {
                d.value.left = f.left
            }
            if (!Sys.isNumber(d.value.top)) {
                d.value.top = f.top
            }
        }
    }
};
Operations.Translate = Sys.extend(Operations.Base, Operations.Translate, "Operations.Translate");
Sys.ns("Operations");
Operations.TransformMatrix = {
    constructor: function() {
        Operations.Translate.superclass.constructor.call(this);
        this.operation = "transformMatrix"
    },
    calculate: function(f, e, c, a) {
        var d = this,
            h = f.prop,
            g, b = a.matrixArray;
        Operations.TransformMatrix.superclass.calculate(f, e, c, a);
        g = Math.round(Animation.utils.getInterpolationValue(d.from, d.to, d.time));
        if (b[g].length === 0) {
            h.skip = true
        } else {
            h.changeMatrix.set(b[g]);
            h.skip = false
        }
        if (Sys.isDefined(c.events)) {
            d.fireEventOnFrame(g, c)
        }
    },
    applyDefaultValuesToOperation: function(a) {
        a.prop.changeMatrix = new Float32Array(6)
    },
    fireEventOnFrame: function(c, b) {
        var a = Game.stage.view.animationManager.renderLoopEndEvents;
        Sys.each(b.events, function(d) {
            if (c >= d.onFrame && !d.fired) {
                a.push(d);
                d.fired = true
            }
        })
    }
};
Operations.TransformMatrix = Sys.extend(Operations.Base, Operations.TransformMatrix, "Operations.TransformMatrix");
Sys.ns("Operations");
Operations.DisplayArea = {
    constructor: function(a) {
        Operations.DisplayArea.superclass.constructor.call(this);
        this.operation = "displayArea"
    },
    calculate: function(l, c, b, d) {
        var f = this,
            k = Animation.utils,
            i = {
                sx: b.value.startX,
                sy: b.value.startY,
                sWidth: b.value.width,
                sHeight: b.value.height
            },
            j = {
                sx: d.value.startX,
                sy: d.value.startY,
                sWidth: d.value.width,
                sHeight: d.value.height
            },
            a = l.prop,
            h = Environment.determineResolution().virtualToWindowScale,
            e, g;
        Operations.DisplayArea.superclass.calculate(l, c, b, d);
        a.SX = Math.round(k.toNthDecimalPlace(k.getInterpolationValue(i.sx, j.sx, f.time), 3) * h);
        a.SY = Math.round(k.toNthDecimalPlace(k.getInterpolationValue(i.sy, j.sy, f.time), 3) * h);
        g = k.toNthDecimalPlace(k.getInterpolationValue(i.sWidth, j.sWidth, f.time), 3);
        e = k.toNthDecimalPlace(k.getInterpolationValue(i.sHeight, j.sHeight, f.time), 3);
        a.SWidth = Math.round(g * h);
        a.SHeight = Math.round(e * h);
        a.width = g;
        a.height = e
    }
};
Operations.DisplayArea = Sys.extend(Operations.Base, Operations.DisplayArea, "Operations.DisplayArea");
Sys.ns("Operations");
Operations.Sprite = {
    constructor: function(a) {
        Operations.Sprite.superclass.constructor.call(this, a);
        this.operation = "sprite"
    },
    calculate: function(e, d, b, a) {
        var c = this,
            g = e.prop,
            f;
        Operations.Sprite.superclass.calculate(e, d, b, a);
        f = Math.round(Animation.utils.getInterpolationValue(c.from, c.to, c.time));
        g.SX = g.spriteArray[f] * g.frameWidth;
        e.prop.SY = 0;
        if (g.SX >= g.totalSpriteWidth) {
            g.SY = Math.floor(g.SX / g.totalSpriteWidth) * g.frameHeight;
            g.SX = g.SX % g.totalSpriteWidth
        }
        g.SWidth = g.frameWidth;
        g.SHeight = g.frameHeight;
        c.fireEventOnFrame(f, b)
    },
    applyDefaultValuesToItem: function(a) {
        var b = a.prop;
        if (typeof b.spriteSequence === "string") {
            b.spriteArray = Resources.readData("sprites")[b.spriteSequence]
        }
    },
    fireEventOnFrame: function(c, b) {
        var a = Game.stage.view.animationManager.renderLoopEndEvents;
        Sys.each(b.events, function(d) {
            if (c >= d.onFrame && !d.fired) {
                a.push(d);
                d.fired = true
            }
        })
    }
};
Operations.Sprite = Sys.extend(Operations.Base, Operations.Sprite, "Operations.Sprite");
Sys.ns("Operations");
Operations.TranslateCurve = {
    constructor: function() {
        Operations.TranslateCurve.superclass.constructor.call(this);
        this.operation = "translateCurve"
    },
    calculate: function(j, b, a, d) {
        var g = a.value.point || a.value,
            f = d.value.point || d.value,
            i = a.value.support || a.value,
            h = d.value.support || d.value,
            c = this.calculateTime(b, a, d),
            e;
        j.curve = {
            p1: g,
            p2: f,
            s1: i,
            s2: h
        };
        if (c > 1) {
            c = 1
        } else {
            if (c < 0) {
                c = 0
            }
        }
        e = Animation.utils.calculateCurveLocation(j.curve, c);
        j.prop.left = Animation.utils.toNthDecimalPlace(e.left, 10);
        j.prop.top = Animation.utils.toNthDecimalPlace(e.top, 10)
    }
};
Operations.TranslateCurve = Sys.extend(Operations.Base, Operations.TranslateCurve, "Operations.TranslateCurve");
Sys.ns("Operations");
Operations.TranslatePath = {
    constructor: function() {
        Operations.TranslatePath.superclass.constructor.call(this);
        this.operation = "translatePath"
    },
    calculate: function(j, c, b, d) {
        var h = j.prop.customProps.points,
            a = j.prop.customProps.totalTime,
            e = j.prop.operations[this.operation].timeBuffer,
            f = h.length,
            i = e / a,
            g;
        if (i > 1) {
            i = 1
        }
        g = Math.floor(i * (f - 1));
        j.prop.left = Animation.utils.toNthDecimalPlace(h[g].x, 10);
        j.prop.top = Animation.utils.toNthDecimalPlace(h[g].y, 10)
    },
    applyDefaultValuesToOperation: function(c) {
        var f = [],
            g = c.prop,
            b = g.operations[this.operation],
            e = b.length,
            d, a;
        for (a = -1; ++a < e;) {
            d = b[a];
            f.push([d.value.left, d.value.top])
        }
        g.customProps.curve = this.getCurveFromPoints(f, 0.5);
        g.customProps.points = this.getStepsFromCurve(g.customProps.curve, 100);
        g.customProps.totalTime = b[e - 1].time
    },
    getCurveFromPoints: function(n, a) {
        var t = n.length,
            l = [],
            h = (a >= 0 || a <= 1) ? a : 1,
            o, e, r, q, d, g, f, k, j, b, m, p, c;
        if (t < 3) {
            return false
        }
        for (o = -1; ++o < t;) {
            e = n[o][0];
            d = n[o][1];
            if (o > 0 && o + 1 < t) {
                q = n[o - 1][0];
                f = n[o - 1][1];
                r = n[o + 1][0];
                g = n[o + 1][1];
                p = ((r - q) / 2) * h;
                c = ((g - f) / 2) * h;
                k = e - p;
                j = d - c;
                b = e + p;
                m = d + c
            } else {
                k = b = e;
                j = m = d
            }
            l.push({
                x: e,
                y: d,
                sx1: k,
                sy1: j,
                sx2: b,
                sy2: m
            })
        }
        return l
    },
    getStepsFromCurve: function(d, f) {
        var l = d.length,
            m = [],
            o, n, h, g, p, b, c, e, k = [],
            a = 0;
        for (h = -1; ++h < (l - 1);) {
            o = d[h];
            n = d[h + 1];
            b = Math.sqrt(Math.pow((o.x - n.x), 2) + Math.pow((o.y - n.y), 2));
            if (b > a) {
                a = b
            }
            k.push(b)
        }
        e = f / a;
        for (h = -1; ++h < (l - 1);) {
            o = d[h];
            n = d[h + 1];
            c = Math.round(k[h] * e);
            for (g = -1; ++g < c;) {
                p = g / c;
                m.push({
                    x: Animation.utils.getCubiqInterpolationValue(o.x, n.x, o.sx2, n.sx1, p),
                    y: Animation.utils.getCubiqInterpolationValue(o.y, n.y, o.sy2, n.sy1, p)
                })
            }
        }
        return m
    }
};
Operations.TranslatePath = Sys.extend(Operations.Base, Operations.TranslatePath, "Operations.TranslatePath");
Sys.ns("Operations");
Operations.Value = {
    constructor: function(a) {
        Operations.Value.superclass.constructor.call(this);
        this.operation = "value"
    },
    calculate: function(i, c, a, e) {
        var f = this,
            h, g, b, d = 3;
        Operations.Value.superclass.calculate(i, c, a, e);
        if (Sys.isDefined(a.support)) {
            h = a.support;
            g = "bezier"
        }
        if (Sys.isDefined(a.numDecimals)) {
            d = a.numDecimals
        }
        b = Animation.utils.getInterpolationValue(f.from, f.to, f.time, {
            support: h,
            type: g
        });
        i.prop.value = Animation.utils.toNthDecimalPlace(b, d)
    }
};
Operations.Value = Sys.extend(Operations.Base, Operations.Value, "Operations.Value");
Sys.ns("Operations");
Operations.TextColorBlend = {
    constructor: function() {
        Operations.TextColorBlend.superclass.constructor.call(this);
        this.operation = "textColorBlend"
    },
    calculate: function(f, e, c, a) {
        var d = this,
            b = {
                colorStop: {
                    start: {
                        r: 0,
                        g: 0,
                        b: 0
                    },
                    end: {
                        r: 0,
                        g: 0,
                        b: 0
                    }
                },
                stroke: {
                    r: 0,
                    g: 0,
                    b: 0
                }
            };
        Operations.ColorBlend.superclass.calculate(f, e, c, a);
        Sys.iterate(b.colorStop.start, function(g) {
            b.colorStop.start[g] = Sys.utils.toInt(Animation.utils.getInterpolationValue(d.from.colorStop.start[g], d.to.colorStop.start[g], d.time))
        });
        Sys.iterate(b.colorStop.end, function(g) {
            b.colorStop.end[g] = Sys.utils.toInt(Animation.utils.getInterpolationValue(d.from.colorStop.end[g], d.to.colorStop.end[g], d.time))
        });
        Sys.iterate(b.stroke, function(g) {
            b.stroke[g] = Sys.utils.toInt(Animation.utils.getInterpolationValue(d.from.stroke[g], d.to.stroke[g], d.time))
        });
        f.prop.colorConfig = b
    },
    applyDefaultValuesToItem: function(a) {
        if (!Sys.isDefined(a.prop.colorConfig)) {
            a.prop.colorConfig = {}
        }
    }
};
Operations.TextColorBlend = Sys.extend(Operations.Base, Operations.TextColorBlend, "Operations.TextColorBlend");
Sys.ns("Operations");
Operations.TextColorBlendDesktop = {
    constructor: function() {
        Operations.TextColorBlendDesktop.superclass.constructor.call(this);
        this.operation = "textColorBlendDesktop"
    },
    calculate: function(i, b, a, d) {
        var g = this,
            c, e, h, f = {
                colorStop: {
                    r: 0,
                    g: 0,
                    b: 0
                }
            };
        Operations.ColorBlend.superclass.calculate(i, b, a, d);
        c = Sys.utils.toInt(Animation.utils.getInterpolationValue(g.from.colorStop.r, g.to.colorStop.r, g.time));
        e = Sys.utils.toInt(Animation.utils.getInterpolationValue(g.from.colorStop.g, g.to.colorStop.g, g.time));
        h = Sys.utils.toInt(Animation.utils.getInterpolationValue(g.from.colorStop.b, g.to.colorStop.b, g.time));
        f.colorStop.r = c;
        f.colorStop.g = e;
        f.colorStop.b = h;
        i.prop.colorConfig = f
    }
};
Operations.TextColorBlendDesktop = Sys.extend(Operations.TextColorBlend, Operations.TextColorBlendDesktop, "Operations.TextColorBlendDesktop");
Sys.ns("Operations");
Operations.SBTranslatePath = {
    applyDefaultValuesToOperation: function(d, b) {
        var g = [],
            h = d.prop,
            c = h.operations[this.operation],
            f = c.length,
            e, a;
        for (a = -1; ++a < f;) {
            e = c[a];
            g.push([e.value.left, e.value.top])
        }
        if (b !== undefined) {
            h.customProps.curve = this.getCurveFromPoints(g, b)
        } else {
            h.customProps.curve = this.getCurveFromPoints(g, 0.5)
        }
        h.customProps.points = this.getStepsFromCurve(h.customProps.curve, 100);
        h.customProps.totalTime = c[f - 1].time
    }
};
Operations.SBTranslatePath = Sys.extend(Operations.TranslatePath, Operations.SBTranslatePath, "Operations.SBTranslatePath");
Sys.ns("Animation");
Animation.AnimationManager = {
    constructor: function(a) {
        var b = this;
        Animation.AnimationManager.superclass.constructor.call(b);
        b.setupImages(a.images, "notify:animationManager.allImagesLoaded");
        b.setupSprites(a.sprites);
        this.init(a);
        b.currentTime = 0;
        b.timeFromStart = 0;
        b.paused = false;
        b.currentStepTime = 0;
        b.isRunning = false;
        b.selectRenderFunction()
    },
    init: function(a) {},
    start: function() {
        var a = this;
        a.isRunning = true;
        a.currentTime = 0;
        a.lastTimeStepOccured = Date.now();
        a.paused = false;
        a.requestNextAnimationStep()
    },
    getSpriteSequence: function(a) {
        return this.sprites[a]
    },
    isRunningRendering: function() {
        return this.isRunning
    },
    pauseAnimation: function() {
        this.paused = true;
        clearTimeout(this.renderTimeout)
    },
    continueAnimation: function() {
        this.paused = false;
        this.run()
    },
    addImages: function(a) {
        Sys.apply(this.images, a)
    },
    shouldRenderNextFrame: function() {
        return (!this.paused)
    },
    run: function() {
        var a = this;
        a.preRender();
        if (a.shouldRenderNextFrame()) {
            a.lastTimeStepOccured = a.updateTime();
            a.postRender();
            a.requestNextAnimationStep()
        } else {
            a.isRunning = false
        }
    },
    preRender: function() {},
    postRender: function() {},
    requestNextAnimationStep: function() {
        var a = this;
        a.animationFunction.call(window, function() {
            a.run()
        })
    },
    updateTime: function() {
        var b = this,
            a = Date.now(),
            c = a - b.lastTimeStepOccured;
        if (c > 250) {
            c = 1000 / 60
        }
        b.currentStepTime = c | 0;
        b.currentTime += b.currentStepTime;
        return a
    },
    updateActiveRenderContextSize: function(a) {
        throw Error("This method of AnimationManager supposed to be overridden")
    },
    selectRenderFunction: function() {
        var a = this;
        this.animationFunction = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(b) {
            clearTimeout(a.renderTimeout);
            a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
        }
    },
    setupImages: function(b, e) {
        var c = this,
            d = Sys.isDefined(b.files) ? b.files : b,
            a = Resources.readData("animationImages") || {};
        c.imageReadyEvent = e;
        c.imagesRemaining = [];
        c.remainingImages = 0;
        Sys.iterate(d, function(f, h) {
            var g = new Image();
            g.onload = function() {
                c.remainingImages--;
                c.imagesLoaded()
            };
            g.src = h;
            a[f] = g;
            c.imagesRemaining.push(g);
            c.remainingImages++
        });
        c.images = a;
        Resources.storeData("animationImages", a)
    },
    setupSprites: function(e) {
        var g = this,
            a, b, f, k, h, j, d, c;
        g.sprites = Resources.readData("sprites") || {};
        if (Sys.isDefined(e)) {
            Sys.iterate(e, function(l, i) {
                b = [];
                Sys.each(i.sequence, function(n, m) {
                    f = new RegExp("\\*").test(n);
                    a = new RegExp("-").test(n);
                    if (a) {
                        k = n.split("-");
                        j = Sys.utils.toInt(k[0]);
                        d = Sys.utils.toInt(k[1]);
                        if (j < d) {
                            d++;
                            for (c = j; c < d; c++) {
                                b.push(c)
                            }
                        } else {
                            d--;
                            for (c = j; c > d; c--) {
                                b.push(c)
                            }
                        }
                    } else {
                        if (f) {
                            k = n.split("*");
                            j = 0;
                            d = Sys.utils.toInt(k[1]);
                            h = Sys.utils.toInt(k[0]);
                            for (c = j; c < d; c++) {
                                b.push(h)
                            }
                        } else {
                            b.push(Sys.utils.toInt(n))
                        }
                    }
                });
                g.sprites[l] = b
            })
        }
        Resources.storeData("sprites", g.sprites)
    },
    imagesLoaded: function() {
        if (this.remainingImages < 1) {
            this.canImagesBeUsed()
        }
    },
    canImagesBeUsed: function() {
        var d = this,
            b = d.imagesRemaining,
            a = b.length,
            c;
        for (c = -1; ++c < a;) {
            if (b[c].width > 0 && b[c].height > 0) {
                b.splice(c, 1);
                --c;
                --a
            }
        }
        clearTimeout(d.tryToDrawImagesTimeout);
        if (b.length > 1) {
            d.tryToDrawImagesTimeout = setTimeout(function() {
                d.canImagesBeUsed()
            }, 50)
        } else {
            d.setupAssets();
            d.fireEvent("notify:animationManager.animationLoopInitialized")
        }
    },
    setupAssets: function() {},
    addToRenderLoop: function() {}
};
Animation.AnimationManager = Sys.extend(Sys.Observable, Animation.AnimationManager, "Animation.CanvasAnimationManager");
Sys.ns("Animation.Operations");
Animation.Operations = {};
(function() {
    Sys.iterate(Operations, function(c, b) {
        var a = new b();
        Animation.Operations[a.operation] = a
    })
}());
Sys.ns("Animation");
Animation.CanvasAnimationManager = {
    init: function(a) {
        var b = this;
        b.canvasList = {};
        b.activeCanvas = b.addCanvas(a);
        b.setupScenes(a.scenes);
        b.renderBuffer = [];
        b.activeRenderBuffer = [];
        b.renderLoopEndEvents = []
    },
    start: function(b) {
        var a = this;
        a.currentScene = b;
        Animation.CanvasAnimationManager.superclass.start.apply(a, arguments)
    },
    switchScenes: function(a) {
        this.currentScene = a
    },
    clearScene: function(a) {
        if (Sys.isDefined(a)) {
            this.scenes[a].lists = []
        }
    },
    addToRenderLoop: function(c, b) {
        var a = Sys.isDefined(b) ? b : this.currentScene;
        if (!this.isInScene(c, a)) {
            this.scenes[a].listsToAdd.push(c)
        } else {
            c.prop.running = true
        }
    },
    isInScene: function(c, d) {
        var b = Sys.isDefined(d) ? d : this.currentScene,
            a = this.scenes[b];
        return (a.lists.contains(c) || a.listsToAdd.contains(c) || a.nonActiveLists.contains(c))
    },
    removeList: function(g, h) {
        var e = this,
            c = Sys.isDefined(h) ? h : e.currentScene,
            d = e.scenes[c],
            a = d.lists.indexOf(g),
            b = d.listsToAdd.indexOf(g),
            f = d.nonActiveLists.indexOf(g);
        if (a > -1) {
            d.lists[a].prop.running = false
        } else {
            if (f > -1) {
                d.nonActiveLists[f].prop.running = false
            } else {
                if (b > -1) {
                    d.listsToAdd.splice(b, 1)
                }
            }
        }
    },
    restore: function(c) {
        var a, b = this;
        if (Sys.isDefined(c.canvas)) {
            a = b.canvasList[c.canvas]
        } else {
            a = b.canvasList[b.defaultCanvas]
        }
        if (c.prop.reset) {
            a.restore();
            a.globalAlpha = 1
        }
        if (Sys.isDefined(c.prop.globalCompositeOperation)) {
            a.globalCompositeOperation = "source-over"
        }
        a.fillStyle = "";
        a.strokeStyle = "";
        a.shadowColor = "";
        a.strokeStyle = "";
        a.shadowBlur = ""
    },
    preRender: function() {
        var a = this;
        a.renderLoopEndEvents.length = 0;
        a.calculate();
        a.render(a.renderBuffer, a.activeCanvas);
        if (a.renderLoopEndEvents.length > 0) {
            a.fireLoopEndEvents()
        }
    },
    fireLoopEndEvents: function() {
        var c = this,
            b = c.renderLoopEndEvents.length,
            a, d;
        for (a = -1; ++a < b;) {
            d = c.renderLoopEndEvents[a];
            d.scope.fireEvent(d.event, d.argument)
        }
    },
    calculate: function() {
        var b = this,
            a = this.scenes[this.currentScene];
        b.clear();
        if (Sys.isDefined(a)) {
            b.renderBuffer.push.apply(b.renderBuffer, a.run({
                timeStep: b.currentStepTime,
                time: b.currentTime
            }));
            b.renderBuffer.sort(function(d, c) {
                return (d.prop.depth - c.prop.depth)
            })
        } else {}
    },
    render: function(f, d) {
        var p = this,
            c = d.ctx,
            q = f.length,
            k, b, n, o, e, g, l, h, a;
        for (l = 0; l < q; l++) {
            k = f[l];
            o = k.prop;
            e = o.matrix;
            if (Sys.isDefined(o.operations)) {
                b = Object.keys(o.operations);
                n = b.length;
                h = 0;
                while (h < n) {
                    Animation.Operations[b[h]].updateProperties(k, c);
                    ++h
                }
            }
            if (o.opacity > 0) {
                if (Sys.isDefined(o.globalCompositeOperation)) {
                    c.globalCompositeOperation = o.globalCompositeOperation
                } else {
                    c.globalCompositeOperation = "source-over"
                }
                if (o.opacity !== 1) {
                    c.globalAlpha = o.opacity;
                    o.contextProperties.globalAlpha = true
                }
                c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                if (Sys.isDefined(o.func)) {
                    g = o.tempMatrix;
                    g.set(e);
                    Animation.utils.multiplyMatrix(g, [1, 0, 0, 1, o.pivot.x - o.left, o.pivot.y - o.top], e);
                    c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                    o.func(c, d.config, p.images, k);
                    c.setTransform(g[0], g[1], g[2], g[3], g[4], g[5])
                }
                if (Sys.isDefined(o.executeBefore)) {
                    o.executeBefore(c, d.config, p.images, k)
                }
                if (Sys.isDefined(o.image)) {
                    a = Sys.isDefined(p.images[o.image]) ? p.images[o.image] : o.image;
                    if (o.reelSym) {
                        c.drawImage(a, 0, o.clipY, a.width, o.clipHeight, o.xPos, o.yPos, o.width, o.renderHeight)
                    } else {
                        if (Sys.isDefined(o.SX) && Sys.isDefined(o.SY) && Sys.isDefined(o.SWidth) && Sys.isDefined(o.SHeight)) {
                            c.drawImage(a, o.SX, o.SY, o.SWidth, o.SHeight, o.pivot.x, o.pivot.y, o.width, o.height)
                        } else {
                            c.drawImage(a, o.pivot.x, o.pivot.y, o.width, o.height)
                        }
                    }
                }
                if (Sys.isDefined(o.afterDraw)) {
                    g = o.tempMatrix;
                    g.set(e);
                    Animation.utils.multiplyMatrix(g, [1, 0, 0, 1, o.pivot.x - o.left, o.pivot.y - o.top], e);
                    c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                    o.afterDraw(c, d.config, p.images, k);
                    c.setTransform(g[0], g[1], g[2], g[3], g[4], g[5])
                }
                if (Sys.isDefined(o.executeAfter)) {
                    o.executeAfter(c, d.config, p.images, k)
                }
            }
            p.restoreContextProperties(c, o.contextProperties)
        }
    },
    clear: function() {
        this.renderBuffer.length = 0;
        this.clearCanvas(this.activeCanvas)
    },
    clearCanvas: function(a) {
        a.ctx.setTransform(1, 0, 0, 1, 0, 0);
        a.ctx.clearRect(0, 0, a.config.width, a.config.height)
    },
    restoreContextProperties: function(b, a) {
        if (!Sys.isDefined(a)) {
            return
        }
        if (a.globalCompositeOperation) {
            b.globalCompositeOperation = "source-over";
            a.globalCompositeOperation = false
        }
        if (a.globalAlpha) {
            b.globalAlpha = 1;
            a.globalAlpha = false
        }
    },
    updateActiveRenderContextSize: function(b) {
        var c = this.activeCanvas.config,
            a = this.activeCanvas.canvas;
        c.width = b.width;
        c.height = b.height;
        a.width = c.width;
        a.height = c.height;
        this.scenes[this.currentScene].updateScaleValue()
    },
    setContextProperty: function(a) {
        Sys.iterate(a, function(b) {
            this.ctx[b] = a[b]
        })
    },
    getItemPos: function(a) {
        return {
            left: a.prop.left,
            top: a.prop.top
        }
    },
    addCanvas: function(b) {
        var c = this,
            d = {},
            a;
        a = c.applyDefaultCanvasConf(b);
        d.canvas = document.createElement("canvas");
        d.canvas.id = a.id;
        d.canvas.width = a.width;
        d.canvas.height = a.height;
        d.canvas.style.position = a.position;
        d.canvas.style.top = a.top;
        d.canvas.style.left = a.left;
        d.canvas.style.zIndex = a.zIndex;
        d.canvas.style.transform = a.transform;
        d.canvas.imageRendering = a.imageRendering;
        if (a.parent) {
            a.parent.appendChild(d.canvas)
        }
        d.ctx = d.canvas.getContext("2d");
        d.ctx.textBaseline = a.ctxTextBaseline;
        d.ctx.textAlign = a.ctxTextAlign;
        d.config = a;
        c.canvasList[a.id] = d;
        return d
    },
    applyDefaultCanvasConf: function(a) {
        var b = {};
        if (Sys.isDefined(a)) {
            Sys.apply(b, a)
        }
        Sys.applyPropertiesIf(b, {
            parent: document.getElementById("uicard") || null,
            id: "canvasAnimationManager",
            width: 1280,
            height: 720,
            position: "absolute",
            top: 0,
            left: 0,
            zIndex: "220",
            transform: Platform.isDesktopDevice ? "translateX(0)" : undefined,
            ctxTextBaseline: "middle",
            ctxTextAlign: "center"
        });
        return b
    },
    setupScenes: function(b) {
        var c = Sys.isDefined(b) ? b : [],
            a = {};
        c.push("base");
        Sys.each(c, function(d) {
            a[d] = new Animation.CanvasAnimationScene({})
        });
        this.scenes = a;
        this.scenes.base.play();
        this.currentScene = "base"
    },
    setupImages: function(b, e) {
        var d = this,
            a = Resources.readData("spriteConfigurations") || {},
            c = {};
        Animation.CanvasAnimationManager.superclass.setupImages.apply(d, arguments);
        if (Sys.isDefined(b.spriteConfigurations)) {
            Sys.iterate(b.spriteConfigurations, function(f, g) {
                if (g.sequence) {
                    c[f] = {
                        sequence: g.sequence
                    }
                }
                a[f] = g
            })
        }
        d.spriteConfigurations = a;
        Resources.storeData("spriteConfigurations", a);
        d.setupSprites(c)
    },
    setupAssets: function() {
        var a = this;
        a.fireEvent(a.imageReadyEvent);
        if (Utils.Platform.isWebGLSupported() && Animation.PixiAdapter) {
            Animation.PixiAdapter.performOverrides()
        }
    }
};
Animation.CanvasAnimationManager = Sys.extend(Animation.AnimationManager, Animation.CanvasAnimationManager, "Animation.CanvasAnimationManager");
Sys.ns("Animation");
Animation.CanvasAnimationList = {
    constructor: function(a) {
        var c = this,
            b;
        Animation.CanvasAnimationList.superclass.constructor.apply(c, arguments);
        a = a || {};
        c.items = [];
        c.id = a.id;
        c.endDurationItems = [];
        b = {
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            delay: 0,
            depth: 0,
            hasEnded: false,
            running: true,
            operations: {},
            operationSteps: {},
            operationEnded: {},
            operationsRunning: true,
            parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            opacity: 1,
            ownOpacity: 1
        };
        a = Sys.apply(b, a);
        a = Animation.utils.parseItemConfig(a);
        c.prop = Sys.apply(c.prop, a);
        c.prop.localTime = 0;
        c.endEvent = a.endEvent || undefined
    },
    run: function(l, f) {
        var k = this,
            a = k.prop,
            j = [],
            g = k.items.length,
            m = Animation.utils,
            h, c, b, e, d;
        a.localTime += l.timeStep;
        if (a.localTime >= a.delay) {
            a.parentMatrix.set(f.matrix);
            m.performAction(k, l.timeStep);
            m.updateMatrix(a);
            a.opacity = a.ownOpacity * f.opacity;
            if (a.pivot.x !== 0 || a.pivot.y !== 0) {
                k.adjustForPivot(a)
            }
            h = false;
            for (e = -1; ++e < g;) {
                c = k.items[e];
                if (c.prop.running) {
                    b = c.run(l, {
                        matrix: a.matrix,
                        opacity: a.opacity
                    });
                    if (b === true) {
                        j.push(c);
                        h = true
                    } else {
                        if (b !== false && Sys.isArray(b)) {
                            j = j.concat(b);
                            h = true
                        }
                    }
                }
            }
            a.running = a.running === false ? false : h;
            if (!a.running && k.endEvent && !k.endFrameFired) {
                k.endFrameFired = true;
                if (Sys.isObj(k.endEvent)) {
                    d = Game.stage.view.animationManager.renderLoopEndEvents;
                    d.push(k.endEvent)
                }
            }
        }
        return j
    },
    adjustForPivot: function(a) {
        a.parentMatrix.set([1, 0, 0, 1, a.pivot.x, a.pivot.y]);
        a.tempMatrix.set(a.matrix);
        Animation.utils.multiplyMatrix(a.tempMatrix, a.parentMatrix, a.matrix)
    },
    clearAnimationList: function() {
        var c = this,
            b = c.items.length,
            a;
        for (a = -1; ++a < b;) {
            c.items[a].finished()
        }
    },
    restore: function(b) {
        var a = this,
            c = a.prop;
        c.running = true;
        c.hasEnded = false;
        c.localTime = 0;
        a.endFrameFired = false;
        Animation.utils.restoreOperations(c);
        if (Sys.isDefined(b)) {
            if (Sys.isObj(b)) {
                b.restore()
            } else {
                if (Sys.isArray(b)) {
                    a.handleItems("restore", b)
                }
            }
        } else {
            a.handleItems("restore")
        }
    },
    add: function(a) {
        Animation.utils.insertInOrder(a, this.items)
    },
    removeItems: function() {
        this.items = []
    },
    setProperty: function(e, d) {
        var a = this.items,
            c = a.length,
            b;
        for (b = -1; ++b < c;) {
            a[b].prop[e] = d
        }
    },
    addItems: function(a) {
        var c = a.length,
            b;
        for (b = -1; ++b < c;) {
            this.add(a[b])
        }
    },
    isRunning: function() {
        return this.prop.running
    },
    stopItemInList: function(c) {
        var b = this,
            a = Sys.utils.containsObject(c, b.items);
        if (a.found) {
            b.items[a.index].finished()
        } else {}
    },
    play: function(a) {
        if (!this.prop.running) {
            this.restore(a)
        } else {
            if (Sys.isDefined(a)) {
                if (Sys.isObj(a)) {
                    a.play()
                } else {
                    if (Sys.isArray(a)) {
                        this.handleItems("play", a)
                    }
                }
            } else {
                this.handleItems("play")
            }
        }
    },
    pause: function() {
        this.handleItems("pause")
    },
    stop: function() {
        this.handleItems("stop")
    },
    restoreList: function() {
        var a = this.prop;
        a.running = true;
        a.hasEnded = false;
        a.localTime = 0;
        this.endFrameFired = false
    },
    handleItems: function(e, d) {
        var a = (Sys.isDefined(d)) ? d : this.items,
            c = a.length,
            b;
        for (b = -1; ++b < c;) {
            a[b][e]()
        }
    }
};
Animation.List = Animation.CanvasAnimationList = Sys.extend(Sys.Observable, Animation.CanvasAnimationList, "Animation.CanvasAnimationList");
Sys.ns("Animation");
Animation.MaskedAnimationList = {
    constructor: function(a) {
        Animation.MaskedAnimationList.superclass.constructor.apply(this, arguments);
        this.setupMaskingCanvas()
    },
    run: function(l, f) {
        var k = this,
            a = k.prop,
            j = [],
            g = k.items.length,
            m = Animation.utils,
            h, c, b, e, d;
        a.localTime += l.timeStep;
        if (a.localTime >= a.delay) {
            a.parentMatrix.set(f.matrix);
            m.performAction(k, l.timeStep);
            m.updateMatrix(a);
            a.opacity = a.ownOpacity * f.opacity;
            if (a.pivot.x !== 0 || a.pivot.y !== 0) {
                k.adjustForPivot(a)
            }
            h = false;
            for (e = -1; ++e < g;) {
                c = k.items[e];
                if (c.prop.running) {
                    b = c.run(l, {
                        matrix: [1, 0, 0, 1, 0, 0],
                        opacity: a.opacity
                    });
                    if (b === true) {
                        j.push(c);
                        h = true
                    } else {
                        if (b !== false && Sys.isArray(b)) {
                            j = j.concat(b);
                            h = true
                        }
                    }
                }
            }
            j = k.maskList(j);
            a.running = a.running === false ? false : h;
            if (!a.running && k.endEvent && !k.endFrameFired) {
                k.endFrameFired = true;
                if (Sys.isObj(k.endEvent)) {
                    d = Game.stage.view.animationManager.renderLoopEndEvents;
                    d.push(k.endEvent)
                }
            }
        }
        return j
    },
    maskList: function(d) {
        var e = this,
            a = e.prop,
            g = Resources.readData("animationImages"),
            f = d.length,
            k = e.maskContext,
            j, b, h, c;
        k.setTransform(1, 0, 0, 1, 0, 0);
        k.clearRect(0, 0, a.maskWidth, a.maskHeight);
        a.width = a.maskWidth;
        a.height = a.maskHeight;
        for (c = -1; ++c < f;) {
            j = d[c].prop;
            h = j.matrix;
            b = g[j.image];
            if (j.opacity !== 1) {
                k.globalAlpha = j.opacity
            }
            k.setTransform(h[0], h[1], h[2], h[3], h[4] - a.left, h[5] - a.top);
            if (Sys.isDefined(j.operations.sprite)) {
                k.drawImage(b, j.SX, j.SY, j.SWidth, j.SHeight, j.pivot.x, j.pivot.y, j.width, j.height)
            } else {
                k.drawImage(b, j.pivot.x, j.pivot.y, j.width, j.height)
            }
            if (j.opacity !== 1) {
                k.globalAlpha = 1
            }
        }
        a.image = e.maskCanvas;
        return [e]
    },
    setupMaskingCanvas: function() {
        var c = this,
            b = document.createElement("canvas"),
            a = b.getContext("2d");
        b.width = c.prop.maskWidth;
        b.height = c.prop.maskHeight;
        c.maskCanvas = b;
        c.maskContext = a
    }
};
Animation.MaskedAnimationList = Sys.extend(Animation.CanvasAnimationList, Animation.MaskedAnimationList, "Animation.MaskedAnimationList");
Sys.ns("Animation");
Animation.CanvasAnimationItem = {
    constructor: function(a) {
        var c = this,
            b = {
                top: 0,
                left: 0,
                width: 0,
                height: 0,
                depth: 0,
                delay: 0,
                reset: false,
                paused: false,
                fullScreen: false,
                operations: {},
                operationSteps: {},
                operationEnded: {},
                customProps: {},
                running: true,
                skip: false,
                operationsRunning: true,
                opacity: 1,
                ownOpacity: 1,
                parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                contextProperties: {
                    globalCompositeOperation: false,
                    globalAlpha: false
                }
            };
        c.setSizeDefaultProperties(a);
        a = Sys.apply(b, a);
        a = Animation.utils.parseItemConfig(a);
        c.prop = Sys.apply(c.prop, a);
        c.prop.localTime = 0;
        c.setOperationDefaultProperties();
        c._defaultProp = Sys.copyObject(c.prop);
        c._stateOperations = {
            "default": c.prop.operations
        }
    },
    run: function(d, c) {
        var b = this,
            e = b.prop,
            a = Animation.utils;
        if (!e.paused) {
            e.localTime += d.timeStep
        }
        e.reset = false;
        if (e.localTime >= e.delay) {
            e.parentMatrix.set(c.matrix);
            a.performAction(b, d.timeStep);
            a.updateMatrix(e);
            e.opacity = e.ownOpacity * c.opacity;
            return !e.skip
        }
        return false
    },
    play: function(a) {
        if (Sys.isDefined(a)) {
            this.reset();
            this.prop.operations = this._stateOperations[a]
        }
        if (!this.isRunning()) {
            this.restore()
        }
        this.prop.paused = false
    },
    pause: function() {
        this.prop.paused = true
    },
    stop: function() {
        this.prop.running = false
    },
    setImage: function(a) {
        if (typeof a !== "string") {
            throw new Error("Value must be a string.")
        }
        this.prop.image = a
    },
    setWidth: function(a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.width = a
    },
    setHeight: function(a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.height = a
    },
    setLeft: function(a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.left = a
    },
    setTop: function(a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.top = a
    },
    updatePivot: function() {
        this.prop.pivot.x = -this.prop.width / 2;
        this.prop.pivot.y = -this.prop.height / 2
    },
    restore: function() {
        var a = this.prop;
        a.localTime = 0;
        a.timeBuffer = 0;
        a.skip = false;
        a.running = true;
        Animation.utils.restoreOperations(a)
    },
    reset: function() {
        this.prop = Sys.copyObject(this._defaultProp)
    },
    setOperationState: function(b, a) {
        if (typeof b !== "string") {
            throw new Error("State value must be a string.")
        } else {
            if (typeof a !== "object") {
                throw new Error("Operations value must be an object.")
            }
        }
        this._stateOperations[b] = a
    },
    isRunning: function() {
        return this.prop.running
    },
    updateOperation: function(a, b) {
        var c = this,
            d = {};
        Animation.Operations[a].applyDefaultValuesToItem(c);
        d[a] = b;
        d = Animation.utils.parseItemConfig(d);
        c.prop.operations[a] = d.operations[a];
        Animation.Operations[a].applyDefaultValuesToOperation(c)
    },
    finished: function() {
        this.prop.running = false
    },
    setOperationDefaultProperties: function() {
        var a = Object.keys(this.prop.operations),
            c = a.length,
            b = 0;
        while (b < c) {
            Animation.Operations[a[b]].applyDefaultValuesToItem(this);
            Animation.Operations[a[b]].applyDefaultValuesToOperation(this);
            ++b
        }
    },
    setSizeDefaultProperties: function(a) {
        ["width", "height"].forEach(function(b) {
            if (!Sys.isDefined(a[b]) && !a.fullScreen) {
                if (a.image instanceof HTMLCanvasElement) {
                    a[b] = a.image[b]
                } else {
                    if (typeof a.image === "string") {
                        a[b] = Resources.readData("animationImages")[a.image][b]
                    }
                }
            }
        })
    }
};
Animation.Item = Animation.CanvasAnimationItem = Sys.extend(Sys.Observable, Animation.CanvasAnimationItem, "Animation.CanvasAnimationItem");
(function() {
    var a = Object.keys(Animation.Operations),
        e = a.length,
        d = 0,
        c, b = function(f) {
            return function(g) {
                this.updateOperation(f, g)
            }
        };
    while (d < e) {
        c = a[d];
        Animation.CanvasAnimationItem.prototype[c] = b(c);
        ++d
    }
}());
Sys.ns("Animation");
Animation.utils = {
    calculateCurveLocation: function(d, a) {
        var c = Sys.utils.toInt(Math.pow(1 - a, 3) * d.p1.left + 3 * a * Math.pow(1 - a, 2) * d.s1.left + 3 * Math.pow(a, 2) * (1 - a) * d.s2.left + Math.pow(a, 3) * d.p2.left),
            b = Sys.utils.toInt(Math.pow(1 - a, 3) * d.p1.top + 3 * a * Math.pow(1 - a, 2) * d.s1.top + 3 * Math.pow(a, 2) * (1 - a) * d.s2.top + Math.pow(a, 3) * d.p2.top);
        return {
            left: c,
            top: b
        }
    },
    getPositions: function(a) {
        var c = a.length,
            d = {
                p1: {
                    left: 0,
                    top: 0
                },
                p2: {
                    left: 0,
                    top: 0
                },
                s1: {
                    left: 0,
                    top: 0
                },
                s2: {
                    left: 0,
                    top: 0
                }
            },
            b, e;
        d.p1.left = a[0].left;
        d.p1.top = a[0].top;
        d.p2.left = a[(c - 1)].left;
        d.p2.top = a[(c - 1)].top;
        e = 142 / 160;
        b = Math.abs((a[0].left * e + a[(c - 1)].left * e) / (a[0].top + a[(c - 1)].top));
        d.s1.left = a[0].left;
        d.s1.top = a[1].top;
        d.s2.left = a[(c - 1)].left;
        d.s2.top = a[1].top;
        if (b === 1) {
            d.s1.left = a[1].left;
            d.s2.left = a[1].left
        }
        if (c > 3) {
            d.s1.top = Math.min(a[1].top, a[2].top);
            d.s2.top = Math.min(a[1].top, a[2].top)
        }
        return d
    },
    degToRad: function(b, c) {
        var a = Sys.isDefined(c) ? c : 8;
        return Animation.utils.toNthDecimalPlace(b * 0.017453292519943295, a)
    },
    radToDeg: function(b, c) {
        var a = Sys.isDefined(c) ? c : 8;
        return Animation.utils.toNthDecimalPlace(b * (360 / (Math.PI * 2)), a)
    },
    setOperationValues: function(a) {
        Sys.iterate(a.operations, function(c, b) {
            Sys.each(b.frames, function(e) {
                var d;
                if (Sys.isObj(e.frame)) {
                    d = e.frame.name;
                    if (Sys.isDefined(e.frame.offset)) {
                        e.frame = a[d] + e.frame.offset
                    } else {
                        e.frame = a[d]
                    }
                }
                if (Sys.isObj(e.value)) {
                    d = e.value.name;
                    if (Sys.isDefined(d)) {
                        e.value = a[d]
                    }
                }
            })
        })
    },
    copyProperties: function(b, a) {
        var c = Sys.clone(Object.getPrototypeOf(b));
        Sys.apply(b, c);
        Sys.apply(b, a)
    },
    insertInOrder: function(e, f) {
        var b = 0,
            g, c, d = f.length,
            a = e.prop.depth;
        if (d > 0) {
            if (a < f[0].prop.depth) {
                f.unshift(e);
                return
            } else {
                if (a >= f[d - 1].prop.depth) {
                    f.push(e);
                    return
                }
            }
            for (b; b < d; b++) {
                g = f[b].prop.depth;
                if (d > b + 1) {
                    c = f[b + 1].prop.depth
                } else {
                    c = g
                }
                if (a > g && a < c) {
                    f.splice(b + 1, 0, e);
                    return
                } else {
                    if (a < g) {
                        f.splice(b, 0, e);
                        return
                    }
                }
            }
        } else {
            f.push(e)
        }
    },
    toNthDecimalPlace: function(a, d) {
        var c = Sys.isDefined(d) ? d : 1,
            b = Math.pow(10, c);
        return Math.round(a * b) / b
    },
    getInterpolationValue: function(g, h, b, m) {
        var l, j, e, c, a, d, f = "linear";
        if (Sys.isDefined(m) && Sys.isDefined(m.support)) {
            l = m.support;
            if (Sys.isArray(l)) {
                f = l.length === 2 ? "cubic" : "nNumber"
            } else {
                f = Sys.isDefined(m.type) ? m.type : "bezier"
            }
        }
        if (b > 1) {
            b = 1
        } else {
            if (b < 0) {
                b = 0
            }
        }
        switch (f) {
            case "linear":
                j = g + b * (h - g);
                break;
            case "bezier":
                j = ((1 - b) * (1 - b)) * g + 2 * b * (1 - b) * l + (b * b) * h;
                break;
            case "cubic":
                j = Math.pow(1 - b, 3) * g + 3 * b * Math.pow(1 - b, 2) * l[0] + 3 * Math.pow(b, 2) * (1 - b) * l[1] + Math.pow(b, 3) * h;
                break;
            case "nNumber":
                a = l.length;
                d = [];
                d.push(g);
                for (e = 0; e < a; e++) {
                    d.push(l[e])
                }
                d.push(h);
                a = d.length;
                for (c = 1; c < a; c++) {
                    for (e = 0; e < (a - c); e++) {
                        d[e] = (1 - b) * d[e] + b * d[e + 1]
                    }
                }
                j = d[0];
                break;
            case "none":
                j = b === 1 ? h : g;
                break;
            default:
        }
        return j
    },
    getCubiqInterpolationValue: function(e, d, b, a, c) {
        if (c > 1) {
            c = 1
        } else {
            if (c < 0) {
                c = 0
            }
        }
        return Math.pow(1 - c, 3) * e + 3 * c * Math.pow(1 - c, 2) * b + 3 * Math.pow(c, 2) * (1 - c) * a + Math.pow(c, 3) * d
    },
    randomBetween: function(b, a) {
        return b + (a - b) * Math.random()
    },
    parseItemConfig: function(d) {
        var b = {
                operations: {}
            },
            a = Object.keys(Animation.Operations),
            q = Object.keys(d),
            m = q.length,
            k = 0,
            o = function(j, i) {
                return (j.time - i.time)
            },
            n, f, l, c, p, h, g, e;
        while (k < m) {
            p = q[k];
            if (a.contains(p)) {
                f = d[p];
                n = Object.keys(f);
                l = n.length;
                g = 0;
                b.operations[p] = [];
                while (g < l) {
                    c = f[n[g]];
                    h = {
                        time: Sys.utils.toInt(n[g])
                    };
                    if (Sys.isObj(c) && Sys.isDefined(c.value)) {
                        h = Sys.apply(h, c)
                    } else {
                        h.value = c
                    }
                    b.operations[p].push(h);
                    ++g
                }
                b.operations[p].sort(o)
            } else {
                b[p] = d[p]
            }++k
        }
        if (!Sys.isDefined(d.pivot)) {
            b.pivot = {
                x: 0,
                y: 0
            };
            if (Sys.isDefined(b.width)) {
                b.pivot.x = -b.width / 2
            }
            if (Sys.isDefined(b.height)) {
                b.pivot.y = -b.height / 2
            }
        }
        if (d.fullScreen) {
            e = Environment.determineResolution().virtualResolution;
            b.width = e.width;
            b.height = e.height
        }
        return b
    },
    makeMotionBlur: function(m, s, u) {
        var t = document.createElement("canvas"),
            q = t.getContext("2d"),
            j = 0,
            c = 0,
            o = Sys.isDefined(m.naturalWidth) ? m.naturalWidth : m.width,
            k = Sys.isDefined(m.naturalHeight) ? m.naturalHeight : m.height,
            n, p, l, w, b, i, g, r, v, f, e, h, a, d;
        if (s === "horizontal") {
            j = (u * 2)
        } else {
            c = (u * 2)
        }
        t.width = o + j;
        t.height = k + c;
        q.drawImage(m, 0, 0, o, k);
        n = q.getImageData(0, 0, o + j, k + c);
        p = u;
        l = 1 / p;
        r = q.createImageData(n);
        o = n.width;
        k = n.height;
        v = n.data;
        f = r.data;
        for (i = -1; ++i < o;) {
            for (g = -1; ++g < k;) {
                e = 0;
                h = 0;
                a = 0;
                d = 0;
                for (w = -1; ++w < p;) {
                    b = (~~(g - p / 2) + w + k) % k;
                    e += v[((o * b) + i) * 4];
                    h += v[((o * b) + i) * 4 + 1];
                    a += v[((o * b) + i) * 4 + 2];
                    d += v[((o * b) + i) * 4 + 3]
                }
                f[((o * g) + i) * 4] = e * l;
                f[((o * g) + i) * 4 + 1] = h * l;
                f[((o * g) + i) * 4 + 2] = a * l;
                f[((o * g) + i) * 4 + 3] = d * l
            }
        }
        q.putImageData(r, 0, 0);
        return t
    },
    multiplyMatrix: function(d, c, e) {
        e[0] = d[0] * c[0] + d[2] * c[1];
        e[2] = d[0] * c[2] + d[2] * c[3];
        e[4] = d[0] * c[4] + d[2] * c[5] + Number(d[4]);
        e[1] = d[1] * c[0] + d[3] * c[1];
        e[3] = d[1] * c[2] + d[3] * c[3];
        e[5] = d[1] * c[4] + d[3] * c[5] + Number(d[5])
    },
    updateMatrix: function(h) {
        var e = this,
            a = h.matrix,
            d = h.tempMatrix,
            f, g, b;
        if (Sys.isDefined(h.changeMatrix)) {
            e.multiplyMatrix(h.parentMatrix, h.changeMatrix, a);
            return
        }
        a.set([1, 0, 0, 1, h.left - h.pivot.x, h.top - h.pivot.y]);
        d.set(a);
        if (Sys.isDefined(h.rotation)) {
            f = h.rotation * 0.017453292519943295;
            g = Math.cos(f);
            b = Math.sin(f);
            e.multiplyMatrix(d, [g, b, -b, g, 0, 0], a)
        }
        if (Sys.isDefined(h.scaleX) && Sys.isDefined(h.scaleY)) {
            d.set(a);
            e.multiplyMatrix(d, [h.scaleX, 0, 0, h.scaleY, 0, 0], a)
        }
        d.set(a);
        e.multiplyMatrix(h.parentMatrix, d, a)
    },
    performAction: function(d, a) {
        var g = d.prop,
            f = 0,
            c = Object.keys(g.operations),
            e = c.length,
            b = 0;
        if (e === 0) {
            return
        }
        while (b < e) {
            f += Animation.Operations[c[b]].performAction(d, a);
            ++b
        }
        if (f === 0 || (Sys.isDefined(g.duration) && g.localTime >= g.delay + g.duration)) {
            d.prop.running = false
        }
    },
    addOperation: function(c, a) {
        var b = this.parseItemConfig(a).operations;
        c.prop.operations = Sys.apply(c.prop.operations, b);
        Sys.iterate(b, function(d) {
            if (Sys.isDefined(c.prop.operationSteps[d])) {
                c.prop.operationSteps[d] = 0
            }
            Animation.Operations[d].applyDefaultValuesToItem(c);
            Animation.Operations[d].applyDefaultValuesToOperation(c)
        })
    },
    removeOperation: function(b, a) {
        if (Sys.isArray(a)) {
            Sys.each(a, function(c) {
                if (Sys.isDefined(b.prop.operations[c])) {
                    delete b.prop.operations[c];
                    delete b.prop.operationSteps[c]
                }
            })
        } else {
            if (Sys.isDefined(b.prop.operations[a])) {
                delete b.prop.operations[a];
                delete b.prop.operationSteps[a]
            }
        }
    },
    restoreOperations: function(b) {
        var a = Object.keys(b.operations),
            f = a.length,
            g = 0,
            l, m, h, c, n, e, d;
        while (g < f) {
            n = a[g];
            h = b.operations[n];
            l = h.length;
            b.operationSteps[n] = 0;
            h.timeBuffer = 0;
            for (e = -1; ++e < l;) {
                c = h[e];
                if (Sys.isDefined(c.fireEvent)) {
                    c.eventFired = false;
                    if (Sys.isDefined(c.iterations)) {
                        c.remainingIterations = c.iterations
                    }
                }
                if (Sys.isDefined(c.events)) {
                    m = c.events.length;
                    for (d = -1; ++d < m;) {
                        c.events[d].fired = false
                    }
                }
                if (Sys.isDefined(c.callback)) {
                    c.callbackCompleted = false
                }
            }++g
        }
        if (f === 0) {
            if (Object.keys(b.operationSteps).length > 0) {
                b.operationSteps = {}
            }
        }
    },
    increaseTimeBuffer: function(b, a, c) {
        var d = b.prop;
        if (!Sys.isDefined(d.operations[a].timeBuffer)) {
            d.operations[a].timeBuffer = 0
        }
        if (!d.paused) {
            d.operations[a].timeBuffer += c
        }
    },
    setTimeBuffer: function(b, a, c) {
        var d = b.prop;
        if (!Sys.isDefined(d.operations[a].timeBuffer)) {
            d.operations[a].timeBuffer = 0
        }
        d.operations[a].timeBuffer = c
    },
    getInMemoryCanvas: function(d, a) {
        var c = document.createElement("canvas"),
            b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {
            canvas: c,
            ctx: b
        }
    },
    isAnimationItem: function(a) {
        if (!Sys.isDefined(Animation.CanvasAnimationItem)) {
            return false
        }
        return a instanceof Animation.CanvasAnimationItem
    }
};
Sys.ns("Animation");
Animation.Emitter = {
    constructor: function(b) {
        var d = this,
            e = document.createElement("canvas"),
            a = e.getContext("2d"),
            c = {
                top: 0,
                left: 0,
                width: 1280,
                height: 720,
                depth: 0,
                delay: 0,
                reset: false,
                paused: false,
                fullScreen: false,
                image: e,
                operations: {},
                operationSteps: {},
                operationEnded: {},
                customProps: {},
                running: true,
                skip: false,
                operationsRunning: true,
                opacity: 1,
                ownOpacity: 1,
                parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
                contextProperties: {
                    globalCompositeOperation: false,
                    globalAlpha: false
                },
                emitterProps: {
                    maximumParticles: 1000,
                    numParticles: 50,
                    delayInterval: 4000,
                    duration: 3000,
                    durationOffset: 1000,
                    constantFlow: false,
                    deleteOutsideScreen: true,
                    fadeIn: false,
                    fadeInTime: 500,
                    fadeOut: false,
                    fadeOutTime: 1000,
                    orginPosX: 640,
                    orginPosY: 733,
                    emitterArea: false,
                    orginMaxPosX: 1280,
                    orginMaxPosY: 753,
                    targetPosX: 640,
                    targetPosY: 867,
                    targetArea: false,
                    targetMaxPosX: 1280,
                    targetMaxPosY: 733,
                    restrictedFromOrginX: false,
                    restrictedFromOrginY: false,
                    acceptableOffsetX: 400,
                    acceptableOffsetY: 13,
                    timeMaxToTarget: 2000,
                    timeMinToTarget: 1000,
                    usingGravity: false,
                    gravity: 2,
                    minStartVel: -93,
                    maxStartVel: -200,
                    maxVel: 200,
                    particleImage: "mintLeaf",
                    particleWidth: 90,
                    particleHeight: 90,
                    differInSize: false,
                    sizeDifferFactorLow: 0.5,
                    sizeDifferFactorHigh: 1.5,
                    numberOfSizeDifferences: 3,
                    turning: false,
                    imageAngles: 18,
                    minTurnSpeed: 1000,
                    maxTurnSpeed: 3000,
                    animating: true,
                    animatingBothWays: true,
                    animationTurning: true,
                    particleFrameRate: 20,
                    particleFrameRateVaried: true,
                    particleMaxFrameRate: 50,
                    imageFrames: 30,
                    imageFramesForRotation: 0,
                    totalSpriteWidth: 2700,
                    orginSize: 1,
                    targetSize: 1,
                    bounceBox: false,
                    bounceBoxDrawn: false,
                    bounceBoxLeft: 1000,
                    bounceBoxRight: 1040,
                    bounceBoxTop: 507,
                    bounceBoxBottom: 600,
                    bounceBoxGravity: 2,
                    bounceBoxStartVel: -20,
                    movingEmitter: false
                }
            };
        d.flowOn = true;
        d.emitterCanvas = e;
        d.emitterCanvas.width = 1280;
        d.emitterCanvas.height = 720;
        d.emitterContext = a;
        Sys.iterate(b, function(f, g) {
            if (Sys.isObj(g)) {
                Sys.iterate(b[f], function(i, h) {
                    c[f][i] = b[f][i]
                })
            } else {
                c[f] = b[f]
            }
        });
        b = c;
        b = Animation.utils.parseItemConfig(b);
        d.prop = Sys.apply(d.prop, b);
        d.prop.localTime = 0;
        d.setOperationDefaultProperties();
        d.setUpEmitter()
    },
    setUpEmitter: function() {
        var c = this,
            b = Game.stage.view.animationManager.images,
            a = b[c.prop.emitterProps.particleImage];
        if (c.prop.emitterProps.turning && !c.prop.emitterProps.animating) {
            c.particleImages = c.createImagesRotated(a)
        } else {
            if (c.prop.emitterProps.animating && !c.prop.emitterProps.turning) {
                c.particleImages = c.createSpriteSheetImages(a)
            }
        }
        c.particles = c.createParticles();
        if (!c.prop.emitterProps.constantFlow) {
            c.restoreExplodingParticles()
        }
        if (c.prop.emitterProps.bounceBoxDrawn) {
            c.bounceBoxDrawn = true
        }
    },
    createImagesRotated: function(e) {
        var f = this,
            d, b = 0,
            h, g = [],
            a = f.prop.emitterProps.particleWidth,
            j = f.prop.emitterProps.particleHeight,
            c, k;
        for (d = -1; ++d < f.prop.emitterProps.imageAngles;) {
            c = document.createElement("canvas");
            k = c.getContext("2d");
            c.width = a;
            c.height = j;
            h = f.radiansFromDegrees(b);
            k.translate(a / 2, j / 2);
            k.rotate(h);
            k.drawImage(e, -(a / 2), -(j / 2), a, j);
            k.rotate(-h);
            k.translate(-(a / 2), -(j / 2));
            g.push(c);
            b += (360 / f.prop.emitterProps.imageAngles)
        }
        return g
    },
    createSpriteSheetImages: function(f) {
        var h = this,
            d, j = [],
            e, a = h.prop.emitterProps.particleWidth,
            l = h.prop.emitterProps.particleHeight,
            b = 0,
            k, c, m, g;
        if (h.prop.emitterProps.imageFramesForRotation > 0) {
            h.usedFrames = h.prop.emitterProps.imageFramesForRotation
        } else {
            h.usedFrames = h.prop.emitterProps.imageFrames
        }
        for (d = 0; d < h.usedFrames; d++) {
            c = document.createElement("canvas");
            m = c.getContext("2d");
            g = d % h.prop.emitterProps.imageFrames;
            c.width = a;
            c.height = l;
            e = h.getFramePosition(g, a, l, h.prop.emitterProps.totalSpriteWidth);
            if (h.prop.emitterProps.animationTurning) {
                k = h.radiansFromDegrees(b);
                m.translate(a / 2, l / 2);
                m.rotate(k);
                m.drawImage(f, e.x, e.y, a, l, -(a / 2), -(l / 2), a, l);
                m.rotate(-k);
                m.translate(-(a / 2), -(l / 2));
                b += (360 / h.usedFrames)
            } else {
                m.drawImage(f, e.x, e.y, a, l, 0, 0, a, l)
            }
            j.push(c)
        }
        return j
    },
    createParticles: function() {
        var c = this,
            b, a = [];
        if (c.prop.emitterProps.differInSize) {
            c.sizeDifferences = c.createDifferences(c.prop.emitterProps.sizeDifferFactorLow, c.prop.emitterProps.sizeDifferFactorHigh, c.prop.emitterProps.numberOfSizeDifferences)
        }
        for (b = -1; ++b < c.prop.emitterProps.maximumParticles;) {
            a.push(c.updateParticle({}))
        }
        return a
    },
    turnOffBounceBox: function() {
        var b = this,
            a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.particles[a].bounceBox = false
        }
        b.prop.emitterProps.bounceBox = false;
        b.bounceBoxDrawn = false
    },
    turnOnBounceBox: function() {
        var b = this,
            a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.particles[a].bounceBox = true
        }
        b.prop.emitterProps.bounceBox = true;
        if (b.prop.emitterProps.bounceBoxDrawn) {
            b.bounceBoxDrawn = true
        }
    },
    createDifferences: function(a, e, b) {
        var f = [],
            d = (e - a) / b,
            c;
        for (c = 0; c < b; c++) {
            f.push((a + (d * c)))
        }
        return f
    },
    restoreExplodingParticles: function() {
        var b = this,
            a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.updateParticle(b.particles[a]);
            b.particles[a].explosionTriggered = true
        }
        b.emittStarted = false;
        b.flowOn = true
    },
    restoreParticles: function() {
        var b = this,
            a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.updateParticle(b.particles[a])
        }
    },
    randomBetweenNotRounded: function(b, a) {
        return (Math.random() * (a - b)) + b
    },
    randomBetween: function(b, a) {
        return Math.floor(Math.random() * (a - b)) + b
    },
    radiansFromDegrees: function(a) {
        return (Math.PI / 180) * a
    },
    getFramePosition: function(f, d, e, c) {
        var b = f * d,
            a = {};
        if (b >= c) {
            a.x = b % c;
            a.y = (Math.floor(b / c) * e)
        } else {
            a.x = b;
            a.y = 0
        }
        return a
    },
    updateParticle: function(c) {
        var a = this,
            b = a.prop;
        if (!a.prop.emitterProps.emitterArea) {
            c.x = b.emitterProps.orginPosX;
            c.y = b.emitterProps.orginPosY
        } else {
            c.x = a.randomBetween(b.emitterProps.orginPosX, b.emitterProps.orginMaxPosX);
            c.y = a.randomBetween(b.emitterProps.orginPosY, b.emitterProps.orginMaxPosY)
        }
        if (!a.prop.emitterProps.targetArea) {
            c.endPosX = a.randomBetweenNotRounded(b.emitterProps.targetPosX - b.emitterProps.acceptableOffsetX, b.emitterProps.targetPosX + b.emitterProps.acceptableOffsetX);
            c.endPosY = a.randomBetweenNotRounded(b.emitterProps.targetPosY - b.emitterProps.acceptableOffsetY, b.emitterProps.targetPosY + b.emitterProps.acceptableOffsetY)
        } else {
            if (a.prop.emitterProps.restrictedFromOrginX) {
                c.endPosX = a.randomBetweenNotRounded(c.x - b.emitterProps.acceptableOffsetX, c.x + b.emitterProps.acceptableOffsetX)
            } else {
                c.endPosX = a.randomBetweenNotRounded(b.emitterProps.targetPosX - b.emitterProps.acceptableOffsetX, b.emitterProps.targetMaxPosX + b.emitterProps.acceptableOffsetX)
            }
            c.endPosY = a.randomBetweenNotRounded(b.emitterProps.targetPosY - b.emitterProps.acceptableOffsetY, b.emitterProps.targetMaxPosY + b.emitterProps.acceptableOffsetY)
        }
        c.width = b.emitterProps.particleWidth;
        c.height = b.emitterProps.particleHeight;
        c.timeToTarget = a.randomBetweenNotRounded(b.emitterProps.timeMinToTarget, b.emitterProps.timeMaxToTarget);
        if (!b.emitterProps.animating && b.emitterProps.turning) {
            c.image = a.randomBetween(0, b.emitterProps.imageAngles)
        } else {
            if (b.emitterProps.animating && b.emitterProps.animatingBothWays) {
                c.image = a.randomBetween(0, a.usedFrames - 1)
            } else {
                c.image = 0
            }
        }
        c.delay = a.randomBetween(0, b.emitterProps.delayInterval);
        c.timer = 0;
        c.emitted = false;
        c.alpha = (b.emitterProps.fadeIn) ? 0 : 1;
        c.fadingIn = b.emitterProps.fadeIn;
        c.fadeOut = b.emitterProps.fadeOut;
        c.fadingOut = false;
        c.fadeInTime = b.emitterProps.fadeInTime;
        c.fadeOutTime = b.emitterProps.fadeOutTime;
        c.deleteOutsideScreen = b.emitterProps.deleteOutsideScreen;
        c.explosionTriggered = false;
        c.goingLeft = (c.x >= c.endPosX);
        c.falling = (c.y < c.endPosY);
        c.durationLimit = a.randomBetween(b.emitterProps.duration - b.emitterProps.durationOffset, b.emitterProps.duration + b.emitterProps.durationOffset);
        c.duration = 0;
        c.gravityOn = b.emitterProps.usingGravity;
        if (c.gravityOn) {
            c.curVel = a.randomBetweenNotRounded(b.emitterProps.minStartVel, b.emitterProps.maxStartVel)
        } else {
            if (c.falling) {
                c.secondSpeedY = ((c.endPosY - c.y) / (c.timeToTarget / 1000));
                if (c.secondSpeedY === 0) {
                    c.secondSpeedY = 0.1
                }
            } else {
                c.secondSpeedY = ((c.y - c.endPosY) / (c.timeToTarget / 1000));
                if (c.secondSpeedY === 0) {
                    c.secondSpeedY = -0.1
                }
            }
        }
        if (!c.goingLeft) {
            c.secondSpeedX = ((c.endPosX - c.x) / (c.timeToTarget / 1000));
            if (c.secondSpeedX === 0) {
                c.secondSpeedX = 0.1
            }
        } else {
            c.secondSpeedX = ((c.x - c.endPosX) / (c.timeToTarget / 1000));
            if (c.secondSpeedX === 0) {
                c.secondSpeedX = -0.1
            }
        }
        if (b.emitterProps.bounceBox) {
            c.bounceBox = true;
            c.bounceBoxLeft = b.emitterProps.bounceBoxLeft;
            c.bounceBoxRight = b.emitterProps.bounceBoxRight;
            c.bounceBoxTop = b.emitterProps.bounceBoxTop;
            c.bounceBoxBottom = b.emitterProps.bounceBoxBottom;
            c.bounced = false;
            c.bounceBoxStartVel = b.emitterProps.bounceBoxStartVel;
            if (!c.gravityOn) {
                b.emitterProps.gravity = b.emitterProps.bounceBoxGravity
            }
        }
        c.drawn = 0;
        if (b.emitterProps.turning) {
            c.turning = true;
            c.turnSpeed = a.randomBetween(b.emitterProps.minTurnSpeed, b.emitterProps.maxTurnSpeed);
            c.nextRotationAt = c.turnSpeed / b.emitterProps.imageAngles;
            if (a.turnLeft) {
                c.turnLeft = true;
                a.turnLeft = false
            } else {
                c.turnLeft = false;
                a.turnLeft = true
            }
        } else {
            c.turning = false
        }
        if (b.emitterProps.animating) {
            c.animating = true;
            if (b.emitterProps.particleFrameRateVaried) {
                c.frameRate = a.randomBetween(b.emitterProps.particleFrameRate, b.emitterProps.particleMaxFrameRate)
            } else {
                c.frameRate = b.emitterProps.particleFrameRate
            }
            if (b.emitterProps.animatingBothWays) {
                if (a.animateLeft) {
                    c.animateLeft = true;
                    a.animateLeft = false
                } else {
                    c.animateLeft = false;
                    a.animateLeft = true
                }
            }
        } else {
            c.animating = false
        }
        if (b.emitterProps.differInSize) {
            c.sizeFactor = a.sizeDifferences[a.randomBetween(0, a.sizeDifferences.length)]
        } else {
            c.sizeFactor = 1
        }
        return c
    },
    run: function(f, e) {
        var d = this,
            h, g, b, c, a = false;
        Animation.Emitter.superclass.run.apply(this, arguments);
        if (!d.emittStarted) {
            d.emittTime = Date.now();
            d.emittStarted = true
        }
        h = Date.now() - d.emittTime;
        d.emitterContext.clearRect(0, 0, d.prop.width, d.prop.height);
        for (b = -1; ++b < d.prop.emitterProps.numParticles;) {
            g = d.particles[b];
            if (d.flowOn && ((!g.emitted && d.prop.emitterProps.constantFlow) || (!d.prop.emitterProps.constantFlow && g.explosionTriggered))) {
                g.timer += h;
                if (g.delay > g.timer) {
                    continue
                }
                if (d.prop.emitterProps.movingEmitter) {
                    if (!d.prop.emitterProps.emitterArea) {
                        g.x = d.prop.emitterProps.orginPosX;
                        g.y = d.prop.emitterProps.orginPosY
                    } else {
                        g.x = d.randomBetween(d.prop.emitterProps.orginPosX, d.prop.emitterProps.orginMaxPosX);
                        g.y = d.randomBetween(d.prop.emitterProps.orginPosY, d.prop.emitterProps.orginMaxPosY)
                    }
                    if (!d.prop.emitterProps.targetArea) {
                        g.endPosX = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosX - d.prop.emitterProps.acceptableOffsetX, d.prop.emitterProps.targetPosX + d.prop.emitterProps.acceptableOffsetX);
                        g.endPosY = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosY - d.prop.emitterProps.acceptableOffsetY, d.prop.emitterProps.targetPosY + d.prop.emitterProps.acceptableOffsetY)
                    } else {
                        if (d.prop.emitterProps.restrictedFromOrginX) {
                            g.endPosX = d.randomBetweenNotRounded(g.x - d.prop.emitterProps.acceptableOffsetX, g.x + d.prop.emitterProps.acceptableOffsetX)
                        } else {
                            g.endPosX = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosX - d.prop.emitterProps.acceptableOffsetX, d.prop.emitterProps.targetMaxPosX + d.prop.emitterProps.acceptableOffsetX)
                        }
                        g.endPosY = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosY - d.prop.emitterProps.acceptableOffsetY, d.prop.emitterProps.targetMaxPosY + d.prop.emitterProps.acceptableOffsetY)
                    }
                }
                g.emitted = true
            }
            if (g.emitted) {
                a = true;
                g.duration += h;
                c = h * 0.001;
                if (g.fadingIn) {
                    g.alpha += h / g.fadeInTime;
                    if (g.alpha >= 1) {
                        g.alpha = 1;
                        g.fadingIn = false
                    }
                }
                if (g.duration > g.durationLimit) {
                    if (g.fadeOut) {
                        g.fadingOut = true
                    } else {
                        d.updateParticle(g);
                        continue
                    }
                }
                if (g.fadingOut) {
                    g.alpha -= h / g.fadeOutTime;
                    if (g.alpha <= 0) {
                        d.updateParticle(g);
                        continue
                    }
                }
                if ((!g.goingLeft && g.x < g.endPosX) || (!g.goingLeft && g.x >= g.endPosX)) {
                    g.x += g.secondSpeedX * c
                } else {
                    if ((g.goingLeft && g.x > g.endPosX) || (g.goingLeft && g.x <= g.endPosX)) {
                        g.x -= g.secondSpeedX * c
                    }
                }
                if (g.bounceBox && !g.bounced) {
                    if (!g.goingLeft && g.x > g.bounceBoxLeft && g.x < g.bounceBoxRight && g.y > g.bounceBoxTop && g.y < g.bounceBoxBottom) {
                        g.bounced = true;
                        g.gravityOn = true;
                        g.curVel = g.bounceBoxStartVel;
                        g.goingLeft = true
                    } else {
                        if (g.goingLeft && g.x < g.bounceBoxLeft && g.x > g.bounceBoxRight && g.y > g.bounceBoxTop && g.y < g.bounceBoxBottom) {
                            g.bounced = true;
                            g.gravityOn = true;
                            g.curVel = g.bounceBoxStartVel;
                            g.goingLeft = false
                        }
                    }
                }
                if (!g.gravityOn) {
                    if (g.falling) {
                        g.y += g.secondSpeedY * c;
                        if (g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                            d.updateParticle(g);
                            continue
                        }
                    } else {
                        g.y -= g.secondSpeedY * c;
                        if (g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                            d.updateParticle(g);
                            continue
                        }
                    }
                } else {
                    g.curVel += d.prop.emitterProps.gravity * (c * 100);
                    if (d.prop.emitterProps.gravity > 0) {
                        if (g.curVel > d.prop.emitterProps.maxVel) {
                            g.curVel = d.prop.emitterProps.maxVel
                        }
                    } else {
                        if (g.curVel < d.prop.emitterProps.maxVel) {
                            g.curVel = d.prop.emitterProps.maxVel
                        }
                    }
                    if (g.curVel > 0 && g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                        d.updateParticle(g);
                        continue
                    }
                    g.y += g.curVel * (c * 10)
                }
                if (g.turning) {
                    g.drawn += h;
                    if (g.drawn >= g.nextRotationAt) {
                        if (g.turnLeft) {
                            g.image -= 1;
                            if (g.image < 0) {
                                g.image = d.prop.emitterProps.imageAngles - 1
                            }
                        } else {
                            g.image += 1;
                            if (g.image >= d.prop.emitterProps.imageAngles) {
                                g.image = 0
                            }
                        }
                        g.drawn = g.drawn % g.nextRotationAt
                    }
                }
                if (g.animating) {
                    g.drawn += h;
                    if (g.drawn >= (1000 / g.frameRate)) {
                        g.drawn = g.drawn % (1000 / g.frameRate);
                        if (g.animateLeft) {
                            g.image -= 1;
                            if (g.image < 0) {
                                g.image = d.usedFrames - 1
                            }
                        } else {
                            g.image += 1;
                            if (g.image >= d.usedFrames) {
                                g.image = 0
                            }
                        }
                    }
                }
                d.emitterContext.globalAlpha = g.alpha;
                d.emitterContext.drawImage(d.particleImages[g.image], 0, 0, g.width, g.height, g.x - (g.width / 2), g.y - (g.height / 2), g.width * g.sizeFactor, g.height * g.sizeFactor);
                d.emitterContext.globalAlpha = 1
            }
        }
        if (d.bounceBoxDrawn) {
            d.emitterContext.globalAlpha = 0.5;
            d.emitterContext.beginPath();
            d.emitterContext.lineWidth = "3";
            d.emitterContext.strokeStyle = "red";
            d.emitterContext.rect(d.prop.emitterProps.bounceBoxLeft, d.prop.emitterProps.bounceBoxTop, d.prop.emitterProps.bounceBoxRight - d.prop.emitterProps.bounceBoxLeft, d.prop.emitterProps.bounceBoxBottom - d.prop.emitterProps.bounceBoxTop);
            d.emitterContext.stroke();
            d.emitterContext.globalAlpha = 1
        }
        d.emittTime = Date.now();
        if (!d.flowOn && !a) {
            d.finished()
        }
        return true
    },
    play: function() {
        if (!this.isRunning()) {
            this.restore()
        }
        this.prop.paused = false
    },
    pause: function() {
        this.prop.paused = true
    },
    stop: function() {
        this.prop.running = false
    },
    restore: function() {
        Animation.Emitter.superclass.restore.apply(this, arguments);
        this.restoreExplodingParticles()
    },
    isRunning: function() {
        return this.prop.running
    },
    finished: function() {
        this.prop.running = false
    },
    stopFlow: function() {
        this.flowOn = false
    }
};
Animation.Emitter = Sys.extend(Animation.CanvasAnimationItem, Animation.Emitter, "Animation.Emitter");
(function() {
    var a = Object.keys(Animation.Operations),
        e = a.length,
        d = 0,
        c, b = function(f) {
            return function(g) {
                this.updateOperation(f, g)
            }
        };
    while (d < e) {
        c = a[d];
        Animation.Emitter.prototype[c] = b(c);
        ++d
    }
}());
Sys.ns("Animation");
Animation.utils.stackBlur = {
    mulTable: [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
    shgTable: [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24],
    stackBlurImage: function(e, d, i, a) {
        var f = e,
            j = f.naturalWidth,
            g = d,
            c = document.createElement("canvas"),
            b = c.getContext("2d");
        c.style.width = j + "px";
        c.style.height = g + "px";
        c.width = j;
        c.height = g;
        b.clearRect(0, 0, j, g);
        b.drawImage(f, 0, (g - f.naturalHeight) / 2, j, f.naturalHeight);
        if (isNaN(i) || i < 1) {
            return undefined
        }
        if (a) {
            return Animation.utils.stackBlur.stackBlurCanvasRGBA(c, 0, 0, j, g, i)
        }
        return Animation.utils.stackBlur.stackBlurCanvasRGB(c, 0, 0, j, g, i)
    },
    stackBlurCanvasRGBA: function(R, m, l, a, b, K) {
        var f = R,
            Y = f.getContext("2d"),
            P, d, j, J, I, U, O, q, u, Q, r, n, S, H, F, E, G, c, t, N, o, k, s, v, w, B, W, M, h, L, A, z, T, D, C, g;
        if (isNaN(K) || K < 1) {
            return undefined
        }
        K |= 0;
        try {
            try {
                P = Y.getImageData(m, l, a, b)
            } catch (X) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                    P = Y.getImageData(m, l, a, b)
                } catch (V) {
                    throw new Error("unable to access local image data: " + V)
                }
            }
        } catch (X) {
            throw new Error("unable to access image data: " + X)
        }
        d = P.data;
        W = K + K + 1;
        M = b - 1;
        h = K + 1;
        L = h * (h + 1) / 2;
        A = new Animation.utils.stackBlur.BlurStack();
        z = A;
        for (U = 1; U < W; U++) {
            z = z.next = new Animation.utils.stackBlur.BlurStack();
            if (U === h) {
                j = z
            }
        }
        z.next = A;
        C = Animation.utils.stackBlur.mulTable[K];
        g = Animation.utils.stackBlur.shgTable[K];
        for (J = 0; J < a; J++) {
            t = N = o = c = r = n = S = Q = 0;
            u = J << 2;
            H = h * (k = d[u]);
            F = h * (s = d[u + 1]);
            E = h * (v = d[u + 2]);
            G = h * (w = d[u + 3]);
            Q += L * k;
            r += L * s;
            n += L * v;
            S += L * w;
            z = A;
            for (U = 0; U < h; U++) {
                z.r = k;
                z.g = s;
                z.b = v;
                z.a = w;
                z = z.next
            }
            q = a;
            for (U = 1; U <= K; U++) {
                u = (q + J) << 2;
                Q += (z.r = (k = d[u])) * (B = h - U);
                r += (z.g = (s = d[u + 1])) * B;
                n += (z.b = (v = d[u + 2])) * B;
                S += (z.a = (w = d[u + 3])) * B;
                c += k;
                t += s;
                N += v;
                o += w;
                z = z.next;
                if (U < M) {
                    q += a
                }
            }
            u = J;
            T = A;
            D = j;
            for (I = 0; I < b; I++) {
                O = u << 2;
                d[O + 3] = w = (S * C) >> g;
                if (w > 0) {
                    w = 255 / w;
                    d[O] = ((Q * C) >> g) * w;
                    d[O + 1] = ((r * C) >> g) * w;
                    d[O + 2] = ((n * C) >> g) * w
                } else {
                    d[O] = d[O + 1] = d[O + 2] = 0
                }
                Q -= H;
                r -= F;
                n -= E;
                S -= G;
                H -= T.r;
                F -= T.g;
                E -= T.b;
                G -= T.a;
                O = (J + (((O = I + h) < M ? O : M) * a)) << 2;
                Q += (c += (T.r = d[O]));
                r += (t += (T.g = d[O + 1]));
                n += (N += (T.b = d[O + 2]));
                S += (o += (T.a = d[O + 3]));
                T = T.next;
                H += (k = D.r);
                F += (s = D.g);
                E += (v = D.b);
                G += (w = D.a);
                c -= k;
                t -= s;
                N -= v;
                o -= w;
                D = D.next;
                u += a
            }
        }
        Y.putImageData(P, m, l);
        return f
    },
    stackBlurCanvasRGB: function(Q, o, n, a, b, J) {
        var f = Q,
            W = f.getContext("2d"),
            O, d, j, I, H, S, N, r, v, l, P, s, q, G, F, E, c, u, M, k, t, w, B, U, m, L, h, K, A, z, R, D, C, g;
        if (isNaN(J) || J < 1) {
            return undefined
        }
        J |= 0;
        try {
            try {
                O = W.getImageData(o, n, a, b)
            } catch (V) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                    O = W.getImageData(o, n, a, b)
                } catch (T) {
                    throw new Error("unable to access local image data: " + T)
                }
            }
        } catch (V) {
            throw new Error("unable to access image data: " + V)
        }
        d = O.data;
        U = J + J + 1;
        m = a - 1;
        L = b - 1;
        h = J + 1;
        K = h * (h + 1) / 2;
        A = new Animation.utils.stackBlur.BlurStack();
        z = A;
        for (S = 1; S < U; S++) {
            z = z.next = new Animation.utils.stackBlur.BlurStack();
            if (S === h) {
                j = z
            }
        }
        z.next = A;
        C = Animation.utils.stackBlur.mulTable[J];
        g = Animation.utils.stackBlur.shgTable[J];
        l = v = 0;
        for (H = 0; H < b; H++) {
            c = u = M = P = s = q = 0;
            G = h * (k = d[v]);
            F = h * (t = d[v + 1]);
            E = h * (w = d[v + 2]);
            P += K * k;
            s += K * t;
            q += K * w;
            z = A;
            for (S = 0; S < h; S++) {
                z.r = k;
                z.g = t;
                z.b = w;
                z = z.next
            }
            for (S = 1; S < h; S++) {
                N = v + ((m < S ? m : S) << 2);
                P += (z.r = (k = d[N])) * (B = h - S);
                s += (z.g = (t = d[N + 1])) * B;
                q += (z.b = (w = d[N + 2])) * B;
                c += k;
                u += t;
                M += w;
                z = z.next
            }
            R = A;
            D = j;
            for (I = 0; I < a; I++) {
                d[v] = (P * C) >> g;
                d[v + 1] = (s * C) >> g;
                d[v + 2] = (q * C) >> g;
                P -= G;
                s -= F;
                q -= E;
                G -= R.r;
                F -= R.g;
                E -= R.b;
                N = (l + ((N = I + J + 1) < m ? N : m)) << 2;
                c += (R.r = d[N]);
                u += (R.g = d[N + 1]);
                M += (R.b = d[N + 2]);
                P += c;
                s += u;
                q += M;
                R = R.next;
                G += (k = D.r);
                F += (t = D.g);
                E += (w = D.b);
                c -= k;
                u -= t;
                M -= w;
                D = D.next;
                v += 4
            }
            l += a
        }
        for (I = 0; I < a; I++) {
            u = M = c = s = q = P = 0;
            v = I << 2;
            G = h * (k = d[v]);
            F = h * (t = d[v + 1]);
            E = h * (w = d[v + 2]);
            P += K * k;
            s += K * t;
            q += K * w;
            z = A;
            for (S = 0; S < h; S++) {
                z.r = k;
                z.g = t;
                z.b = w;
                z = z.next
            }
            r = a;
            for (S = 1; S <= J; S++) {
                v = (r + I) << 2;
                P += (z.r = (k = d[v])) * (B = h - S);
                s += (z.g = (t = d[v + 1])) * B;
                q += (z.b = (w = d[v + 2])) * B;
                c += k;
                u += t;
                M += w;
                z = z.next;
                if (S < L) {
                    r += a
                }
            }
            v = I;
            R = A;
            D = j;
            for (H = 0; H < b; H++) {
                N = v << 2;
                d[N] = (P * C) >> g;
                d[N + 1] = (s * C) >> g;
                d[N + 2] = (q * C) >> g;
                P -= G;
                s -= F;
                q -= E;
                G -= R.r;
                F -= R.g;
                E -= R.b;
                N = (I + (((N = H + h) < L ? N : L) * a)) << 2;
                P += (c += (R.r = d[N]));
                s += (u += (R.g = d[N + 1]));
                q += (M += (R.b = d[N + 2]));
                R = R.next;
                G += (k = D.r);
                F += (t = D.g);
                E += (w = D.b);
                c -= k;
                u -= t;
                M -= w;
                D = D.next;
                v += a
            }
        }
        W.putImageData(O, o, n);
        return f
    },
    BlurStack: function() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null
    }
};
Sys.ns("Animation.utils");
Animation.utils.text = {
    measureText: function(e, c, d, b) {
        var a = Animation.utils.text.getHeightOfFont(c) * 1.5;
        d = d || 0;
        b.font = c;
        return {
            width: Math.ceil(b.measureText(e).width) + d * 2,
            height: a + d * 2
        }
    },
    getHeightOfFont: function(a) {
        return parseInt(/(\d*)px/.exec(a)[1], 10)
    },
    drawText: function(i, k, e, c, h, a) {
        var d, b, j, g, f;
        k = k || 50;
        e = e || "Verdana";
        c = c || 0;
        a = a || [{}];
        a[0] = a[0] || {};
        b = document.createElement("canvas");
        j = b.getContext("2d");
        d = Animation.utils.text.shrinkFont(i, k, e, c, h, j);
        b.width = d.dimensions.width;
        b.height = d.dimensions.height;
        g = c;
        f = d.dimensions.height / 2;
        Animation.utils.text.performOperations(i, d.font, g, f, a, j);
        return b
    },
    createText: function(h, d, e, b) {
        var a, c, i, g, f;
        d = d || "50px Verdana";
        e = e || 0;
        b = b || [{}];
        b[0] = b[0] || {};
        c = document.createElement("canvas");
        i = c.getContext("2d");
        a = Animation.utils.text.measureText(h, d, e, i);
        c.width = a.width;
        c.height = a.height;
        g = e;
        f = a.height / 2;
        Animation.utils.text.performOperations(h, d, g, f, b, i);
        return c
    },
    createCharacterSet: function(e, d, b, f, a) {
        var i, h, c, m, l, k, g;
        c = document.createElement("canvas");
        c.width = b * e.length;
        c.height = f;
        m = c.getContext("2d");
        for (g = 0; g < e.length; g++) {
            i = e[g];
            h = Animation.utils.text.measureText(i, d, 0, m);
            l = g * b + b / 2 - h.width / 2;
            k = f / 2;
            Animation.utils.text.performOperations(i, d, l, k, a, m)
        }
        return c
    },
    performOperations: function(i, d, g, f, b, j, h) {
        var e, c, a;
        j.shadowOffsetX = 0;
        j.textBaseline = "middle";
        j.font = d;
        Sys.each(b, function(k) {
            e = k.drawType || "fill";
            Sys.iterate(k, function(l, o) {
                var n, m;
                if (l !== "drawType") {
                    if (l === "fillStyle" && Sys.isObj(o)) {
                        if (o.type === "linearGradient") {
                            n = o.linearGradient;
                            m = j.createLinearGradient(n[0], n[1], n[2], n[3]);
                            Sys.each(o.colorStop, function(p) {
                                m.addColorStop(p.pos, p.rgb)
                            });
                            j.fillStyle = m
                        }
                    } else {
                        j[l] = o
                    }
                }
            });
            c = Sys.isDefined(k.offsetX) ? g + k.offsetX : g;
            a = Sys.isDefined(k.offsetY) ? f + k.offsetY : f;
            if (Sys.isDefined(h)) {
                j[e + "Text"](i, c, a, h)
            } else {
                j[e + "Text"](i, c, a)
            }
            j.shadowBlur = null
        })
    },
    drawTextFromImage: function(o, g, m, l, a, e, j, k, d, p, b) {
        var n, h, c, f;
        o = o.toString();
        n = o.length;
        if (a) {
            m = m - (n * k + g * (n - 1)) / 2;
            l = l - d / 2
        }
        if (Sys.isiPhone) {
            p.save();
            p.scale(1000000, 1000000);
            p.drawImage(e, 0, 0, 1e-7, 1e-7, 0, 0, 1e-7, 1e-7);
            p.restore()
        }
        for (f = 0; f < n; f++) {
            h = o[f];
            c = j[h] * k;
            p.drawImage(e, c, (b || 0), k, d, m, l, k, d);
            m = m + k + g
        }
    },
    createNumberDrawingProperties: function(a) {
        var c, b;
        if (Sys.isDefined(a.NUMBER_IMAGE)) {
            b = a.NUMBER_CHAR_MAP || Sys.range(0, 9);
            c = Resources.readData("animationImages")[a.NUMBER_IMAGE]
        } else {
            b = Sys.range(0, 9);
            c = Animation.utils.text.createCharacterSet("0123456789", a.NUMBER_FONT, a.NUMBER_WIDTH, a.NUMBER_HEIGHT, a.NUMBER_TEXT_OPERATIONS)
        }
        return {
            image: c,
            width: a.NUMBER_WIDTH,
            height: a.NUMBER_HEIGHT,
            charMap: b
        }
    },
    wrapCanvasText: function(m, d, h, f, k, j, a, o, i, b) {
        var c, g = Sys.isDefined(b) ? m.split(b) : this.wrapCanvasTextSplitInRows(m, k, o),
            e = g.length,
            l = o.canvas.height / 2,
            p = l - (e / 2 - 0.5) * j;
        if (i) {
            f = p;
            o.textBaseline = "center"
        }
        for (c = 0; c < e; c++) {
            this.performOperations(g[c], d, h, f, a, o, k);
            f += j
        }
    },
    wrapCanvasTextSplitInRows: function(g, f, i) {
        var d = g.trim().split(" "),
            j = "",
            a, e = [],
            b, c, h;
        for (a = 0; a < d.length; a++) {
            b = j === "" ? d[a] : j + " " + d[a];
            c = i.measureText(b);
            h = c.width;
            if (d[a] === "") {
                continue
            }
            if (h > f) {
                e.push(j);
                j = a < d.length - 1 ? "" : d[a]
            } else {
                j = b
            }
        }
        e.push(j);
        return e
    },
    shrinkFont: function(f, h, d, c, e, g) {
        var i = h,
            b, a;
        do {
            b = h + "px " + d;
            a = Animation.utils.text.measureText(f, b, c, g);
            h--
        } while (a.width > e);
        h++;
        return {
            font: b,
            fontSize: h,
            dimensions: a,
            sizeOffset: i - h
        }
    }
};
Sys.ns("Animation");
Animation.CanvasAnimationScene = {
    constructor: function(a) {
        var b = this,
            c = Environment.determineResolution().virtualToWindowScale;
        a = a || {};
        b.prop = {
            delay: 0,
            duration: 0,
            running: true,
            matrix: new Float32Array([c, 0, 0, c, 0, 0]),
            opacity: 1
        };
        b.prop = Sys.apply(b.prop, a);
        b.endEvent = a.endEvent || undefined;
        b.lists = [];
        b.listsToAdd = [];
        b.nonActiveLists = [];
        b.active = a.active || false
    },
    updateScaleValue: function() {
        var a = Environment.determineResolution().virtualToWindowScale;
        this.prop.matrix[0] = a;
        this.prop.matrix[3] = a
    },
    run: function(f) {
        var d = this,
            g = d.prop,
            b, a = [],
            e, c;
        if (f.time >= g.delay) {
            d.checkNonActiveLists();
            if (d.listsToAdd.length > 0) {
                d.addLists(d.listsToAdd);
                d.listsToAdd.length = 0
            }
            b = d.lists.length;
            for (c = -1; ++c < b;) {
                e = d.lists[c];
                if (e.prop.running) {
                    a.push.apply(a, e.run(f, {
                        matrix: g.matrix,
                        opacity: g.opacity
                    }))
                } else {
                    d.nonActiveLists.push(e);
                    d.lists.splice(c, 1);
                    b--;
                    c--
                }
            }
        }
        return a
    },
    add: function(a) {
        a.prop.running = true;
        Animation.utils.insertInOrder(a, this.lists)
    },
    addLists: function(a) {
        var b = a.length,
            c;
        for (c = -1; ++c < b;) {
            this.add(a[c])
        }
    },
    play: function() {
        this.prop.running = true
    },
    stop: function() {
        this.prop.running = false
    },
    isActive: function() {
        return this.active
    },
    checkNonActiveLists: function() {
        var a = this.nonActiveLists,
            b = a.length,
            c;
        for (c = -1; ++c < b;) {
            if (a[c].prop.running) {
                this.listsToAdd.push(a[c]);
                a.splice(c, 1);
                b--;
                c--
            }
        }
    }
};
Animation.CanvasAnimationScene = Sys.extend(Sys.Observable, Animation.CanvasAnimationScene, "Animation.CanvasAnimationScene");
Sys.ns("Animation");
Animation.VideoItem = {
    constructor: function(a) {
        var b = this;
        Animation.VideoItem.superclass.constructor.call(b, a);
        b.setupVideo(a);
        b.setupEvents(a.callbacks)
    },
    setupVideo: function(b) {
        var d = this,
            a = document.createElement("video"),
            c = Resources.readData("videos");
        a.src = c[b.src];
        a.preload = "auto";
        a.loop = Sys.isDefined(b.loop) ? b.loop : true;
        a.autoplay = Sys.isDefined(b.autoplay) ? b.autoplay : true;
        a.type = Sys.isDefined(b.type) ? b.type : undefined;
        if (b.callbacks && b.callbacks.onEndedCallback) {
            a.onended = function() {
                b.callbacks.onEndedCallback()
            }
        }
        a.style.display = "none";
        document.body.appendChild(a);
        d.prop.image = a;
        d.videoEl = a
    },
    setupEvents: function(c) {
        var b = this,
            a;
        if (Sys.isDefined(c)) {
            a = Sys.isDefined(c.canPlayThrough) ? c.canPlayThrough : undefined
        }
        b.videoEl.addEventListener("canplaythrough", b.onCanPlayThrough(a))
    },
    onCanPlayThrough: function(b) {
        var a = this;
        if (Sys.isDefined(b)) {
            b()
        }
        a.videoEl.removeEventListener("canplaythrough", a.onCanPlayThrough)
    },
    toggleSound: function(a) {
        this.videoEl.muted = Sys.isDefined(a) ? a : !this.videoEl.muted
    },
    play: function() {
        var a = this;
        if (!a.isRunning()) {
            a.restore();
            a.videoEl.load()
        }
        a.prop.paused = false;
        return a.videoEl.play()
    },
    restore: function() {
        if (this.videoEl.currentTime > 0) {
            this.videoEl.currentTime = 0
        }
        Animation.VideoItem.superclass.restore.apply(this, arguments)
    },
    pause: function() {
        Animation.VideoItem.superclass.pause.apply(this, arguments);
        this.videoEl.pause()
    },
    stop: function() {
        var a = this;
        Animation.VideoItem.superclass.stop.apply(a, arguments);
        a.videoEl.pause();
        if (a.videoEl.currentTime > 0) {
            a.videoEl.currentTime = 0
        }
    }
};
Animation.VideoItem = Sys.extend(Animation.CanvasAnimationItem, Animation.VideoItem, "Animation.VideoItem");
Sys.ns("Animation");
Animation.ReelList = {
    constructor: function(a) {
        var b = this;
        Animation.ReelList.superclass.constructor.call(b, {});
        a = b.applyDefaultsToConfig(a);
        b.id = a.id;
        b.symbolWidths = a.symbolWidths;
        b.symbolHeights = a.symbolHeights;
        b.blurredSymbolWidths = a.blurredSymbolWidths;
        b.blurredSymbolHeights = a.blurredSymbolHeights;
        b.maxBlurredSymbolHeight = 0;
        Sys.iterate(a.blurredSymbolHeights, function(d, c) {
            b.maxBlurredSymbolHeight = Math.max(b.maxBlurredSymbolHeight, c)
        });
        b.maxBlurredSymbolWidth = 0;
        Sys.iterate(a.blurredSymbolWidths, function(d, c) {
            b.maxBlurredSymbolWidth = Math.max(b.maxBlurredSymbolWidth, c)
        });
        b.baseDepth = a.baseDepth;
        b.depthDistribution = a.depthDistribution;
        b.symbolSpecificDepthModifiers = a.symbolSpecificDepthModifiers;
        b.x = a.x;
        b.y = a.y;
        if (a.orientation === "vertical") {
            b.x -= (b.maxBlurredSymbolWidth - b.symbolWidths.standard) / 2
        } else {
            b.y -= (b.maxBlurredSymbolHeight - b.symbolHeights.standard) / 2
        }
        b.orientation = a.orientation;
        b.reelAreaLength = a.visibleLength;
        b.spinDirection = a.spinDirection;
        b.maxTimeStep = Math.round(a.timeToMoveOneSlot * 0.75);
        b.hasSignaledReelStop = true;
        b.model = b.createModel(a);
        b.animationItems = b.createAnimationItems();
        b.depthDistributionArray = b.calculateDepthDistributionArray();
        b.symbolsWithSpecialEffects = {}
    },
    applyDefaultsToConfig: function(a) {
        var b = {
            id: "UnidentifiedReelList",
            symbolWidths: 150,
            symbolHeights: 150,
            blurredSymbolWidths: undefined,
            blurredSymbolHeights: undefined,
            symbolCenterToCenter: 150,
            baseDepth: 0,
            depthDistribution: {
                type: "increasing",
                step: 1
            },
            symbolSpecificDepthModifiers: {},
            numberOfOutcomeSymbols: 3,
            x: 0,
            y: 0,
            orientation: "vertical",
            visibleLength: undefined,
            outcomeOffset: 0,
            spinDirection: "positive",
            reelStrip: ["SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4", "SYM4"],
            timeToMoveOneSlot: 1000,
            startBounceSupportPointOffset: undefined,
            endBounceSupportPointOffsets: [],
            endBounceDurations: [],
            startSpinCompleteCallback: function() {},
            bounceStartCallback: function() {},
            reelStoppedCallback: function() {}
        };
        Sys.applyProperties(b, a);
        if (Sys.isNumber(b.symbolWidths)) {
            b.symbolWidths = {
                standard: b.symbolWidths
            }
        }
        if (Sys.isNumber(b.symbolHeights)) {
            b.symbolHeights = {
                standard: b.symbolHeights
            }
        }
        if (!Sys.isDefined(b.blurredSymbolWidths)) {
            b.blurredSymbolWidths = b.symbolWidths
        } else {
            if (Sys.isNumber(b.blurredSymbolWidths)) {
                b.blurredSymbolWidths = {
                    standard: b.blurredSymbolWidths
                }
            }
        }
        if (!Sys.isDefined(b.blurredSymbolHeights)) {
            b.blurredSymbolHeights = b.symbolHeights
        } else {
            if (Sys.isNumber(b.blurredSymbolHeights)) {
                b.blurredSymbolHeights = {
                    standard: b.blurredSymbolHeights
                }
            }
        }
        if (!Sys.isDefined(b.visibleLength)) {
            b.visibleLength = b.numberOfOutcomeSymbols * b.symbolCenterToCenter
        }
        if (!Sys.isDefined(b.startBounceSupportPointOffset)) {
            b.startBounceSupportPointOffset = -2 * b.symbolCenterToCenter
        }
        return b
    },
    createModel: function(c) {
        var f = this,
            e = c.orientation === "vertical",
            d = e ? f.maxBlurredSymbolHeight : f.maxBlurredSymbolWidth,
            a = e ? f.symbolHeights.standard : f.symbolWidths.standard,
            g = c.symbolCenterToCenter - d,
            b = c.outcomeOffset - (d - a) / 2;
        return new Animation.ReelModel({
            reelStrip: c.reelStrip,
            reelID: c.id,
            symbolLength: d,
            symbolSpacing: g,
            numberOfOutcomeSymbols: c.numberOfOutcomeSymbols,
            visibleWindowLength: c.visibleLength,
            outcomeOffset: b,
            startBounceSupportPointOffset: c.startBounceSupportPointOffset,
            endBounceSupportPointOffsets: c.endBounceSupportPointOffsets,
            endBounceDurations: c.endBounceDurations,
            timeToMoveOneSlot: c.timeToMoveOneSlot,
            startSpinCompleteCallback: c.startSpinCompleteCallback,
            bounceStartCallback: c.bounceStartCallback,
            reelStoppedCallback: c.reelStoppedCallback
        })
    },
    createAnimationItems: function() {
        var d = this,
            b = [],
            a = d.model.visibleSymbolsCount,
            c;
        for (c = 0; c < a; c++) {
            b.push(new Animation.Item({}))
        }
        return b
    },
    calculateDepthDistributionArray: function() {
        var f = this,
            g = f.model.visibleSymbolsCount,
            e = f.depthDistribution.type,
            d = f.depthDistribution.step,
            c, h, a = Math.floor(g / 2),
            b = [];
        for (c = 0; c < g; c++) {
            if (e === "increasing") {
                h = c
            } else {
                if (e === "decreasing") {
                    h = g - c
                } else {
                    if (e === "curve-out") {
                        h = Math.abs(a - Math.abs(a - c))
                    } else {
                        if (e === "curve-in") {
                            h = Math.abs(a - c)
                        }
                    }
                }
            }
            b.push(h * d)
        }
        return b
    },
    getSymbolLayout: function() {
        var e = this,
            d = [],
            c, b, f = 0,
            a = e.model.numberOfOutcomeSymbols;
        if (e.indexOfFirstOutcomeItem) {
            f = e.indexOfFirstOutcomeItem
        }
        if (e.model.isUsingStackedSymbols()) {
            a += e.model.getNumberOfRowsAbove() + e.model.getNumberOfRowsBelow();
            if (a > e.animationItems.length) {
                a = e.animationItems
            }
        }
        for (b = 0; b < a; ++b) {
            c = e.animationItems[f + b];
            d.push({
                top: c.prop.top,
                left: c.prop.left,
                width: c.prop.width,
                height: c.prop.height,
                depth: c.prop.depth
            })
        }
        return d
    },
    startSpin: function() {
        this.model.start()
    },
    stopSpin: function(a) {
        this.model.storeSpinOutcome(a.symbols);
        this.model.stop()
    },
    isStopping: function() {
        return this.model.isStopping()
    },
    setAllReelSymbols: function(a) {
        this.model.setInitialOutcome(a.symbols)
    },
    setReelSymbol: function(b, a) {
        this.model.updateOutcome(a, b)
    },
    run: function(e, c) {
        var b = this,
            d = Math.min(e.timeStep, b.maxTimeStep),
            a, f;
        b.model.move(d);
        a = b.model.getSymbolsToRender();
        f = b.getReelItemsForRendering(a, e, c);
        b.addDepthModifiers(f);
        return f
    },
    getReelItemsForRendering: function(v, j, o) {
        var B = this,
            y = B.shouldUseMotionBlur(),
            n = B.maxBlurredSymbolWidth,
            a = B.maxBlurredSymbolHeight,
            l = B.orientation === "vertical" ? a : n,
            t, u, x, h = [],
            q, s, c, b, p, A = y ? B.blurredSymbolWidths : B.symbolWidths,
            g = y ? B.blurredSymbolHeights : B.symbolHeights,
            k, z, m, w, r, d = Environment.determineResolution().virtualToWindowScale,
            f = v.length,
            e;
        B.indexOfFirstOutcomeItem = B.animationItems.length - 1;
        for (u = -1; ++u < f;) {
            if (v[u].isOutcomeSymbol && u < B.indexOfFirstOutcomeItem) {
                B.indexOfFirstOutcomeItem = u
            }
            x = B.animationItems[u];
            q = v[u].symbol;
            b = Sys.isDefined(A[q]) ? q : "standard";
            p = Sys.isDefined(g[q]) ? q : "standard";
            s = v[u].position;
            c = l;
            k = A[b];
            z = g[p];
            m = B.orientation === "vertical" ? z : k;
            w = (l - m) / 2;
            r = 0;
            if (y) {
                q += "-BLURRED"
            } else {
                if (B.shouldUseSpecialEffect(q)) {
                    q += "-SPECIAL_EFFECT"
                }
            }
            if (s < 0) {
                r = -s;
                s = 0;
                c -= r
            }
            if (w > 0) {
                if (r > w) {
                    r -= w;
                    c -= w
                } else {
                    if (r + c < w) {
                        r = 0;
                        c = 0
                    } else {
                        c += (w - r);
                        s += (w - r);
                        r = 0
                    }
                }
                if (r + c > m) {
                    c = m - r
                }
            }
            t = (s + c) - B.reelAreaLength;
            if (t > 0) {
                c -= t
            }
            if (x.isRunning() && c > 0) {
                s = Math.floor(s);
                c = Math.ceil(c);
                r = Math.floor(r);
                if (B.spinDirection === "negative") {
                    s = B.reelAreaLength - s;
                    s -= c;
                    r = r === 0 ? m - c : 0
                }
                m = Math.floor(m * d);
                r = Math.floor(r * d);
                e = r > 0 ? m - r : Math.floor(c * d);
                if (B.orientation === "vertical") {
                    x.prop = Sys.applyProperties(x.prop, {
                        image: q,
                        SX: 0,
                        SY: r,
                        SWidth: Math.floor(k * d),
                        SHeight: e,
                        left: Math.floor(B.x + (n - k) / 2),
                        top: B.y + s,
                        width: k,
                        height: c,
                        depth: B.baseDepth,
                        pivot: {
                            x: -(k / 2),
                            y: -(c / 2)
                        }
                    })
                } else {
                    x.prop = Sys.applyProperties(x.prop, {
                        image: q,
                        SX: r,
                        SY: 0,
                        SWidth: e,
                        SHeight: Math.floor(z * d),
                        left: B.x + s,
                        top: Math.floor(B.y + (a - z) / 2),
                        width: c,
                        height: z,
                        depth: B.baseDepth,
                        pivot: {
                            x: -(c / 2),
                            y: -(z / 2)
                        }
                    })
                }
                if (x.prop.SWidth > 0 && x.prop.SHeight > 0) {
                    x.run(j, o);
                    h.push(x)
                } else {
                    x.prop.image = undefined
                }
            } else {
                x.prop.image = undefined
            }
        }
        return h
    },
    shouldUseMotionBlur: function() {
        return this.model.isSpinning()
    },
    addDepthModifiers: function(f) {
        var e = this,
            c = e.getReelPositionDepthOffsets(f.length),
            b = e.symbolSpecificDepthModifiers,
            d, a;
        Sys.each(f, function(h, g) {
            a = c[g];
            d = h.prop.image;
            if (Sys.isDefined(b[d])) {
                a += b[d]
            }
            h.prop.depth += a
        })
    },
    getReelPositionDepthOffsets: function(a) {
        var c = this,
            b = c.depthDistributionArray;
        if (c.depthDistribution === "increasing" || c.depthDistribution === "decreasing") {
            return b
        }
        return b.slice(Math.floor((b.length - a) / 2))
    },
    hideSymbols: function(a) {
        this.setPlayingStateForSymbols(a, false)
    },
    showSymbols: function(a) {
        this.setPlayingStateForSymbols(a, true)
    },
    setPlayingStateForSymbols: function(b, d) {
        var a, c;
        if (Sys.isArray(b)) {
            a = b.length;
            for (c = -1; ++c < a;) {
                this.setPlayingStateForSymbol(b[c], d)
            }
        } else {
            this.setPlayingStateForSymbol(b, d)
        }
    },
    setPlayingStateForSymbol: function(b, c) {
        var a = this.animationItems;
        b += this.indexOfFirstOutcomeItem;
        if (Sys.isNumber(b) && Sys.isDefined(a[b])) {
            if (c) {
                a[b].play()
            } else {
                a[b].stop()
            }
        }
    },
    shouldUseSpecialEffect: function(a) {
        return this.symbolsWithSpecialEffects[a] === true
    }
};
Animation.ReelList = Sys.extend(Animation.CanvasAnimationList, Animation.ReelList, "Animation.ReelList");
Sys.ns("Animation");
Animation.ReelModel = function(a) {
    var b = this;
    Sys.applyProperties(b, a);
    b.slotLength = b.symbolLength + b.symbolSpacing;
    b.outcomeWindowLength = b.numberOfOutcomeSymbols * b.slotLength;
    b.reelStripLength = b.slotLength * b.reelStrip.length;
    b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
    b.leadingSymbolsCount = b.getNumberOfNeededLeadingSymbols();
    b.visibleSymbolsCount += b.leadingSymbolsCount;
    b.outcomeSymbols = [];
    b.setWindowPosition(-b.outcomeOffset);
    b.firstOutcomeSymbolReelStripIndex = 0;
    b.currentTime = 0;
    b.targetOffset = 0;
    b.startTime = 0;
    b.startDuration = b.timeToMoveOneSlot * ((b.visibleWindowLength + Math.abs(b.startBounceSupportPointOffset) * 2) / b.slotLength);
    b.stopTime = 0;
    b.stopDuration = 0;
    b.currentBounce = b.endBounceSupportPointOffsets.length;
    b.accumulatedBounceTime = 0;
    b.hasCompletedSpin = true;
    b.hasCompletedBounce = true;
    b.state = "stopping"
};
Animation.ReelModel.prototype = {
    setWindowPosition: function(a) {
        var b = this.reelStripLength;
        while (a < 0) {
            a += b
        }
        if (a > b) {
            a %= b
        }
        this.windowPosition = a
    },
    setInitialOutcome: function(a) {
        var b = this;
        b.outcomeSymbols = a;
        if (b.isUsingStackedSymbols()) {
            b.replaceStackedSymbolsInOutcome(true)
        }
    },
    updateOutcome: function(a, d) {
        var c = this,
            b = (c.isUsingStackedSymbols()) ? a + c.getNumberOfRowsAbove() : a;
        if (this.outcomeSymbols && b >= 0 && b < this.outcomeSymbols.length) {
            this.outcomeSymbols[b] = d
        }
    },
    symbolShouldBeStacked: function(e) {
        var c = this,
            a = false,
            f, d, b;
        if (c.isUsingStackedSymbols()) {
            if (c.reelID.indexOf("_") > -1) {
                f = c.reelID.split("_")[0];
                d = Sys.utils.toInt(c.reelID.split("_")[1]);
                b = Resources.readData("reelsWithStackedSymbols")[f].filter(function(g) {
                    return g.reelIndex === d
                });
                if (b.length === 1) {
                    if (b[0].symbols.indexOf(e) !== -1) {
                        a = true
                    }
                }
            }
        }
        return a
    },
    replaceStackedSymbolsInOutcome: function(o) {
        var q = this,
            e = Resources.readData("config"),
            d = (Sys.isDefined(q.nextOutcomeSymbols)) ? q.nextOutcomeSymbols : [],
            l, i, r, c, n, b, g, h, m, p, f = function(j, k) {
                c = 0;
                for (l = k; l < d.length; l++) {
                    if (d[l] === j) {
                        c++
                    }
                }
                return c
            },
            a = function(k, s, j) {
                b = k;
                g = 0;
                if ((k === 0) && (j < s.size)) {
                    b = (k - (s.size - j))
                }
                h = k + s.size;
                b += q.getNumberOfRowsAbove();
                h += q.getNumberOfRowsAbove();
                for (i = b; i < h; i++) {
                    if (g >= s.size) {
                        break
                    }
                    m = s.symbol + "." + s.size + "." + g;
                    if (i >= 0) {
                        if (o) {
                            q.outcomeSymbols[i] = m
                        } else {
                            q.nextOutcomeSymbols[i] = m
                        }
                    }
                    b++;
                    g++
                }
            };
        if (o) {
            d = q.outcomeSymbols
        }
        r = 0;
        Sys.each(d, function(j) {
            Sys.each(e.reel.stackedSymbols, function(k) {
                p = r;
                if (k.symbol === j) {
                    n = f(k.symbol, p);
                    if (q.symbolShouldBeStacked(k.symbol)) {
                        a(p - q.getNumberOfRowsAbove(), k, n)
                    }
                    r = r + n
                }
            }, this);
            r++
        }, this)
    },
    storeSpinOutcome: function(a) {
        var d = this,
            b, c;
        if (!d.isUsingStackedSymbols()) {
            d.nextOutcomeSymbols = a
        } else {
            d.nextOutcomeSymbols = [];
            for (b = 0; b < d.numberOfOutcomeSymbols; b++) {
                if (b < a.length) {
                    c = b + d.getNumberOfRowsAbove();
                    d.nextOutcomeSymbols[c] = a[b]
                }
            }
            d.replaceStackedSymbolsInOutcome()
        }
    },
    setOutcomeSymbol: function(m, d, b, r) {
        var o = this,
            q, n, h, k, e, p, j = 0,
            c, l, g, a = Resources.readData("config"),
            f;
        o.nextOutcomeSymbols[m] = d;
        if (m === 0) {
            q = o.firstOutcomeSymbolReelStripIndex - 1;
            if (q < 0) {
                q = o.reelStrip.length - 1
            }
            h = o.reelStrip[q];
            if (h.indexOf(".") > -1) {
                c = Sys.utils.toInt(h.charAt(h.length - 1));
                g = c + 1;
                e = h.split(".")[0];
                Sys.each(a.reel.stackedSymbols, function(i) {
                    if (i.symbol === e) {
                        j = i.size
                    }
                });
                for (f = 0; f < j - (c + 1); f++) {
                    p = h.substr(0, h.length - 1) + (g);
                    if (!r) {
                        o.nextOutcomeSymbols[f] = p
                    }
                    g++
                }
            }
        }
        if (m === b) {
            n = o.firstOutcomeSymbolReelStripIndex + b + 1;
            if (n > (o.reelStrip.length - 1)) {
                n = n - o.reelStrip.length
            }
            k = o.reelStrip[n];
            if (!r) {
                k = o.nextOutcomeSymbols[b + 1]
            }
            if (k.indexOf(".") > -1) {
                c = Sys.utils.toInt(k.charAt(k.length - 1));
                g = 1;
                for (f = c; f > 0; f--) {
                    p = k.substr(0, k.length - 1) + (f - 1);
                    l = o.nextOutcomeSymbols.length - g;
                    if (r) {
                        o.nextOutcomeSymbols[l] = p
                    }
                    g++
                }
            }
        }
    },
    start: function() {
        var a = this;
        a.startTime = a.currentTime;
        a.targetOffset = a.visibleWindowLength + a.slotLength * a.leadingSymbolsCount;
        a.state = "starting";
        a.hasCompletedSpin = false;
        a.hasCompletedBounce = false
    },
    stop: function() {
        var a = this,
            c = a.getIndexForFirstVisibleSymbol(),
            d = a.getNumberOfRowsAbove() + a.getNumberOfRowsBelow(),
            b = c - a.numberOfOutcomeSymbols + d;
        a.targetPosition = b * a.slotLength - a.outcomeOffset;
        a.targetOffset = a.windowPosition - a.targetPosition;
        a.stopDuration = Math.round(a.timeToMoveOneSlot * (a.targetOffset / a.slotLength));
        a.outcomeSymbols = a.nextOutcomeSymbols;
        a.stopTime = a.currentTime;
        a.currentBounce = 0;
        a.accumulatedBounceTime = 0;
        a.state = "stopping";
        a.stopKey = Date.now();
        a.firstOutcomeSymbolReelStripIndex = (b - a.getNumberOfRowsAbove()) < 0 ? b + a.reelStrip.length - a.getNumberOfRowsAbove() : b - a.getNumberOfRowsAbove()
    },
    getNumberOfNeededLeadingSymbols: function() {
        var d = this,
            b = Resources.readData("config"),
            e, a = 0,
            c;
        if (d.isUsingStackedSymbols()) {
            Sys.each(b.reel.stackedSymbols, function(f) {
                c = f.size;
                a = Math.max(a, c)
            });
            return a + 2
        }
        if (d.symbolSpacing < 0) {
            e = Math.ceil(d.symbolLength / d.slotLength)
        } else {
            e = 0
        }
        return e
    },
    isUsingStackedSymbols: function() {
        var b = Resources.readData("config"),
            c = Sys.isDefined(b.reel.stackedSymbols),
            a = false;
        if (c && b.reel.stackedSymbols.length > 0) {
            a = true
        }
        return a
    },
    getNumberOfRowsAbove: function() {
        return (this.isUsingStackedSymbols()) ? this.getNumberOfNeededLeadingSymbols() : 0
    },
    getNumberOfRowsBelow: function() {
        var e = this,
            b = Resources.readData("config"),
            d = 0,
            a = 0,
            f, c;
        if (e.isUsingStackedSymbols()) {
            f = (Sys.isDefined(b.reel.fixedSpacingRows)) ? b.reel.fixedSpacingRows : -1;
            if (f > -1) {
                return f
            }
            Sys.each(b.reel.stackedSymbols, function(g) {
                c = g.size;
                a = Math.max(a, c)
            });
            d = ((a - 1) * 2) + 1
        }
        return d
    },
    getIndexForFirstVisibleSymbol: function() {
        return Math.floor(this.windowPosition / this.slotLength) - this.leadingSymbolsCount
    },
    move: function(b) {
        var a = this;
        a.setWindowPosition(a.windowPosition - a.getDistance(b));
        a.currentTime += b;
        if (a.state === "starting" && a.currentTime >= a.startTime + a.startDuration) {
            a.state = "spinning";
            a.startSpinCompleteCallback()
        } else {
            if (a.state === "stopping" && a.currentTime >= a.stopTime + a.stopDuration) {
                if (!a.hasCompletedSpin) {
                    a.hasCompletedSpin = true;
                    a.bounceStartCallback()
                }
            }
        }
    },
    getDistance: function(b) {
        var a = this;
        if (a.state === "starting") {
            return a.getStartingDistance(b)
        } else {
            if (a.state === "stopping") {
                return a.getStoppingDistance(b)
            }
        }
        return a.getSpinningDistance(b)
    },
    getStartingDistance: function(f) {
        var e = this,
            d = Math.min(1, (e.currentTime - e.startTime) / e.startDuration),
            b = Animation.utils.getInterpolationValue(0, e.targetOffset, d, {
                type: "bezier",
                support: e.startBounceSupportPointOffset
            }),
            a = Math.min(1, (e.currentTime - e.startTime + f) / e.startDuration),
            c = Animation.utils.getInterpolationValue(0, e.targetOffset, a, {
                type: "bezier",
                support: e.startBounceSupportPointOffset
            });
        return c - b
    },
    getStoppingDistance: function(g) {
        var f = this,
            h, a, e, c, b, d;
        if (f.currentTime < f.stopTime + f.stopDuration) {
            h = f.targetOffset;
            a = f.targetOffset / 2;
            e = Math.min(1, (f.currentTime - f.stopTime) / f.stopDuration);
            b = Math.min(1, (f.currentTime - f.stopTime + g) / f.stopDuration)
        } else {
            if (f.currentBounce < f.endBounceSupportPointOffsets.length) {
                h = 0;
                a = f.endBounceSupportPointOffsets[f.currentBounce];
                e = Math.min(1, (f.currentTime - f.stopTime - f.stopDuration - f.accumulatedBounceTime) / f.endBounceDurations[f.currentBounce]);
                b = Math.min(1, (f.currentTime - f.stopTime - f.stopDuration - f.accumulatedBounceTime + g) / f.endBounceDurations[f.currentBounce]);
                if (b === 1) {
                    f.accumulatedBounceTime += f.endBounceDurations[f.currentBounce];
                    f.currentBounce++;
                    return f.windowPosition - f.targetPosition
                }
            } else {
                if (!f.hasCompletedBounce) {
                    f.hasCompletedBounce = true;
                    f.hasCompletedSpin = true;
                    f.reelStoppedCallback();
                    return f.windowPosition - f.targetPosition
                }
                return 0
            }
        }
        c = Animation.utils.getInterpolationValue(0, h, e, {
            type: "bezier",
            support: a
        });
        d = b === 1 ? h : Animation.utils.getInterpolationValue(0, h, b, {
            type: "bezier",
            support: a
        });
        return d - c
    },
    getSpinningDistance: function(b) {
        var a = b / this.timeToMoveOneSlot;
        return Math.round(a * this.slotLength)
    },
    getSymbolsToRender: function() {
        var b = this,
            a = b.getVisibleSymbols();
        if (b.state === "starting" || b.state === "stopping") {
            a = b.insertOutcome(a)
        }
        return a
    },
    getVisibleSymbols: function() {
        var e = this,
            g = e.reelStrip,
            f = e.getIndexForFirstVisibleSymbol(),
            a = f + e.visibleSymbolsCount - 1,
            c = [],
            d, b;
        for (d = f; d <= a; d++) {
            b = d > g.length - 1 ? d - g.length : d;
            b = b < 0 ? b + g.length : b;
            c.push({
                symbol: g[b],
                position: d * e.slotLength - e.windowPosition
            })
        }
        return c
    },
    insertOutcome: function(c) {
        var f = this,
            h = f.getIndexForFirstVisibleSymbol(),
            e = f.firstOutcomeSymbolReelStripIndex,
            d, j = [],
            k, g, a = Resources.readData("config"),
            b = a.reel.symbolRows;
        for (d = 0; d < f.numberOfOutcomeSymbols; d++) {
            j.push((e + d) % f.reelStrip.length)
        }
        for (d = 0; d < f.visibleSymbolsCount; d++) {
            k = (h + d) % f.reelStrip.length;
            g = j.indexOf(k);
            if (g >= 0) {
                if (f.isUsingStackedSymbols() && Sys.isDefined(f.nextOutcomeSymbols)) {
                    c[d].symbol = f.nextOutcomeSymbols[g]
                } else {
                    c[d].symbol = f.outcomeSymbols[g]
                }
                if (((g >= f.getNumberOfRowsAbove()) && (g < (f.getNumberOfRowsAbove() + b))) || (!f.isUsingStackedSymbols())) {
                    c[d].isOutcomeSymbol = true
                }
            }
        }
        return c
    },
    isStopping: function() {
        return this.state === "stopping"
    },
    isSpinning: function() {
        return this.state === "spinning"
    }
};
Sys.ns("Animation");
Animation.PhysicsItem = {
    constructor: function(a) {
        Animation.PhysicsItem.superclass.constructor.call(this, a);
        this.prop = this.prop || {};
        this.prop.timeSinceStart = 0
    },
    restore: function() {
        var a = this;
        Animation.PhysicsItem.superclass.restore.call(a);
        a.prop.timeSinceStart = 0;
        a.prop.left = a.prop.startLeft;
        a.prop.top = a.prop.startTop
    },
    run: function(i, h) {
        var g = this,
            e, b, c, f, j;
        g.prop.localTime += i.timeStep;
        g.prop.reset = false;
        if (g.prop.localTime >= g.prop.delay) {
            g.prop.timeStep = i.timeStep;
            g.prop.timeSinceStart += i.timeStep;
            e = g.prop.timeSinceStart / 1000 * 10;
            b = g.prop.gravity;
            c = g.prop.vy + (b * e);
            f = g.prop.vx;
            j = g.prop.direction;
            g.prop.top = g.prop.startTop - ((c * e) - (0.5 * b * Math.pow(e, 2))) * Sys.Math.sin(j);
            g.prop.left = g.prop.startLeft - ((f * e) - (0.5 * b * Math.pow(e, 2))) * Sys.Math.cos(j);
            g.prop.parentMatrix.set(h.matrix);
            g.performAction(i.timeStep);
            Animation.utils.updateMatrix(g.prop);
            g.prop.opacity = g.prop.ownOpacity * h.opacity;
            return !g.prop.skip
        }
        return true
    },
    exceedingBounds: function(a) {
        if (!Sys.isDefined(a.bounds)) {
            return false
        }
        return a.left < a.bounds.x1 || a.left > a.bounds.x2 || a.top < a.bounds.y1 || a.top > a.bounds.y2
    },
    performAction: function(a) {
        var f = 0,
            d = Object.keys(this.prop.operations),
            e = d.length,
            b = true,
            c = 0;
        while (c < e) {
            f += Animation.Operations[d[c]].performAction(this, a);
            ++c
        }
        if (this.exceedingBounds(this.prop) || this.prop.top > 600 || f === 0) {
            b = false
        }
        if (!b) {
            this.finished()
        }
        return b
    },
    finished: function() {
        var a = this;
        Animation.PhysicsItem.superclass.finished.call(a);
        if (typeof a.prop.stopped === "function") {
            a.prop.stopped()
        }
    }
};
Animation.PhysicsItem = Sys.extend(Animation.CanvasAnimationItem, Animation.PhysicsItem, "Animation.PhysicsItem");
Sys.ns("Integration");
Integration.PluginMenu = {
    constructor: function() {
        Integration.PluginMenu.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            controller: Integration.PluginMenuController,
            view: Integration.PluginMenuBaseView,
            model: Integration.PluginMenuModel
        }
    }
};
Integration.PluginMenu = Sys.extend(Core.Module, Integration.PluginMenu, "Integration.PluginMenu");
Sys.ns("Integration");
Integration.PluginMenuController = {
    constructor: function() {
        Integration.PluginMenuController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var b = this,
            a = {
                "notify:stateHandler.enteringBeforeLoaderCloseState": b.onBeforeLoaderClose,
                "notify:settingsMenu.open": b.view.hideButton.bind(b.view),
                "notify:settingsMenu.closed": b.onSettingsMenuClosed,
                "notify:scaling.gameSizeChanged": b.onGameSizeChanged,
                "request:pluginMenu.init": b.initParams,
                "request:pluginMenu.activate": b.activate,
                "request:pluginMenu.deactivate": b.deactivate,
                "request:pluginMenu.notification": b.onNotification,
                "request:pluginMenu.changeMenuHeight": b.onChangeMenuHeight,
                "request:pluginMenu.enable": b.view.enableButton.bind(b.view, "PLUGIN_MENU"),
                "request:pluginMenu.disable": b.view.disableButton.bind(b.view, "PLUGIN_MENU"),
                "notify:stateHandler.enteringIdleState": b.view.enableButton.bind(b.view, "IDLE_STATE"),
                "notify:stateHandler.leavingIdleState": b.view.disableButton.bind(b.view, "IDLE_STATE"),
                "notify.fullscreen.enteringFullscreen": b.onEnteringFullscreen,
                "notify.fullscreen.leavingFullscreen": b.onLeavingFullscreen,
                "view:buttonClicked": b.onButtonClicked
            };
        a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveStart"] = b.onUserInputStart;
        a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveEnd"] = b.onUserInputEnd;
        b.on(a)
    },
    initParams: function(c, a, b) {
        var d = this;
        if (c !== "" && c !== "default") {
            d.view.buttonImageExternalUrl = c
        }
        d.setMenuHeight(a);
        if (b) {
            d.model.storeData("transparent", true)
        }
        d.model.storeData("pluginMenuInitialized", true);
        d.model.storeData("pluginMenuButtonRequestedByPlugin", true)
    },
    setMenuHeight: function(c) {
        var b = this,
            a = b.view.getMaxHeight();
        if (!Sys.isDefined(c)) {
            return false
        }
        if (Sys.isObj(c)) {
            b.model.storeData("manualSetHeight", c);
            a = (b.model.readData("currentOrientation") === "PORTRAIT") ? c.portrait : c.landscape
        } else {
            if (Sys.isNumber(c) && c > 0) {
                b.model.storeData("manualSetHeight", c);
                a = c
            }
        }
        b.view.height = a;
        return true
    },
    onBeforeLoaderClose: function() {
        this.view.setupContent();
        this.view.disableButton("IDLE_STATE")
    },
    onChangeMenuHeight: function(b) {
        var a = this;
        if (a.setMenuHeight(b)) {
            a.view.refresh()
        }
    },
    onButtonClicked: function() {
        var a = this;
        if (a.model.readData("pluginMenuActivated") === false) {
            a.activate()
        } else {
            a.deactivate()
        }
    },
    activate: function() {
        var a = this;
        a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
        a.fireEvent("request:quickSettingsMenu.externalDeactivate", a.MODULE_NAME);
        a.fireEvent("request:spinButton.hide", a.MODULE_NAME);
        a.view.activatePluginMenu();
        a.model.storeData("pluginMenuActivated", true);
        Resources.storeData("pluginMenuOpen", true);
        a.fireEvent("notify:pluginMenu.activated")
    },
    deactivate: function() {
        var a = this;
        a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
        a.fireEvent("request:quickSettingsMenu.externalActivate", a.MODULE_NAME);
        a.fireEvent("request:spinButton.show", a.MODULE_NAME);
        a.view.deactivatePluginMenu();
        a.model.storeData("pluginMenuActivated", false);
        Resources.storeData("pluginMenuOpen", false);
        a.fireEvent("notify:pluginMenu.deactivated")
    },
    onEnteringFullscreen: function() {
        this.model.storeData("disableUserInteraction", false)
    },
    onLeavingFullscreen: function() {
        this.model.storeData("disableUserInteraction", true)
    },
    onUserInputStart: function(c) {
        var a = this,
            b;
        if (!a.model.readData("disableUserInteraction")) {
            b = !Sys.UserInputUtils.isCoordinateTarget(a.view.pluginIframe, c);
            a.model.storeData("clickedOutsideIframe", b)
        }
    },
    onUserInputEnd: function(c) {
        var b = this,
            a;
        if (!b.model.readData("disableUserInteraction")) {
            a = !Sys.UserInputUtils.isCoordinateTarget(b.view.pluginIframe, c);
            if (b.model.readData("clickedOutsideIframe") && a) {
                b.deactivate()
            }
        }
    },
    onNotification: function(a) {
        this.view.changeToNotificationImage(a)
    },
    onGameSizeChanged: function() {
        var a = this;
        if (typeof a.view.refresh === "function") {
            a.model.storeData("gameSizeChangedTriggered", true);
            a.view.refresh()
        }
    },
    onSettingsMenuClosed: function() {
        if (this.model.readData("pluginMenuInitialized") === true) {
            this.view.showButton()
        }
    }
};
Integration.PluginMenuController = Sys.extend(Core.Controller, Integration.PluginMenuController, "Integration.PluginMenuController");
Sys.ns("Integration");
Integration.PluginMenuBaseView = {
    HEIGHT: 0,
    PORTRAIT_TOP_OFFSET: 0,
    BUTTON_EXTERNAL_IMAGE_URL: "",
    BUTTON_DEFAULT_IMAGE_CSS: "integration-pluginMenu_button_uri",
    BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS: "integration-pluginMenu_button_notification_uri",
    BASE_BUTTON_CSS: "integration-pluginMenuButton_baseButton",
    PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase",
    LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase",
    DARK_OVERLAY_BASE_CSS: "integration-pluginMenuDarkOverlay_baseOverlay",
    DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase",
    DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase",
    SWEDEN_BUTTONS_LANDSCAPE_HEIGHT: 53,
    RENDER_TARGET: "gameWrapper",
    constructor: function() {
        var a = this;
        Integration.PluginMenuBaseView.superclass.constructor.apply(a, arguments);
        a.height = a.HEIGHT;
        a.portraitTopOffset = a.PORTRAIT_TOP_OFFSET;
        a.buttonImageExternalUrl = a.BUTTON_EXTERNAL_IMAGE_URL;
        a.enableSwedenPlugin = Resources.readData("queryData") ? Resources.readData("queryData").enableDefaultSwedenButtons : false;
        a.addScrollHandler()
    },
    setupContent: function() {
        var a = this;
        a.createDarkOverlay();
        a.createMenuButton();
        a.pluginIframe = document.getElementById("netEntExtendPlugin");
        if (a.height !== 0) {
            document.getElementById("gameWrapper").classList.add("pluginMenu");
            a.showButton()
        }
        a.model.storeData("pluginMenuInitialized", true)
    },
    addScrollHandler: function() {
        var a = this;
        document.addEventListener("scroll", function() {
            if (!a.model.readData("disableUserInteraction") && a.model.readData("pluginMenuActive") && window.scrollY > 0) {
                window.scrollTo(0, 0);
                document.body.scrollTop = 0
            }
        })
    },
    createDarkOverlay: function() {
        var a = this;
        a.darkOverlay = new Sys.Element({
            tag: "div",
            id: "pluginMenuDarkOverlay",
            cls: a.DARK_OVERLAY_BASE_CSS,
            style: "display:none",
            renderTo: a.RENDER_TARGET
        })
    },
    createMenuButton: function() {
        var a = this;
        a.menuButton = new Interface.utils.DOMButton({
            id: "pluginMenuButton",
            baseCSS: a.BASE_BUTTON_CSS + " " + a.BUTTON_DEFAULT_IMAGE_CSS,
            renderTo: a.RENDER_TARGET,
            clickCallback: a.onButtonClick.bind(a)
        });
        a.hideButton();
        a.menuButtonSysElement = a.menuButton.getContainer();
        if (a.buttonImageExternalUrl !== "") {
            a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
        }
    },
    onButtonClick: function() {
        this.fireEvent("view:buttonClicked");
        this.changeToNormalImage()
    },
    activatePluginMenu: function() {
        var a = this;
        a.adjustHeight();
        a.adjustTopOffset();
        a.darkOverlay.el.style.display = "block";
        a.pluginIframe.height = a.height;
        a.pluginIframe.style.top = a.portraitTopOffset + "px";
        a.model.storeData("pluginMenuActive", true);
        a.refresh()
    },
    deactivatePluginMenu: function() {
        this.pluginIframe.blur();
        this.darkOverlay.el.style.display = "none";
        this.pluginIframe.height = 0;
        this.pluginIframe.style.top = 0;
        this.model.removeData("pluginMenuActive")
    },
    setStyle: function(d) {
        var e = this,
            c = d + "_CSS",
            f = d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS",
            b = "DARK_OVERLAY_" + d + "_CSS",
            a = "DARK_OVERLAY_" + d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(e.menuButtonSysElement) && Sys.isDefined(e[c])) {
            e.menuButtonSysElement.removeCls(e[f]);
            e.menuButtonSysElement.addCls(e[c])
        }
        if (Sys.isDefined(e.darkOverlay) && Sys.isDefined(e[b])) {
            e.darkOverlay.removeCls(e[a]);
            e.darkOverlay.addCls(e[b])
        }
    },
    showButton: function() {
        if (Resources.readData("pluginURL") && this.model.readData("pluginMenuButtonRequestedByPlugin") && this.height !== 0) {
            this.menuButton.show(this.MODULE_NAME)
        }
    },
    hideButton: function() {
        this.menuButton.hide(this.MODULE_NAME)
    },
    enableButton: function(a) {
        this.menuButton.enable(a || this.MODULE_NAME)
    },
    disableButton: function(a) {
        this.menuButton.disable(a || this.MODULE_NAME)
    },
    adaptToOrientation: function(a) {
        var c = this,
            b = c.model;
        b.storeData("currentOrientation", a);
        c.setStyle(a);
        if (!b.readData("gameSizeChangedTriggered")) {
            c.refresh()
        }
    },
    refresh: function() {
        var a = this;
        if (!a.model.readData("pluginMenuInitialized")) {
            return
        }
        if (a.model.readData("transparent")) {
            a.setIframeTransparent()
        }
        a.adjustHeight();
        a.adjustTopOffset();
        if (Sys.isDefined(a.model.readData("pluginMenuActive"))) {
            a.pluginIframe.height = a.height;
            if (a.model.readData("currentOrientation") === "PORTRAIT") {
                a.pluginIframe.style.top = a.portraitTopOffset + "px"
            } else {
                if (this.enableSwedenPlugin && a.model.readData("currentOrientation") === "LANDSCAPE") {
                    a.pluginIframe.style.top = a.SWEDEN_BUTTONS_LANDSCAPE_HEIGHT + "px"
                } else {
                    a.pluginIframe.style.top = "0"
                }
            }
        }
    },
    setIframeTransparent: function() {
        this.pluginIframe.style.backgroundColor = "transparent"
    },
    adjustHeight: function() {
        var d = this,
            c = d.getMaxHeight(),
            b = d.model.readData("manualSetHeight"),
            a = d.model.readData("currentOrientation");
        if (Sys.isObj(b)) {
            c = Math.min((a === "PORTRAIT") ? b.portrait : b.landscape, c)
        } else {
            if (Sys.isNumber(b) && b < c && b > 0) {
                c = Math.min(b, c)
            }
        }
        d.model.storeData("maxHeight", c);
        d.height = c
    },
    adjustTopOffset: function() {
        var b = this,
            a = b.getPortraitTopOffset();
        b.model.storeData("portraitTopOffset", a);
        b.portraitTopOffset = a
    },
    changeToNotificationImage: function(a) {
        var b = this;
        if (a !== "" && a !== "default") {
            b.menuButtonSysElement.el.style["background-image"] = "url(" + a + ")"
        } else {
            b.menuButtonSysElement.removeCls(b.BUTTON_DEFAULT_IMAGE_CSS);
            b.menuButtonSysElement.addCls(b.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS)
        }
    },
    changeToNormalImage: function() {
        var a = this;
        if (a.buttonImageExternalUrl !== "") {
            a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
        } else {
            a.menuButtonSysElement.removeCls(a.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS);
            a.menuButtonSysElement.addCls(a.BUTTON_DEFAULT_IMAGE_CSS)
        }
    },
    getMaxHeight: function() {
        var a = this,
            b;
        a.adjustTopOffset();
        if (a.model.readData("currentOrientation") === "PORTRAIT") {
            b = a.portraitTopOffset
        } else {
            b = document.getElementById("gameFooter").offsetHeight
        }
        if (this.enableSwedenPlugin && a.model.readData("currentOrientation") === "LANDSCAPE") {
            b = document.getElementById("gameFooter").offsetHeight + a.SWEDEN_BUTTONS_LANDSCAPE_HEIGHT
        }
        return Sys.utils.toInt((Environment.determineResolution().resolution.height + Environment.getSpaceBelowGame()) - b)
    },
    getPortraitTopOffset: function() {
        var a = document.getElementById("settingsButtonBackground"),
            c = (a) ? a.offsetTop : 0,
            b = (a) ? a.offsetHeight : 0;
        return c + b
    }
};
Integration.PluginMenuBaseView = Sys.extend(Core.View, Integration.PluginMenuBaseView, "Integration.PluginMenuBaseView");
Sys.ns("Integration");
Integration.PluginMenuMobileView = {
    PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase_mobile",
    LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase_mobile",
    DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase_mobile",
    DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase_mobile",
    constructor: function() {
        Integration.PluginMenuMobileView.superclass.constructor.apply(this, arguments)
    }
};
Integration.PluginMenuMobileView = Sys.extend(Integration.PluginMenuBaseView, Integration.PluginMenuMobileView, "Integration.PluginMenuMobileView");
Sys.ns("Integration");
Integration.PluginMenuModel = {
    constructor: function() {
        Integration.PluginMenuModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = this;
        a.storeData("pluginMenuActivated", false);
        a.storeData("pluginMenuInitialized", false);
        a.storeData("pluginMenuButtonRequestedByPlugin", false)
    }
};
Integration.PluginMenuModel = Sys.extend(Core.Model, Integration.PluginMenuModel, "Integration.PluginMenuModel");
if (Sys.isAndroidDevice) {
    Sys.override(Interface.SettingsWindowBaseView, {
        open: function() {
            Game.stage.view.animationManager.pauseAnimation();
            this.container.el.style.display = "block";
            this.fireEvent("view:opened")
        },
        close: function() {
            Game.stage.view.animationManager.continueAnimation();
            this.container.el.style.display = "none";
            this.fireEvent("view:closed")
        }
    });
    Sys.override(Core.ResourceLoaderController, {
        fetchAudioElementSource: function(e) {
            var d = this,
                f = document.createElement("audio"),
                c, b, a;
            c = function() {
                a();
                d.fetchedResource(e, f)
            };
            b = function() {
                a();
                d.failedToLoadResource(e)
            };
            a = function() {
                f.removeEventListener("canplaythrough", c, false);
                f.removeEventListener("error", b, false)
            };
            f.addEventListener("canplaythrough", c, false);
            f.addEventListener("error", b, false);
            f.src = e.url;
            f.load()
        }
    })
}
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbols = {
    constructor: function() {
        Game.Slots.BlurredSymbols.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        return {
            setupGame: {
                queue: [function(a) {
                    a.stateHandler.pushState(a.states.blurImages)
                }]
            },
            blurImages: {
                state: {
                    name: "BlurImage",
                    execute: function(a) {},
                    waitEvents: {
                        "notify:blurredSymbols.blurredImagesCompleted": false
                    }
                }
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.BlurredSymbolsModel,
            view: Core.View,
            controller: Game.Slots.BlurredSymbolsController
        }
    }
};
Game.Slots.BlurredSymbols = Sys.extend(Core.Module, Game.Slots.BlurredSymbols, "Game.Slots.BlurredSymbols");
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbolsController = {
    constructor: function() {
        Game.Slots.BlurredSymbolsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBlurImageState": a.blurSymbols
        })
    },
    blurSymbols: function() {
        this.model.createBlurredImages();
        this.fireEvent("notify:blurredSymbols.blurredImagesCompleted")
    }
};
Game.Slots.BlurredSymbolsController = Sys.extend(Core.Controller, Game.Slots.BlurredSymbolsController, "Game.Slots.BlurredSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.BlurredSymbolsModel = {
    constructor: function() {
        Game.Slots.BlurredSymbolsModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("config") || {};
        this.storeData("reelConfig", a.reel);
        this.storeData("layeringConfig", a.layering)
    },
    blurImagesLegacy: function() {
        var h = this,
            j = Resources.readData("animationImages"),
            e = h.readData("reelConfig"),
            l = e.blurredSymbols,
            a = e.blurredSymbolHeights,
            k, f = Environment.determineResolution().virtualToWindowScale,
            c, m, g = {},
            b, d;
        for (d = 0; d < l.length; d++) {
            b = l[d];
            if (Sys.isNumber(a)) {
                k = a
            } else {
                if (Sys.isDefined(a[b])) {
                    k = a[b]
                } else {
                    k = a.standard
                }
            }
            k *= f;
            c = j[b];
            if (c) {
                m = Animation.utils.stackBlur.stackBlurImage(c, k, 15, true);
                g[b + "-BLURRED"] = m
            }
        }
        Game.stage.view.animationManager.addImages(g)
    },
    blurImages: function() {
        var a = Resources.readData("config").reelGroups["default"].blurredSymbols || [];
        if (a.length) {
            Game.stage.view.animationManager.addBlurredSymbols(a, "-BLURRED", Animation.utils.stackBlur.stackBlurImage)
        }
    },
    createBlurredImages: function() {
        if (Game.stage.view.animationManager.addBlurredSymbols) {
            this.blurImages()
        } else {
            this.blurImagesLegacy()
        }
    }
};
Game.Slots.BlurredSymbolsModel = Sys.extend(Core.Model, Game.Slots.BlurredSymbolsModel, "Game.Slots.BlurredSymbolsModel");
Sys.ns("Game");
Game.Logo = {
    constructor: function() {
        Game.Logo.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            view: Game.LogoView,
            controller: Game.LogoController
        }
    }
};
Game.Logo = Sys.extend(Core.Module, Game.Logo, "Game.Logo");
Sys.ns("Game");
Game.LogoController = {
    constructor: function() {
        Game.LogoController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "request:logo.hide": this.hide,
            "request:logo.show": this.show,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:animationManager.allImagesLoaded": this.initAnimations
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    hide: function() {
        this.view.hide()
    },
    show: function() {
        this.view.show()
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.view.refresh()
        }
    }
};
Game.LogoController = Sys.extend(Core.Controller, Game.LogoController, "Game.LogoController");
Sys.ns("Game");
Game.LogoView = {
    IMAGE: "logo",
    OFFSET_LEFT: 0,
    OFFSET_TOP: 0,
    SIZE_WIDTH: 418,
    SIZE_HEIGHT: 89,
    constructor: function() {
        var a = {
            OFFSET_LEFT: this.OFFSET_LEFT,
            OFFSET_TOP: this.OFFSET_TOP,
            SIZE_WIDTH: this.SIZE_WIDTH,
            SIZE_HEIGHT: this.SIZE_HEIGHT
        };
        Game.LogoView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    hide: function() {
        this.item.stop()
    },
    show: function() {
        this.item.play()
    },
    initAnimations: function() {
        var c = this,
            a = c.getRenderingAttributes(),
            d = new Animation.CanvasAnimationList({}),
            b = new Animation.CanvasAnimationItem({
                left: a.left,
                top: a.top,
                width: a.width,
                height: a.height,
                depth: Layering.Game.Logo.image,
                image: c.IMAGE
            });
        d.add(b);
        c.list = d;
        c.item = b;
        Game.stage.view.addToRenderLoop(d)
    },
    getRenderingAttributes: function() {
        var c = this.getScaleFactor(),
            b = Environment.determineResolution().virtualResolution,
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        return {
            left: ((b.width - a.SIZE_WIDTH * c) / 2) + a.OFFSET_LEFT * c,
            top: a.OFFSET_TOP * c,
            width: a.SIZE_WIDTH * c,
            height: a.SIZE_HEIGHT * c
        }
    },
    getScaleFactor: function() {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    refresh: function() {
        var a = this.getRenderingAttributes(),
            b = this.item;
        if (Animation.utils.isAnimationItem(b)) {
            b.setImage(Game.stage.getOrientationSpecificImage(this.IMAGE));
            b.setLeft(a.left);
            b.setTop(a.top);
            b.setWidth(a.width);
            b.setHeight(a.height)
        }
    }
};
Game.LogoView = Sys.extend(Core.View, Game.LogoView, "Game.LogoView");
Sys.ns("Core");
Core.Fullscreen = {
    ENABLED: true,
    constructor: function(a) {
        this.ENABLED = typeof a.enabled === "boolean" ? a.enabled : this.ENABLED;
        Core.Fullscreen.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        var a;
        if (Utils.Platform.isFullScreenAPISupported()) {
            a = Core.FullscreenView
        } else {
            if (Platform.isIOSDevice && Platform.isMobileDevice && (Sys.isSafari || Sys.isChromeForIOS)) {
                a = Core.FullscreenFallbackView
            }
        }
        if (Utils.Platform.inIframe() || !this.ENABLED || typeof a === "undefined") {
            return {
                controller: Core.Controller
            }
        }
        return {
            controller: Core.FullscreenController,
            model: Core.FullscreenModel,
            view: a
        }
    }
};
Core.Fullscreen = Sys.extend(Core.Module, Core.Fullscreen, "Core.Fullscreen");
Sys.ns("Core");
Core.FullscreenController = {
    setupEvents: function() {
        if (Utils.Platform.isFullScreenAPISupported()) {
            this.on({
                "notify:userInputManager.userInputEnded": this.onUserInputEnded,
                "request:fullscreen.request": this.onRequestFullScreen,
                "request:fullscreen.exit": this.onExitFullScreen,
                "request:fullscreen.setSafeArea": this.onSetSafeArea,
                "request:fullscreen.removeSafeArea": this.onRemoveSafeArea
            })
        } else {
            if (!Utils.Platform.isStandAlone()) {
                this.on({
                    "notify:loader.closed": this.onLoaderClosed,
                    "notify:platform.resized": this.onResize,
                    "notify:pluginMenu.deactivated": this.onResize
                });
                this.view.enable()
            }
        }
    },
    onLoaderClosed: function() {
        if (!this.view.isFullscreen() && !this.model.readData("overlayEnabled")) {
            this.showOverlay()
        }
    },
    onResize: function() {
        if (this.view.isFullscreen()) {
            this.hideOverlay()
        } else {
            if (!this.model.readData("overlayEnabled") && !Resources.readData("pluginMenuOpen")) {
                this.showOverlay()
            }
        }
        window.scrollTo(0, 0)
    },
    showOverlay: function() {
        this.view.showOverlay();
        this.fireEvent("request:userInputManager.allowPropagation");
        this.fireEvent("request:userInputManager.activateExclusivity", "fullscreen");
        this.model.storeData("overlayEnabled", true)
    },
    hideOverlay: function() {
        this.view.hideOverlay();
        this.fireEvent("request:userInputManager.disAllowPropagation");
        this.fireEvent("request:userInputManager.deactivateExclusivity", "fullscreen");
        this.model.storeData("overlayEnabled", false)
    },
    onRequestFullScreen: function() {
        this.view.request()
    },
    onExitFullScreen: function() {
        this.view.exit()
    },
    onUserInputEnded: function(a) {
        if (!this.view.isFullscreen() && !this.model.isInSafeArea(a)) {
            this.view.request()
        }
    },
    onSetSafeArea: function(b, a) {
        this.model.setSafeArea(b, a)
    },
    onRemoveSafeArea: function(a) {
        this.model.removeSafeArea(a)
    }
};
Core.FullscreenController = Sys.extend(Core.Controller, Core.FullscreenController, "Core.FullscreenController");
Sys.ns("Core");
Core.FullscreenModel = {
    constructor: function() {
        Core.FullscreenModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        this.storeData("safeAreas", {});
        this.storeData("overlayEnabled", false)
    },
    setSafeArea: function(c, a) {
        var b = this.readData("safeAreas");
        b[c] = a;
        this.storeData("safeAreas", b)
    },
    removeSafeArea: function(b) {
        var a = this.readData("safeAreas");
        if (a[b]) {
            a[b] = null;
            this.storeData("safeAreas", a)
        }
    },
    isElement: function(b, c) {
        var a = b.element;
        return a && Sys.UserInputUtils.isCoordinateTarget(a, c)
    },
    isClickedWithinCircle: function(b, c) {
        var a = c.x,
            d = c.y;
        return !b.height && Math.sqrt(Math.pow((a - b.x), 2) + Math.pow((d - b.y), 2)) < b.width
    },
    isClickedWithinRectangle: function(b, c) {
        var a = c.x,
            d = c.y;
        return a >= b.x && a <= b.x + b.width && d >= b.y && d <= b.y + b.height
    },
    isInSafeArea: function(f) {
        var d = this.readData("safeAreas"),
            e = Object.keys(d),
            b, c, a;
        if (f) {
            for (c = 0, a = e.length; c < a; c++) {
                b = d[e[c]];
                if (this.isElement(b, f) || this.isClickedWithinCircle(b, f) || this.isClickedWithinRectangle(b, f)) {
                    return true
                }
            }
        }
        return false
    }
};
Core.FullscreenModel = Sys.extend(Core.Model, Core.FullscreenModel, "Core.FullscreenModel");
Sys.ns("Core");
Core.FullscreenView = {
    EMULATED: false,
    FULLSCREEN_MAP: [{
        fullscreenEnabled: "fullscreenEnabled",
        fullscreenElement: "fullscreenElement",
        onfullscreenchange: "onfullscreenchange",
        onfullscreenerror: "onfullscreenerror",
        exitFullscreen: "exitFullscreen",
        requestFullscreen: "requestFullscreen"
    }, {
        fullscreenEnabled: "webkitFullscreenEnabled",
        fullscreenElement: "webkitFullscreenElement",
        onfullscreenchange: "onwebkitfullscreenchange",
        onfullscreenerror: "onwebkitfullscreenerror",
        exitFullscreen: "webkitExitFullscreen",
        requestFullscreen: "webkitRequestFullscreen"
    }, {
        fullscreenEnabled: "mozFullScreenEnabled",
        fullscreenElement: "mozFullScreenElement",
        onfullscreenchange: "onmozfullscreenchange",
        onfullscreenerror: "onmozfullscreenerror",
        exitFullscreen: "mozCancelFullScreen",
        requestFullscreen: "mozRequestFullScreen"
    }, {
        fullscreenEnabled: "msFullscreenEnabled",
        fullscreenElement: "msFullscreenElement",
        onfullscreenchange: "MSFullscreenChange",
        onfullscreenerror: "MSFullscreenError",
        exitFullscreen: "msExitFullscreen",
        requestFullscreen: "msRequestFullscreen"
    }],
    constructor: function() {
        Core.FullscreenView.superclass.constructor.apply(this, arguments);
        this.FULLSCREEN_MAP.some(function(a) {
            if (a.requestFullscreen in document.documentElement) {
                this.API = a;
                return true
            }
            return false
        }, this)
    },
    request: function() {
        if (this.EMULATED) {
            return
        }
        document.documentElement[this.API.requestFullscreen]()
    },
    exit: function() {
        document[this.API.exitFullscreen]()
    },
    isFullscreen: function() {
        return Boolean(document[this.API.fullscreenElement])
    }
};
Core.FullscreenView = Sys.extend(Core.View, Core.FullscreenView, "Core.FullscreenView");
Sys.ns("Core");
Core.FullscreenFallbackView = {
    constructor: function(a) {
        Core.FullscreenFallbackView.superclass.constructor.apply(this, arguments);
        this.initialized = false
    },
    enable: function() {
        if (!this.initialized) {
            this.background = Sys.utils.createElement("div", ["fullscreen-background"]);
            this.instructions = this.createInstructionElement();
            this.overlay = Sys.utils.createElement("div", ["fullscreen-overlay"]);
            document.body.appendChild(this.background);
            document.body.appendChild(this.instructions);
            document.body.appendChild(this.overlay);
            this.initialized = true;
            this.hideOverlay()
        }
        if (!this.isFullscreen) {
            this.showOverlay()
        }
    },
    disable: function() {
        if (this.overlay) {
            document.body.removeChild(this.background);
            document.body.removeChild(this.instructions);
            document.body.removeChild(this.overlay)
        }
    },
    showOverlay: function() {
        if (this.overlay && !Resources.readData("pluginMenuOpen")) {
            this.background.dataset.active = true;
            this.overlay.dataset.active = true;
            this.instructions.dataset.active = true
        }
    },
    hideOverlay: function() {
        if (this.overlay) {
            this.background.dataset.active = false;
            this.overlay.dataset.active = false;
            this.instructions.dataset.active = false
        }
    },
    isFullscreen: function() {
        var b = Utils.Platform.getDeviceSize(),
            a = Utils.Platform.isLandscape() ? b.width : b.height;
        return a === window.innerHeight || (window.innerHeight / a) >= 0.9
    },
    createInstructionElement: function() {
        var b = Sys.utils.createElement("div", ["fullscreen-instructions"]),
            a = document.createElementNS("http://www.w3.org/2000/svg", "svg"),
            c = document.createElementNS("http://www.w3.org/2000/svg", "path");
        a.classList.add("fullscreen-instructions-swipe");
        a.setAttribute("viewBox", "0 0 24 24");
        c.setAttribute("d", "M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z");
        a.appendChild(c);
        b.appendChild(a);
        return b
    }
};
Core.FullscreenFallbackView = Sys.extend(Core.View, Core.FullscreenFallbackView, "Core.FullscreenFallbackView");
Sys.ns("SB");
SB.CutOutAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            view: Core.View,
            controller: SB.CutOutAnimationController
        }
    }
};
SB.CutOutAnimation = Sys.extend(Core.Module, SB.CutOutAnimation, "SB.CutOutAnimation");
Sys.ns("SB");
SB.CutOutAnimationController = {
    constructor: function() {
        SB.CutOutAnimationController.superclass.constructor.apply(this, arguments);
        this.lists = []
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "request:cutOutAnimation.setupAnimation": a.setupAnimation,
            "request:cutOutAnimation.setupAnimationsForPooling": a.setupAnimation
        })
    },
    setupAnimation: function(c) {
        var b = this,
            a = c.cfg,
            e = c.endEvent,
            d;
        if (Sys.isArray(a)) {
            d = [];
            Sys.each(a, function(f) {
                if (Sys.isDefined(f.makeNumberOfSets) && f.makeNumberOfSets > 1) {
                    d.push(b.makeSets(f))
                } else {
                    d.push(b.createAnimation(f))
                }
            })
        } else {
            if (Sys.isObj(a)) {
                if (Sys.isDefined(a.makeNumberOfSets) && a.makeNumberOfSets > 1) {
                    d = b.makeSets(a)
                } else {
                    d = b.createAnimation(a)
                }
            } else {}
        }
        b.fireEvent(e, d)
    },
    makeSets: function(a) {
        var e = new Animation.List({
                id: a.name + "Master"
            }),
            d = a.depth,
            b;
        for (b = 0; b < a.makeNumberOfSets; b++) {
            e.add(this.getListFromAnimation(a));
            a.depth = d
        }
        var c = {};
        c[e.prop.id] = e;
        return c
    },
    getListFromAnimation: function(a) {
        var b = this.createAnimation(a);
        return b[Object.keys(b)[0]]
    },
    createAnimation: function(b) {
        var e = this,
            d = Platform.isDesktopDevice ? Resources.readData("desktopAnimationCfg") : Resources.readData("animationCfg"),
            c = d[b.name].clips,
            g = e.sortChildren(c),
            a = new Animation.List(b.baseCfg),
            f = {};
        e.cfg = b;
        e.loopEventSet = false;
        e.eventSet = false;
        e.objectToHoldEvents = {
            obj: {},
            maxFrame: 0,
            foundNew: false
        };
        e.lists.push(a);
        Sys.each(g, function(h) {
            a.add(e.parseChild(h, h.name, b))
        });
        e.setEvents();
        f[b.name] = a;
        return f
    },
    sortChildren: function(b) {
        var a = [];
        Sys.iterate(b, function(c, d) {
            d.d = Sys.isDefined(d.d) ? d.d : 0;
            d.name = c;
            a.push(d)
        });
        return Sys.utils.objSort(a, "d")
    },
    parseChild: function(e, b, a) {
        var f = this,
            h = Animation.utils,
            d = Sys.isDefined(e.x) ? e.x : 0,
            g = Sys.isDefined(e.y) ? e.y : 0,
            i, c;
        a.depth = e.d === 0 ? a.depth : a.depth + 1;
        if (a.translationPointCenter && Sys.isDefined(e.x) && Sys.isDefined(e.y)) {
            d = e.x - (e.w / 2);
            g = e.y - (e.h / 2)
        }
        if (Sys.isDefined(e.i)) {
            i = new Animation.Item({
                id: b,
                image: e.i,
                left: d,
                top: g,
                width: e.w,
                height: e.h,
                depth: a.depth
            });
            if (!Sys.isDefined(a.translationPointCenter) || !a.translationPointCenter) {
                i.prop.pivot = {
                    x: 0,
                    y: 0
                }
            }
        } else {
            i = new Animation.List({
                id: b,
                left: d,
                top: g,
                depth: a.depth
            });
            c = f.sortChildren(e.c);
            Sys.each(c, function(j) {
                i.add(f.parseChild(j, j.name, a))
            })
        }
        if (Sys.isDefined(e.a) && e.a.hasOwnProperty("0")) {
            h.addOperation(i, f.createFadeOperation(e))
        }
        if (Sys.isDefined(e.sf)) {
            i.prop.changeMatrix = new Float32Array(6);
            i.prop.changeMatrix.set(e.sf)
        } else {
            if (Sys.isDefined(e.f) && e.f.hasOwnProperty("0")) {
                h.addOperation(i, f.createTransformCfg(e));
                if (f.objectToHoldEvents.foundNew) {
                    f.objectToHoldEvents.obj = i;
                    f.objectToHoldEvents.foundNew = false
                }
            }
        }
        return i
    },
    createFadeOperation: function(f) {
        var e = this,
            c = f.a,
            a = {
                fade: []
            },
            d = Sys.isDefined(f.fps) ? 1000 / f.fps : 33.33,
            b = 0;
        Sys.iterate(c, function(g, h) {
            a.fade[b] = {
                time: g * d,
                value: Sys.utils.toFloat(h)
            };
            b++
        });
        b--;
        if (e.cfg.loopOperation) {
            a.fade[b].goTo = 0
        }
        return a
    },
    createTransformCfg: function(e) {
        var j = this,
            h = e.f,
            c = {
                transformMatrix: []
            },
            g = Sys.isDefined(e.fps) ? 1000 / e.fps : 33.33,
            b = [],
            a, k, f, d;
        Sys.iterate(h, function(i, l) {
            k = Sys.utils.toInt(i) - 1;
            f = b.length - 1;
            for (d = f; d < k; d++) {
                b.push(b[f])
            }
            var m = new Float32Array(l);
            b.push(m);
            j.lookForMaxFrame(k)
        });
        a = b.length - 1;
        c.transformMatrix[0] = {
            time: 0,
            value: 0
        };
        c.transformMatrix[1] = {
            time: a * g,
            value: a,
            matrixArray: b
        };
        if (j.cfg.loopOperation) {
            c.transformMatrix[1].goTo = 0
        }
        return c
    },
    lookForMaxFrame: function(b) {
        var a = this;
        if (b > a.objectToHoldEvents.maxFrame) {
            a.objectToHoldEvents.foundNew = true;
            a.objectToHoldEvents.maxFrame = b
        }
    },
    setEvents: function() {
        var c = this,
            d = c.objectToHoldEvents.obj.prop,
            a = d.operations.transformMatrix;
        if (c.cfg.loop) {
            a[1].fireEvent = {
                event: "view:playAgain",
                scope: c.cfg.loop.scope,
                argument: c.lists[c.lists.length - 1]
            }
        }
        if (Sys.isDefined(c.cfg.events)) {
            var b = c.cfg.events;
            Sys.each(b, function(f) {
                var e = {};
                e = Sys.apply(e, f);
                if (!Sys.isDefined(a[1].events)) {
                    a[1].events = []
                }
                if (f.onFrame === "end") {
                    e.onFrame = a[1].value;
                    a[1].events.push(e)
                } else {
                    a[1].events.push(e)
                }
            })
        }
    }
};
SB.CutOutAnimationController = Sys.extend(Core.Controller, SB.CutOutAnimationController, "SB.CutOutAnimationController");
Sys.ns("SB");
SB.LogoView = {
    OFFSET_LEFT: 27,
    SIZE_WIDTH: 590,
    SIZE_HEIGHT: 117
};
SB.LogoView = Sys.extend(Game.LogoView, SB.LogoView, "SB.LogoView");
Sys.ns("SB");
SB.LogoDesktopView = {
    SIZE_WIDTH: 356,
    SIZE_HEIGHT: 87,
    OFFSET_LEFT: 0,
    OFFSET_TOP: 0,
    hide: function() {
        this.list.stop()
    },
    show: function() {
        this.list.play()
    }
};
SB.LogoDesktopView = Sys.extend(Game.LogoView, SB.LogoDesktopView, "SB.LogoDesktopView");
Sys.ns("SB");
SB.BetlineIndicators = {
    getMixinDependencies: function() {
        return {
            desktop: [{
                userInput: {
                    inputEvents: ["hover", "move"],
                    listenToUserInput: true
                }
            }]
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.Slots.BetlineIndicatorsModel,
            view: SB.BetlineIndicatorsView,
            controller: SB.BetlineIndicatorsController
        }
    }
};
SB.BetlineIndicators = Sys.extend(Game.Slots.BetlineIndicators, SB.BetlineIndicators, "SB.BetlineIndicators");
Sys.ns("SB");
SB.BetlineIndicatorsView = {
    INDICATOR_IMAGE: "betlineIndicator",
    createHighlightItems: function(d) {
        var c = this,
            e = c.calculateNumberOfNeededItems(),
            a, b;
        d = !d ? c.highlightAnimationList : d;
        for (b = -1; ++b < e;) {
            a = new Animation.CanvasAnimationItem({
                width: Platform.isDesktopDevice ? 47 : 53,
                height: Platform.isDesktopDevice ? 47 : 52,
                depth: Layering.Game.Slots.WinSituationsDisplay.betlineNumberHighlight,
                image: c.INDICATOR_IMAGE,
                globalCompositeOperation: "lighter",
                customProps: {
                    number: "not set yet"
                },
                operations: {
                    fade: [{
                        time: 0,
                        value: 1,
                        fireEvent: {
                            event: "view:animationComplete",
                            scope: c
                        }
                    }, {
                        time: 1,
                        value: 1,
                        goTo: 0
                    }]
                }
            });
            d.add(a)
        }
    },
    calculateNumberOfNeededItems: function() {
        var a = this.model.readData("numberConfig").configurations,
            b = 2;
        Sys.iterate(a, function(c, d) {
            if (Sys.isArray(d)) {
                b = Math.max(b, d.length)
            }
        });
        return b
    },
    animate: function(h, f, g) {
        var e = this,
            d = [],
            c, b = [],
            a = e.model.readData("numberConfig").configurations;
        d.push(a.right[h]);
        d.push(a.left[h]);
        f = f ? f : e.highlightAnimationList;
        Sys.each(d, function(i, j) {
            c = f.items[j];
            e.configureItemForHighlight(c, h, i, g);
            b.push(c)
        });
        f.play(b)
    },
    configureItemForHighlight: function(a, c, b) {
        a.prop.customProps.number = c;
        a.prop.top = b.top;
        a.prop.left = b.left
    },
    isUserInputInBetlineSegment: function(c) {
        var d = this,
            f = d.model.readData("numberConfig").configurations,
            b = d.model.readData("numberConfig").hoverArea,
            e, a = -1;
        f = c.x < 1280 / 2 ? f.left : f.right;
        Sys.iterate(f, function(g) {
            e = {
                x: f[g].left + b.offsetX,
                y: f[g].top + b.offsetY,
                width: b.width,
                height: b.height
            };
            if (Sys.UserInputUtils.isUserInputInSegment(c, e)) {
                a = g
            }
        });
        return a
    },
    refresh: function() {}
};
SB.BetlineIndicatorsView = Sys.extend(Game.Slots.BetlineIndicatorsView, SB.BetlineIndicatorsView, "SB.BetlineIndicatorsView");
Sys.ns("SB");
SB.BetlineIndicatorsController = {
    setupEvents: function() {
        var a = this;
        SB.BetlineIndicatorsController.superclass.setupEvents.apply(a, arguments);
        if (Platform.isDesktopDevice) {
            a.on({
                "notify:stateHandler.enteringBigWinState": a.onEnteringBigWinState,
                "notify:stateHandler.leavingBigWinState": a.onLeavingBigWinState
            })
        }
    },
    onEnteringBigWinState: function() {
        var a = this;
        a.model.setState("disabled");
        a.fireEvent("request:winSituations.hideDisplayBetline")
    },
    onLeavingBigWinState: function() {
        this.model.setState("enabled")
    },
    onUserInputHover: function(b) {
        var a = this;
        if (Platform.isDesktopDevice && !a.model.isState("disabled")) {
            a.view.onUserInputHover(b)
        }
    },
    onUserInputMove: function(a) {
        if (Platform.isDesktopDevice) {
            this.onUserInputHover(a)
        }
    }
};
SB.BetlineIndicatorsController = Sys.extend(Game.Slots.BetlineIndicatorsController, SB.BetlineIndicatorsController, "SB.BetlineIndicatorsController");
Sys.ns("SB");
SB.WinSituationsView = {
    showDisplayBetline: function(a, c) {
        var e = this,
            d = e.model.readData("displayBetlineWho"),
            b = Environment.getResolution();
        if (!Sys.isArray(a)) {
            a = [a]
        }
        if (!Sys.isDefined(c)) {
            c = "hover"
        }
        if (c !== d) {
            e.hideDisplayBetline(d)
        }
        e.model.storeData("displayBetlineWho", c);
        e.hoverBetlineContext.clearRect(0, 0, b.width, b.height);
        a.forEach(function(f) {
            e.drawBetline(f, e.hoverBetlineContext)
        });
        e.hoverBetlineAnimationList.play()
    }
};
SB.WinSituationsView = Sys.extend(Game.Slots.WinSituationsView, SB.WinSituationsView, "SB.WinSituationsView");
Sys.ns("SB");
SB.WinSituationsDisplayController = {
    setupEvents: function() {
        var a = this;
        SB.WinSituationsDisplayController.superclass.setupEvents.apply(a, arguments);
        if (Platform.isDesktopDevice) {
            a.on({
                "request:abortPresentation": a.abortPresentation
            })
        }
    },
    abortPresentation: function() {
        var a = this;
        if (a.model.isState("toggling")) {
            return
        } else {
            this.abort()
        }
    }
};
SB.WinSituationsDisplayController = Sys.extend(Game.Slots.WinSituationsDisplayController, SB.WinSituationsDisplayController, "SB.WinSituationsDisplayController");
Sys.ns("SB");
SB.WinSituationsDisplayModel = {
    processServerResponse: function(c) {
        var b = this,
            a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            if (Platform.isDesktopDevice) {
                a = SB.utils.serverResponse.getRandomWinSituationsToToggle()
            } else {
                Sys.each(c.wins.winSituations, function(e, d) {
                    if (b.shouldToggleWinSituation(e)) {
                        a.push(d)
                    }
                })
            }
        }
        b.storeData("winSituationsToToggle", a)
    }
};
SB.WinSituationsDisplayModel = Sys.extend(Game.Slots.WinSituationsDisplayModel, SB.WinSituationsDisplayModel, "SB.WinSituationsDisplayModel");
Sys.ns("SB");
SB.CoinWinView = {
    NUMBER_IMAGE: "CoinWin",
    NUMBER_WIDTH: 114,
    NUMBER_HEIGHT: 113,
    NUMBER_OFFSET: -50,
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_DRAWING_FUNCTION: function() {},
    BACKGROUND_WIDTH: undefined,
    BACKGROUND_HEIGHT: undefined,
    createTextItem: function() {
        var a = this,
            c = Animation.utils.text.createNumberDrawingProperties(a),
            b = 300;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: Layering.Game.Slots.CoinWin.text,
            customProps: {
                text: "not set yet"
            },
            executeBefore: function(d) {
                var e = this;
                Animation.utils.text.drawTextFromImage(e.customProps.text, a.NUMBER_OFFSET, e.pivot.x, e.pivot.y, true, c.image, c.charMap, c.width, c.height, d)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 1,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: a
                    }
                }, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }],
                scale: [{
                    time: 0,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }, {
                    time: b,
                    value: {
                        scaleX: 1,
                        scaleY: 1
                    }
                }]
            }
        })
    }
};
SB.CoinWinView = Sys.extend(Game.Slots.CoinWinView, SB.CoinWinView, "SB.CoinWinView");
Sys.ns("SB");
SB.CoinWinDesktopView = {
    NUMBER_IMAGE: "CountUpNumber",
    NUMBER_WIDTH: 63,
    NUMBER_HEIGHT: 70,
    NUMBER_OFFSET: -20,
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_DRAWING_FUNCTION: function() {},
    BACKGROUND_WIDTH: undefined,
    BACKGROUND_HEIGHT: undefined,
    createTextItem: function() {
        var a = this,
            c = Animation.utils.text.createNumberDrawingProperties(a),
            b = 300;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: Layering.Game.Slots.CoinWin.text,
            customProps: {
                text: "not set yet"
            },
            executeBefore: function(d) {
                var e = this;
                Animation.utils.text.drawTextFromImage(e.customProps.text, a.NUMBER_OFFSET, e.pivot.x, e.pivot.y, true, c.image, c.charMap, c.width, c.height, d)
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: b,
                    value: 1
                }],
                rotate: [{
                    time: 0,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: a
                    }
                }, {
                    time: 1,
                    value: 0,
                    goTo: 0
                }],
                scale: [{
                    time: 0,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }, {
                    time: b,
                    value: {
                        scaleX: 1,
                        scaleY: 1
                    }
                }]
            }
        })
    }
};
SB.CoinWinDesktopView = Sys.extend(Game.Slots.CoinWinView, SB.CoinWinDesktopView, "SB.CoinWinDesktopView");
Sys.ns("Layering.Game");
Sys.applyProperties(Layering.Game.Slots, {
    Background: {
        fader: 19,
        netEntProd: 161,
        movingFireFly: 7,
        dividers: 22,
        greyLayer: 152,
        novaItem: 40,
        betlineNumbers: 8
    },
    BigWin: {
        text: 59,
        burst_container: 49,
        yellowCloud: 50,
        symbolGlow: 51,
        white_pulse: 52,
        white_cloud: 53,
        white_burst: 54,
        colored_cloud: 55,
        colored_cloud1: 56,
        colored_cloud2: 57,
        yellowCloud1: 58
    },
    CoinWin: {
        background: 16,
        text: 37
    },
    Keypad: {
        background_basic: 123,
        background_freespin: 135,
        bet: 124,
        balance: 124,
        win: 136,
        total_win: 136,
        betLevelSelector: 125,
        coinValueSelector: 125,
        maxBet: {
            button: 125,
            label: 126
        },
        autoPlay: {
            button: 125,
            label: 126
        },
        paytable: {
            button: 153,
            label: 154
        }
    },
    Spin: {
        symbols: 10
    },
    WinningSymbols: {
        animationItems: 11,
        burstAnimation: 41,
        flyingAnimation: 42,
        comboAnimation: 43
    },
    WinSituationsDisplay: {
        betlines: 6,
        betlineNumberHighlight: 9,
        bendingBetlines: 35
    },
    ExpandingWild: {
        glow: 5,
        rainbow_container: 21,
        particle_container: 25,
        symbols: 31,
        burst_container: 30,
        topFader: 22
    },
    IntroOutro: {
        background: 155,
        text: 156,
        overlay: 157
    },
    WinBanner: {
        background: 150,
        text: 151
    }
});
Sys.applyProperties(Layering.Game, {
    Logo: {
        image: 60
    }
});
Sys.ns("SB");
SB.SymbolBurstAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.SymbolBurstAnimationModel,
            controller: SB.SymbolBurstAnimationController,
            view: SB.SymbolBurstAnimationView
        }
    }
};
SB.SymbolBurstAnimation = Sys.extend(Core.Module, SB.SymbolBurstAnimation, "SB.SymbolBurstAnimation");
Sys.ns("SB");
SB.SymbolBurstAnimationModel = {
    SYMBOLS_TO_ANIMATE: ["SYM3", "SYM4", "SYM5", "SYM6", "SYM7", "SYM8", "SYM9"],
    processServerResponse: function(c) {
        var b = this,
            a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            if (Platform.isDesktopDevice) {
                a = SB.utils.serverResponse.randomizeWinSituations(c.wins.winSituations)
            } else {
                a = c.wins.winSituations.slice(0)
            }
        }
        b.storeData("winSituations", Sys.clone(a));
        if (c.clientaction !== "init" && c.totalwin.coins > 0) {
            b.storeData("winType", c.wins.winType)
        }
    }
};
SB.SymbolBurstAnimationModel = Sys.extend(Core.Model, SB.SymbolBurstAnimationModel, "SB.SymbolBurstAnimationModel");
Sys.ns("SB");
SB.SymbolBurstAnimationController = {
    LOW_WIN: {
        count: 5,
        symbols: ["SYM8", "SYM9"]
    },
    MEDIUM_WIN: {
        count: 4,
        symbols: ["SYM7", "SYM6", "SYM5"]
    },
    HIGH_WIN: {
        count: 3,
        symbols: ["SYM4", "SYM3"]
    },
    novaAnim: undefined,
    setupEvents: function() {
        var a = this;
        a.on({
            "request:symbolBurst.showBurst": a.playSymbolBurstAnimation,
            "view:playNextBurst": a.playNextBurst,
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:bigWin.animationAborted": a.abort,
            "notify:winAnimations.animationAborted": a.abort
        });
        if (Platform.isDesktopDevice) {
            a.on({
                "notify:stateHandler.enteringSpinningState": a.onEnteringSpinnningState,
                "view:animationComplete": a.fireEvent.bind(a, "notify:symbolBurstAnimation.finish")
            })
        }
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    onEnteringSpinnningState: function() {
        SB.utils.serverResponse.winSituationsAlreadyRandomised = false
    },
    playSymbolBurstAnimation: function() {
        var e = this,
            c = e.model,
            a = c.readData("winSituations"),
            f = {
                delay: 0
            };
        c.setState("showing");
        if (a.length > 0) {
            var d = a.splice(0, 1)[0],
                b = "betlineWin" + d.betline + d.dir;
            c.storeData("winSituations", a);
            c.storeData(b, d);
            d.reverseBurst = false;
            if (Platform.isDesktopDevice) {
                f.delay = 20;
                e.checkNova(b);
                d.noOfSymWin = d.positions.length;
                e.configureReverseBurst(b)
            }
            e.animateSymbol(b, f);
            this.fireEvent("request:audioPlayer.play", {
                name: "winShockwaveSnd",
                id: "winShockwaveSnd"
            })
        }
    },
    checkNova: function(a) {
        var c = this,
            b = c.model.readData(a);
        if ((b.positions.length >= c.LOW_WIN.count && c.LOW_WIN.symbols.indexOf(b.sym) > -1) || (b.positions.length >= c.HIGH_WIN.count && c.HIGH_WIN.symbols.indexOf(b.sym) > -1) || (b.positions.length >= c.MEDIUM_WIN.count && c.MEDIUM_WIN.symbols.indexOf(b.sym) > -1)) {
            b.hasNova = true;
            b.novaSymbolIndex = Math.floor(b.positions.length / 2);
            b.novaSymbolPosition = b.positions[b.novaSymbolIndex];
            c.model.storeData(a, b)
        }
    },
    configureReverseBurst: function(a) {
        var d = this,
            c = d.model.readData(a);
        d.hasReverseBurst = false;
        if (c.positions.length === 5 && d.model.readData("winType") !== "bigWin") {
            var b = Sys.clone(c.positions);
            b.pop();
            b.reverse();
            c.positions = c.positions.concat(b);
            c.reverseBurst = true
        }
    },
    animateSymbol: function(c, f) {
        var e = this,
            b = e.model,
            d = b.readData(c);
        if (Platform.isDesktopDevice && d.positions.length > 0) {
            f.burstingDuration = 900;
            if (d.reverseBurst && d.positions.length < 5) {
                f.burstingDuration = 1100;
                f.nextBurstTimming = 130
            }
        }
        e.fireEvent("request:audioPlayer.play", {
            name: "symExplosions",
            id: "symExplosions"
        });
        var a = d.positions.splice(0, 1)[0];
        d.currentIndex = Sys.isDefined(d.currentIndex) ? d.currentIndex + 1 : 0;
        b.storeData(c, d);
        e.view.animateSymbol({
            pos: a,
            sym: d.sym,
            betlineWin: c
        }, f);
        if (d.hasNova && d.currentIndex === 0 && Platform.isDesktopDevice) {
            e.view.NOVA_SYM_CONFIG = {
                pos: d.novaSymbolPosition,
                sym: d.sym,
                betlineWin: c
            };
            e.view.animateNovaSymbol(c)
        }
        if (d.currentIndex === 2) {
            e.playSymbolBurstAnimation()
        }
    },
    playNextBurst: function(b) {
        var c = this,
            d = {};
        d.delay = 0;
        if (c.model.readData(b).positions.length > 0) {
            c.animateSymbol(b, d)
        } else {
            var a = c.model.readData("winSituations");
            if (a.length <= 0 && !c.model.isState("finished")) {
                c.model.setState("finished");
                c.fireEvent("notify:SymbolBurstAnimation.SymbolBurstAnimationFinished")
            }
        }
    },
    abort: function() {
        var a = this;
        a.model.storeData("winSituations", []);
        a.view.finish()
    }
};
SB.SymbolBurstAnimationController = Sys.extend(Core.Controller, SB.SymbolBurstAnimationController, "SB.SymbolBurstAnimationController");
Sys.ns("SB");
SB.SymbolBurstAnimationView = {
    IMAGE_WIDTH: 386,
    IMAGE_HEIGHT: 370,
    ANIMATION_IMAGES: {
        SYM3: "BURSTS_SYM3",
        SYM4: "BURSTS_SYM4",
        SYM5: "BURSTS_SYM5",
        SYM6: "BURSTS_SYM6",
        SYM7: "BURSTS_SYM7",
        SYM8: "BURSTS_SYM8",
        SYM9: "BURSTS_SYM9"
    },
    initAnimations: function() {
        var c = this,
            d = Resources.readData("config").reel,
            a = d.symbolCols,
            b = d.symbolRows;
        c.symbolAnimationItems = Sys.utils.init2dMatrix(a, b);
        c.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.animationList);
        c.animationList.stop()
    },
    configureSymbolAnimation: function(d, a) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.pos.reelIndex, a.pos.symbolIndex);
        if (d.isRunning() && Sys.isDefined(d.prop.operations.fade)) {
            b.fireEvent("view:playNextBurst", d.prop.operations.fade[2].fireEvent.argument)
        }
        d.prop = Sys.apply(d.prop, {
            image: b.ANIMATION_IMAGES[a.sym],
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 150,
                    value: 0.9
                }, {
                    time: 200,
                    value: 0.7,
                    fireEvent: {
                        event: "view:playNextBurst",
                        scope: b,
                        argument: a.betlineWin
                    }
                }, {
                    time: 1000,
                    value: 0
                }],
                scale: [{
                    time: 0,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }, {
                    time: 150,
                    value: {
                        scaleX: 1.8,
                        scaleY: 1.8
                    }
                }, {
                    time: 1000,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }]
            }
        });
        d.prop.top = c.top - (b.IMAGE_HEIGHT - c.height) / 2;
        d.prop.left = c.left - (b.IMAGE_WIDTH - c.width) / 2;
        d.restore()
    },
    animateSymbol: function(d, f) {
        var c = this,
            a, e, b;
        a = d.pos.reelIndex;
        e = d.pos.symbolIndex;
        if (Sys.isDefined(c.symbolAnimationItems[a][e])) {
            b = c.symbolAnimationItems[a][e]
        } else {
            b = c.createSymbolBurstAnimationItem();
            c.animationList.add(b);
            c.symbolAnimationItems[a][e] = b
        }
        c.configureSymbolAnimation(b, d, f);
        c.animationList.play(b)
    },
    createSymbolBurstAnimationItem: function() {
        var a = this;
        return new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.burstAnimation,
            width: a.IMAGE_WIDTH,
            height: a.IMAGE_HEIGHT,
            delay: 1
        })
    },
    finish: function() {
        var a = this;
        a.animationList.stop()
    }
};
SB.SymbolBurstAnimationView = Sys.extend(Core.View, SB.SymbolBurstAnimationView, "SB.SymbolBurstAnimationView");
Sys.ns("SB");
SB.SymbolBurstAnimationDesktopView = {
    SYM_DETAILS: {
        SYM1: {
            OPACITY: 0.8,
            SCALE: 1.2,
            BREAKPOINT_OPACITY: 0.7
        },
        SYM3: {
            OPACITY: 0.8,
            SCALE: 1.8,
            BREAKPOINT_OPACITY: 0.7
        },
        SYM4: {
            OPACITY: 0.95,
            SCALE: 1.8,
            BREAKPOINT_OPACITY: 0.95
        },
        SYM5: {
            OPACITY: 0.9,
            SCALE: 1.4,
            BREAKPOINT_OPACITY: 0.8
        },
        SYM6: {
            OPACITY: 0.8,
            SCALE: 1.4,
            BREAKPOINT_OPACITY: 0.7
        },
        SYM7: {
            OPACITY: 0.8,
            SCALE: 1.2,
            BREAKPOINT_OPACITY: 0.7
        },
        SYM8: {
            OPACITY: 0.8,
            SCALE: 1.3,
            BREAKPOINT_OPACITY: 0.7
        },
        SYM9: {
            OPACITY: 0.9,
            SCALE: 1.4,
            BREAKPOINT_OPACITY: 0.8
        }
    },
    NOVA_CONFIG: {
        width: 381,
        height: 274,
        sprite: "novaImage"
    },
    NOVA_SYM_CONFIG: undefined,
    setupEvents: function() {
        var a = this;
        a.on({
            "view:burstAnimationComplete": a.onBurstAnimationComplete
        })
    },
    onBurstAnimationComplete: function() {
        var a = this;
        a.animationCounter.pop();
        if (a.animationCounter.length === 0) {
            a.animationCounter = [];
            a.fireEvent("view:animationComplete")
        }
    },
    initAnimations: function() {
        var c = this,
            d = Resources.readData("config").reel,
            a = d.symbolCols,
            b = d.symbolRows;
        c.symbolAnimationItems = Sys.utils.init2dMatrix(a, b);
        c.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.animationList);
        c.animationList.stop();
        c.novaAnimationList = new Animation.CanvasAnimationList();
        c.initNovaAnimation();
        c.animationCounter = []
    },
    initNovaAnimation: function() {
        var c = this,
            a, b;
        for (b = 0; b < 10; b++) {
            a = c.createNovaItem();
            c.novaAnimationList.add(a)
        }
        c.novaAnimationList.prop.globalCompositeOperation = "screen";
        Game.stage.view.addToRenderLoop(c.novaAnimationList);
        c.novaAnimationList.stop()
    },
    createNovaItem: function() {
        var d = Environment.getStageResolution().width / Environment.getResolution().width,
            c = Environment.getStageResolution().height / Environment.getResolution().height,
            b, e = this,
            a = Resources.readData("spriteConfigurations").nova,
            f = Game.stage.view.animationManager.getSpriteSequence("novaAnimation");
        b = new Animation.CanvasAnimationItem({
            width: e.NOVA_CONFIG.width * d,
            height: e.NOVA_CONFIG.height * c,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            totalSpriteHeight: a.totalSpriteHeight,
            image: e.NOVA_CONFIG.sprite,
            depth: Layering.Game.Slots.Background.novaItem,
            spriteArray: f,
            operations: {
                sprite: [{
                    time: 0,
                    value: 0
                }, {
                    time: a.duration,
                    value: f.length - 1
                }],
                fade: [{
                    time: 0,
                    value: 1
                }, {
                    time: a.duration,
                    value: 1
                }],
                rotate: []
            }
        });
        return b
    },
    configureSymbolAnimation: function(f, c, a) {
        var k = this,
            b = Game.stage.model.getSymbolConfiguration(c.pos.reelIndex, c.pos.symbolIndex),
            m, g = a.delay,
            j = [0, 30, 45, 60, 75],
            e = Math.floor(Math.random() * (4 - 0 + 1)),
            l = k.SYM_DETAILS[c.sym],
            h = a.burstingDuration ? a.burstingDuration : 700,
            d, i;
        m = k.model.readData(c.betlineWin);
        k.animationCounter.push(m.betline);
        if (m.noOfSymWin === 3) {
            i = 20;
            d = l.OPACITY
        } else {
            if (m.noOfSymWin === 4) {
                i = 99;
                d = l.BREAKPOINT_OPACITY
            } else {
                if (m.noOfSymWin === 5) {
                    i = 99;
                    d = l.OPACITY
                }
            }
        }
        i = a.nextBurstTimming ? a.nextBurstTimming : i;
        if (f.isRunning() && Sys.isDefined(f.prop.operations.fade && m.reverseBurst === false)) {
            k.fireEvent("view:playNextBurst", f.prop.operations.fade[2].fireEvent.argument)
        }
        f.prop = Sys.apply(f.prop, {
            image: k.ANIMATION_IMAGES[c.sym],
            operations: {
                fade: [{
                    time: g,
                    value: 0
                }, {
                    time: m.reverseBurst ? 99 + g : 99 + g,
                    value: l.OPACITY
                }, {
                    time: i + g,
                    value: d,
                    fireEvent: {
                        event: "view:playNextBurst",
                        scope: k,
                        argument: c.betlineWin
                    }
                }, {
                    time: h + g,
                    value: 0,
                    fireEvent: {
                        event: "view:burstAnimationComplete",
                        scope: k
                    }
                }],
                scale: [{
                    time: g,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }, {
                    time: m.reverseBurst ? 99 + g : 99 + g,
                    value: {
                        scaleX: l.SCALE,
                        scaleY: l.SCALE
                    }
                }, {
                    time: h + g,
                    value: {
                        scaleX: 0,
                        scaleY: 0
                    }
                }],
                rotate: [{
                    time: g,
                    value: j[e]
                }, {
                    time: h + g,
                    value: j[e]
                }]
            }
        });
        if (m.reverseBurst === true && f.isRunning()) {
            f.prop.operations.rotate = [{
                time: g,
                value: j[e]
            }, {
                time: h + g,
                value: j[e]
            }]
        }
        f.prop.top = b.top - (k.IMAGE_HEIGHT - b.height) / 2;
        f.prop.left = b.left - (k.IMAGE_WIDTH - b.width) / 2;
        f.prop.globalCompositeOperation = "lighter";
        f.restore()
    },
    animateNovaSymbol: function(b) {
        var d = this,
            a = b.substr(10, 1) - 1,
            f = d.novaAnimationList.items[a],
            e = Game.stage.model.getSymbolConfiguration(d.NOVA_SYM_CONFIG.pos.reelIndex, d.NOVA_SYM_CONFIG.pos.symbolIndex),
            g = [0, 3, 6, 9, 12],
            c = Math.floor(Math.random() * (4 - 0 + 1));
        f.prop.top = e.top - (d.NOVA_CONFIG.height - e.height) / 2;
        f.prop.left = e.left - (d.NOVA_CONFIG.width - e.width) / 2;
        f.prop.globalCompositeOperation = "screen";
        f.prop.operations.rotate = [{
            time: 0,
            value: g[c]
        }, {
            time: 1100,
            value: g[c]
        }];
        d.novaAnimationList.play(f)
    },
    animateSymbol: function(e, g) {
        var d = this,
            a, f, c;
        a = e.pos.reelIndex;
        f = e.pos.symbolIndex;
        if (Sys.isDefined(d.symbolAnimationItems[a][f])) {
            c = d.symbolAnimationItems[a][f]
        } else {
            c = d.createSymbolBurstAnimationItem();
            d.animationList.add(c);
            d.symbolAnimationItems[a][f] = c
        }
        if (c.isRunning()) {
            var b = d.createSymbolBurstAnimationItem();
            d.animationList.add(b);
            d.configureSymbolAnimation(b, e, g);
            d.animationList.play(b)
        } else {
            d.configureSymbolAnimation(c, e, g);
            d.animationList.play(c)
        }
    },
    finish: function() {
        var a = this;
        a.animationList.stop();
        a.novaAnimationList.stop()
    }
};
SB.SymbolBurstAnimationDesktopView = Sys.extend(SB.SymbolBurstAnimationView, SB.SymbolBurstAnimationDesktopView, "SB.SymbolBurstAnimationDesktopView");
Sys.ns("SB");
SB.SymbolFlyingAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.SymbolFlyingAnimationModel,
            controller: SB.SymbolFlyingAnimationController,
            view: SB.SymbolFlyingAnimationView
        }
    }
};
SB.SymbolFlyingAnimation = Sys.extend(Core.Module, SB.SymbolFlyingAnimation, "SB.SymbolFlyingAnimation");
Sys.ns("SB");
SB.SymbolFlyingAnimationController = {
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:winAnimations.showAnimation": a.view.animateFlying.bind(a.view),
            "view:animationComplete": a.fireEvent.bind(a, "notify:symbolFlyingAnimation.finish"),
            "notify:winAnimations.animationAborted": a.view.restoreAnimation.bind(a.view)
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    }
};
SB.SymbolFlyingAnimationController = Sys.extend(Core.Controller, SB.SymbolFlyingAnimationController, "SB.SymbolFlyingAnimationController");
Sys.ns("SB");
SB.SymbolFlyingAnimationModel = {
    setupData: function() {
        if (Platform.isDesktopDevice) {
            var a = Resources.readData("config").winSituationsDisplay || {},
                b = a.betlines || {};
            this.storeData("lineConfig", b.lines)
        }
    },
    processServerResponse: function(b) {
        var a = this;
        if (Platform.isDesktopDevice && b.clientaction !== "init" && b.totalwin.coins > 0) {
            a.storeData("winType", b.wins.winType)
        }
    }
};
SB.SymbolFlyingAnimationModel = Sys.extend(Core.Model, SB.SymbolFlyingAnimationModel, "SB.SymbolFlyingAnimationModel");
Sys.ns("SB");
SB.SymbolFlyingAnimationView = {
    FLYING_NUMBER_CONFIG: {
        NUMBER_FONT: "90px BauhausRegular",
        NUMBER_WIDTH: 50,
        NUMBER_HEIGHT: 100,
        NUMBER_TEXT_OPERATIONS: [{
            fillStyle: "blue",
            drawType: "fill"
        }, {
            lineWidth: 4,
            fillStyle: "green",
            drawType: "stroke"
        }]
    },
    FLYING_NUMBER_IMAGES: {},
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.FLYING_NUMBER_CONFIG.NUMBER_FONT = "90px SBMyroidProBold"
        }
        b.setDuration = 350;
        b.numberAnimationItems = [];
        b.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(b.animationList);
        b.animationList.stop()
    },
    createNumberAnimation: function() {
        var a = this;
        return new Animation.CanvasAnimationItem({
            width: 100,
            height: 100,
            top: 0,
            left: 0,
            depth: Layering.Game.Slots.WinningSymbols.flyingAnimation,
            executeBefore: function(b) {
                var d = this,
                    c = a.FLYING_NUMBER_IMAGES[d.symbol];
                Animation.utils.text.drawTextFromImage(d.coinWin, 0, d.pivot.x, d.pivot.y, true, c.image, c.charMap, c.width, c.height, b, 0)
            }
        })
    },
    configureNumberAnimation: function(i, e) {
        var g = this,
            b = e,
            h = b.winSituation,
            a = b.symbolConfig,
            j = b.pathConfig,
            f = j.length,
            d = (f - 1) * g.setDuration,
            c = h.sym;
        i.prop.coinWin = h.wins.coins;
        i.prop.symbol = c;
        g.setFadeOperation(i, d);
        g.setRotateOperation(i, d);
        g.setTranslateOperation(i, f, e, j);
        Animation.Operations.translatePath.applyDefaultValuesToOperation(i);
        i.restore();
        g.applyTextFormat(c, a)
    },
    setFadeOperation: function(a, b) {
        a.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 100,
            value: 1
        }, {
            time: b,
            value: 1
        }]
    },
    setRotateOperation: function(a, b) {
        a.prop.operations.rotate = [{
            time: 0,
            value: 0
        }, {
            time: b / 4,
            value: -3
        }, {
            time: b,
            value: 10
        }]
    },
    setTranslateOperation: function(g, a, b, c) {
        var f = this,
            d, e = [];
        for (d = 0; d < a; d++) {
            var h = {
                time: 0,
                value: {
                    top: 0,
                    left: 0
                }
            };
            h.time = d * f.setDuration;
            h.value.top = c[d].top;
            h.value.left = c[d].left;
            if (b.last && d === a - 1) {
                h.fireEvent = {
                    event: "view:animationComplete",
                    scope: f
                }
            }
            e.push(h)
        }
        g.prop.operations.translatePath = e
    },
    applyTextFormat: function(c, b) {
        var a = this;
        if (!Sys.isDefined(a.FLYING_NUMBER_IMAGES[c])) {
            a.FLYING_NUMBER_CONFIG.NUMBER_TEXT_OPERATIONS[0].fillStyle = b.fillColor;
            a.FLYING_NUMBER_CONFIG.NUMBER_TEXT_OPERATIONS[1].strokeStyle = b.strokeColor;
            a.FLYING_NUMBER_IMAGES[c] = Animation.utils.text.createNumberDrawingProperties(a.FLYING_NUMBER_CONFIG)
        }
    },
    animateFlying: function(a) {
        var d = this,
            c, b = a.counter;
        if (Sys.isDefined(d.numberAnimationItems[b])) {
            c = d.numberAnimationItems[b]
        } else {
            c = d.createNumberAnimation();
            d.animationList.add(c);
            d.numberAnimationItems[b] = c
        }
        d.configureNumberAnimation(c, a);
        d.animationList.play(d.numberAnimationItems[b])
    },
    restoreAnimation: function() {
        var a = this;
        a.animationList.restore();
        a.animationList.stop()
    }
};
SB.SymbolFlyingAnimationView = Sys.extend(Core.View, SB.SymbolFlyingAnimationView, "SB.SymbolFlyingAnimationView");
Sys.ns("SB");
SB.SymbolFlyingAnimationDesktopView = {
    setupEvents: function() {
        var a = this;
        a.on({
            "view:flyingAnimationComplete": a.onflyingAnimationComplete
        })
    },
    onflyingAnimationComplete: function() {
        var a = this;
        a.animationCounter.pop();
        if (a.animationCounter.length === 0) {
            a.fireEvent("view:animationComplete")
        }
    },
    initAnimations: function() {
        var a = this;
        a.setDuration = 550;
        a.numberAnimationItems = [];
        a.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(a.animationList);
        a.animationList.stop();
        a.animationCounter = []
    },
    configureNumberAnimation: function(n, i) {
        var k = this,
            d = i,
            m = d.winSituation,
            c = d.symbolConfig,
            o = d.pathConfig,
            j = o.length,
            e = m.sym,
            a = k.model.readData("lineConfig"),
            l = a[m.betline].FlyingNumberAngleValues,
            g, b;
        if (d.counter === 1) {
            k.animationCounter = []
        }
        k.animationCounter.push(m.betline);
        g = k.setDurationForAnimation(o, m);
        var f, h;
        if (m.dir === "right") {
            f = o[0].left;
            h = o[0].left
        } else {
            f = o[0].left + 50;
            h = o[0].left
        }
        n.prop.pivot.x = 0;
        n.prop.pivot.y = 0;
        n.prop.coinWin = m.wins.coins;
        n.prop.symbol = e;
        b = k.getTimePeriod(j, g);
        k.setFadeOperation(n, g);
        k.setScaleOperation(n, g);
        k.setRotateOperation(n, b, l, m);
        if (k.model.readData("winType") !== "bigWin" && j === 5) {
            k.applyOperationsFor5SymsWin(n, o, j, b, m, l, g, f, h)
        } else {
            k.setTranslateOperation(n, o, f)
        }
        if (j === 5 && (m.betline === 1 || m.betline === 2 || m.betline === 3)) {
            Animation.Operations.translatePath.applyDefaultValuesToOperation(n, 0.5)
        } else {
            Animation.Operations.translatePath.applyDefaultValuesToOperation(n, 0.7)
        }
        n.restore();
        k.applyTextFormat(e, c)
    },
    applyTextFormat: function(c, b) {
        var a = this;
        if (!Sys.isDefined(a.FLYING_NUMBER_IMAGES[c])) {
            a.FLYING_NUMBER_CONFIG.NUMBER_TEXT_OPERATIONS[0].fillStyle = b.fillColor;
            a.FLYING_NUMBER_CONFIG.NUMBER_TEXT_OPERATIONS[1].strokeStyle = b.strokeColor;
            a.FLYING_NUMBER_CONFIG.NUMBER_TEXT_OPERATIONS[1].lineWidth = b.lineWidth;
            a.FLYING_NUMBER_IMAGES[c] = Animation.utils.text.createNumberDrawingProperties(a.FLYING_NUMBER_CONFIG)
        }
    },
    setDurationForAnimation: function(b, c) {
        var d = this,
            a = b.length,
            e;
        if (a === 3) {
            d.setDuration = 550
        } else {
            if (a === 4) {
                d.setDuration = 430
            } else {
                if (a === 5) {
                    d.setDuration = 250
                }
            }
        }
        e = (a - 1) * d.setDuration;
        if (d.model.readData("winType") !== "bigWin" && a === 5) {
            e = (a - 1) * d.setDuration * 2 + d.setDuration
        }
        if (c.betline === 1 || c.betline === 2 || c.betline === 3) {
            if (a === 5) {
                b.splice(1, 1);
                b.splice(2, 1);
                b[1].left = (b[0].left + b[2].left) / 2;
                b[1].top = b[2].top;
                if (d.model.readData("winType") !== "bigWin") {
                    d.setDuration = e / 4
                } else {
                    d.setDuration = e / 2
                }
            } else {
                if (a === 4) {
                    b.splice(1, 1);
                    if (c.dir === "right") {
                        b[1].left = Math.abs(b[2].left + b[0].left) / 2
                    } else {
                        b[1].left = Math.abs(b[2].left - b[0].left) / 2
                    }
                    b[1].top = b[2].top;
                    d.setDuration = e / 2
                }
            }
        }
        return e
    },
    setFadeOperation: function(a, b) {
        a.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: b / 3,
            value: 1
        }, {
            time: 5 * b / 6,
            value: 1
        }, {
            time: b,
            value: 0
        }]
    },
    setScaleOperation: function(a, b) {
        a.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.5,
                scaleY: 0.5
            }
        }, {
            time: 2 * b / 8,
            value: {
                scaleX: 1,
                scaleY: 1
            }
        }, {
            time: 3 * b / 8,
            value: {
                scaleX: 1.1,
                scaleY: 1.1
            }
        }, {
            time: 4 * b / 8,
            value: {
                scaleX: 1.1,
                scaleY: 1.1
            }
        }, {
            time: 5 * b / 8,
            value: {
                scaleX: 0.7,
                scaleY: 0.7
            }
        }, {
            time: b,
            value: {
                scaleX: 0.5,
                scaleY: 0.5
            }
        }]
    },
    setRotateOperation: function(e, b, f, d) {
        var a, c = 4;
        e.prop.operations.rotate = [];
        for (a = 0; a < f.length; a++) {
            if (d.dir === "right") {
                if (f[a].length === 1) {
                    e.prop.operations.rotate.push({
                        time: b[a],
                        value: f[c][0]
                    })
                } else {
                    e.prop.operations.rotate.push({
                        time: b[a] - 100,
                        value: f[c][2]
                    });
                    e.prop.operations.rotate.push({
                        time: b[a],
                        value: f[c][1]
                    });
                    e.prop.operations.rotate.push({
                        time: b[a] + 100,
                        value: f[c][0]
                    })
                }
                c--
            } else {
                if (f[a].length === 1) {
                    e.prop.operations.rotate.push({
                        time: b[a],
                        value: f[a][0]
                    })
                } else {
                    e.prop.operations.rotate.push({
                        time: b[a] - 50,
                        value: f[a][0]
                    });
                    e.prop.operations.rotate.push({
                        time: b[a],
                        value: f[a][1]
                    });
                    e.prop.operations.rotate.push({
                        time: b[a] + 50,
                        value: f[a][2]
                    })
                }
            }
        }
    },
    applyOperationsFor5SymsWin: function(i, j, e, a, h, g, b, c, d) {
        var f = this;
        f.setFadeFor5SymWin(i, b);
        f.setScaleFor5SymWin(i, b);
        f.setTranslatePathFor5SymWin(i, j, e, a, h, g, c, d)
    },
    setFadeFor5SymWin: function(a, b) {
        a.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 0.5 * b / 6,
            value: 1
        }, {
            time: 5.5 * b / 6,
            value: 1
        }, {
            time: b,
            value: 0
        }]
    },
    setScaleFor5SymWin: function(a, b) {
        a.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.5,
                scaleY: 0.5
            }
        }, {
            time: b / 6,
            value: {
                scaleX: 0.8,
                scaleY: 0.8
            }
        }, {
            time: b / 3,
            value: {
                scaleX: 1.2,
                scaleY: 1.2
            }
        }, {
            time: b / 2,
            value: {
                scaleX: 1.2,
                scaleY: 1.2
            }
        }, {
            time: 5 * b / 6,
            value: {
                scaleX: 1,
                scaleY: 1
            }
        }, {
            time: b,
            value: {
                scaleX: 0.5,
                scaleY: 0.5
            }
        }]
    },
    setTranslatePathFor5SymWin: function(s, h, p, c, v, e, q, f) {
        var w = this,
            g, l, o, n, m, d = [],
            b = p,
            u = 1,
            a = 5,
            r = false,
            t = [1, 2, 3];
        for (o = 0; o < h.length; o++) {
            g = {
                time: 0,
                value: {
                    top: 0,
                    left: 0
                }
            };
            g.time = c[o];
            g.value.top = h[o].top;
            g.value.left = h[o].left;
            if (o === 0) {
                g.value.left = q
            }
            g.value.top = h[o].top;
            d.push(g)
        }
        if (t.indexOf(v.betline) > -1) {
            u = 2;
            a = 3;
            r = true
        }
        for (n = h.length - u, m = a; n >= 0; n--, m++) {
            g = {
                time: 0,
                value: {
                    top: 0,
                    left: 0
                }
            };
            g.time = (r) ? m * w.setDuration : c[m];
            g.value.top = h[n].top;
            g.value.left = h[n].left;
            if (n === 0) {
                g.value.left = f;
                g.fireEvent = {
                    event: "view:flyingAnimationComplete",
                    scope: w
                }
            }
            d.push(g)
        }
        for (l = p - 1; l >= 0; l--) {
            if (e[l].length === 1) {
                s.prop.operations.rotate.push({
                    time: c[b],
                    value: e[l][0]
                })
            } else {
                s.prop.operations.rotate.push({
                    time: c[b] - 100,
                    value: e[l][2]
                });
                s.prop.operations.rotate.push({
                    time: c[b],
                    value: e[l][1]
                });
                s.prop.operations.rotate.push({
                    time: c[b] + 100,
                    value: e[l][0]
                })
            }
            b++
        }
        s.prop.operations.translatePath = d
    },
    setTranslateOperation: function(f, a, d) {
        var e = this,
            g, b, c = [];
        for (b = 0; b < a.length; b++) {
            g = {
                time: 0,
                value: {
                    top: 0,
                    left: 0
                }
            };
            g.time = b * e.setDuration;
            g.value.top = a[b].top;
            g.value.left = a[b].left;
            if (b === 0) {
                g.value.left = d - 25
            }
            if (b === a.length - 1) {
                g.fireEvent = {
                    event: "view:flyingAnimationComplete",
                    scope: e
                }
            }
            c.push(g)
        }
        f.prop.operations.translatePath = c
    },
    getTimePeriod: function(b, c) {
        var a;
        if (b === 3) {
            a = [0, c / 2, c]
        } else {
            if (b === 4) {
                a = [0, c / 3, 2 * c / 3, c]
            } else {
                if (b === 5) {
                    a = [0, c / 9, 2 * c / 9, c / 3, 4 * c / 9, 5 * c / 9, 2 * c / 3, 7 * c / 9, 8 * c / 9, c]
                }
            }
        }
        return a
    }
};
SB.SymbolFlyingAnimationDesktopView = Sys.extend(SB.SymbolFlyingAnimationView, SB.SymbolFlyingAnimationDesktopView, "SB.SymbolFlyingAnimationDesktopView");
Sys.ns("SB");
SB.BigWinModel = {
    SUPPORTED_SUB_TYPES: ["bigWin", "megaWin", "superMegaWin"],
    SUB_TYPE_LIMITS: {
        bigWin: {
            from: 0,
            to: 30
        },
        megaWin: {
            from: 30,
            to: 60
        },
        superMegaWin: {
            from: 60
        }
    },
    COUNT_UP_DURATIONS: {
        bigWin: 6000,
        megaWin: 7000,
        superMegaWin: 9000
    },
    SHOW_TOTAL_DURATION: 3000,
    SHOW_ALL_WINS_DURATION: 1000,
    COUNT_UP_DURATIONS_FACTOR: {
        bigWin: 0.5,
        megaWin: 0.1,
        superMegaWin: 0.15
    },
    MIN_BIGWIN_DURATION: 7500,
    WIN_TYPE_TIME_LIMIT: {
        bigWin: 0,
        megaWin: 3500,
        superMegaWin: 6000
    },
    processServerResponse: function(e) {
        var c = this,
            b, d, a;
        c.storeData("serverResponse", e);
        c.storeData("startingNextSpin", false);
        if (Sys.isDefined(e.wins) && e.wins.winType === "bigWin") {
            b = e.wins.coins;
            c.storeData("coinWin", b);
            c.determineWinType(b);
            c.setState("animationRequested");
            d = e.clientaction;
            a = e.nextaction;
            c.storeData("inBasicSpin", a === "spin" ? !!(d === "respin" || d === "spin") : false);
            c.storeData("showAllWins", c.shouldShowAllWins(e));
            c.storeData("showWinAnimations", true);
            c.storeData("nextSpinType", a);
            c.storeWinningSymbols(e)
        } else {
            c.storeData("coinWin", 0);
            c.storeData("winType", undefined);
            c.setState("idle")
        }
    },
    storeWinningSymbols: function(h) {
        var d = this,
            c = h.reelInfo,
            g, f, e, b = [],
            a;
        if (h.wins && Sys.isArray(h.wins.winSituations)) {
            Sys.each(h.wins.winSituations, function(i) {
                Sys.each(i.positions, function(j) {
                    g = j.reelIndex;
                    f = j.symbolIndex;
                    if (c[g].overlaySymbols[f]) {
                        a = c[g].overlaySymbols[f]
                    } else {
                        a = c[g].symbols[f]
                    }
                    e = {
                        x: g,
                        y: f,
                        symbol: a
                    };
                    b.push(e)
                })
            })
        }
        d.storeData("winningSymbols", b)
    },
    getWinCountUpDuration: function() {
        var h = this,
            b, a, j, c, f = Services.moneyManager.getBetCoins(),
            e = h.COUNT_UP_DURATIONS_FACTOR.bigWin,
            d = h.COUNT_UP_DURATIONS_FACTOR.megaWin,
            g = h.COUNT_UP_DURATIONS_FACTOR.superMegaWin,
            i = h.readData("coinWin") / f;
        a = e * Math.min(i, h.SUB_TYPE_LIMITS.bigWin.to);
        a = Math.min(a, 7.5);
        j = Math.max(0, d * Math.min(i - h.SUB_TYPE_LIMITS.megaWin.from, h.SUB_TYPE_LIMITS.megaWin.from));
        j = Math.min(j, 3);
        c = Math.max(0, g * (i - h.SUB_TYPE_LIMITS.superMegaWin.from));
        c = Math.min(c, 7);
        b = (a + j + c) * 1000;
        return b
    },
    isAutoPlayMode: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            b = Sys.isDefined(a) && a > 0;
        return b
    },
    shouldToggleWins: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            b = Sys.isDefined(a) && a > 0;
        return !b && !this.readData("togglePreventedByFreeSpins") && !this.readData("startingNextSpin")
    }
};
SB.BigWinModel = Sys.extend(Game.Slots.BigWinModel, SB.BigWinModel, "SB.BigWinModel");
Sys.ns("SB");
SB.BigWinView = {
    TEXT_OPERATIONS: [{
        fillStyle: {
            type: "linearGradient",
            linearGradient: [0, 0, 0, 120],
            colorStop: [{
                pos: 0,
                rgb: "#fffbe8"
            }, {
                pos: 1,
                rgb: "#ffbe9b"
            }]
        }
    }, {
        lineWidth: 3,
        strokeStyle: "#9d42ef",
        drawType: "stroke"
    }],
    FONT: "130px BauhausRegular",
    TEXT_OFFSET: 0,
    TEXT_TOP: 180,
    TEXT_LEFT: undefined,
    CLOUD_IMAGES: ["bigWinblueCloud", "bigWinGreenCloud", "bigWinPurpleCloud", "bigWinYellowCloud"],
    TEXT_COLOR_BEND: [{
        time: 0,
        value: {
            colorStop: {
                start: {
                    r: 255,
                    g: 251,
                    b: 232
                },
                end: {
                    r: 255,
                    g: 190,
                    b: 155
                }
            },
            stroke: {
                r: 157,
                g: 66,
                b: 239
            }
        }
    }, {
        time: 200,
        value: {
            colorStop: {
                start: {
                    r: 241,
                    g: 253,
                    b: 255
                },
                end: {
                    r: 130,
                    g: 236,
                    b: 255
                }
            },
            stroke: {
                r: 17,
                g: 159,
                b: 72
            }
        }
    }, {
        time: 400,
        value: {
            colorStop: {
                start: {
                    r: 246,
                    g: 255,
                    b: 218
                },
                end: {
                    r: 190,
                    g: 251,
                    b: 9
                }
            },
            stroke: {
                r: 110,
                g: 146,
                b: 1
            }
        }
    }, {
        time: 600,
        value: {
            colorStop: {
                start: {
                    r: 253,
                    g: 243,
                    b: 255
                },
                end: {
                    r: 245,
                    g: 188,
                    b: 255
                }
            },
            stroke: {
                r: 191,
                g: 59,
                b: 213
            }
        }
    }, {
        time: 800,
        value: {
            colorStop: {
                start: {
                    r: 255,
                    g: 243,
                    b: 242
                },
                end: {
                    r: 255,
                    g: 187,
                    b: 181
                }
            },
            stroke: {
                r: 255,
                g: 60,
                b: 42
            }
        }
    }, {
        time: 1000,
        value: {
            colorStop: {
                start: {
                    r: 255,
                    g: 253,
                    b: 213
                },
                end: {
                    r: 240,
                    g: 228,
                    b: 1
                }
            },
            stroke: {
                r: 136,
                g: 129,
                b: 1
            }
        }
    }, {
        time: 1200,
        value: {
            colorStop: {
                start: {
                    r: 255,
                    g: 253,
                    b: 213
                },
                end: {
                    r: 240,
                    g: 228,
                    b: 1
                }
            },
            stroke: {
                r: 136,
                g: 129,
                b: 1
            }
        },
        goTo: 0
    }],
    calculateMaxScaleFactorForText: function(c) {
        var d = 1.5,
            b = 1050,
            a = b / c.prop.width;
        if (a > d) {
            a = d
        }
        return a
    },
    configureTextAnimation: function(c) {
        var b = this,
            d = b.calculateMaxScaleFactorForText(c),
            a = d > 1 ? 1 : d;
        c.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 300,
            value: 1
        }, {
            time: 2000,
            value: 1,
            goTo: 1
        }];
        c.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }, {
            time: 300,
            value: {
                scaleX: a,
                scaleY: a
            }
        }, {
            time: 6000,
            value: {
                scaleX: d,
                scaleY: d
            }
        }]
    },
    configureSwitchAnimation: function(c) {
        var b = this,
            d = b.calculateMaxScaleFactorForText(c),
            a = d > 1 ? 1 : d;
        c.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: a,
                scaleY: a
            }
        }, {
            time: 200,
            value: {
                scaleX: d,
                scaleY: d
            }
        }];
        c.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: 200,
            value: 0
        }]
    },
    configureTextEndingAnimation: function(a, b) {
        a.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: this.model.readData("showTotalDuration") - 200,
            value: 1
        }, {
            time: this.model.readData("showTotalDuration"),
            value: 0,
            fireEvent: {
                event: "view:bigWinTextEndAnimationFinished",
                scope: this
            }
        }];
        a.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: b,
                scaleY: b
            }
        }, {
            time: this.model.readData("showTotalDuration") - 200,
            value: {
                scaleX: b,
                scaleY: b
            }
        }, {
            time: this.model.readData("showTotalDuration"),
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }];
        a.restore()
    },
    constructor: function() {
        SB.BigWinView.superclass.constructor.apply(this, arguments);
        this.typeOfColorIndex = -1
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "view:bigWinTextEndAnimationFinished": a.bigWinTextEndAnimationFinished
        })
    },
    bigWinTextEndAnimationFinished: function() {
        var b = this.model.readData("animations");
        var a = b[0];
        Sys.iterate(a, function(c) {
            a[c].stop()
        })
    },
    initBigWinAnimations: function() {
        var a = this.model.readData("animations");
        Sys.each(a, function(b) {
            Sys.iterate(b, function(c) {
                if (c !== "burst_container" && c !== "BgGlow_container") {
                    Sys.each(b[c].items, function(d) {
                        d.prop.globalCompositeOperation = "lighter"
                    })
                }
                Game.stage.view.addToRenderLoop(b[c]);
                b[c].stop()
            })
        })
    },
    show: function() {
        var b = this,
            d, c = b.model.readData("coinWin");
        if (Platform.isDesktopDevice) {
            d = b.model.getWinCountUpDuration() < 9000 ? b.model.getWinCountUpDuration() : 9000
        } else {
            d = b.model.COUNT_UP_DURATIONS[b.model.readData("winType")]
        }
        b.doAnimation(0, c, d);
        b.playAudio("bigWinStart");
        b.fireEvent("view:playAudio", {
            name: "bigWinLoop",
            id: "bigWinLoop",
            loop: true
        });
        var e = this.model.readData("animations");
        var a = e[0];
        Sys.iterate(a, function(f) {
            a[f].play()
        })
    },
    createTextAnimation: function(e) {
        var c = this,
            f = Environment.getStageResolution(),
            d = c.createText(e),
            b = d.width,
            a = d.height;
        return new Animation.CanvasAnimationItem({
            width: b,
            height: a,
            top: c.TEXT_TOP * c.scaleFactor,
            left: Sys.isDefined(c.TEXT_LEFT) ? c.TEXT_LEFT * c.scaleFactor : (f.width - b) / 2,
            opacity: 1,
            depth: Layering.Game.Slots.BigWin.text,
            image: d,
            operations: {
                textColorBlend: c.TEXT_COLOR_BEND
            },
            text: e,
            executeBefore: function() {
                var j = this,
                    g = j.colorConfig,
                    l = c.getSupportedRGB(g.colorStop.start),
                    i = c.getSupportedRGB(g.colorStop.end),
                    k = c.getSupportedRGB(g.stroke),
                    h = [{
                        fillStyle: {
                            type: "linearGradient",
                            linearGradient: [0, 0, 0, 120],
                            colorStop: [{
                                pos: 0,
                                rgb: l
                            }, {
                                pos: 1,
                                rgb: i
                            }]
                        }
                    }, {
                        lineWidth: 3,
                        strokeStyle: k,
                        drawType: "stroke"
                    }];
                j.image = Animation.utils.text.createText(e, c.FONT, c.TEXT_OFFSET, h)
            }
        })
    },
    getSupportedRGB: function(b) {
        var a = "rgb(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + ")";
        return a
    },
    finish: function() {
        var c = this,
            a = c.animations[c.model.readData("winType") + "End"],
            b = c.animations[c.model.readData("winType")],
            d = Sys.isDefined(b.prop.scaleX) && b.prop.scaleX > 1 ? b.prop.scaleX : c.calculateMaxScaleFactorForText(a);
        c.configureTextEndingAnimation(a, d);
        SB.BigWinView.superclass.finish.apply(this, arguments)
    },
    showWinText: function(c) {
        var e = this,
            d = e.currentlyShowingWin,
            a = e.animations[d + "Switch"],
            b = Sys.isArray(e.animations[c]) ? e.animations[c] : [e.animations[c]];
        Sys.each(b, function(f) {
            e.configureTextAnimation(f, c)
        });
        e.list.stop();
        if (Sys.isDefined(d) && Sys.isDefined(a)) {
            e.configureSwitchAnimation(a);
            a = Sys.isArray(a) ? a : [a];
            b = b.concat(a)
        }
        e.currentlyShowingWin = c;
        e.list.play(b);
        e.playAudio(c);
        e.remainingWinTypes.splice(e.remainingWinTypes.indexOf(c), 1)
    },
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.FONT = "130px SBMyroidProBold"
        }
        SB.BigWinView.superclass.initAnimations.apply(b, arguments)
    }
};
SB.BigWinView = Sys.extend(Game.Slots.BigWinView, SB.BigWinView, "SB.BigWinView");
Sys.ns("SB");
SB.BigWinDesktopView = {
    BURST_IMAGE: {
        width: 1280,
        height: 720,
        sprite: "BigWinBurst"
    },
    TEXT_OPERATIONS: [{
        fillStyle: {
            type: "linearGradient",
            linearGradient: [0, 50, 0, 150],
            colorStop: [{
                pos: 0,
                rgb: "#ffffff"
            }, {
                pos: 0.5,
                rgb: "#fed49e"
            }, {
                pos: 1,
                rgb: "#fdb181"
            }]
        }
    }, {
        lineJoin: "round",
        lineWidth: 16,
        strokeStyle: "#7730a8",
        drawType: "stroke"
    }, {
        globalCompositeOperation: "destination-out"
    }, {
        drawType: "fill"
    }, {
        lineWidth: 7,
        strokeStyle: "#9a52c2",
        drawType: "stroke"
    }, {
        globalCompositeOperation: "source-over"
    }, {
        drawType: "fill"
    }, {
        lineWidth: 3,
        strokeStyle: "#9a52c2",
        drawType: "stroke"
    }],
    TEXT_OFFSET: 8,
    MAX_SCALE: 1.8,
    BIG_WIN_SCALING_DELTA: 0.3,
    MEGA_WIN_SCALING_DELTA: 0.3,
    SUPER_MEGA_WIN_SCALING_DELTA: 0.3,
    MAX_WIDTH: 1100,
    BIG_WIN_TEXT_BLENDING: {
        time: [0, 3, 15, 23, 27, 32, 39, 46, 53, 60, 67, 75, 81, 88, 95, 102, 109, 116, 123, 130, 136, 144, 151, 158, 165, 172, 179, 183, 187, 194, 202, 207, 212, 219, 226, 234, 241, 248, 256, 261, 266, 268, 270],
        colorstop: [{
            r: 10,
            g: 151,
            b: 150
        }, {
            r: 38,
            g: 38,
            b: 38
        }, {
            r: 38,
            g: 38,
            b: 38
        }, {
            r: 10,
            g: 10,
            b: 10
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: 50,
            b: 50
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: 18,
            g: 36,
            b: -18
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 38,
            g: 38,
            b: 38
        }, {
            r: 10,
            g: 10,
            b: 10
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -27,
            g: 55,
            b: -27
        }, {
            r: -38,
            g: 77,
            b: -38
        }, {
            r: -50,
            g: 100,
            b: -50
        }]
    },
    MEGA_WIN_TEXT_BLENDING: {
        time: [0, 7, 13, 20, 27, 34, 41, 48, 55, 63, 66, 74, 81, 88, 95, 102, 109, 116, 119, 122, 129, 136, 144, 151, 158, 166, 171, 176, 178, 180],
        colorstop: [{
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: 50,
            b: 50
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: 18,
            g: 36,
            b: -18
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -27,
            g: 55,
            b: -27
        }, {
            r: -38,
            g: 77,
            b: -38
        }, {
            r: -50,
            g: 100,
            b: -50
        }]
    },
    SUPER_MEGA_WIN_TEXT_BLENDING: {
        time: [0, 7, 12, 17, 22, 29, 36, 44, 51, 58, 66, 71, 76, 78, 80],
        colorstop: [{
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 38,
            g: 38,
            b: 38
        }, {
            r: 10,
            g: 10,
            b: 10
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: -50,
            g: 100,
            b: -50
        }, {
            r: -50,
            g: 50,
            b: 255
        }, {
            r: 50,
            g: 0,
            b: 100
        }, {
            r: 150,
            g: -50,
            b: -50
        }, {
            r: 0,
            g: 0,
            b: 0
        }, {
            r: 50,
            g: 100,
            b: -50
        }, {
            r: -27,
            g: 55,
            b: -27
        }, {
            r: -38,
            g: 77,
            b: -38
        }, {
            r: -50,
            g: 100,
            b: -50
        }]
    },
    calculateMaxScaleFactorForText: function(c) {
        var d = this.MAX_SCALE,
            b = this.MAX_WIDTH,
            a = b / c.prop.width;
        if (a > d) {
            a = d
        }
        return a
    },
    initAnimations: function() {
        var a = this;
        SB.BigWinDesktopView.superclass.initAnimations.apply(a, arguments);
        a.animations.megaWin.prop.operations.textColorBlendDesktop = a.configureMegaWinTextColor();
        a.animations.superMegaWin.prop.operations.textColorBlendDesktop = a.configureSuperMegaWinTextColor();
        a.list.stop()
    },
    showWinText: function(c) {
        var e = this,
            d = e.currentlyShowingWin,
            a = e.animations[d + "Switch"],
            b = Sys.isArray(e.animations[c]) ? e.animations[c] : [e.animations[c]];
        Sys.each(b, function(f) {
            e.configureTextAnimation(f, c)
        });
        e.list.stop();
        if (Sys.isDefined(d) && Sys.isDefined(a)) {
            e.configureSwitchAnimation(a);
            a = Sys.isArray(a) ? a : [a];
            b = b.concat(a)
        }
        e.currentlyShowingWin = c;
        e.list.play(b);
        e.playAudio(c);
        e.remainingWinTypes.splice(e.remainingWinTypes.indexOf(c), 1)
    },
    doAnimation: function(e, d, c) {
        var b = this,
            a = {
                from: e,
                to: d,
                duration: c,
                fireEventsOnTime: []
            };
        b.remainingWinTypes = [];
        Sys.iterate(b.model.readData("winTypeCoinLimits"), function(f, g) {
            if (g <= d) {
                b.remainingWinTypes.push(f);
                a.fireEventsOnTime.push({
                    value: b.model.WIN_TYPE_TIME_LIMIT[f],
                    event: "view:showWinText",
                    argument: f,
                    scope: b
                })
            }
        });
        b.currentlyShowingWin = undefined;
        b.fireEvent("view:startCountUp", a)
    },
    finish: function(c) {
        var d = this,
            a = d.animations[d.model.readData("winType") + "End"],
            b = d.animations[d.model.readData("winType")],
            e = d.remainingWinTypes.length - 1,
            f = Sys.isDefined(b.prop.scaleX) && b.prop.scaleX > 1 ? b.prop.scaleX : d.calculateMaxScaleFactorForText(a);
        d.configureTextEndingAnimation(a, f, c);
        d.list.stop();
        d.fireEvent("view:stopAudio", "bigWinLoop");
        d.list.play(a);
        d.fireEvent("view:stopAudio", "bigWin");
        d.playAudio(d.remainingWinTypes[e]);
        d.playAudio("bigWinEnd");
        d.playAudio("bigWinLoopEnd");
        d.fireEvent("view:showTotalInCountUp", c)
    },
    configureTextEndingAnimation: function(d, h, a) {
        var c = this,
            g, f, b, e;
        g = c.calculateMaxScaleFactorForText(d);
        e = c.calculateScaleParameters(g);
        h = g - e.scaleDelta;
        b = e.scaleDelta;
        f = a ? this.model.readData("showTotalDuration") : 600;
        d.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: f - 400,
            value: 1
        }, {
            time: f - 200,
            value: 0
        }, {
            time: f,
            value: 0,
            fireEvent: {
                event: "view:bigWinTextEndAnimationFinished",
                scope: this
            }
        }];
        d.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: h,
                scaleY: h
            }
        }, {
            time: f - 600,
            value: {
                scaleX: h,
                scaleY: h
            }
        }, {
            time: f - 400,
            value: {
                scaleX: h + b,
                scaleY: h + b
            }
        }, {
            time: f - 200,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }];
        d.restore()
    },
    calculateScaleParameters: function(b) {
        var a = {};
        if (b <= 1.8 && b > 1.4) {
            a.scaleDelta = 0.3;
            a.startingScaling = b - 0.5
        } else {
            if (b <= 1.4 && b > 1.2) {
                a.scaleDelta = 0.2;
                a.startingScaling = b - 0.4
            } else {
                if (b <= 1.2) {
                    a.scaleDelta = 0.1;
                    a.startingScaling = b - 0.2
                }
            }
        }
        return a
    },
    configureTextAnimation: function(d, a) {
        var c = this,
            g, b, f, e;
        g = c.calculateMaxScaleFactorForText(d);
        f = c.calculateScaleParameters(g);
        g = g - f.scaleDelta;
        e = c.MAX_WIDTH / d.prop.width;
        b = f.startingScaling;
        d.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 300,
            value: 1
        }, {
            time: 2000,
            value: 1,
            goTo: 1
        }];
        if (a === "bigWin") {
            d.prop.operations.scale = [{
                time: 0,
                value: {
                    scaleX: e,
                    scaleY: e
                }
            }, {
                time: 150,
                value: {
                    scaleX: b,
                    scaleY: b
                }
            }, {
                time: 8000,
                value: {
                    scaleX: g,
                    scaleY: g
                }
            }]
        } else {
            d.prop.operations.scale = [{
                time: 0,
                value: {
                    scaleX: 0,
                    scaleY: 0
                }
            }, {
                time: 300,
                value: {
                    scaleX: b,
                    scaleY: b
                }
            }, {
                time: 8000,
                value: {
                    scaleX: g,
                    scaleY: g
                }
            }]
        }
    },
    createBigWinBurstAnimation: function() {
        var d = this,
            b = this.BURST_IMAGE,
            c = 1000 / 30,
            a = Resources.readData("spriteConfigurations").bigWinBurst,
            e = Game.stage.view.animationManager.getSpriteSequence("bigWinBurstAnimation");
        return new Animation.CanvasAnimationItem({
            left: 0,
            top: 0,
            width: b.width,
            height: b.height,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            totalSpriteHeight: a.totalSpriteHeight,
            image: b.sprite,
            spriteArray: e,
            depth: Layering.Game.Slots.BigWin.burst_container,
            globalCompositeOperation: "lighter",
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: c * 3,
                    value: 0
                }, {
                    time: c * 4,
                    value: 1
                }, {
                    time: c * 40,
                    value: 1,
                    fireEvent: {
                        event: "view:showBigWinText",
                        scope: d
                    }
                }, {
                    time: c * 60,
                    value: 0,
                    fireEvent: {
                        event: "view:burstAnimationFinished",
                        scope: d
                    }
                }],
                sprite: [{
                    time: c * 4,
                    value: 0
                }, {
                    time: a.duration,
                    value: e.length - 1
                }]
            }
        })
    },
    show: function() {
        var c = this,
            e, b = 7500,
            d = c.model.readData("coinWin");
        if (Platform.isDesktopDevice) {
            e = c.model.getWinCountUpDuration() < b ? c.model.getWinCountUpDuration() : b
        } else {
            e = c.model.COUNT_UP_DURATIONS[c.model.readData("winType")]
        }
        c.doAnimation(0, d, e);
        c.playAudio("bigWinStart");
        c.fireEvent("view:playAudio", {
            name: "bigWinLoop",
            id: "bigWinLoop",
            loop: true
        });
        var f = this.model.readData("animations");
        var a = f[0];
        Sys.iterate(a, function(g) {
            a[g].play()
        });
        c.burstlist.play();
        c.animateAllWinningSymbols()
    },
    createTextAnimation: function(g) {
        var d = this,
            h = Environment.getStageResolution(),
            f = d.createText(g),
            c = f.width,
            a = f.height,
            e = Sys.isDefined(d.TEXT_LEFT) ? d.TEXT_LEFT * d.scaleFactor : (h.width - c) / 2;
        var b = [];
        b = d.createTextColorBlendOperation(d.BIG_WIN_TEXT_BLENDING);
        return new Animation.CanvasAnimationItem({
            width: c,
            height: a,
            top: d.TEXT_TOP * d.scaleFactor,
            left: e,
            opacity: 1,
            depth: Layering.Game.Slots.BigWin.text,
            image: f,
            operations: {
                textColorBlendDesktop: b
            },
            executeBefore: function() {
                var v = this,
                    u = v.colorConfig,
                    k = u.colorStop.r,
                    j = u.colorStop.g,
                    s = u.colorStop.b,
                    m, t;
                var o, l;
                o = document.createElement("canvas");
                l = o.getContext("2d");
                o.width = c;
                o.height = a;
                var r = f;
                l.drawImage(r, 0, 0, c, a);
                m = l.getImageData(0, 0, c, a);
                t = m.data;
                for (var q = 0, p = t.length; q < p; q += 4) {
                    t[q] = d.rgbLimitCheck(t[q] + k);
                    t[q + 1] = d.rgbLimitCheck(t[q + 1] + j);
                    t[q + 2] = d.rgbLimitCheck(t[q + 2] + s)
                }
                l.putImageData(m, 0, 0);
                v.image = o
            }
        })
    },
    rgbLimitCheck: function(a) {
        var b;
        b = a > 255 ? 255 : a;
        b = b < 0 ? 0 : b;
        return b
    },
    configureMegaWinTextColor: function() {
        var b, a = this;
        b = a.createTextColorBlendOperation(a.MEGA_WIN_TEXT_BLENDING);
        return b
    },
    configureSuperMegaWinTextColor: function() {
        var b, a = this;
        b = a.createTextColorBlendOperation(a.SUPER_MEGA_WIN_TEXT_BLENDING);
        return b
    },
    createTextColorBlendOperation: function(c) {
        var b = [],
            e = 1000 / 30;
        for (var d = 0; d < c.time.length; d++) {
            var a = {},
                f = {};
            a.time = c.time[d] * e;
            f.colorStop = c.colorstop[d];
            a.value = f;
            b.push(a)
        }
        return b
    },
    initBigWinAnimations: function() {
        var c = this.model.readData("animations"),
            b = ["yellowcloud_01", "whitecloud_pulse", "colorcloud_new1", "colorcloud_new2", "whitecloud"];
        var a = this;
        a.burstlist = new Animation.CanvasAnimationList({});
        a.burstlist.add(a.createBigWinBurstAnimation());
        Game.stage.view.addToRenderLoop(a.burstlist);
        a.burstlist.stop();
        a.initSymbolAnimations();
        Sys.each(c, function(d) {
            Sys.iterate(d, function(e) {
                if (b.indexOf(e) !== -1) {
                    Sys.each(d[e].items, function(f) {
                        f.prop.globalCompositeOperation = "overlay"
                    })
                } else {
                    if (e === "symbol_glow") {
                        Sys.each(d[e].items, function(f) {
                            f.prop.globalCompositeOperation = "lighten"
                        })
                    } else {
                        if (e === "colorcloud_new" || e === "whitecloud_burst" || e === "yellowcloud_02") {
                            Sys.each(d[e].items, function(f) {
                                f.prop.globalCompositeOperation = "lighter"
                            })
                        }
                    }
                }
                Game.stage.view.addToRenderLoop(d[e]);
                d[e].stop()
            })
        })
    },
    initSymbolAnimations: function() {
        var c = this,
            d = Game.stage.model.getCurrentReelGroupConfiguration(),
            a = d.symbolCols,
            b = d.symbolRows;
        c.symbolAnimationItems = Sys.utils.init2dMatrix(a, b);
        c.symbolAnimationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.symbolAnimationList);
        c.symbolAnimationList.stop()
    },
    animateAllWinningSymbols: function() {
        this.animateSymbols(this.model.readData("winningSymbols"), this.configureItemForAllWinningSymbolsDisplay)
    },
    animateSymbols: function(b, c) {
        var e = this,
            a, f, d;
        e.symbolAnimationList.restore();
        e.symbolAnimationList.stop();
        Sys.each(b, function(g) {
            a = g.x;
            f = g.y;
            if (Sys.isDefined(e.symbolAnimationItems[a][f])) {
                d = e.symbolAnimationItems[a][f]
            } else {
                d = new Animation.CanvasAnimationItem({});
                e.symbolAnimationList.add(d);
                e.symbolAnimationItems[a][f] = d
            }
            c.call(e, d, g);
            d.play()
        })
    },
    configureItemForAllWinningSymbolsDisplay: function(d, a) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        b.symbolGlowAnimation(d, a);
        d.restore()
    },
    symbolGlowAnimation: function(d, b) {
        var a = 1,
            c = 1000 / 30;
        Sys.applyProperties(d.prop, {
            image: b.symbol,
            depth: Layering.Game.Slots.WinningSymbols.animationItems + 2,
            executeBefore: function(e) {
                e.globalCompositeOperation = "lighter"
            },
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 60 * c,
                    value: a
                }, {
                    time: 280 * c,
                    value: a
                }, {
                    time: 281 * c,
                    value: 0
                }]
            }
        })
    },
    bigWinTextEndAnimationFinished: function() {
        var b = this,
            c = this.model.readData("animations"),
            a = c[0];
        Sys.iterate(a, function(d) {
            a[d].stop()
        });
        b.burstlist.stop();
        b.symbolAnimationList.stop()
    }
};
SB.BigWinDesktopView = Sys.extend(SB.BigWinView, SB.BigWinDesktopView, "SB.BigWinDesktopView");
Sys.ns("SB");
SB.BigWinController = {
    constructor: function() {
        SB.BigWinController.superclass.constructor.apply(this, arguments);
        this.loadAnimations()
    },
    setupEvents: function() {
        var a = this;
        SB.BigWinController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:bigWin.storeBigWinAnimation": a.initBigWinAnimations,
            "view:burstAnimationFinished": a.burstAnimationFinished,
            "notify:winAnimations.showingWinAnimations": a.handleWaitRequest,
            "notify:stateHandler.enteringSpinningState": a.spinStarted,
            "notify:spin.AllIsStopped": a.spinStopped
        });
        if (Platform.isDesktopDevice) {
            a.on({
                "view:showBigWinText": a.showBigWinText,
                "notify:winBanner.animate": a.handleWaitRequest,
                "notify:winAnimations.winAnimationsFinished": a.allWinAnimationComplete,
                "notify:winBanner.animationComplete": a.winBannerAnimationComplete,
                "notify:spinButton.down": a.onSpinButtonDown
            })
        }
    },
    spinStarted: function() {
        this.isSpinStarted = true
    },
    spinStopped: function() {
        this.isSpinStarted = false
    },
    initBigWinAnimations: function(c) {
        var b = this.model,
            a, d;
        if (Sys.isArray(c)) {
            Sys.each(c, function(e) {
                d = Sys.apply(d, e)
            })
        } else {
            if (Sys.isObj(c)) {
                d = Sys.apply(d, c)
            }
        }
        a = b.readData("animations") || [];
        a.push(d);
        b.storeData("animations", a);
        this.view.initBigWinAnimations()
    },
    loadAnimations: function() {
        var a = this.getAnimationsConfigToCreate();
        this.fireEvent("request:cutOutAnimation.setupAnimation", {
            cfg: a,
            endEvent: "request:bigWin.storeBigWinAnimation"
        })
    },
    getAnimationsConfigToCreate: function() {
        var b = this,
            a;
        if (Platform.isDesktopDevice) {
            a = [{
                name: "symbol_glow",
                depth: Layering.Game.Slots.BigWin.symbolGlow,
                ownOpacity: 0.4,
                baseCfg: {
                    id: "symbol_glow",
                    left: 130,
                    top: 35,
                    ownOpacity: 0.4
                }
            }, {
                name: "whitecloud",
                depth: Layering.Game.Slots.BigWin.white_pulse,
                baseCfg: {
                    id: "whitecloud",
                    left: 0,
                    top: 0
                }
            }, {
                name: "whitecloud_burst",
                depth: Layering.Game.Slots.BigWin.white_burst,
                baseCfg: {
                    id: "whitecloud",
                    left: 0,
                    top: 0
                }
            }, {
                name: "colorcloud_new",
                depth: Layering.Game.Slots.BigWin.colored_cloud,
                ownOpacity: 0.4,
                baseCfg: {
                    id: "colorcloud_new",
                    left: 0,
                    top: 0,
                    ownOpacity: 0.4
                }
            }, {
                name: "colorcloud_new1",
                depth: Layering.Game.Slots.BigWin.colored_cloud1,
                baseCfg: {
                    id: "colorcloud_new1",
                    left: 0,
                    top: 0
                }
            }, {
                name: "colorcloud_new2",
                depth: Layering.Game.Slots.BigWin.colored_cloud2,
                ownOpacity: 0.2,
                baseCfg: {
                    id: "colorcloud_new2",
                    left: 0,
                    top: 0,
                    ownOpacity: 0.2
                }
            }, {
                name: "whitecloud_pulse",
                depth: Layering.Game.Slots.BigWin.white_pulse,
                ownOpacity: 0.2,
                baseCfg: {
                    id: "whitecloud_pulse",
                    left: 0,
                    top: 0,
                    ownOpacity: 0.2
                }
            }, {
                name: "yellowcloud_01",
                depth: Layering.Game.Slots.BigWin.yellowCloud,
                baseCfg: {
                    id: "yellowcloud_01",
                    left: 0,
                    top: 0
                }
            }, {
                name: "yellowcloud_02",
                depth: Layering.Game.Slots.BigWin.yellowCloud1,
                baseCfg: {
                    id: "yellowcloud_02",
                    left: 0,
                    top: 0
                }
            }]
        } else {
            a = [{
                name: "BgGlow_container",
                depth: Layering.Game.Background.image + 1,
                baseCfg: {
                    id: "BgGlow_container",
                    fullScreen: true
                }
            }, {
                name: "burst_container",
                depth: Layering.Game.Slots.BigWin.burst_container,
                events: [{
                    onFrame: "end",
                    event: "view:burstAnimationFinished",
                    scope: b.view
                }],
                baseCfg: {
                    id: "burst_container",
                    left: 0,
                    top: 0
                }
            }, {
                name: "BigWinCloudBurst_container",
                depth: Layering.Game.Slots.BigWin.white_cloud,
                baseCfg: {
                    id: "BigWinCloudBurst_container",
                    left: 0,
                    top: 0,
                    ownOpacity: 1
                }
            }, {
                name: "BigWinCloudPulse_container",
                depth: Layering.Game.Slots.BigWin.white_pulse,
                baseCfg: {
                    id: "BigWinCloudPulse_container",
                    left: 0,
                    top: 0,
                    ownOpacity: 0.5
                }
            }, {
                name: "colorcloud",
                depth: Layering.Game.Slots.BigWin.colored_cloud,
                fullScreen: true,
                baseCfg: {
                    id: "colorcloud",
                    fullScreen: true,
                    ownOpacity: 1
                }
            }]
        }
        return a
    },
    showBigWinText: function() {
        var a = this;
        if (!a.model.readData("isAborted")) {
            a.view.showWinText("bigWin")
        }
    },
    showSymbolBurst: function() {
        this.fireEvent("request:symbolBurst.showBurst")
    },
    burstAnimationFinished: function() {
        var a = this;
        if (a.model.isState("showing")) {
            if (!Platform.isDesktopDevice) {
                a.view.showWinText("bigWin")
            }
            a.fireEvent("request:audioPlayer.play", {
                name: "bigWinAmbienceSnd",
                id: "bigWinAmbienceSnd"
            });
            a.fireEvent("request:symbolBurst.showBurst")
        }
    },
    show: function() {
        if (Platform.isDesktopDevice) {
            this.fireEvent("request:dimmedSymbols.dimNoWinSymbols")
        }
        SB.BigWinController.superclass.show.apply(this, arguments);
        this.model.storeData("isAborted", false)
    },
    showWinText: function(a) {
        if (a !== "bigWin") {
            this.view.showWinText(a);
            this.fireEvent("notify:bigWin.showingWinType", a)
        }
    },
    winBannerAnimationComplete: function() {
        var a = this;
        a.onWaitEventReceived("notify:winBanner.animationComplete");
        a.model.storeData("winBannerCountupComplete", true)
    },
    allWinAnimationComplete: function() {
        var a = this;
        if (!a.model.readData("winType")) {
            return
        }
        if (!a.model.readData("isAborted") || (a.model.readData("isAborted") && a.eventsToWaitFor.length > 0 && Sys.contains(a.eventsToWaitFor, "notify:winAnimations.winAnimationsFinished"))) {
            a.onWaitEventReceived("notify:winAnimations.winAnimationsFinished");
            a.model.setState("showingAllWins");
            a.fireEvent("request:winSituationsDisplay.showAllWins", {
                showDuration: a.model.readData("showAllWinsDuration")
            });
            a.fireEvent("request:winSituationsDisplay.abort");
            if (!a.model.isAutoPlayMode() && a.model.readData("nextSpinType") !== "respin") {
                a.fireEvent("request:winSituationsDisplay.toggleWins")
            }
        }
    },
    close: function() {
        var a = this;
        if (a.isSpinStarted === false) {
            a.model.setState("closed");
            a.view.bigWinTextEndAnimationFinished();
            a.view.close();
            if (a.model.readData("showWinAnimations") && !a.model.readData("isAborted")) {
                a.model.setState("showingWinAnimations");
                if (Platform.isDesktopDevice) {
                    a.fireEvent("request:winAnimations.startAnimation")
                } else {
                    a.initializeWaitSequence("request:winAnimations.startAnimation")
                }
            } else {
                if (a.model.readData("showAllWins")) {
                    a.model.setState("showingAllWins");
                    a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
                        showDuration: a.model.readData("showAllWinsDuration")
                    });
                    if (Platform.isDesktopDevice) {
                        a.fireEvent("request:winSituationsDisplay.abort");
                        if (!a.model.isAutoPlayMode() && a.model.readData("nextSpinType") !== "respin") {
                            a.fireEvent("request:winSituationsDisplay.toggleWins")
                        }
                    }
                } else {
                    a.onWaitIsComplete()
                }
            }
        }
    },
    handleWaitRequest: function(a) {
        this.onWaitRequested(a)
    },
    onWaitIsComplete: function() {
        var a = this;
        if (Platform.isDesktopDevice && a.model.isState("finished")) {
            return
        }
        if (a.model.isState("showingWinAnimations")) {
            if (a.model.readData("showAllWins")) {
                a.model.setState("showingAllWins");
                a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
                    showDuration: a.model.readData("showAllWinsDuration")
                });
                if (Platform.isDesktopDevice) {
                    a.fireEvent("request:winSituationsDisplay.abort");
                    if (!a.model.isAutoPlayMode() && a.model.readData("nextSpinType") !== "respin") {
                        a.fireEvent("request:winSituationsDisplay.toggleWins")
                    }
                }
            } else {
                a.onWaitIsComplete()
            }
        } else {
            a.stopListeningToUserInput();
            a.model.storeData("showAllWins", false);
            a.fireEvent("notify:bigWin.presentationFinished")
        }
    },
    handleUserInput: function() {
        var a = this;
        if (Platform.isDesktopDevice && a.model.readData("isAborted") === false) {
            if (a.model.isState("showing") || a.model.isState("finished") || a.model.isState("showingWinAnimations") || a.model.isState("showingAllWins")) {
                a.model.storeData("isAborted", true);
                a.finish(true);
                a.model.storeData("isAbortedInFinish", true);
                a.close();
                a.fireEvent("request:winSituationsDisplay.abort");
                a.fireEvent("notify:bigWin.animationAborted");
                a.fireEvent("request:audioPlayer.stop", "bigWinAmbienceSnd");
                a.fireEvent("request:winBanner.showTotal", {
                    showDuration: 10
                })
            }
        } else {
            if (a.model.isState("showing") || a.model.isState("finished") || a.model.isState("showingWinAnimations")) {
                a.model.storeData("isAborted", true);
                a.fireEvent("notify:bigWin.animationAborted");
                a.fireEvent("request:audioPlayer.stop", "bigWinAmbienceSnd")
            }
            SB.BigWinController.superclass.handleUserInput.apply(this, arguments)
        }
    },
    onConutUpStart: function(a) {
        var b = this;
        if (Platform.isDesktopDevice) {
            b.fireEvent("request:coinsField.showWin");
            b.initializeWaitSequence("request:winBanner.animate", b.model.getWinCountUpDuration());
            b.model.storeData("winBannerCountupComplete", false);
            b.fireEvent("request:cashField.showWin")
        }
        b.fireEvent("request:bigWinCountUp.start", a)
    },
    finish: function(a) {
        var b = this;
        if (Platform.isDesktopDevice) {
            b.model.setState("finished");
            b.view.finish(a)
        } else {
            SB.BigWinController.superclass.finish.apply(this, arguments)
        }
    },
    onShowTotalRequest: function(a) {
        var b = this,
            c;
        b.fireEvent("notify:bigWin.showTotalInCountUp");
        c = b.model.readData("showTotalDuration");
        if (Platform.isDesktopDevice && !a) {
            c = 1500
        }
        b.fireEvent("request:bigWinCountUp.showTotal", {
            showDuration: c
        });
        b.fireEvent("request:coinsField.showWin");
        b.fireEvent("request:cashField.showWin")
    },
    onUserInputStart: function() {},
    onUserInputEnd: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    },
    onSpinButtonDown: function() {
        this.model.storeData("startingNextSpin", true)
    }
};
SB.BigWinController = Sys.extend(Game.Slots.BigWinController, SB.BigWinController, "SB.BigWinController");
Sys.ns("SB");
SB.BigWinCountUpView = {
    BACKGROUND_LEFT: undefined,
    BACKGROUND_TOP: 484,
    BACKGROUND_DEPTH: 100,
    BACKGROUND_IMAGE: "WinBanner",
    BACKGROUND_IMAGE_WIDTH: 293,
    BACKGROUND_IMAGE_HEIGHT: 109,
    SHOW_TOTAL_DURATION: 500,
    NUMBER_IMAGE: "CoinWin",
    NUMBER_WIDTH: 114,
    NUMBER_HEIGHT: 113,
    NUMBER_FONT: "70px bold Century Gothic, sans-serif",
    NUMBER_OFFSET: -50,
    NUMBER_TEXT_OPERATIONS: [{
        fillStyle: "#f9e791"
    }, {
        lineWidth: 0,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_DEPTH: 101,
    COUNT_UP_TOP: 500,
    COUNT_UP_EASING_TYPE: "ease-in",
    configureStartAnimation: function(b) {
        var a = this;
        a.countUpItem.prop.ownOpacity = 1;
        a.countUpItem.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 1,
                scaleY: 1
            }
        }, {
            time: b,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }]
    },
    configureEndAnimation: function(b) {
        var a = this;
        a.countUpItem.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }, {
            time: 200,
            value: {
                scaleX: 2.5,
                scaleY: 2.5
            }
        }, {
            time: 400,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }, {
            time: 600,
            value: {
                scaleX: 2.5,
                scaleY: 2.5
            }
        }, {
            time: 800,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }, {
            time: 1000,
            value: {
                scaleX: 2.5,
                scaleY: 2.5
            }
        }, {
            time: 1200,
            value: {
                scaleX: 1.5,
                scaleY: 1.5
            }
        }];
        a.countUpItem.prop.operations.fade = [{
            value: 1,
            time: 0
        }, {
            value: 1,
            time: 200
        }, {
            value: 0,
            time: b
        }]
    },
    createBackgroundItem: function() {
        var a = this,
            b = Environment.getStageResolution();
        return new Animation.CanvasAnimationItem({
            left: Sys.isDefined(a.BACKGROUND_LEFT) ? Math.round(a.BACKGROUND_LEFT * a.scaleFactor) : b.width / 2 - Math.round(a.BACKGROUND_IMAGE_WIDTH * a.scaleFactor) / 2,
            top: Math.round(a.BACKGROUND_TOP * a.scaleFactor),
            width: Math.round(a.BACKGROUND_IMAGE_WIDTH * a.scaleFactor),
            height: Math.round(a.BACKGROUND_IMAGE_HEIGHT * a.scaleFactor),
            image: a.BACKGROUND_IMAGE,
            opacity: 1,
            delay: 0,
            depth: a.BACKGROUND_DEPTH,
            operations: {}
        })
    }
};
SB.BigWinCountUpView = Sys.extend(Game.Slots.BigWinCountUpView, SB.BigWinCountUpView, "SB.BigWinCountUpView");
Sys.ns("SB");
SB.BigWinCountUpDesktopView = {
    NUMBER_WIDTH: 72,
    NUMBER_HEIGHT: 81,
    NUMBER_OFFSET: -20,
    COUNT_UP_END_DURATION: 500,
    configureStartAnimation: function(b) {
        var a = this;
        a.countUpItem.prop.ownOpacity = 1;
        a.countUpItem.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }, {
            time: b,
            value: {
                scaleX: 0.01,
                scaleY: 0.01
            }
        }]
    },
    configureEndAnimation: function() {
        var a = this;
        a.countUpItem.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }, {
            time: a.COUNT_UP_END_DURATION,
            value: {
                scaleX: 0.01,
                scaleY: 0.01
            },
            goTo: 0
        }];
        a.countUpItem.prop.operations.fade = [{
            value: 1,
            time: 0
        }, {
            value: 1,
            time: 200
        }, {
            value: 0,
            time: a.COUNT_UP_END_DURATION
        }]
    },
    createCountUpItem: function() {
        var a = this,
            b = Animation.utils.text.createNumberDrawingProperties(a);
        return new Animation.CanvasAnimationItem({
            left: Math.round(a.COUNT_UP_LEFT * a.scaleFactor) || Environment.getStageResolution().width / 2,
            top: Math.round(a.COUNT_UP_TOP * a.scaleFactor),
            width: 0,
            height: 0,
            depth: a.COUNT_UP_DEPTH,
            executeBefore: function(c) {
                var i = this,
                    e, g, f = this,
                    h = f.value.toString(),
                    d;
                Animation.utils.text.drawTextFromImage(h, a.NUMBER_OFFSET, i.pivot.x, i.pivot.y, true, b.image, b.charMap, b.width, b.height, c);
                if (Sys.isDefined(f.fireOnTime)) {
                    e = f.fireOnTime.length;
                    for (d = -1; ++d < e;) {
                        g = f.fireOnTime[d];
                        if (!g.fired && f.localTime >= g.value) {
                            g.scope.fireEvent(g.event, g.argument);
                            g.fired = true
                        }
                    }
                }
            },
            operations: {}
        })
    },
    setCountUpValues: function(a) {
        var b = this,
            c = b.countUpItem.prop;
        c.fireOnTime = a.fireEventsOnTime;
        c.operations = {
            value: [{
                time: 0,
                value: a.from,
                support: b.model.readData("easingMethods")[b.COUNT_UP_EASING_TYPE] * a.to,
                numDecimals: 0
            }, {
                time: a.duration,
                value: a.to,
                fireEvent: {
                    event: "view:countUpComplete",
                    scope: b
                }
            }, {
                time: a.duration + 1,
                value: a.to
            }, {
                time: a.duration + 2,
                value: a.to,
                goTo: 2
            }]
        };
        b.configureStartAnimation(a.duration)
    },
    showTotal: function(e) {
        var c = this,
            b, d = [],
            a;
        e = e || {};
        c.list.stop();
        b = c.countUpItem.prop.operations.value[1].value;
        c.countUpItem.prop.fireOnTime.length = 0;
        c.list.restore();
        d.push({
            value: b,
            time: 0
        });
        if (e.showUntilStopped) {
            d.push({
                value: b,
                time: 1,
                goTo: 0
            })
        } else {
            a = Sys.isDefined(e.showDuration) ? e.showDuration : c.SHOW_TOTAL_DURATION;
            d.push({
                value: b,
                time: a,
                fireEvent: {
                    event: "view:showTotalDurationPassed",
                    scope: c
                }
            })
        }
        c.countUpItem.value(d);
        c.configureEndAnimation(a);
        c.list.play()
    }
};
SB.BigWinCountUpDesktopView = Sys.extend(SB.BigWinCountUpView, SB.BigWinCountUpDesktopView, "SB.BigWinCountUpDesktopView");
Sys.ns("SB");
SB.BigWinCountUpController = {
    start: function(a) {
        var b = this;
        SB.BigWinCountUpController.superclass.start.apply(b, arguments);
        if (!Platform.isDesktopDevice) {
            b.fireEvent("request:audioPlayer.play", {
                name: "countUpLoop",
                loop: true,
                id: "countUpLoop"
            })
        }
    },
    showTotal: function(b) {
        var a = this;
        SB.BigWinCountUpController.superclass.showTotal.apply(a, arguments);
        if (!Platform.isDesktopDevice) {
            a.fireEvent("request:audioPlayer.stop", "countUpLoop");
            a.fireEvent("request:audioPlayer.play", {
                name: "countUpLoopEnd",
                id: "countUpLoopEnd"
            })
        }
    },
    onCountUpComplete: function() {
        var a = this;
        SB.BigWinCountUpController.superclass.onCountUpComplete.apply(a, arguments);
        if (!Platform.isDesktopDevice) {
            a.fireEvent("request:audioPlayer.stop", "countUpLoop");
            a.fireEvent("request:audioPlayer.play", {
                name: "countUpLoopEnd",
                id: "countUpLoopEnd"
            })
        }
    }
};
SB.BigWinCountUpController = Sys.extend(Core.CountUpController, SB.BigWinCountUpController, "SB.BigWinCountUpController");
Sys.ns("SB");
SB.StandardWinController = {
    setupEvents: function() {
        var a = this;
        SB.StandardWinController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:winAnimations.showingWinAnimations": a.handleWaitRequest
        });
        if (Platform.isDesktopDevice) {
            a.on({
                "notify:winBanner.animate": a.handleWaitRequest,
                "notify:spinButton.down": a.onSpinButtonDown
            })
        }
    },
    attachDitachEventsAtRunTime: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            if (a.model.readData("spinType") === "respin" && a.model.readData("nextSpinType") === "spin") {
                a.removeListener("notify:winAnimations.winAnimationsFinished")
            } else {
                a.on({
                    "notify:winAnimations.winAnimationsFinished": a.allWinAnimationComplete
                })
            }
        }
    },
    allWinAnimationComplete: function() {
        var a = this;
        if (a.model.readData("winType") && a.model.readData("winType") !== "bigWin") {
            a.onWaitEventReceived("notify:winAnimations.winAnimationsFinished");
            a.startTogglingAnimation()
        }
    },
    startTogglingAnimation: function() {
        var a = this;
        if (Platform.isDesktopDevice && a.model.shouldToggleWins() && a.model.readData("nextSpinType") !== "respin" && !a.model.readData("isAbort")) {
            a.model.storeData("startToggling", true);
            a.fireEvent("request:winSituationsDisplay.toggleWins")
        }
    },
    onServerResponse: function(b) {
        var a = this;
        a.model.processServerResponse(b);
        if (Platform.isDesktopDevice) {
            a.model.storeData("isAbort", false);
            a.model.storeData("startToggling", false);
            a.hideWinBannder();
            a.attachDitachEventsAtRunTime()
        }
    },
    startPresentation: function() {
        var b = this,
            a = b.model.readData("winClip"),
            c = b.model.readData("countUpDuration");
        b.fireEvent("request:settingsWindow.close");
        b.startListeningToUserInput();
        if (Platform.isDesktopDevice) {
            b.fireEvent("request:coinsField.showWin");
            b.fireEvent("request:cashField.showWin");
            b.fireEvent("request:dimmedSymbols.dimNoWinSymbols")
        }
        b.model.setState("countingUp");
        b.model.storeData("showingWinAnimations", true);
        b.initializeWaitSequence("request:winAnimations.startAnimation");
        if (b.model.readData("countUpDisplay") === "winBanner") {
            b.fireEvent("request:winBanner.animate", c)
        } else {
            b.fireEvent("request:coinsField.countUp", c)
        }
        if (a) {
            b.fireEvent("request:audioPlayer.play", {
                name: a,
                id: "winClip"
            })
        }
        b.fireEvent("notify:standardWin.startPresentation", a)
    },
    handleWaitRequest: function(a) {
        this.onWaitRequested(a)
    },
    handleUserInput: function() {
        var a = this;
        a.model.storeData("isAbort", true);
        if (a.model.readData("inNoWinPresentation")) {
            a.abortNoWinPresentation()
        } else {
            if (a.model.isState("countingUp")) {
                a.fireEvent("notify:standardWinAnimations.animationAborted");
                if (a.model.readData("countUpDisplay") === "winBanner") {
                    if (!Platform.isDesktopDevice) {
                        a.fireEvent("request:winBanner.showTotal", {
                            showUntilStopped: true
                        })
                    } else {
                        a.fireEvent("request:winBanner.showTotal", {
                            showDuration: 10
                        })
                    }
                } else {
                    a.fireEvent("request:coinsField.showWin")
                }
                a.fireEvent("request:audioPlayer.stop", "winClip");
                a.onShowingTotal();
                a.fireEvent("notify:standardWin.countupAborted")
            } else {
                if (a.model.isState("showingTotal")) {
                    a.fireEvent("notify:standardWinAnimations.animationAborted");
                    a.fireEvent("request:audioPlayer.stop", "winClip");
                    a.endPresentation(true)
                }
            }
        }
    },
    onWaitIsComplete: function() {
        var a = this;
        if (a.model.readData("showingWinAnimations")) {
            a.model.storeData("showingWinAnimations", false);
            var b = a.model.readData("countUpDuration"),
                c = a.model.readData("totalWinDisplayDuration");
            if (!Platform.isDesktopDevice) {
                a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
                    showDuration: b + c,
                    "standardWin:countUpDuration": b,
                    "standardWin:showTotalDuration": c
                })
            }
            if (Platform.isDesktopDevice) {
                this.endPresentation(false)
            }
        } else {
            this.endPresentation(false)
        }
    },
    onShowingTotal: function() {
        var a = this;
        if (a.model.isState("countingUp")) {
            a.model.setState("showingTotal");
            a.fireEvent("notify:standardWin.showingWinTotal");
            if (!Platform.isDesktopDevice) {
                a.fireEvent("request:coinsField.showWin");
                a.fireEvent("request:cashField.showWin")
            }
            if (a.eventsToWaitFor.indexOf("notify:winSituationsDisplay.finishedShowingAllWins") === -1) {
                a.showWinTimeout = setTimeout(a.endPresentation.bind(a, false), a.model.readData("totalWinDisplayDuration"))
            }
        }
    },
    hideWinBannder: function() {
        var a = this;
        if (Platform.isDesktopDevice && a.model.readData("spinType") !== "respin" && a.model.readData("countUpDisplay") === "winBanner") {
            a.fireEvent("request:winBanner.lastAnimation")
        }
    },
    endPresentation: function(b) {
        var a = this;
        if (!Platform.isDesktopDevice && !a.model.isState("showingTotal") && !a.model.readData("inNoWinPresentation")) {
            return
        }
        a.stopListeningToUserInput();
        a.model.setState("complete");
        clearTimeout(a.showWinTimeout);
        a.fireEvent("request:audioPlayer.stop", "winClip");
        if (!Platform.isDesktopDevice) {
            a.fireEvent("request:winSituationsDisplay.abort");
            if (a.model.readData("countUpDisplay") === "winBanner") {
                a.fireEvent("request:winBanner.hide")
            }
            if (a.model.shouldToggleWins()) {
                a.fireEvent("request:winSituationsDisplay.toggleWins")
            }
        } else {
            if (a.model.shouldToggleWins() && a.model.readData("nextSpinType") !== "respin" && !a.model.readData("startToggling")) {
                a.model.storeData("startToggling", true);
                a.fireEvent("request:winSituationsDisplay.toggleWins")
            }
        }
        a.fireEvent("notify:standardWin.presentationComplete", b)
    },
    onUserInputStart: function() {},
    onUserInputEnd: function(a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    },
    onSpinButtonDown: function() {
        this.model.storeData("startingNextSpin", true)
    }
};
SB.StandardWinController = Sys.extend(Core.Slots.StandardWinController, SB.StandardWinController, "SB.StandardWinController");
Sys.ns("SB");
SB.StandardWinModel = {
    COUNT_UP_DURATIONS: {
        smallWin: (Platform.isDesktopDevice) ? 1000 : 1000,
        mediumWin: (Platform.isDesktopDevice) ? 2000 : 2000,
        largeWin: (Platform.isDesktopDevice) ? 3000 : 3000
    },
    processServerResponse: function(a) {
        var c = this,
            d = (a.currentGameState === "freespin" || a.clientaction === "respin") ? ((Platform.isDesktopDevice) ? "winBanner" : "coinsField") : "winBanner",
            b = (a.currentGameState === "freespin" || a.nextaction === "freespin") || (a.clientaction === "respin" && a.nextaction !== "spin");
        SB.StandardWinModel.superclass.processServerResponse.apply(c, arguments);
        c.storeData("countUpDisplay", d);
        c.storeData("togglePreventedByFreeSpins", b);
        c.storeData("startingNextSpin", false);
        if (Platform.isDesktopDevice) {
            c.storeData("spinType", a.clientaction);
            c.storeData("nextSpinType", a.nextaction);
            if (Sys.isDefined(a.wins) && a.wins.coinsTotal > 0) {
                c.storeData("winType", a.wins.winType)
            }
        }
    },
    shouldToggleWins: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (!Sys.isDefined(a) || a === 0) && !this.readData("togglePreventedByFreeSpins") && !this.readData("startingNextSpin")
    }
};
SB.StandardWinModel = Sys.extend(Core.Slots.StandardWinModel, SB.StandardWinModel, "SB.StandardWinModel");
Sys.ns("SB");
SB.ResponseParserController = {
    parseReelInfo: function(a) {
        var b = Sys.isDefined(a.current) ? a.current.rs.i0 : "basic";
        return Sys.utils.parseReelInfo(a, b)
    },
    doGameSpecificWinSituationParsing: function(f) {
        var e = f.winSituations,
            a, c, d = function(g) {
                return g.filter(function(h) {
                    return h.reelIndex === 0
                })
            };
        for (var b = 0; b < e.length; b++) {
            c = e[b].positions;
            if (c !== undefined) {
                a = d(c);
                if (Sys.isDefined(a) && a.length > 0) {
                    e[b].dir = "left";
                    e[b].positions = c
                } else {
                    e[b].dir = "right";
                    e[b].positions = c.reverse()
                }
            }
        }
        f.winSituations = e
    },
    parseWinLayouts: function(a, f) {
        var b, g, c, d = [],
            i, j = 0,
            h = 0,
            e = 0;
        for (b = 0; b < a.length; b++) {
            d.push({
                betline: Sys.isNumber(a[b].betline) ? a[b].betline + 1 : undefined,
                positions: [],
                reelset: a[b].reelset,
                wins: {},
                sym: a[b].sym
            });
            if (Sys.isDefined(a[b].pos)) {
                for (g = 0; Sys.isDefined(a[b].pos["i" + g]); g++) {
                    i = {};
                    i.reelIndex = a[b].pos["i" + g][0];
                    i.symbolIndex = a[b].pos["i" + g][1];
                    i = Sys.apply(i, f[i.reelIndex].symbols[i.symbolIndex]);
                    d[b].positions.push(i)
                }
                d[b].positions.sort(this.sortSymbols)
            }
            for (c = 0; Sys.isDefined(a[b].types["i" + c]) && Sys.isDefined(a[b].types["i" + c].wintype); c++) {
                d[b].wins.type = a[b].types["i" + c].wintype;
                if (a[b].types["i" + c].wintype === "coins") {
                    d[b].wins.coins = a[b].types["i" + c].coins;
                    d[b].wins.cents = a[b].types["i" + c].cents;
                    j += a[b].types["i" + c].coins;
                    h += a[b].types["i" + c].cents
                } else {
                    if (a[b].types["i" + c].wintype === "freespins") {
                        d[b].wins.freespins = a[b].types["i" + c].freespins;
                        e += a[b].types["i" + c].freespins
                    } else {}
                }
            }
        }
        d.sort(this.sortWinSituations);
        return {
            winSituations: d,
            coins: j,
            cents: h,
            freespins: e
        }
    }
};
SB.ResponseParserController = Sys.extend(Core.Slots.ResponseParserController, SB.ResponseParserController, "SB.ResponseParserController");
Sys.ns("SB");
SB.PaytableBaseView = {
    SECTIONS: ["SpecialSymbols", "SymbolValues", "Betlines", "Disclaimer"],
    MEDIUM_WIN: {
        COLOR: "#465e85",
        SYMBOLS: ["SYM3", "SYM4", "SYM5", "SYM6", "SYM7", "SYM8", "SYM9"]
    },
    DISCLAIMER_STRINGS: ["MGpaytableInfoBetLevel1", "paytableHighestRev", "winBothWaysPaysRev", Language.Keys.paytable_voidAllPays],
    createSpecialSymbols: function() {
        var d = this,
            b = Resources.readData("animationImages"),
            e = new Sys.Element({
                tag: "div",
                "class": d.SECTION_CSS
            }),
            f = e.add(new Sys.Element({
                tag: "ul",
                style: "margin-bottom: 28px;",
                "class": "SB_paytable_list"
            }));
        var c = f.add(new Sys.Element({
                tag: "li",
                style: "width: 30%; text-align: center;"
            })),
            a = f.add(new Sys.Element({
                tag: "li",
                style: "width: 70%;",
                "class": "SB_paytable_textBlock"
            }));
        if (Sys.isDefined(b.SYM1)) {
            c.el.appendChild(b.SYM1)
        }
        a.add(new Sys.Element({
            tag: "div",
            style: "padding-left: 20px;",
            textContent: Services.languageManager.getText("starburstNameOfWild")
        }));
        a.add(new Sys.Element({
            tag: "div",
            style: "padding-left: 20px;",
            textContent: Services.languageManager.getText("MGsubAllSymbolsLC") + " " + Services.languageManager.getText("MGappearsOnReelsLC", ["2", "3", "4"]) + " " + Services.languageManager.getText("MGexpandReelTriggerLC") + " " + Services.languageManager.getText("MGmaxNumberReSpinsLC", ["3"])
        }));
        d.container.add(e)
    }
};
SB.PaytableBaseView = Sys.extend(Interface.PaytableBaseView, SB.PaytableBaseView, "SB.PaytableBaseView");
Sys.ns("SB");
SB.PaytableDesktopView = {
    SECTION_SEPARATOR_URI: "",
    SECTIONS: ["PaytableWild", "SymbolValues"],
    SRC: "movie",
    MEDIUM_WIN: {
        COLOR: "#FFFFB5",
        SYMBOLS: ["SYM3", "SYM4", "SYM5", "SYM6"]
    },
    LOW_WIN: {
        COLOR: "#FFFFB5",
        SYMBOLS: ["SYM7", "SYM8", "SYM9"]
    },
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 37,
            y: 624,
            width: 52,
            height: 52
        },
        buttonImages: {
            up: "paytableButtonUp",
            down: "paytableButtonDown",
            hover: "paytableButtonOver",
            disabled: "paytableButtonDisabled"
        }
    },
    BASE_CSS: "tab interface-paytableDesktop_base sb-paytableDesktop_base",
    SECTION_CSS: "interface-paytable_section interface-settingsSection_subSection sb-paytable-section",
    SETTINGS_WINDOW_CSS: "interface-settingsWindow_base interface-gameSettings-paytable-background-uri",
    STARBURST_IMG: "paytableStar",
    STARBURST_WILD: "starburstWild",
    STARBURST_PAYTABLE: "starburstPaytable",
    main_Container: undefined,
    IMAGES: undefined,
    CONTAINER_STYLE: "width:90px; font: 27px BauhausRegular; overflow: hidden; max-width: 130px;",
    initAnimations: function() {
        var c = this,
            d = Resources.readData("language").lang,
            b = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (b.indexOf(d) > -1) {
            c.CONTAINER_STYLE = "width:90px; font: 27px SBMyroidProBold; overflow: hidden; max-width: 130px;"
        }
        var a = Sys.applyProperties({
            clickCallback: c.onButtonClick.bind(c)
        }, c.KEYPAD_BUTTON_CONFIG);
        if (Sys.isDefined(a.buttonLabel)) {
            a.buttonLabel.depth = Layering.Game.Slots.Keypad.paytable.label
        }
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.paytable.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.paytable.button
        }
        c.button = new Interface.utils.CanvasButton(a);
        c.button.ID = "paytable";
        c.button.SOUND_CLICK = "paytableButtonClick";
        c.animationsReady = true
    },
    addMainContainer: function() {
        var b = this,
            a = new Sys.Element({
                tag: "div"
            });
        b.container.add(a);
        b.main_Container = a
    },
    createPaytableWild: function() {
        var a = this;
        a.addMainContainer();
        a.createBackgroundStar();
        a.createHeader();
        a.sectionElements.PaytableWild = a.main_Container;
        a.container.add(a.main_Container)
    },
    setUpContent: function() {
        var a = this;
        a.model.setNumberOfPages(a.SECTIONS.length);
        a.model.setCurrentPage(1);
        a.IMAGES = Resources.readData("images");
        a.createSections();
        a.createDisclaimer();
        a.createNavigation();
        this.model.storeData("activetArea", [{
            x: 130,
            y: 57,
            width: 1022,
            height: 485
        }, {
            x: 0,
            y: 695,
            width: 1280,
            height: 200
        }, {
            x: 37,
            y: 624,
            width: 52,
            height: 52
        }, {
            x: 513,
            y: 0,
            width: 280,
            height: 60
        }]);
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: "",
            content: a.container
        });
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    show: function(b) {
        var c = this,
            a;
        a = 0;
        Interface.PaytableDesktopView.superclass.show.apply(c, arguments);
        if (Sys.isNumber(b) && b > 0 && b <= c.SECTIONS.length) {
            a = b - 1
        }
        c.navigation.selectCard(a);
        c.navigation.enable(c.MODULE_NAME);
        document.getElementById("settingsWindow").className = c.SETTINGS_WINDOW_CSS;
        c.movieList.items[0].play();
        c.movieList.play()
    },
    hide: function() {
        var a = this;
        SB.PaytableDesktopView.superclass.hide.apply(a, arguments);
        a.movieList.pause()
    },
    createSymbolSubSection: function(c, e, k, d) {
        k = k || "";
        var g = this,
            a = new Sys.Element({
                tag: "table",
                "class": "interface-paytable_symbols_desktop"
            }),
            b = new Sys.Element({
                tag: "div",
                "class": k
            }),
            h = c.length,
            j, f;
        for (f = -1; ++f < h;) {
            if (f % d === 0) {
                j = a.add(new Sys.Element({
                    tag: "tr"
                }))
            }
            g.appendSymbolContainer(j, c[f], e)
        }
        b.add(a);
        return b
    },
    appendSymbolContainer: function(a, d, e, b, f, n) {
        var k = Resources.readData("animationImages"),
            j = this,
            c = a.add(new Sys.Element({
                tag: "td",
                id: "paytable_symbolContainer",
                style: "overfolow:hidden; max-width:130px;"
            })),
            h = this.model.getCondensedInfo(d, b, f, n).sort(function(r, i) {
                return i.from - r.from
            }),
            m = h.length,
            p, o, g, q;
        if (Sys.isDefined(k[d])) {
            c.el.appendChild(k[d])
        }
        var l = j.CONTAINER_STYLE;
        if (Platform.isIEBrowser || Platform.isEdgeBrowser || Environment.browser === "firefox") {
            l = l + "line-height: 25px;"
        } else {
            l = l + "padding-top:2%; line-height: 28px;"
        }
        p = a.add(new Sys.Element({
            tag: "td",
            style: l
        })).add(new Sys.Element({
            tag: "table",
            "class": "interface-paytable_symbolValues interface-paytable_desktop_data_payoutSymbols"
        }));
        for (g = -1; ++g < m;) {
            o = h[g];
            if (Sys.isDefined(o.value)) {
                q = p.add(new Sys.Element({
                    tag: "tr"
                }));
                q.add(new Sys.Element({
                    tag: "td",
                    textContent: o.from,
                    style: "width: 33%; color: " + e + "; font-weight: bold;text-shadow: 1px 1px 10px rgba(208,110,19,0.4),-1px -1px 10px rgba(208,110,19,0.4),1px 0px 10px rgba(208,110,19,0.4),-1px 0px 10px rgba(208,110,19,0.4)"
                }));
                q.add(new Sys.Element({
                    tag: "td",
                    textContent: o.value,
                    style: "width: 66%;"
                }))
            }
        }
    },
    createNavigation: function() {
        var a = this;
        a.navigation = new SB.CardNavigation({
            id: "paytableNavigation",
            numCards: this.SECTIONS.length,
            selectionCallback: a.onCardSelection.bind(a),
            closeCallback: a.onCloseCallback.bind(a)
        });
        a.subComponents = [a.navigation];
        a.container.add(a.navigation.getArrows());
        a.container.add(a.navigation.getIndicators())
    },
    createSections: function() {
        var c = this,
            d = c.SECTIONS,
            a = d.length,
            b;
        for (b = 0; b < a; b++) {
            if (typeof c["create" + d[b]] === "function") {
                c["create" + d[b]]()
            }
        }
    },
    createSymbolValues: function() {
        var a = this,
            c = new Sys.Element({
                tag: "div",
                "class": a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
            });
        if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
            c.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR, "paytable-lastView-symbol-container", 4))
        }
        if (a.LOW_WIN.SYMBOLS.length > 0) {
            c.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR, "paytable-lastView-symbol-container", 3))
        }
        var d = new Sys.Element({
            tag: "div"
        }).add(new Sys.Element({
            tag: "img",
            "class": "paytable-lastView-image",
            src: a.IMAGES.files[a.STARBURST_PAYTABLE]
        }));
        var b = new Sys.Element({
            tag: "div",
            "class": "paytable-listView-betline-wrapper"
        });
        b.add(d);
        c.add(b);
        a.container.add(c);
        a.sectionElements.SymbolValues = c
    },
    createDisclaimer: function() {
        var d = this,
            c = "Paytable-firstView-center-disclaimer";
        var b = new Sys.Element({
            tag: "div",
            "class": c
        });
        var e = [];
        e.push(Services.languageManager.getText("paytableInfoBetLevel1"));
        e.push(Services.languageManager.getText("paytableHighestRev"));
        e.push(Services.languageManager.getText("winBothWaysPaysRev"));
        e.push(Services.languageManager.getText("voidAllPays"));
        for (var a = 0; a < e.length; a++) {
            b.add(new Sys.Element({
                tag: "p",
                textContent: e[a]
            }))
        }
        d.container.add(b)
    },
    createBetlines: function() {
        var a = this,
            b = new Sys.Element({
                tag: "div",
                "class": a.SECTION_CSS + " utils_center_text " + a.SECTION_SEPARATOR_URI
            });
        b.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText("MGwinningLinesHeading"),
            "class": a.HEADING_CSS,
            style: "padding-bottom : 15px"
        }));
        if (Sys.isObj(a.images) && Sys.isDefined(a.images.betlines)) {
            b.el.appendChild(a.images.betlines)
        }
        a.sectionElements.Betlines = b;
        a.container.add(b)
    },
    getMovieAnimation: function(b) {
        var a = this;
        return new SB.VideoItem({
            width: 315,
            height: 185,
            src: a.SRC,
            poster: "moviePoster",
            container: b
        })
    },
    createBackgroundStar: function() {
        var d = this,
            a, f, b, c, e, g;
        a = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-left-firstWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        f = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-left-secondWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        b = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-left-thirdWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        c = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-right-firstWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        e = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-right-secondWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        g = new Sys.Element({
            tag: "img",
            "class": "Paytable-firstView-right-thirdWild",
            src: d.IMAGES.files[d.STARBURST_IMG]
        });
        d.main_Container.add(a);
        d.main_Container.add(f);
        d.main_Container.add(b);
        d.main_Container.add(c);
        d.main_Container.add(e);
        d.main_Container.add(g)
    },
    createHeader: function() {
        var f = this,
            e = new Sys.Element({
                tag: "img",
                src: f.IMAGES.files[f.STARBURST_WILD],
                "class": "Paytable-firstView-center-header"
            });
        f.main_Container.add(e);
        var d = [];
        var g = {
            "{0}": "2",
            "{1}": "3",
            "{2}": "4"
        };
        d.push(Services.languageManager.getText("subAllSymbols"));
        d.push(Services.languageManager.getText("appearsOnReels").replace(/\{0\}|\{1\}|\{2\}/gi, function(h) {
            return g[h]
        }));
        d.push(Services.languageManager.getText("expandReelTrigger"));
        d.push(Services.languageManager.getText("maxNumberReSpins").replace("{0}", "3"));
        for (var b = 0; b < d.length; b++) {
            f.main_Container.add(new Sys.Element({
                tag: "p",
                "class": "Paytable-firstView-center-headerText",
                textContent: d[b]
            }))
        }
        var a = new Sys.Element({
            tag: "div",
            "class": "Paytable-firstView-center-videoContainer-wrapper"
        });
        var c = new Sys.Element({
            tag: "div",
            "class": "Paytable-firstView-center-videoContainer"
        });
        f.movieList = new Animation.List({});
        f.movieList.add(f.getMovieAnimation(c));
        Game.stage.view.addToRenderLoop(f.movieList);
        f.movieList.stop();
        a.add(c);
        f.main_Container.add(a)
    },
    onGreyAreaClick: function(c) {
        var b = document.getElementById("canvasAnimationManager"),
            a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, b);
        return Sys.UserInputUtils.isUserInputInSegment(a, this.model.readData("activetArea"))
    }
};
SB.PaytableDesktopView = Sys.extend(Interface.PaytableDesktopView, SB.PaytableDesktopView, "SB.PaytableDesktopView");
Sys.ns("SB");
SB.AutoplaySettingsView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 476,
            y: 612,
            width: 125,
            height: 71
        },
        buttonImages: {
            up: "autoPlayButtonUp",
            down: "autoPlayButtonDown",
            hover: "autoPlayButtonOver",
            disabled: "autoPlayButtonDisabled"
        },
        buttonLabel: {
            offsetX: -5,
            offsetY: 0,
            width: 125,
            height: 71,
            text: "autoplayButtonTwoLine",
            font: "15px SBMyroidProBold",
            lineHeight: 15,
            alignment: "center",
            color: "#ffffff",
            textBaseline: "middle",
            shadowColor: "#524B4B",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 1,
            breakOn: "<br>"
        },
        clickArea: {
            x: 475,
            y: 612,
            width: 110,
            height: 71
        }
    },
    setUpKeypadButton: function() {
        var b = this,
            a = Sys.applyProperties({
                clickCallback: b.onButtonClick.bind(b)
            }, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.autoPlay.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.autoPlay.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.autoPlay.button
        }
        b.keypadButton = new SB.CanvasButton(a);
        b.keypadPendingDisable.forEach(b.keypadButton.disable.bind(b.keypadButton));
        delete b.keypadPendingDisable
    }
};
SB.AutoplaySettingsView = Sys.extend(Interface.AutoplaySettingsView, SB.AutoplaySettingsView, "SB.AutoplaySettingsView");
Sys.ns("SB");
SB.AutoplaySettingsController = {
    setupEvents: function() {
        var a = this;
        SB.AutoplaySettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:disableKeypad": a.view.disableKeypadButton.bind(a.view)
        })
    }
};
SB.AutoplaySettingsController = Sys.extend(Interface.AutoplaySettingsController, SB.AutoplaySettingsController, "SB.AutoplaySettingsController");
Sys.ns("SB");
SB.MaxBetButtonController = {
    setupEvents: function() {
        var a = this;
        SB.MaxBetButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:disableKeypad": a.view.disable.bind(a.view)
        })
    }
};
SB.MaxBetButtonController = Sys.extend(Interface.Slots.MaxBetButtonController, SB.MaxBetButtonController, "SB.MaxBetButtonController");
Sys.ns("SB");
SB.MaxBetButtonBaseView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {
            x: 678,
            y: 612,
            width: 125,
            height: 71
        },
        buttonImages: {
            up: "maxBetButtonUp",
            down: "maxBetButtonDown",
            hover: "maxBetButtonOver",
            disabled: "maxBetButtonDisabled"
        },
        buttonLabel: {
            offsetX: 5,
            offsetY: 0,
            width: 125,
            height: 71,
            text: "OCTmaxbetbuttonTwoLine",
            font: "15px SBMyroidProBold",
            lineHeight: 15,
            color: "#ffffff",
            alignment: "center",
            textBaseline: "middle",
            shadowColor: "#524B4B",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 1,
            breakOn: "<br>"
        },
        clickArea: {
            x: 690,
            y: 612,
            width: 110,
            height: 71
        }
    },
    setUpKeypadButton: function() {
        var b = this,
            a = Sys.applyProperties({
                clickCallback: b.onButtonClick.bind(b)
            }, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.maxBet.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.maxBet.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.maxBet.button
        }
        b.keypadButton = new SB.CanvasButton(a)
    }
};
SB.MaxBetButtonBaseView = Sys.extend(Interface.Slots.MaxBetButtonBaseView, SB.MaxBetButtonBaseView, "SB.MaxBetButtonBaseView");
Sys.ns("SB.Interface.Slots");
SB.Interface.Slots.MaxBetButtonModel = {
    setupData: function() {
        var d = Resources.readData("gameServerInitResponseObject").betlevel.all,
            a = Resources.readData("config"),
            b = Object.keys(a.winSituationsDisplay.betlines.numbers.configurations.left),
            e = a.winSituationsDisplay.winSituationMinimumDisplayTime,
            c = 0;
        Interface.Slots.MaxBetButtonModel.superclass.setupData.apply(this, arguments);
        Sys.each(d, function(f) {
            c = Math.max(f, c)
        });
        this.storeData("maxBetLevel", c);
        this.storeData("betlines", b);
        this.storeData("winSituationMinimumDisplayTime", e)
    }
};
SB.Interface.Slots.MaxBetButtonModel = Sys.extend(Interface.Slots.MaxBetButtonModel, SB.Interface.Slots.MaxBetButtonModel, "SB.Interface.Slots.MaxBetButtonModel");
Sys.ns("SB");
SB.SpinButtonController = {
    setupEvents: function() {
        var a = this;
        SB.SpinButtonController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "request:disableKeypad": a.disable,
            "notify:stateHandler.enteringBigWinState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingBigWinState": a.model.storeData.bind(a.model, "inWinState", false),
            "notify:stateHandler.enteringStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", false)
        })
    },
    onPressedRequest: function() {
        var b = this,
            a = b.model.isAutoPlayMode();
        if (Platform.isDesktopDevice) {
            if ((b.model.readData("inIdleState") || b.model.readData("inWinState")) && a === false) {
                b.view.onPressedRequest()
            }
        } else {
            if (b.model.readData("inIdleState")) {
                b.view.onPressedRequest()
            }
        }
    },
    onReleasedRequest: function() {
        var b = this,
            a = b.model.isAutoPlayMode();
        if (Platform.isDesktopDevice) {
            if ((b.model.readData("inIdleState") || b.model.readData("inWinState")) && a === false) {
                b.view.onReleasedRequest()
            }
        } else {
            if (b.model.readData("inIdleState")) {
                b.view.onReleasedRequest()
            }
        }
    },
    onClick: function() {
        var b = this,
            a = b.model;
        if (a.hasProperty("hidden")) {
            if (b.view.canInteractWhileHidden()) {
                b.fireEvent("notify:spinButton.clickedWhileHidden")
            }
        } else {
            b.fireEvent("request:audioPlayer.play", {
                name: "spinButtonClick"
            });
            b.fireEvent("notify:spinButton.clicked", {
                skip: a.readData("noStopOnSpin")
            });
            if (a.readData("inIdleState") || (Platform.isDesktopDevice && a.readData("inWinState") && !a.hasProperty("disabled"))) {
                if (a.hasDisplayType("autoPlay")) {
                    b.fireEvent(b.AUTOPLAY_START_EVENT)
                } else {
                    b.fireEvent(b.ROUND_START_EVENT)
                }
            }
        }
    }
};
SB.SpinButtonController = Sys.extend(Interface.Slots.SpinButtonController, SB.SpinButtonController, "SB.SpinButtonController");
Sys.ns("SB");
SB.SpinButtonDesktopView = {
    BUTTON_POSITION: {
        x: 595,
        y: 603,
        width: 90,
        height: 90,
        centerX: 640,
        centerY: 647,
        radius: 45
    },
    getButtonDepth: function() {
        return 140
    }
};
SB.SpinButtonDesktopView = Sys.extend(Interface.Slots.SpinButtonDesktopView, SB.SpinButtonDesktopView, "SB.SpinButtonDesktopView");
Sys.ns("SB");
SB.BetSettingsController = {
    setupEvents: function() {
        var a = this;
        SB.BetSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:disableKeypad": a.disable
        })
    }
};
SB.BetSettingsController = Sys.extend(Interface.BetSettingsController, SB.BetSettingsController, "SB.BetSettingsController");
Sys.ns("SB");
SB.BetSettingsDesktopView = {
    GAME_MODES: ["BASIC"],
    BASIC_BETLEVEL_LABEL: {
        font: "21px BauhausRegular",
        fillstyle: "#ffffff"
    },
    BASIC_BETLEVEL_VALUE: {
        font: "36px BauhausRegular",
        fillstyle: "#FCE0AD"
    },
    BASIC_COINVALUE_LABEL: {
        font: "21px BauhausRegular",
        fillstyle: "#ffffff"
    },
    BASIC_COINVALUE_VALUE: {
        font: "36px BauhausRegular",
        fillstyle: "#FCE0AD"
    },
    BETLEVEL_VALUE_SELECTOR_BASE_POSITION: {
        x: 296,
        y: 637
    },
    COINVALUE_VALUE_SELECTOR_BASE_POSITION: {
        x: 838,
        y: 637
    },
    VALUE_SELECTOR_POSITION_OFFSET_LABEL: {
        x: 0,
        y: (Platform.isIEBrowser) ? -33 : -37
    },
    VALUE_SELECTOR_POSITION_OFFSET_VALUE: {
        x: 0,
        y: (Platform.isIEBrowser) ? -23 : -28
    },
    VALUE_SELECTOR_RIGHT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_LEFT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_HANDLE_POSITION_OFFSET: {
        LEFT: {
            x: 0,
            y: -7
        },
        RIGHT: {
            x: 110,
            y: -7
        }
    },
    VALUE_SELECTOR_RIGHT_HANDLE_POSITION_OFFSET: {
        LEFT: {
            x: 0,
            y: -7
        },
        RIGHT: {
            x: 140,
            y: -7
        }
    },
    VALUE_SELECTOR_HANDLE_DIMENSIONS: {
        LEFT: {
            width: 35,
            height: 50
        },
        RIGHT: {
            width: 35,
            height: 50
        }
    },
    VALUE_SELECTOR_HANDLE_COLLISION_BOX: {
        LEFT: {
            xOffset: 0,
            yOffset: -2,
            width: 35,
            height: 50
        },
        RIGHT: {
            xOffset: 0,
            yOffset: -2,
            width: 35,
            height: 50
        }
    },
    VALUE_SELECTOR_BAR_BACKGROUND: undefined,
    VALUE_SELECTOR_BAR_BACKGROUND_DISABLED: undefined,
    VALUE_SELECTOR_BAR_FILL: undefined,
    VALUE_SELECTOR_BAR_FILL_DISABLED: undefined,
    LEVEL_VALUE_SELECTOR_BAR_DIMENSIONS: {
        background: {
            width: 146,
            height: 6
        },
        fill: {
            width: 146,
            height: 6
        }
    },
    COINVALUE_SELECTOR_BAR_DIMENSIONS: {
        background: {
            width: 175,
            height: 6
        },
        fill: {
            width: 175,
            height: 6
        }
    },
    VALUE_SELECTOR_BAR_POSITIONS_OFFSET: {
        background: {
            x: 0,
            y: 52
        },
        fill: {
            x: 0,
            y: 52
        }
    },
    VALUE_SELECTOR_RIGHT_BAR_POSITIONS_OFFSET: {
        background: {
            x: 0,
            y: 52
        },
        fill: {
            x: 0,
            y: 52
        }
    },
    COINVALUE_FIX: {
        MAX_WIDTH: 90,
        FONT: "36px BauhausRegular",
        POSITION: {
            y: 637
        }
    },
    initSelectors: function() {
        var c = this,
            b = c.keyPadLayering,
            a;
        a = c.model.readData("coinValues").map(function(d) {
            return Sys.utils.numberToFixedDigits(d, 3)
        });
        c.selectors = {
            betLevelSelector: new Interface.utils.CanvasValueSelector({
                id: "betLevelSelector",
                x: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("betLevels"),
                callback: c.onValueChange.bind(c, "betLevelChanged"),
                disabled: !c.model.readData("updatableBetLevels"),
                label: Services.languageManager.getText(Language.Keys.level),
                fontLabel: c.BASIC_BETLEVEL_LABEL.font,
                fontValue: c.BASIC_BETLEVEL_VALUE.font,
                fillstyleLabel: c.BASIC_BETLEVEL_LABEL.fillstyle,
                fillstyleValue: c.BASIC_BETLEVEL_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.LEVEL_VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            }),
            coinValueSelector: new Interface.utils.CanvasValueSelector({
                id: "coinValueSelector",
                x: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("coinValues"),
                valueNames: a,
                callback: c.onValueChange.bind(c, "coinValueChanged"),
                disabled: !c.model.readData("updatableCoinValues"),
                label: Services.languageManager.getText(Language.Keys.machinetext_coinvalue),
                fontLabel: c.BASIC_COINVALUE_LABEL.font,
                fontValue: c.BASIC_COINVALUE_VALUE.font,
                fillstyleLabel: c.BASIC_COINVALUE_LABEL.fillstyle,
                fillstyleValue: c.BASIC_COINVALUE_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_RIGHT_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.COINVALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_RIGHT_BAR_POSITIONS_OFFSET
            })
        }
    },
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.BASIC_BETLEVEL_LABEL.font = "21px SBMyroidProBold";
            b.BASIC_BETLEVEL_VALUE.font = "36px SBMyroidProBold";
            b.BASIC_COINVALUE_LABEL.font = "21px SBMyroidProBold";
            b.BASIC_COINVALUE_VALUE.font = "36px SBMyroidProBold"
        }
        SB.BetSettingsDesktopView.superclass.initAnimations.apply(b, arguments)
    }
};
SB.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsDesktopView, SB.BetSettingsDesktopView, "SB.BetSettingsDesktopView");
Sys.ns("SB");
Sys.override(Interface.utils.CanvasValueSelector, {
    updateValueItem: function(e) {
        var b = this,
            h = b.valueItem.prop,
            a = h.customProps.ctx,
            d = b.valueNameArray[b.valueArray.indexOf(e)],
            c = Animation.utils.text.measureText(d, b.FONT_VALUE, 20, a),
            g = b.HANDLE_DIMENSIONS.RIGHT.width + b.HANDLE_POSITION_OFFSET.RIGHT.x,
            f = b.POSITION_OFFSET_VALUE;
        h.image.width = c.width;
        h.image.height = c.height;
        h.width = c.width;
        h.height = c.height;
        h.top = b.basePosition.y + f.y;
        h.left = ((b.basePosition.x + (g / 2)) - (h.image.width / 2)) + f.x;
        a.clearRect(0, 0, h.width, h.height);
        a.globalCompositeOperation = "lighter";
        a.imageSmoothingEnabled = true;
        a.fontSmoothingEnabled = true;
        Animation.utils.text.performOperations(d, b.FONT_VALUE, 20, c.height / 2, [{
            fillStyle: b.FILLSTYLE_VALUE,
            drawType: "fill",
            shadowColor: "#ff8c21",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 25
        }], a)
    }
});
Sys.ns("SB");
SB.CanvasButton = {
    init: function(a) {
        this.clickArea = a.clickArea || a.dimensions;
        SB.CanvasButton.superclass.init.apply(this, arguments)
    },
    isInputTarget: function(c) {
        var a = this,
            b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
        return Sys.UserInputUtils.isUserInputInSegment(b, a.clickArea) && Sys.UserInputUtils.isCoordinateTarget(a.canvasElement, c)
    },
    createTextLabel: function(j) {
        var i = this,
            g = j.text,
            d = j.offsetY || 0,
            f = j.offsetX || 0,
            k = 0,
            l = j.width,
            e = j.height,
            c = Animation.utils.getInMemoryCanvas(l, e),
            b = Services.languageManager.hasText(g) ? Services.languageManager.getText(g) : g,
            a = (Sys.isDefined(j.operations) ? j.operations : [{
                fillStyle: j.color,
                drawType: "fill"
            }]);
        if (j.alignment === "center") {
            c.ctx.textAlign = j.alignment;
            k = l / 2
        }
        if (j.shadowColor) {
            Animation.utils.text.wrapCanvasText(b, j.font, k, 0, l, j.lineHeight, [{
                textBaseline: j.textBaseline,
                shadowColor: j.shadowColor,
                shadowOffsetX: j.shadowOffsetX,
                shadowOffsetY: j.shadowOffsetY,
                shadowBlur: j.shadowBlur
            }], c.ctx, true, j.breakOn)
        }
        Animation.utils.text.wrapCanvasText(b, j.font, k, 0, l, j.lineHeight, a, c.ctx, true, j.breakOn);
        return new Animation.Item({
            width: l,
            height: e,
            left: i.dimensions.x + Math.round(Math.abs((l - i.dimensions.width) / 2)) + f,
            top: i.dimensions.y + Math.round(Math.abs((e - i.dimensions.height) / 2)) + d,
            depth: j.depth,
            image: c.canvas
        })
    }
};
SB.CanvasButton = Sys.extend(Interface.utils.CanvasButton, SB.CanvasButton, "SB.CanvasButton");
Sys.ns("Animation.utils");
Animation.utils.text.drawText = function(j, l, f, d, i, a, c) {
    var e, b, k, h, g;
    l = l || 50;
    f = f || "Verdana";
    d = d || 0;
    a = a || [{}];
    a[0] = a[0] || {};
    b = document.createElement("canvas");
    k = b.getContext("2d");
    e = Animation.utils.text.shrinkFont(j, l, f, d, i, k);
    b.width = e.dimensions.width;
    b.height = e.dimensions.height;
    h = d;
    g = e.dimensions.height / 2;
    if (c) {
        k.globalCompositeOperation = c.compositeOperation
    }
    Animation.utils.text.performOperations(j, e.font, h, g, a, k);
    return b
};
Sys.ns("SB");
SB.WinBannerView = {
    BACKGROUND_LEFT: undefined,
    BACKGROUND_TOP: 484,
    BACKGROUND_DEPTH: 150,
    BACKGROUND_IMAGE: "WinBanner",
    BACKGROUND_IMAGE_WIDTH: 293,
    BACKGROUND_IMAGE_HEIGHT: 109,
    SHOW_TOTAL_DURATION: 500,
    NUMBER_IMAGE: "CountUpNumber",
    NUMBER_WIDTH: 52,
    NUMBER_HEIGHT: 52,
    NUMBER_FONT: "50px Century Gothic, sans-serif",
    NUMBER_OFFSET: -20,
    NUMBER_TEXT_OPERATIONS: [{
        fillStyle: "#f9e791"
    }, {
        lineWidth: 0,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_DEPTH: 151,
    COUNT_UP_TOP: 537,
    COUNT_UP_EASING_TYPE: "ease-in",
    start: function(c) {
        var b = this,
            a = b.model.readData("coinWin"),
            d = b.model.readData("totalCoinWin");
        Game.Slots.WinBannerView.superclass.start.call(b, {
            from: d - a,
            to: d,
            duration: c,
            fireEventsOnValue: [{
                value: 0,
                event: "view:playSound",
                scope: b
            }, {
                value: d,
                event: "view:stopSound",
                argument: {
                    stopSound: true
                },
                scope: b
            }]
        })
    },
    refresh: function() {}
};
SB.WinBannerView = Sys.extend(Game.Slots.WinBannerView, SB.WinBannerView, "SB.WinBannerView");
Sys.ns("SB");
SB.WinBannerDesktopView = {
    SHOW_TOTAL_DURATION: 500,
    NUMBER_IMAGE: "CoinWin",
    NUMBER_WIDTH: 80,
    NUMBER_HEIGHT: 90,
    NUMBER_OFFSET: -30,
    COUNT_UP_LEFT: undefined,
    COUNT_UP_DEPTH: Layering.Game.Slots.WinBanner.text,
    COUNT_UP_TOP: (Platform.isIEBrowser) ? 575 : 571,
    COUNT_UP_EASING_TYPE: "ease-in",
    COUNTUP_LEFT: 0,
    COUNTUP_LENGTH: 0,
    COUNTUP_OFFSET: 2,
    FONT_FAMILY: "BauhausRegular",
    createItems: function() {
        var a = this;
        Game.Slots.WinBannerView.superclass.createItems.apply(this, arguments);
        a.winTextItem = a.createWinTextItem();
        a.list.add(a.winTextItem)
    },
    createWinTextItem: function() {
        var d = this,
            f = Services.languageManager.getText(Language.Keys.winColon_uc),
            e = 32,
            a = d.FONT_FAMILY,
            c = 550,
            g = Animation.utils.text.drawText(f, e, a, 0, c, [{
                fillStyle: "#ffffff"
            }]),
            b = Math.round(d.COUNT_UP_LEFT * d.scaleFactor) || Environment.getStageResolution().width / 2;
        d.COUNTUP_LEFT = g.width;
        return new Animation.Item({
            left: b,
            top: d.COUNT_UP_TOP - 23,
            width: g.width,
            height: g.height,
            depth: Layering.Game.Slots.WinBanner.background,
            image: g,
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 10000,
                    value: 0
                }]
            }
        })
    },
    createCountUpItem: function() {
        var b = this,
            c = Animation.utils.text.createNumberDrawingProperties(b),
            a = Math.round(b.COUNT_UP_LEFT * b.scaleFactor) || Environment.getStageResolution().width / 2;
        return new Animation.CanvasAnimationItem({
            left: a,
            top: Math.round(b.COUNT_UP_TOP * b.scaleFactor),
            width: 0,
            height: 0,
            depth: b.COUNT_UP_DEPTH,
            executeBefore: function(d) {
                var k = this,
                    f, h, g = this,
                    i = g.value.toString(),
                    e;
                Animation.utils.text.drawTextFromImage(i, b.NUMBER_OFFSET, k.pivot.x, k.pivot.y, true, c.image, c.charMap, c.width, c.height, d);
                if (Sys.isDefined(g.fireOnValue)) {
                    f = g.fireOnValue.length;
                    for (e = -1; ++e < f;) {
                        h = g.fireOnValue[e];
                        if (!h.fired && g.value >= h.value) {
                            h.scope.fireEvent(h.event, h.argument);
                            h.fired = true
                        }
                    }
                }
            },
            operations: {}
        })
    },
    start: function(c) {
        var b = this,
            a = b.model.readData("coinWin"),
            d = b.model.readData("totalCoinWin");
        b.COUNTUP_LENGTH = 15 * (d.toString().length);
        Game.Slots.WinBannerView.superclass.start.call(b, {
            from: d - a + 1,
            to: d,
            duration: c,
            fireEventsOnValue: [{
                value: d - a,
                event: "view:playSound",
                scope: b
            }, {
                value: d,
                event: "view:stopSound",
                argument: {
                    stopSound: true
                },
                scope: b
            }]
        });
        if (b.model.isAutoPlayMode() === true && b.model.readData("winType") !== "bigWin") {
            b.showTotal()
        }
    },
    setCountUpValues: function(a) {
        var e = this,
            g = e.countUpItem.prop,
            d, c = Math.round(e.COUNT_UP_LEFT * e.scaleFactor) || Environment.getStageResolution().width / 2,
            b = Math.round(e.COUNT_UP_TOP * e.scaleFactor),
            f = c + Math.round(e.COUNTUP_LEFT * e.scaleFactor) / 2 + e.COUNTUP_OFFSET;
        b += (Platform.isIEBrowser) ? -3 : 0;
        g.fireOnValue = a.fireEventsOnValue;
        if (e.model.readData("winType") === "bigWin") {
            d = a.from + (a.to * 5 / 100)
        } else {
            d = a.from
        }
        g.operations.value = [{
            time: 0,
            value: a.from,
            support: d,
            numDecimals: 0
        }, {
            time: a.duration,
            value: a.to,
            fireEvent: {
                event: "view:counterStop",
                scope: e
            }
        }, {
            time: a.duration + 600,
            value: a.to,
            fireEvent: {
                event: "view:countUpComplete",
                scope: e
            }
        }, {
            time: a.duration + 601,
            value: a.to
        }, {
            time: a.duration + 20000,
            value: a.to,
            goTo: 2
        }];
        g.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.3,
                scaleY: 0.3
            }
        }, {
            time: a.duration,
            value: {
                scaleX: 0.75,
                scaleY: 0.75
            }
        }, {
            time: a.duration + 200,
            value: {
                scaleX: 1.1,
                scaleY: 1.1
            }
        }, {
            time: a.duration + 400,
            value: {
                scaleX: 0.8,
                scaleY: 0.8
            }
        }, {
            time: a.duration + 600,
            value: {
                scaleX: 1.1,
                scaleY: 1.1
            }
        }, {
            time: a.duration + 800,
            value: {
                scaleX: 0.8,
                scaleY: 0.8
            }
        }, {
            time: a.duration + 1000,
            value: {
                scaleX: 1.1,
                scaleY: 1.1
            }
        }, {
            time: a.duration + 1200,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }, {
            time: a.duration + 20000,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }];
        g.operations.translate = [{
            time: 0,
            value: {
                left: c,
                top: b
            }
        }, {
            time: a.duration + 1200,
            value: {
                left: c,
                top: b
            }
        }, {
            time: a.duration + 1400,
            value: {
                left: f,
                top: b
            },
            fireEvent: {
                event: "view:winBannerAnimationComplete",
                scope: e
            }
        }, {
            time: a.duration + 10000,
            value: {
                left: f,
                top: b
            },
            goTo: 2
        }];
        if (e.model.readData("spinType") === "respin") {
            g.operations.scale = [{
                time: 0,
                value: {
                    scaleX: 0.3,
                    scaleY: 0.3
                }
            }, {
                time: a.duration,
                value: {
                    scaleX: 0.75,
                    scaleY: 0.75
                }
            }, {
                time: a.duration + 500,
                value: {
                    scaleX: 0.55,
                    scaleY: 0.55
                }
            }, {
                time: a.duration + 20000,
                value: {
                    scaleX: 0.55,
                    scaleY: 0.55
                }
            }];
            g.operations.translate = [{
                time: 0,
                value: {
                    left: c,
                    top: b
                }
            }, {
                time: a.duration + 500,
                value: {
                    left: c,
                    top: b
                }
            }, {
                time: a.duration + 700,
                value: {
                    left: f,
                    top: b
                },
                fireEvent: {
                    event: "view:winBannerAnimationComplete",
                    scope: e
                }
            }, {
                time: a.duration + 10000,
                value: {
                    left: f,
                    top: b
                },
                goTo: 2
            }]
        }
        g.operations.fade = [{
            value: 1,
            time: 0
        }, {
            value: 1,
            time: 1000
        }];
        e.configureStartAnimation(a.duration)
    },
    configureStartAnimation: function(e) {
        var c = this,
            f = c.winTextItem.prop,
            a = Math.round(c.COUNT_UP_LEFT * c.scaleFactor) || Environment.getStageResolution().width / 2,
            d = a - Math.round(c.COUNTUP_LEFT * c.scaleFactor) / 2 - Math.round(c.COUNTUP_LENGTH * c.scaleFactor) - c.COUNTUP_OFFSET,
            b = c.COUNT_UP_TOP - 23;
        f.operations = {
            fade: [{
                time: 0,
                value: 0
            }, {
                time: e + 1200,
                value: 0
            }, {
                time: e + 1201,
                value: 1
            }, {
                time: e + 10000,
                value: 1,
                goTo: 2
            }],
            translate: [{
                time: 0,
                value: {
                    left: a,
                    top: b
                }
            }, {
                time: e + 1200,
                value: {
                    left: a,
                    top: b
                }
            }, {
                time: e + 1400,
                value: {
                    left: d,
                    top: b
                }
            }, {
                time: e + 20000,
                value: {
                    left: d,
                    top: b
                },
                goTo: 2
            }]
        };
        if (c.model.readData("spinType") === "respin") {
            f.operations = {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: e + 500,
                    value: 0
                }, {
                    time: e + 501,
                    value: 1
                }, {
                    time: e + 10000,
                    value: 1,
                    goTo: 2
                }],
                translate: [{
                    time: 0,
                    value: {
                        left: a,
                        top: b
                    }
                }, {
                    time: e + 500,
                    value: {
                        left: a,
                        top: b
                    }
                }, {
                    time: e + 700,
                    value: {
                        left: d,
                        top: b
                    }
                }, {
                    time: e + 20000,
                    value: {
                        left: d,
                        top: b
                    },
                    goTo: 2
                }]
            }
        }
    },
    configureEndAnimation: function(d) {
        var c = this,
            g = c.countUpItem.prop,
            b = Math.round(c.COUNT_UP_LEFT * c.scaleFactor) || Environment.getStageResolution().width / 2,
            a = Math.round(c.COUNT_UP_TOP * c.scaleFactor),
            e = b - c.COUNTUP_LEFT / 2 - c.COUNTUP_LENGTH - c.COUNTUP_OFFSET,
            f = b + c.COUNTUP_LEFT / 2 + c.COUNTUP_OFFSET;
        a += (Platform.isIEBrowser) ? -3 : 0;
        g.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }, {
            time: d + 20000,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            },
            goTo: 0
        }];
        g.operations.fade = [{
            value: 1,
            time: 0,
            fireEvent: {
                event: "view:winBannerAnimationComplete",
                scope: c
            }
        }, {
            value: 1,
            time: d + 20000,
            goTo: 0
        }];
        c.winTextItem.prop.operations = {
            fade: [{
                time: 0,
                value: 1
            }, {
                time: d,
                value: 1,
                gpTo: 0
            }],
            translate: [{
                time: 0,
                value: {
                    left: e,
                    top: c.COUNT_UP_TOP - 23
                }
            }, {
                time: 0,
                value: {
                    left: e,
                    top: c.COUNT_UP_TOP - 23
                },
                goTo: 0
            }]
        };
        g.operations.translate = [{
            time: 0,
            value: {
                left: f,
                top: a
            }
        }, {
            time: d,
            value: {
                left: f,
                top: a
            }
        }]
    },
    showTotal: function(e) {
        var c = this,
            b, d = [],
            a;
        e = e || {};
        c.list.stop();
        b = c.countUpItem.prop.operations.value[1].value;
        c.countUpItem.prop.fireOnValue.length = 0;
        c.list.restore();
        d.push({
            value: b,
            time: 0
        });
        if (e.showUntilStopped) {
            d.push({
                value: b,
                time: 1,
                goTo: 0
            })
        } else {
            a = Sys.isDefined(e.showDuration) ? e.showDuration : c.SHOW_TOTAL_DURATION;
            d.push({
                value: b,
                time: a,
                fireEvent: {
                    event: "view:stopSound",
                    argument: {
                        stopSound: true
                    },
                    scope: c
                }
            })
        }
        c.countUpItem.value(d);
        c.configureEndAnimation(a);
        c.list.play()
    },
    configureLastAnimation: function(d) {
        var c = this,
            g = c.countUpItem.prop,
            b = Math.round(c.COUNT_UP_LEFT * c.scaleFactor) || Environment.getStageResolution().width / 2,
            a = Math.round(c.COUNT_UP_TOP * c.scaleFactor),
            e = b - Math.round(c.COUNTUP_LEFT * c.scaleFactor) / 2 - Math.round(c.COUNTUP_LENGTH * c.scaleFactor) - c.COUNTUP_OFFSET,
            f = b + Math.round(c.COUNTUP_LEFT * c.scaleFactor) / 2 + c.COUNTUP_OFFSET;
        a += (Platform.isIEBrowser) ? -3 : 0;
        g.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }, {
            time: d,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            },
            fireEvent: {
                event: "view:winBannerHide",
                scope: this
            }
        }];
        g.operations.fade = [{
            value: 1,
            time: 0
        }, {
            value: 1,
            time: d - 200
        }, {
            value: 0,
            time: d - 100
        }, {
            value: 0,
            time: d
        }];
        if (c.model.readData("spinType") !== "respin") {
            c.winTextItem.prop.operations = {
                fade: [{
                    time: 0,
                    value: 1
                }, {
                    time: d - 100,
                    value: 1
                }, {
                    time: d,
                    value: 0
                }],
                translate: [{
                    time: 0,
                    value: {
                        left: e,
                        top: c.COUNT_UP_TOP - 23
                    }
                }, {
                    time: d,
                    value: {
                        left: e,
                        top: c.COUNT_UP_TOP - 23
                    }
                }]
            };
            g.operations.translate = [{
                time: 0,
                value: {
                    left: f,
                    top: a
                }
            }, {
                time: d,
                value: {
                    left: f,
                    top: a
                }
            }]
        }
    },
    lastAnimation: function() {
        var c = this,
            b, d = [],
            a = 500;
        c.list.stop();
        b = c.countUpItem.prop.operations.value[1].value;
        c.countUpItem.prop.fireOnValue.length = 0;
        c.list.restore();
        d.push({
            value: b,
            time: 0
        });
        d.push({
            value: b,
            time: a
        });
        c.countUpItem.value(d);
        c.configureLastAnimation(a);
        c.list.play()
    },
    stopCountup: function() {
        var f = this,
            a = f.countUpItem.prop,
            d = Math.round(f.COUNT_UP_LEFT * f.scaleFactor) || Environment.getStageResolution().width / 2,
            i = Math.round(f.COUNT_UP_TOP * f.scaleFactor),
            h, c = f.winTextItem.prop,
            e = d - Math.round(f.COUNTUP_LEFT * f.scaleFactor) / 2 - Math.round(f.COUNTUP_LENGTH * f.scaleFactor) - f.COUNTUP_OFFSET,
            g = d + Math.round(f.COUNTUP_LEFT * f.scaleFactor) / 2 + f.COUNTUP_OFFSET,
            b = f.model.isAutoPlayMode();
        if (b === true && f.model.readData("winType") !== "bigWin") {
            return
        }
        c.operations = {
            fade: [{
                time: 500,
                value: 0
            }, {
                time: 501,
                value: 1
            }, {
                time: 10000,
                value: 1,
                goTo: 1
            }],
            translate: [{
                time: 500,
                value: {
                    left: d,
                    top: f.COUNT_UP_TOP - 23
                }
            }, {
                time: 700,
                value: {
                    left: e,
                    top: f.COUNT_UP_TOP - 23
                }
            }, {
                time: 20000,
                value: {
                    left: e,
                    top: f.COUNT_UP_TOP - 23
                },
                goTo: 1
            }]
        };
        i += (Platform.isIEBrowser) ? -3 : 0;
        h = f.countUpItem.prop.operations.value[1].value;
        a.operations.value = [{
            time: 0,
            value: h
        }, {
            time: 20000,
            value: h,
            goTo: 1
        }];
        a.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0.75,
                scaleY: 0.75
            }
        }, {
            time: 500,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }, {
            time: 20000,
            value: {
                scaleX: 0.55,
                scaleY: 0.55
            }
        }];
        a.operations.translate = [{
            time: 500,
            value: {
                left: d,
                top: i
            }
        }, {
            time: 700,
            value: {
                left: g,
                top: i
            },
            fireEvent: {
                event: "view:winBannerAnimationComplete",
                scope: f
            }
        }, {
            time: 10000,
            value: {
                left: g,
                top: i
            },
            goTo: 1
        }];
        f.list.restore()
    },
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.FONT_FAMILY = "SBMyroidProBold"
        }
        SB.WinBannerDesktopView.superclass.initAnimations.apply(this, arguments)
    },
    refresh: function() {}
};
SB.WinBannerDesktopView = Sys.extend(Game.Slots.WinBannerView, SB.WinBannerDesktopView, "SB.WinBannerDesktopView");
Sys.ns("SB");
SB.WinBannerController = {
    setupEvents: function() {
        var a = this;
        SB.WinBannerController.superclass.setupEvents.apply(this, arguments);
        if (Platform.isDesktopDevice) {
            a.on({
                "view:stopSound": a.handleStop,
                "request:winBanner.lastAnimation": a.lastAnimation,
                "view:winBannerHide": a.stop,
                "view:countUpComplete": a.countupComplete,
                "notify:winAnimations.winAnimationsFinished": a.winAnimationComplete,
                "view:winBannerAnimationComplete": a.fireEvent.bind(a, "notify:winBanner.animationComplete"),
                "view:counterStop": a.counterStop
            })
        } else {
            a.on({
                "view:stopSound": a.handleStop
            })
        }
    },
    start: function(a) {
        var b = this;
        SB.WinBannerController.superclass.start.apply(b, arguments);
        b.model.storeData("stopSoundPlayed", false);
        b.model.storeData("counterStop", false)
    },
    counterStop: function() {
        if (Platform.isDesktopDevice) {
            this.model.storeData("counterStop", true)
        }
    },
    countupComplete: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.fireEvent("notify:coinsField.countUpComplete");
            a.model.setState("countupComplete")
        } else {
            a.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
        }
    },
    winAnimationComplete: function() {
        var a = this;
        if (Platform.isDesktopDevice && !a.model.readData("counterStop") && a.isAnimationComplete()) {
            a.view.stopCountup()
        }
    },
    isAnimationComplete: function() {
        var a = this;
        return ((a.model.readData("spinType") === "respin" && a.model.isState("countingUp")) || (a.model.isState("countingUp") && a.model.isAutoPlayMode()))
    },
    lastAnimation: function() {
        var a = this;
        if (!a.model.isState("stopped")) {
            a.view.lastAnimation()
        }
    },
    handleStop: function(a) {
        var b = this;
        if (Platform.isDesktopDevice && b.model.readData("stopSoundPlayed")) {
            return
        } else {
            b.model.storeData("stopSoundPlayed", true);
            b.fireEvent("request:audioPlayer.stop", "winBannerCountUp");
            if (Sys.isDefined(a) && a.stopSound === true) {
                b.fireEvent("request:audioPlayer.play", {
                    name: "countUpLoopEnd",
                    id: "countUpLoopEnd"
                })
            }
        }
    }
};
SB.WinBannerController = Sys.extend(Game.Slots.WinBannerController, SB.WinBannerController, "SB.WinBannerController");
Sys.ns("SB");
SB.WinBannerModel = {
    processServerResponse: function(b) {
        var a = this;
        SB.WinBannerModel.superclass.processServerResponse.apply(a, arguments);
        a.storeData("spinType", b.nextaction);
        if (Sys.isDefined(b.wins)) {
            a.storeData("winType", b.wins.winType)
        }
    },
    isAutoPlayMode: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            b = Sys.isDefined(a) && a > 0;
        return b
    }
};
SB.WinBannerModel = Sys.extend(Game.Slots.WinBannerModel, SB.WinBannerModel, "SB.WinBannerModel");
Sys.ns("Interface.Slots");
SB.CoinsField = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.CoinsFieldModel,
            controller: SB.CoinsFieldController,
            view: SB.CoinsFieldBaseView
        }
    }
};
SB.CoinsField = Sys.extend(Interface.Slots.CoinsField, SB.CoinsField, "SB.CoinsField");
Sys.ns("SB");
SB.CoinsFieldModel = {
    setupData: function() {
        this.WIN_UP_TO = "50000";
        SB.CoinsFieldModel.superclass.setupData.apply(this, arguments)
    },
    processServerResponse: function(b) {
        var a = this;
        if (b.restore && b.nextaction === "respin" && b.totalwin.coins > 0) {
            a.storeData("hasLastSpinWin", true);
            a.storeData("restoreWin", b.totalwin.coins)
        }
        a.storeData("spinType", b.nextaction);
        a.storeData("currentSpinType", b.clientaction);
        SB.CoinsFieldModel.superclass.processServerResponse.apply(a, arguments)
    }
};
SB.CoinsFieldModel = Sys.extend(Interface.Slots.CoinsFieldModel, SB.CoinsFieldModel, "SB.CoinsFieldModel");
Sys.ns("SB");
SB.CoinsFieldController = {
    setupEvents: function() {
        var a = this;
        SB.CoinsFieldController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:coinsField.showProgressiveWinBanner": a.onShowProgressiveWinBanner
        });
        if (Platform.isDesktopDevice) {
            a.on({
                "notify:featureSplash.closed": a.onFeatureSplashClosed,
                "request:winBanner.animate": a.countupstart,
                "request:spin.startNewRound": a.onRoundStart
            })
        }
    },
    countupstart: function() {
        var a = this;
        a.view.stopAllAnimations();
        a.fireEvent("notify:winBanner.animate", "notify:winBanner.animationComplete")
    },
    onServerResponse: function(b) {
        var a = this;
        a.model.processServerResponse(b);
        if (Platform.isDesktopDevice && b.clientaction !== "init") {
            if (a.model.readData("hasLastSpinWin")) {
                a.showCoinWin()
            } else {
                a.showBalanceAndBet()
            }
        }
    },
    onShowProgressiveWinBanner: function(c) {
        if (!Platform.isDesktopDevice) {
            var b = this,
                a = b.model.readData("totalWin") === "" ? 0 : b.model.readData("totalWin"),
                d = b.model.readData("win") === "" ? 0 : b.model.readData("win");
            b.onShowProgressiveWinRequest(c);
            b.view.changeProgressiveWinCoinValue(a, d)
        }
    },
    onEnteringIdleState: function() {
        var a = this;
        if (!Platform.isDesktopDevice) {
            SB.CoinsFieldController.superclass.onEnteringIdleState.apply(this, arguments)
        } else {
            a.model.storeData("shouldShowIdleAnimation", true);
            if (a.model.readData("hasLastSpinWin")) {
                a.model.storeData("hasLastSpinWin", false);
                if (a.model.readData("win") === 0) {
                    a.showCoinWin();
                    return
                }
            }
            if (a.model.readData("win") > 0) {
                a.view.stopAllAnimations()
            }
        }
    },
    onFeatureSplashClosed: function() {
        var a = this;
        a.view.showBalanceAndBet();
        if (Platform.isDesktopDevice) {
            a.TOGGLE_SEQUENCE = []
        }
    },
    showInfoBanner: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.view.showInfoBanner(a.currentToggleConfig)
        }
    },
    showWin: function() {
        var a = this;
        SB.CoinsFieldController.superclass.showWin.apply(a, arguments)
    },
    showCoinWin: function() {
        if (Platform.isDesktopDevice) {
            this.view.showCoinWin()
        }
    },
    onSettingsWindowOpened: function() {
        if (Platform.isDesktopDevice) {
            return
        }
        clearTimeout(this.toggleTimeout);
        this.showBalanceAndBet()
    },
    onEnteringSpinningState: function() {
        if (!Platform.isDesktopDevice) {
            var a = this;
            SB.CoinsFieldController.superclass.onEnteringSpinningState.apply(a, arguments)
        }
    },
    onInfoChanged: function(b) {
        var a = this;
        a.fireEvent("request:dimmedSymbols.unDimNoWinSymbols", b.doAnimate);
        if (!Platform.isDesktopDevice) {
            a.view.showBalanceAndBet()
        } else {
            a.view.updateTexts();
            if (a.model.readData("shouldShowIdleAnimation")) {
                a.fireEvent("request:idleAnimation.animateAllSymbols")
            }
        }
    },
    onRoundStart: function() {
        var a = this;
        a.model.storeData("shouldShowIdleAnimation", false)
    },
    onBeforeLoaderClose: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            if (a.model.readData("hasLastSpinWin")) {
                a.showCoinWin()
            } else {
                this.view.showBalanceAndBet()
            }
        } else {
            SB.CoinsFieldController.superclass.onBeforeLoaderClose.apply(a, arguments)
        }
    }
};
SB.CoinsFieldController = Sys.extend(Interface.Slots.CoinsFieldController, SB.CoinsFieldController, "SB.CoinsFieldController");
Sys.ns("SB");
SB.CoinsFieldBaseView = {
    showInfoBanner: function() {},
    hideInfoBanner: function() {},
    showCoinWin: function() {},
    clearWinUpToTimeout: function() {},
    changeProgressiveWinCoinValue: function(a, c) {
        var b = this;
        b.progressiveWinCoinsElement.textContent = "";
        b.totalWinCoinsElement.textContent = (a - c) === 0 ? "" : (a - c)
    }
};
SB.CoinsFieldBaseView = Sys.extend(Interface.Slots.CoinsFieldBaseView, SB.CoinsFieldBaseView, "SB.CoinsFieldBaseView");
Sys.ns("SB");
SB.CoinsFieldDesktopView = {
    HAS_LOADED: false,
    BASE_CSS: "interface-coinsField_desktop",
    GAME_MODES: ["BASIC"],
    BASIC_BET_LABEL: {
        font: "21px BauhausRegular",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 78,
            y: (Platform.isIEBrowser) ? 604 : 600,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "center",
            vertical: false
        }
    },
    BASIC_BET_VALUE: {
        font: "36px BauhausRegular",
        fillstyle: "#FCE0AD",
        position: {
            x: 77,
            y: (Platform.isIEBrowser) ? 635 : 628,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "center",
            vertical: false
        }
    },
    BASIC_BALANCE_LABEL: {
        font: "21px BauhausRegular",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {
            x: 1008,
            y: (Platform.isIEBrowser) ? 604 : 600,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "center",
            vertical: false
        }
    },
    BASIC_BALANCE_VALUE: {
        font: "36px BauhausRegular",
        fillstyle: "#FCE0AD",
        position: {
            x: 1008,
            y: (Platform.isIEBrowser) ? 635 : 628,
            width: 267,
            height: 133
        },
        alignment: {
            horizontal: "center",
            vertical: false
        }
    },
    BASIC_BACKGROUND: {
        image: "keypadBackground",
        position: {
            x: 0,
            y: 525,
            width: 1280,
            height: 195
        }
    },
    HAS_ABORT: false,
    WIN_UP_TO: {
        left: 640,
        top: (Platform.isIEBrowser) ? 571 : 569,
        textOperation: [{
            fillStyle: "#FCE0AD",
            drawType: "fill",
            shadowColor: "#ff8c21",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 25
        }],
        fontSize: "36",
        fontFamily: "BauhausRegular",
        xoffset: 0,
        yoffset: 2
    },
    WIN_TEXT: {
        left: 640,
        top: (Platform.isIEBrowser) ? 575 : 569,
        textOperation: [{
            fillStyle: "#ffffff"
        }],
        fontSize: "32",
        fontFamily: "BauhausRegular",
        xoffset: 17,
        yoffset: 2
    },
    WIN_NUMBER: {
        left: 640,
        top: (Platform.isIEBrowser) ? 579 : 571,
        textOperation: [{
            textBaseline: "middle",
            shadowColor: "#b15d0f",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 12
        }, {
            textBaseline: "middle",
            shadowColor: "#b15d0f",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 12
        }, {
            textBaseline: "middle",
            shadowColor: "#b15d0f",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 12
        }, {
            textBaseline: "middle",
            shadowColor: "#b15d0f",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 0
        }, {
            fillStyle: "#FFFEB4"
        }],
        fontSize: "48",
        fontFamily: "BauhausRegular",
        xoffset: -10,
        yoffset: 0
    },
    updateSubTypeTexts: function(j, k, g, f) {
        var o = this,
            l = Object.keys(j),
            r = l.length,
            p, n, q, c, h;
        for (h = -1; ++h < r;) {
            p = l[h];
            n = j[p];
            q = n.item;
            c = q.prop;
            var b = k + "_" + f + "_" + p,
                e = c.customProps.defaultMainType + "_" + f + "_" + p,
                d = (Sys.isDefined(o[b]) ? o[b].font : o[e].font),
                a = [{
                    fillStyle: (o[b]) ? o[b].fillstyle : o[e].fillstyle,
                    drawType: "fill"
                }],
                m;
            if (p === "VALUE") {
                a = [{
                    fillStyle: (o[b]) ? o[b].fillstyle : o[e].fillstyle,
                    drawType: "fill",
                    shadowColor: "#ff8c21",
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    shadowBlur: 25
                }]
            }
            m = o.getAlignment(b, e);
            if (g) {
                o.updateTextItem(q, n.valueFunction.call(o), d, a, m);
                if (!q.prop.running) {
                    q.play()
                }
            } else {
                q.stop()
            }
        }
    },
    updateTextItem: function(l, c, d, a, f, j) {
        var b = l.prop,
            i = Sys.isDefined(f) ? f : {
                horizontal: "left",
                vertical: false
            },
            h = i.horizontal === "right" ? b.width : 0,
            e = b.customProps.inMemCanvas,
            g = Animation.utils.text.measureText(c.toString(), d, 0, e.ctx).height / 2,
            k = Sys.isDefined(j) ? j : 20;
        e.ctx.clearRect(0, 0, e.canvas.width, e.canvas.height);
        if (i.horizontal === "center") {
            h = b.width / 2
        }
        e.ctx.globalCompositeOperation = "lighter";
        e.ctx.imageSmoothingEnabled = true;
        e.ctx.fontSmoothingEnabled = true;
        if (!isNaN(c) && String(c).length > 9) {
            Animation.utils.text.wrapCanvasText(c.toString(), d, h, 7, 190, k, a, e.ctx, i.vertical)
        } else {
            Animation.utils.text.wrapCanvasText(c.toString(), d, h, g, b.width, k, a, e.ctx, i.vertical)
        }
    },
    countUpCallback: function() {
        Interface.Slots.CoinsFieldDesktopView.superclass.countUpCallback.apply(this, arguments)
    },
    showCoinWin: function() {
        var a = this;
        this.hideWinupTo();
        if (a.model.getState() !== "showingWinInRestore") {
            this.showWinInRestore()
        }
    },
    showBalanceAndBet: function() {
        var a = this;
        a.showWinUpToBalance()
    },
    showWinUpToBalance: function() {
        var a = this;
        if (a.model.getState() === "showingWinInRestore") {
            a.hideWinInRestore()
        }
        if (a.model.getState() !== "showingBalance" && !(a.model.readData("currentSpinType") === "respin" && a.model.readData("totalWin") > 0)) {
            a.showWinupTo()
        }
    },
    showWin: function() {
        this.updateTexts();
        if (this.model.readData("win") > 0) {
            this.hideWinupTo()
        }
    },
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.BASIC_BET_LABEL.font = "21px SBMyroidProBold";
            b.BASIC_BET_VALUE.font = "36px SBMyroidProBold";
            b.BASIC_BALANCE_LABEL.font = "21px SBMyroidProBold";
            b.BASIC_BALANCE_VALUE.font = "36px SBMyroidProBold";
            b.WIN_UP_TO.fontFamily = "SBMyroidProBold";
            b.WIN_TEXT.fontFamily = "SBMyroidProBold";
            b.WIN_NUMBER.fontFamily = "SBMyroidProBold"
        }
        SB.CoinsFieldDesktopView.superclass.initAnimations.apply(b, arguments);
        b.winUpToList = new Animation.CanvasAnimationList({});
        b.winInRestoreList = new Animation.CanvasAnimationList({});
        b.winuptoAnimation = b.createWinUpTo();
        b.winUpToList.add(b.winuptoAnimation);
        b.winTextAnimation = b.createWinText();
        b.winNumberAnimation = b.createWinNumber();
        b.winInRestoreList.add(b.winTextAnimation);
        b.winInRestoreList.add(b.winNumberAnimation);
        Game.stage.view.addToRenderLoop(b.winUpToList);
        Game.stage.view.addToRenderLoop(b.winInRestoreList);
        b.winUpToList.stop();
        b.winInRestoreList.stop()
    },
    createWinUpTo: function() {
        var b = this,
            a = b.WIN_UP_TO,
            c, d;
        d = Services.languageManager.getText(Language.Keys.winUpTo).replace("{0}", b.model.getWinUpToText());
        c = Animation.utils.text.drawText(d, a.fontSize, a.fontFamily, 15, 778, a.textOperation, {
            compositeOperation: "lighter"
        });
        if (Platform.isIEBrowser) {
            a.yoffset = a.yoffset + 4
        }
        return new Animation.CanvasAnimationItem({
            left: a.left - c.width / 2 + a.xoffset,
            top: a.top - c.height / 2 + a.yoffset,
            width: c.width,
            height: c.height,
            depth: Layering.Game.Slots.WinBanner.text,
            image: c,
            operations: {}
        })
    },
    createWinText: function() {
        var b = this,
            a = b.WIN_TEXT,
            c, d;
        d = Services.languageManager.getText(Language.Keys.winColon_uc);
        c = Animation.utils.text.drawText(d, a.fontSize, a.fontFamily, 17, 778, a.textOperation);
        return new Animation.CanvasAnimationItem({
            left: a.left - c.width + a.xoffset,
            top: a.top - c.height / 2 + a.yoffset,
            width: c.width,
            height: c.height,
            depth: Layering.Game.Slots.WinBanner.text,
            image: c
        })
    },
    createWinNumber: function() {
        var b = this,
            a = b.WIN_NUMBER,
            c, d;
        d = b.model.readData("restoreWin");
        c = Animation.utils.text.drawText(d, a.fontSize, a.fontFamily, 17, 778, a.textOperation);
        return new Animation.CanvasAnimationItem({
            left: a.left + a.xoffset,
            top: a.top - c.height / 2 + a.yoffset,
            width: c.width,
            height: c.height,
            depth: Layering.Game.Slots.WinBanner.text,
            image: c
        })
    },
    showWinupTo: function() {
        var a = this;
        a.model.setState("showingBalance");
        if (a.HAS_LOADED) {
            a.winuptoAnimation.prop.operations = {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 1500,
                    value: 0
                }, {
                    time: 1700,
                    value: 1
                }, {
                    time: 3000,
                    value: 1,
                    goTo: 2
                }]
            }
        } else {
            a.HAS_LOADED = true;
            a.winuptoAnimation.prop.operations = {}
        }
        if (a.model.readData("win") === 0) {
            a.winUpToList.play()
        }
    },
    hideWinupTo: function() {
        var a = this;
        a.model.setState("hidingBalance");
        a.winUpToList.stop()
    },
    showWinInRestore: function() {
        var a = this;
        a.model.setState("showingWinInRestore");
        a.winInRestoreList.play()
    },
    hideWinInRestore: function() {
        var a = this;
        a.model.setState("hidingWinInRestore");
        a.winInRestoreList.stop()
    },
    stopAllAnimations: function() {
        var a = this;
        a.model.setState("hidingBalance");
        a.winUpToList.stop();
        a.winInRestoreList.stop()
    }
};
SB.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldDesktopView, SB.CoinsFieldDesktopView, "SB.CoinsFieldDesktopView");
Sys.ns("SB");
SB.CoinsFieldMobileView = {
    BASE_CSS: "interface-coinsField_base interface-coinsField_mobile",
    PORTRAIT_CSS: "interface-coinsField_portrait_mobile",
    LANDSCAPE_CSS: "interface-coinsField_landscape_mobile"
};
SB.CoinsFieldMobileView = Sys.extend(SB.CoinsFieldBaseView, SB.CoinsFieldMobileView, "SB.CoinsFieldMobileView");
Sys.ns("SB");
SB.ExpandingWild = {
    getMixinDependencies: function() {
        return [{
            userInput: {
                inputEvents: ["start"]
            }
        }]
    },
    getDefaultMVCClasses: function() {
        return {
            model: SB.ExpandingWildModel,
            controller: SB.ExpandingWildController,
            view: SB.ExpandingWildView
        }
    },
    getStateChanges: function() {
        return {
            stopped: {
                waitEvents: ["notify:ExpandingWild.AllExpandingWildAnimationsFinished"]
            },
            beforeLoaderClose: {
                queue: [function() {}],
                waitEvents: ["notify:ExpandingWild.ExpandingWildAnimationFinished"]
            }
        }
    }
};
SB.ExpandingWild = Sys.extend(Core.Module, SB.ExpandingWild, "SB.ExpandingWild");
Sys.ns("SB");
SB.ExpandingWildController = {
    IS_ABORT: false,
    ReelsOnWhichWildSymbolCanLand: [1, 2, 3],
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:spin.reelStoppedSpinning": a.onReelStoppedSpinning,
            "notify:stateHandler.enteringSpinningState": a.onEnteringSpinnigState,
            "request:expandingWild.glowAnimationLoaded": a.glowAnimationLoaded,
            "request:expandingWild.storeWildAnimation": a.initWildAnimations,
            "view:Wild_second_spinAnimationCompleted": a.onAnimationComplete,
            "notify:stateHandler.enteringIdleState": a.restoreAnimation,
            "view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
            "view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
            "notify:stateHandler.enteringStoppedState": a.onEnteringStoppedState,
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:serverManager.serverErrorReceived": a.errorResponse,
            "view:glowFadeOutStart": a.requestHideFader,
            "view:staticBGFadeOut": a.requestHideFader,
            "view:glowFadeOutComplete": a.glowFadeOutComplete,
            "view:staticBGFadeOutComplete": a.glowFadeOutComplete,
            "view:glowFadeInStart": a.requestChangeToLightFader,
            "view:bgAnimationComplete": a.onBgAnimationComplete,
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.executeOnGameRestore,
            "notify:stateHandler.enteringStandardWinPresentationState": a.dimNonWinningWildSymbols,
            "notify:stateHandler.enteringBigWinState": a.dimNonWinningWildSymbols,
            "notify:stateHandler.leavingIdleState": a.undimNonWinningWildSymbols,
            "notify:ExpandingWildAnimationComplete": a.changeTopFader,
            "notify:wildExpanding.stopAnimation": a.onUserInputKeyDown
        })
    },
    changeTopFader: function() {
        if (Platform.isDesktopDevice) {
            this.view.configTopRainbowFader(100)
        }
    },
    dimNonWinningWildSymbols: function() {
        var e = this,
            f;
        for (f = 1; f <= 3; f++) {
            var a = e.view.AnimationItems[f],
                b = [],
                c;
            b[0] = a.Wild_nospin;
            b[1] = a.WildSym_firstspin;
            b[2] = a.WildSym_secondspin;
            for (c = 0; c < 3; c++) {
                var d = b[c];
                if (Sys.isDefined(d.prop.symPos) && e.model.shouldSymDim({
                        reelPos: parseInt(f, 10),
                        symPos: d.prop.symPos
                    })) {
                    e.view.updateOperations(d, 0.3);
                    e.model.readData("dimSymbolsCol").push(d)
                } else {
                    if (Sys.isDefined(d.prop.symPos) && !(e.model.shouldSymDim({
                            reelPos: parseInt(f, 10),
                            symPos: d.prop.symPos
                        }))) {
                        e.view.updateOperations(d, 1)
                    }
                }
            }
        }
    },
    undimNonWinningWildSymbols: function() {
        var e = this,
            f;
        if (Sys.isDefined(e.view.AnimationItems) && Platform.isDesktopDevice) {
            for (f = 1; f <= 3; f++) {
                var a = e.view.AnimationItems[f],
                    b = [],
                    c;
                b[0] = a.Wild_nospin;
                b[1] = a.WildSym_firstspin;
                b[2] = a.WildSym_secondspin;
                for (c = 0; c < 3; c++) {
                    var d = b[c];
                    e.view.updateOperations(d, 1)
                }
            }
        }
    },
    glowFadeOutComplete: function() {
        if (!Platform.isDesktopDevice) {
            this.requestChangeFader("darkFader")
        }
        this.fireEvent("notify:ExpandingWildAnimationComplete")
    },
    onEnteringSpinnigState: function() {
        var b = this,
            a;
        if (b.model.readData("nextAction") === "spin") {
            b.view.stopWildSymbols()
        } else {
            if (Platform.isDesktopDevice && Sys.isDefined(b.model.readData("dimSymbolsCol"))) {
                b.fireEvent("request:spinButton.enable", this.MODULE_NAME);
                for (a = 0; a < b.model.readData("dimSymbolsCol").length; a++) {
                    b.view.updateOperations(b.model.readData("dimSymbolsCol")[a], 1)
                }
            }
        }
    },
    onBgAnimationComplete: function() {
        if (!Platform.isDesktopDevice) {
            this.requestChangeFader("lightFader")
        }
        this.fireEvent("request:coinsField.showProgressiveWinBanner")
    },
    onServerResponse: function(a) {
        var c = this;
        c.model.processServerResponse(a);
        c.reelsStoped = false;
        c.IS_ABORT = false;
        var b = c.model.readData("wildToBeAnimatedOnReels");
        if (b.length > 0 && !Platform.isDesktopDevice) {
            c.startListeningToUserInput()
        }
        if (b.length < 1 && Platform.isDesktopDevice) {
            c.startListeningToUserInput();
            c.IS_ABORT = true
        }
    },
    errorResponse: function() {
        this.model.storeData("symbolsToAnimate", [])
    },
    initAnimations: function() {
        var a = this;
        a.loadBackground();
        a.loadAnimations()
    },
    loadBackground: function() {
        var a = this;
        a.fireEvent("request:cutOutAnimation.setupAnimation", {
            cfg: {
                name: "BgGlow",
                depth: Layering.Game.Slots.ExpandingWild.glow,
                events: [{
                    onFrame: "end",
                    event: "view:bgAnimationComplete",
                    scope: a.view
                }],
                baseCfg: {
                    id: "BgGlow",
                    fullScreen: true
                }
            },
            endEvent: "request:expandingWild.glowAnimationLoaded"
        })
    },
    glowAnimationLoaded: function(a) {
        var b = this;
        if (Sys.isDefined(a)) {
            b.view.GlowAnimItem = a;
            b.view.initGlowBackground()
        }
    },
    executeOnGameRestore: function() {
        var b = this;
        if (b.model.isExpandingWild()) {
            var a = b.model.readData("symbolsToAnimate"),
                c = a.map(function(d) {
                    return d.x
                });
            b.model.storeData("animatingOnReels", c);
            b.handleAmbiance(true);
            b.skipWildAnimation();
            b.fireEvent("notify:ExpandingWild.ExpandingWildAnimationCompleted", "notify:ExpandingWild.ExpandingWildAnimationFinished")
        } else {
            b.fireEvent("notify:ExpandingWild.ExpandingWildAnimationFinished");
            b.notifyAllExpandingWildAnimFinished(true);
            b.requestChangeFader("darkFader")
        }
    },
    loadAnimations: function() {
        var b = this,
            a;
        for (a = 0; a < b.ReelsOnWhichWildSymbolCanLand.length; a++) {
            var c = b.getAnimationsConfigToCreate(b.ReelsOnWhichWildSymbolCanLand[a]);
            this.fireEvent("request:cutOutAnimation.setupAnimation", {
                cfg: c,
                endEvent: "request:expandingWild.storeWildAnimation"
            })
        }
    },
    getAnimationsConfigToCreate: function(b) {
        var a = this,
            c = Layering.Game.Slots.ExpandingWild;
        return [{
            name: "Rainbow_container",
            depth: c.rainbow_container,
            events: [{
                onFrame: "end",
                event: "view:rainbowAnimationCompleted",
                scope: a.view,
                argument: b
            }],
            baseCfg: {
                id: "Rainbow_container",
                left: 0,
                top: 0
            }
        }, {
            name: "particle_container",
            depth: c.particle_container,
            loopOperation: true,
            baseCfg: {
                id: "particle_container",
                left: 0,
                top: 0
            }
        }, {
            name: "particle2_container",
            depth: c.particle_container,
            loopOperation: true,
            baseCfg: {
                id: "particle2_container",
                left: 0,
                top: 0
            }
        }, {
            name: "Wild_nospin",
            depth: c.symbols,
            events: [{
                onFrame: "end",
                event: "view:Wild_nospinAnimationCompleted",
                scope: a.view,
                argument: b
            }],
            baseCfg: {
                id: "Wild_nospin",
                left: 0,
                top: 0
            }
        }, {
            name: "Burst_container",
            depth: c.burst_container,
            baseCfg: {
                id: "Burst_container",
                left: 0,
                top: 0
            }
        }, {
            name: "WildSym_firstspin",
            depth: c.symbols,
            events: [{
                onFrame: "end",
                event: "view:Wild_first_spinAnimationCompleted",
                scope: a.view,
                argument: b
            }],
            baseCfg: {
                id: "WildSym_firstspin",
                left: 0,
                top: 0
            }
        }, {
            name: "WildSym_secondspin",
            depth: c.symbols,
            events: [{
                onFrame: "end",
                event: "view:Wild_second_spinAnimationCompleted",
                scope: a.view,
                argument: b
            }],
            baseCfg: {
                id: "WildSym_secondspin",
                left: 0,
                top: 0
            }
        }]
    },
    initWildAnimations: function(c) {
        var e = this,
            b = e.view.AnimationItems,
            f = {},
            d;
        if (Sys.isArray(c)) {
            Sys.each(c, function(g) {
                f = Sys.apply(f, g)
            })
        }
        for (var a = 0; a < e.ReelsOnWhichWildSymbolCanLand.length; a++) {
            d = e.ReelsOnWhichWildSymbolCanLand[a];
            if (!Sys.isDefined(b[d])) {
                b[d] = f;
                break
            }
        }
        if (Object.keys(b).length === 3) {
            e.view.initExpandingWildAnimations()
        }
    },
    onAnimationComplete: function(b) {
        var d = this,
            c = d.model.readData("wildToBeAnimatedOnReels"),
            a = c[c.length - 1];
        d.fireEvent("notify:ExpandingWild.ExpandingWildAnimationFinished");
        if ((a === b || "" + a === b) && !d.model.readData("quickStopped")) {
            d.notifyAllExpandingWildAnimFinished(false)
        }
    },
    onReelStoppedSpinning: function(d) {
        var f = this,
            b = f.model.readData("symbolsToAnimate"),
            a = f.model.readData("quickStopped"),
            c = b.filter(function(g) {
                return g.x === d
            }),
            e = f.model.readData("wildToBeAnimatedOnReels");
        if (c.length > 0 && !a) {
            if (Sys.contains(e, c[0].x)) {
                f.view.expandWild(c[0]);
                if (Platform.isDesktopDevice) {
                    f.fireEvent("request:spinButton.disable", this.MODULE_NAME)
                }
            }
            f.fireEvent("request:spin.setReelsVisibility", {
                reels: [d],
                opacity: 0,
                time: (Platform.isDesktopDevice) ? 1000 : 200
            })
        }
    },
    notifyAllExpandingWildAnimFinished: function(b) {
        var a = this;
        a.stopListeningToUserInput();
        a.handleAmbiance(b);
        a.fireEvent("notify:ExpandingWild.AllExpandingWildAnimationsFinished")
    },
    onUserInputKeyDown: function() {
        var a = this;
        if (a.IS_ABORT) {
            a.model.storeData("quickStopped", true)
        }
    },
    onUserInputStart: function() {
        var b = this,
            a = b.model.readData("symbolsToAnimate"),
            c = a.map(function(d) {
                return d.x
            });
        b.model.storeData("quickStopped", true);
        b.model.storeData("animatingOnReels", c);
        if (b.reelsStoped) {
            b.skipWildAnimation();
            b.notifyAllExpandingWildAnimFinished(false)
        }
    },
    stopAnimationIfQuickStopped: function() {
        var a = this;
        if (a.model.readData("quickStopped")) {
            a.skipWildAnimation()
        }
    },
    onEnteringStoppedState: function() {
        var b = this,
            a = b.model.readData("wildToBeAnimatedOnReels");
        b.reelsStoped = true;
        b.stopAnimationIfQuickStopped();
        if (!a.length || b.model.readData("quickStopped")) {
            b.notifyAllExpandingWildAnimFinished(false)
        }
    },
    handleAmbiance: function(c) {
        var b = this,
            a = b.model.getAmbianceSndChange();
        if (a.change && b.ambienceAlreadySet !== a.snd) {
            b.ambienceAlreadySet = a.snd;
            if ((c && a.snd === "ambienceRespin") || !c) {
                b.fireEvent("request:ambienceManager.ambienceChangeActive", {
                    name: a.snd,
                    id: a.snd,
                    loop: true
                })
            }
        }
    },
    skipWildAnimation: function() {
        var a = this;
        a.fireEvent("request:audioPlayer.stop", "wildExpansionSnd");
        a.view.skipWildAnimation();
        a.fireEvent("request:spin.setReelsVisibility", {
            reels: a.model.readData("animatingOnReels"),
            opacity: 0
        })
    },
    restoreAnimation: function() {
        var c = this,
            b = c.model.isModeChanged(),
            a = c.model.readData("nextAction"),
            d = c.model.readData("mode");
        if (d === "respin" && ((b && a === "spin") || !c.model.readData("quickStopped"))) {
            c.fireEvent("request:audioPlayer.play", {
                name: "wildRainbowExitSnd",
                id: "wildRainbowExitSnd"
            });
            c.view.restoreAnimation()
        } else {
            this.fireEvent("notify:ExpandingWildAnimationComplete")
        }
    },
    requestHideFader: function() {
        this.fireEvent("request:background.hideFader")
    },
    requestChangeFader: function(a) {
        this.fireEvent("request:background.changeFader", a)
    },
    requestChangeToLightFader: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.fireEvent("request:background.changeFader", "lightFader")
        } else {
            a.requestHideFader()
        }
    }
};
SB.ExpandingWildController = Sys.extend(Core.Controller, SB.ExpandingWildController, "SB.ExpandingWildController");
Sys.ns("SB");
SB.ExpandingWildModel = {
    SYMBOLS_TO_ANIMATE: ["SYM1"],
    constructor: function() {
        SB.ExpandingWildModel.superclass.constructor.apply(this, arguments);
        this.storeData("symbolsToAnimate", []);
        this.storeData("animatingOnReels", [])
    },
    processServerResponse: function(f) {
        var v = this,
            k = f.reelInfo,
            a, m, s = [],
            l = v.readData("animatingOnReels"),
            u, r = [],
            o, q, d = [],
            e, b = [];
        v.storeData("symbolsToAnimate", []);
        for (var p = -1; ++p < k.length;) {
            a = k[p].symbols;
            for (var t = -1; ++t < a.length;) {
                m = a[t];
                if (Sys.contains(v.SYMBOLS_TO_ANIMATE, m) && !v.symbolAlreadyAddedForAnimation(p, t)) {
                    u = {
                        x: p,
                        y: t,
                        symIdx: m
                    };
                    s.push(u);
                    v.storeData("symbolsToAnimate", s);
                    if (!Sys.contains(l, p)) {
                        r.push(p)
                    }
                }
            }
        }
        o = (f.clientaction !== f.nextaction);
        v.storeData("winningWildSymbols", []);
        v.storeData("dimSymbolsCol", []);
        if (f.clientaction === "spin") {
            v.storeData("animatingOnReels", []);
            v.storeData("mode", "basic")
        } else {
            if (f.clientaction === "respin") {
                v.storeData("mode", "respin")
            }
        }
        v.storeData("modeChanged", o);
        v.storeData("nextAction", f.nextaction);
        v.storeData("quickStopped", false);
        v.storeData("wildToBeAnimatedOnReels", r);
        var c = 0;
        e = v.readData("symbolsToAnimate");
        Sys.each(e, function(i) {
            b[c] = i.x;
            c++
        });
        if (Sys.isArray(b) && b.length > 0 && f.wins.winSituations && Platform.isDesktopDevice) {
            for (q = 0; q < f.wins.winSituations.length; q++) {
                var h = f.wins.winSituations[q],
                    n = 0;
                for (n = 0; n < h.positions.length; n++) {
                    if (b.contains(h.positions[n].reelIndex)) {
                        var g = {
                            reelPos: h.positions[n].reelIndex,
                            symPos: h.positions[n].symbolIndex
                        };
                        if (!v.hasItem(d, g)) {
                            d.push(g)
                        }
                    }
                }
            }
            v.storeData("winningWildSymbols", d)
        }
    },
    shouldSymDim: function(a) {
        var b = this,
            c = b.readData("winningWildSymbols");
        return (!Sys.isDefined(c) || c.length === 0) ? false : !b.hasItem(c, a)
    },
    isModeChanged: function() {
        return this.readData("modeChanged")
    },
    symbolAlreadyAddedForAnimation: function(b) {
        var c = false,
            a = this.readData("symbolsToAnimate");
        Sys.each(a, function(d) {
            if (d.x === b) {
                c = true
            }
        });
        return c
    },
    isExpandingWild: function() {
        var c = this,
            a = c.readData("animatingOnReels"),
            b = c.readData("symbolsToAnimate");
        b = b.filter(function(d) {
            return a.indexOf(d.x) < 0 || a.length === 0
        });
        return b.length >= 1
    },
    getAmbianceSndChange: function() {
        var c = this.readData("modeChanged"),
            b, a;
        if (c) {
            a = this.readData("nextAction");
            if (a === "respin") {
                b = "ambienceRespin"
            } else {
                b = "ambienceGeneral"
            }
        }
        return {
            change: c,
            snd: b
        }
    },
    hasItem: function(a, d) {
        var c = false,
            b;
        for (b = 0; b < a.length; b++) {
            if (a[b].reelPos === d.reelPos && a[b].symPos === d.symPos) {
                c = true;
                break
            }
        }
        return c
    }
};
SB.ExpandingWildModel = Sys.extend(Core.Model, SB.ExpandingWildModel, "SB.ExpandingWildModel");
Sys.ns("SB");
SB.ExpandingWildView = {
    AnimationItems: {},
    GlowAnimItem: undefined,
    InitialDelay: 100,
    GlowAnimStoppedList: new Animation.CanvasAnimationList({}),
    getPositions: function(c, d) {
        var b = {};
        b["0"] = Game.stage.model.getSymbolConfiguration(c, 0);
        b["1"] = (Game.stage.model.getSymbolConfiguration(c, 1));
        b["2"] = (Game.stage.model.getSymbolConfiguration(c, 2));
        d = d || 0;
        var a = b[d];
        b.Rainbow_container = {
            top: -200,
            left: a.left - 33
        };
        b.particle_container = {
            top: -300,
            left: a.left - 40
        };
        b.particle2_container = {
            top: -300,
            left: a.left - 55
        };
        b.Burst_container = {
            top: a.top + 30,
            left: a.left + 15
        };
        b.Wild_nospin = {
            top: a.top,
            left: a.left
        };
        switch (d) {
            case 0:
                b.WildSym_firstspin = {
                    top: b["1"].top,
                    left: a.left
                };
                b.WildSym_secondspin = {
                    top: b["2"].top,
                    left: a.left
                };
                break;
            case 1:
                b.WildSym_firstspin = {
                    top: b["0"].top,
                    left: a.left
                };
                b.WildSym_secondspin = {
                    top: b["2"].top,
                    left: a.left
                };
                break;
            case 2:
                b.WildSym_firstspin = {
                    top: b["1"].top,
                    left: a.left
                };
                b.WildSym_secondspin = {
                    top: b["0"].top,
                    left: a.left
                };
                break;
            default:
                break
        }
        return b
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "view:triggerFirstSpinWild": a.triggerFirstSpinWild,
            "view:triggerSecondSpinWild": a.triggerSecondSpinWild,
            "view:rainbowFadeOutComplete": a.rainbowFadesOut,
            "view:glowFadeOutComplete": a.restoreGlowAnimation,
            "view:triggerParticle2_container": a.triggerPrticle2Container
        })
    },
    rainbowFadesOut: function(b) {
        var a = this;
        a.stopWildSymbols(b);
        a.restoreRainbowAnimation(b)
    },
    stopWildSymbols: function(c) {
        var b = this;
        if (Sys.isDefined(c)) {
            var a = b.AnimationItems[c];
            a.WildSym_firstspin.stop();
            a.WildSym_secondspin.stop();
            a.Wild_nospin.stop()
        } else {
            Sys.iterate(b.AnimationItems, function(e, d) {
                Sys.iterate(d, function(g, f) {
                    switch (g) {
                        case "WildSym_firstspin":
                        case "WildSym_secondspin":
                        case "Wild_nospin":
                            f.restore();
                            f.stop();
                            break;
                        default:
                            break
                    }
                })
            })
        }
    },
    expandWild: function(d) {
        var f = this,
            e = d,
            c = f.model.readData("animatingOnReels"),
            b = f.getPositions(e.x, e.y),
            a = f.AnimationItems[e.x];
        c.push(e.x);
        f.model.storeData("animatingOnReels", c);
        f.restoreRainbowAnimation(e.x);
        Sys.apply(a.Rainbow_container.prop, b.Rainbow_container);
        Sys.apply(a.particle_container.prop, b.particle_container);
        Sys.apply(a.particle2_container.prop, b.particle2_container);
        Sys.apply(a.Burst_container.prop, b.Burst_container);
        Sys.apply(a.Wild_nospin.prop, b.Wild_nospin);
        Sys.apply(a.WildSym_firstspin.prop, b.WildSym_firstspin);
        Sys.apply(a.WildSym_secondspin.prop, b.WildSym_secondspin);
        f.playGlowFadeAnimation();
        a.Burst_container.play();
        a.Rainbow_container.play();
        a.Wild_nospin.play();
        f.fireEvent("view:playAudio", {
            id: "wildExpansionSnd",
            name: "wildExpansionSnd"
        })
    },
    restoreAnimation: function() {
        var a = this;
        a.stopAnimations();
        a.model.storeData("animatingOnReels", [])
    },
    stopAnimations: function() {
        var b = this,
            a = Services.settingsManager.getSetting("quickSpin");
        Sys.iterate(b.AnimationItems, function(d, c) {
            Sys.iterate(c, function(f, e) {
                switch (f) {
                    case "Rainbow_container":
                        if (e.prop.left > 0) {
                            e.prop.operations = {};
                            e.prop.operations.fade = [{
                                time: 0,
                                value: 1
                            }, {
                                time: a ? 1000 : 1500,
                                value: 0,
                                fireEvent: {
                                    event: "view:rainbowFadeOutComplete",
                                    argument: d,
                                    scope: b
                                }
                            }]
                        }
                        break;
                    case "quickStopAnimList":
                        Sys.each(e.items, function(g) {
                            if (g.prop.id === "rainbow") {
                                g.prop.opacity = g.prop.ownOpacity = 1;
                                g.prop.operations = {};
                                g.prop.operations.fade = [{
                                    time: 0,
                                    value: 1
                                }, {
                                    time: 1500,
                                    value: 0,
                                    fireEvent: {
                                        event: "view:staticOutComplete",
                                        scope: b
                                    }
                                }];
                                g.restore()
                            } else {
                                g.stop()
                            }
                        });
                        break;
                    case "WildSym_firstspin":
                    case "WildSym_secondspin":
                    case "Wild_nospin":
                        break;
                    default:
                        e.restore();
                        e.stop();
                        break
                }
            })
        });
        b.GlowAnimItem.BgGlow.prop.operations = {};
        b.GlowAnimItem.BgGlow.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: 1500,
            value: 0,
            fireEvent: {
                event: "view:glowFadeOutComplete",
                scope: b
            }
        }];
        if (b.model.isModeChanged()) {
            b.skipGlowAnimation()
        }
    },
    restoreRainbowAnimation: function(d) {
        var c = this,
            b = c.AnimationItems[d],
            a = c.getAnimationItemFromListWithId(b.Rainbow_container, "Rainbow");
        b.Rainbow_container.prop.operations = {};
        b.Rainbow_container.prop.opacity = b.Rainbow_container.prop.ownOpacity = 1;
        a.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 300,
            value: 1
        }, {
            time: 301,
            value: 1,
            goTo: 1
        }];
        b.Rainbow_container.restore();
        b.Rainbow_container.stop()
    },
    restoreGlowAnimation: function() {
        var b = this,
            a = b.getAnimationItemFromListWithId(b.GlowAnimItem.BgGlow, "bg_2");
        b.GlowAnimItem.BgGlow.prop.operations = {};
        b.GlowAnimItem.BgGlow.prop.opacity = b.GlowAnimItem.BgGlow.prop.ownOpacity = 1;
        b.GlowAnimItem.BgGlow.prop.delay = b.InitialDelay;
        a.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 1500,
            value: 1
        }, {
            time: 1501,
            value: 1,
            goTo: 1
        }];
        b.GlowAnimItem.BgGlow.restore();
        b.GlowAnimItem.BgGlow.stop()
    },
    initExpandingWildAnimations: function() {
        var a = this;
        Sys.iterate(a.AnimationItems, function(b, c) {
            a.addQuickStopAnimations(c, b);
            Sys.iterate(c, function(d, e) {
                switch (d) {
                    case "Rainbow_container":
                        e.prop.delay = a.InitialDelay;
                        a.tweakItemToAddNeverLastingFadeEffect(a.getAnimationItemFromListWithId(e, "Rainbow"));
                        break;
                    case "Burst_container":
                        e.prop.delay = a.InitialDelay;
                        e.prop.globalCompositeOperation = "lighter";
                        a.getAnimationItemFromListWithId(e, "RainbowBurst").prop.globalCompositeOperation = "lighter";
                        break;
                    case "Wild_nospin":
                        e.prop.delay = a.InitialDelay;
                        a.tweakItemToAddNeverLastingFadeEffect(a.getAnimationItemFromListWithId(e, "Wild_Star"));
                        a.addFakeItemToRaiseEventAfterTime(e, 467, "view:triggerFirstSpinWild", b);
                        break;
                    case "WildSym_firstspin":
                        a.tweakItemToAddNeverLastingFadeEffect(a.getAnimationItemFromListWithId(e, "WildSym"));
                        a.addFakeItemToRaiseEventAfterTime(e, 300, "view:triggerSecondSpinWild", b);
                        break;
                    case "WildSym_secondspin":
                        a.tweakItemToAddNeverLastingFadeEffect(a.getAnimationItemFromListWithId(e, "WildSym"));
                        a.addFakeItemToRaiseEventAfterTime(e, 367, "view:Wild_second_spinAnimationCompleted", b);
                        break;
                    case "particle_container":
                        a.addFakeItemToRaiseEventAfterTime(e, 3.003, "view:triggerParticle2_container", b);
                        break;
                    default:
                        break
                }
                Game.stage.view.addToRenderLoop(e);
                e.stop()
            })
        })
    },
    initGlowBackground: function() {
        var c = this,
            a, b = c.getAnimationItemFromListWithId(c.GlowAnimItem.BgGlow, "bg_2");
        c.tweakItemToAddNeverLastingFadeEffect(b);
        Game.stage.view.addToRenderLoop(c.GlowAnimItem.BgGlow);
        c.GlowAnimItem.BgGlow.prop.delay = c.InitialDelay;
        c.GlowAnimItem.BgGlow.stop();
        a = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.ExpandingWild.glow,
            image: "bg_2",
            fullScreen: true
        });
        c.GlowAnimStoppedList.add(a);
        Game.stage.view.addToRenderLoop(c.GlowAnimStoppedList);
        c.GlowAnimStoppedList.stop()
    },
    tweakItemToAddNeverLastingFadeEffect: function(c) {
        if (Sys.isDefined(c.prop.operations.fade)) {
            var a = c.prop.operations.fade[c.prop.operations.fade.length - 1];
            var b = Sys.clone(a);
            b.goTo = c.prop.operations.fade.length - 1;
            c.prop.operations.fade.push(b)
        }
    },
    tweakItemToGotoFirstStep: function(c, b) {
        if (Sys.isDefined(c.prop.operations[b])) {
            var a = c.prop.operations[b][c.prop.operations[b].length - 1];
            a.goTo = 0
        }
    },
    tweakItemToRetriggerTransformMatrixOperation: function(c) {
        if (Sys.isDefined(c.prop.operations.transformMatrix)) {
            var b = c.prop.operations.transformMatrix[c.prop.operations.transformMatrix.length - 1];
            var a = Sys.clone(b);
            a.time += 1;
            a.goTo = 0;
            c.prop.operations.transformMatrix.push(a)
        }
    },
    addFakeItemToRaiseEventAfterTime: function(e, d, c, a) {
        var b = this;
        e.add(new Animation.CanvasAnimationItem({
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            depth: 100,
            operations: {
                fade: [{
                    time: 0,
                    value: 0.1
                }, {
                    time: d,
                    value: 0.1,
                    fireEvent: {
                        event: c,
                        argument: a,
                        scope: b
                    }
                }]
            }
        }))
    },
    triggerFirstSpinWild: function(b) {
        var a = this.AnimationItems[b];
        a.particle_container.play();
        a.WildSym_firstspin.play()
    },
    triggerPrticle2Container: function(b) {
        var a = this.AnimationItems[b];
        a.particle2_container.play()
    },
    triggerSecondSpinWild: function(b) {
        var a = this.AnimationItems[b];
        a.WildSym_secondspin.play()
    },
    addQuickStopAnimations: function(b, f) {
        var h = this,
            i = new Animation.CanvasAnimationList({}),
            a = Platform.isDesktopDevice ? Resources.readData("desktopAnimationCfg") : Resources.readData("animationCfg"),
            g, d, e = h.getPositions(f);
        for (var c = 0; c < Resources.readData("config").reel.symbolRows; c++) {
            d = e[c];
            g = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.ExpandingWild.symbols,
                image: a.Wild_nospin.clips.Wild_Star.i
            });
            g.prop.width = d.width;
            g.prop.height = d.height;
            g.prop.top = d.top;
            g.prop.left = d.left;
            i.add(g)
        }
        i.add(new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.ExpandingWild.rainbow_container,
            image: a.Rainbow_container.clips.Rainbow.i,
            id: "rainbow",
            width: 261,
            height: 858,
            top: -20,
            left: d.left - 33
        }));
        Sys.apply(b.particle_container.prop, e.particle_container);
        Sys.apply(b.particle2_container.prop, e.particle2_container);
        b.quickStopAnimList = i
    },
    skipWildAnimation: function() {
        var e = this,
            c = e.model.readData("animatingOnReels"),
            b = e.AnimationItems,
            a, d;
        if (c && c.length > 0) {
            e.skipGlowAnimation(true);
            Sys.each(c, function(f) {
                a = b[f];
                a.Wild_nospin.stop();
                a.WildSym_firstspin.stop();
                a.WildSym_secondspin.stop();
                a.Rainbow_container.stop();
                Sys.each(a.quickStopAnimList.items, function(g) {
                    if (g.prop.id === "rainbow") {
                        g.prop.operations = {};
                        g.prop.opacity = g.prop.ownOpacity = 1
                    }
                });
                a.quickStopAnimList.play();
                a.particle_container.play();
                a.particle2_container.play();
                d = f
            });
            e.fireEvent("view:Wild_second_spinAnimationCompleted", d)
        }
    },
    playGlowFadeAnimation: function() {
        var b = this,
            a = b.getAnimationItemFromListWithId(b.GlowAnimItem.BgGlow, "bg_2");
        if (b.model.isModeChanged() && !a.isRunning()) {
            if (b.model.readData("mode") === "basic") {
                b.restoreGlowAnimation();
                b.fireEvent("view:glowFadeInStart")
            } else {
                if (b.model.readData("mode") === "respin") {
                    b.fireEvent("view:glowFadeOutStart")
                }
            }
            b.GlowAnimItem.BgGlow.prop.delay = 0;
            b.GlowAnimItem.BgGlow.play();
            b.GlowAnimStoppedList.stop()
        }
    },
    skipGlowAnimation: function(b) {
        var a = this;
        a.GlowAnimItem.BgGlow.stop();
        if (b || a.model.readData("mode") === "basic") {
            a.GlowAnimStoppedList.prop.opacity = a.GlowAnimStoppedList.prop.ownOpacity = 1;
            a.GlowAnimStoppedList.prop.operations = {};
            a.GlowAnimStoppedList.restore();
            a.GlowAnimStoppedList.play();
            a.fireEvent("view:bgAnimationComplete")
        } else {
            if (a.model.readData("mode") === "respin") {
                a.fireEvent("view:staticBGFadeOut");
                a.GlowAnimStoppedList.prop.opacity = a.GlowAnimStoppedList.prop.ownOpacity = 1;
                a.GlowAnimStoppedList.prop.operations = {};
                a.GlowAnimStoppedList.prop.operations.fade = [{
                    time: 0,
                    value: 1
                }, {
                    time: 1500,
                    value: 0,
                    fireEvent: {
                        event: "view:staticBGFadeOutComplete",
                        scope: a
                    }
                }];
                a.GlowAnimStoppedList.restore()
            }
        }
    },
    getAnimationItemFromListWithId: function(b, c) {
        var a;
        Sys.each(b.items, function(d) {
            if (d.prop.id === c) {
                a = d;
                return false
            }
        });
        return a
    }
};
SB.ExpandingWildView = Sys.extend(Core.View, SB.ExpandingWildView, "SB.ExpandingWildView");
Sys.ns("SB");
SB.ExpandingWildDesktopView = {
    PER_FRAME: 1000 / 30,
    topFaderList: new Animation.CanvasAnimationList({}),
    getPositions: function(c, d) {
        var b = {};
        b["0"] = Game.stage.model.getSymbolConfiguration(c, 0);
        b["1"] = (Game.stage.model.getSymbolConfiguration(c, 1));
        b["2"] = (Game.stage.model.getSymbolConfiguration(c, 2));
        d = d || 0;
        var a = b[d];
        b.Rainbow_container = {
            top: -200,
            left: a.left - 95
        };
        b.particle_container = {
            top: -300,
            left: a.left - 95
        };
        b.particle2_container = {
            top: -300,
            left: a.left - 95
        };
        b.Burst_container = {
            top: 300,
            left: a.left + 25
        };
        b.Wild_nospin = {
            top: a.top,
            left: a.left
        };
        switch (d) {
            case 0:
                b.WildSym_firstspin = {
                    top: b["1"].top,
                    left: a.left,
                    symPos: 1
                };
                b.WildSym_secondspin = {
                    top: b["2"].top,
                    left: a.left,
                    symPos: 2
                };
                break;
            case 1:
                b.WildSym_firstspin = {
                    top: b["0"].top,
                    left: a.left,
                    symPos: 0
                };
                b.WildSym_secondspin = {
                    top: b["2"].top,
                    left: a.left,
                    symPos: 2
                };
                break;
            case 2:
                b.WildSym_firstspin = {
                    top: b["1"].top,
                    left: a.left,
                    symPos: 1
                };
                b.WildSym_secondspin = {
                    top: b["0"].top,
                    left: a.left,
                    symPos: 0
                };
                break;
            default:
                break
        }
        return b
    },
    initGlowBackground: function() {
        var b = this,
            a;
        SB.ExpandingWildDesktopView.superclass.initGlowBackground.apply(this, arguments);
        a = b.getRainbowFader();
        b.topFaderList.add(a);
        Game.stage.view.addToRenderLoop(b.topFaderList);
        b.topFaderList.stop()
    },
    skipGlowAnimation: function(b) {
        var a = this;
        a.GlowAnimItem.BgGlow.stop();
        if (b || a.model.readData("mode") === "basic") {
            a.GlowAnimStoppedList.prop.opacity = a.GlowAnimStoppedList.prop.ownOpacity = 1;
            a.GlowAnimStoppedList.prop.operations = {};
            a.GlowAnimStoppedList.restore();
            a.GlowAnimStoppedList.play();
            a.fireEvent("view:bgAnimationComplete")
        } else {
            if (a.model.readData("mode") === "respin") {
                a.fireEvent("view:staticBGFadeOut");
                a.GlowAnimStoppedList.prop.opacity = a.GlowAnimStoppedList.prop.ownOpacity = 1;
                a.GlowAnimStoppedList.prop.operations = {};
                a.GlowAnimStoppedList.prop.operations.fade = [{
                    time: 0,
                    value: 0.02
                }, {
                    time: 100,
                    value: 0,
                    fireEvent: {
                        event: "view:staticBGFadeOutComplete",
                        scope: a
                    }
                }];
                a.GlowAnimStoppedList.restore()
            }
        }
    },
    stopAnimations: function() {
        var b = this,
            a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            c = Sys.isDefined(a) && a > 0,
            d = (c) ? 5 : 20;
        d = (b.model.readData("quickStopped")) ? 1 : d;
        Sys.iterate(b.AnimationItems, function(f, e) {
            Sys.iterate(e, function(h, g) {
                switch (h) {
                    case "Rainbow_container":
                        if (g.items.length > 0) {
                            g.prop.operations = {};
                            g.prop.operations.fade = [{
                                time: 0,
                                value: 1
                            }, {
                                time: d * b.PER_FRAME,
                                value: 0,
                                fireEvent: {
                                    event: "view:rainbowFadeOutComplete",
                                    argument: f,
                                    scope: b
                                }
                            }];
                            Sys.each(g.items, function(i) {
                                i.prop.depth = 7
                            })
                        }
                        break;
                    case "quickStopAnimList":
                        Sys.each(g.items, function(i) {
                            if (i.prop.id === "rainbow") {
                                i.prop.opacity = i.prop.ownOpacity = 1;
                                i.prop.operations = {};
                                i.prop.operations.fade = [{
                                    time: 0,
                                    value: 1
                                }, {
                                    time: d * b.PER_FRAME,
                                    value: 0,
                                    fireEvent: {
                                        event: "view:staticOutComplete",
                                        scope: b
                                    }
                                }];
                                i.restore()
                            } else {
                                i.stop()
                            }
                        });
                        break;
                    case "WildSym_firstspin":
                    case "WildSym_secondspin":
                    case "Wild_nospin":
                        g.stop();
                        break;
                    default:
                        g.restore();
                        g.stop();
                        break
                }
            })
        });
        b.GlowAnimItem.BgGlow.prop.operations = {};
        b.GlowAnimItem.BgGlow.prop.operations.fade = [{
            time: 0,
            value: 1
        }, {
            time: d * b.PER_FRAME,
            value: 0,
            fireEvent: {
                event: "view:glowFadeOutComplete",
                scope: b
            }
        }];
        if (b.model.isModeChanged()) {
            b.skipGlowAnimation()
        }
    },
    restoreRainbowAnimation: function(f) {
        var e = this,
            d = e.AnimationItems[f],
            c = e.getAnimationItemFromListWithId(d.Rainbow_container, "Rainbow"),
            a = 0,
            b = 500;
        d.Rainbow_container.prop.operations = {};
        d.Rainbow_container.prop.opacity = d.Rainbow_container.prop.ownOpacity = 1;
        c.prop.operations.fade = [{
            time: a,
            value: 0
        }, {
            time: b,
            value: 1
        }, {
            time: b + 100,
            value: 1,
            goTo: 1
        }];
        c.prop.depth = Layering.Game.Slots.ExpandingWild.rainbow_container;
        e.applyGlobalComposite(d.Rainbow_container, "lighter");
        d.Rainbow_container.restore();
        d.Rainbow_container.stop()
    },
    expandWild: function(d) {
        var f = this,
            e = d,
            c = f.model.readData("animatingOnReels"),
            b = f.getPositions(e.x, e.y),
            a = f.AnimationItems[e.x];
        c.push(e.x);
        f.model.storeData("animatingOnReels", c);
        f.restoreRainbowAnimation(e.x);
        Sys.apply(b.Wild_nospin, {
            symPos: e.y
        });
        Sys.apply(a.Rainbow_container.prop, b.Rainbow_container);
        Sys.apply(a.particle_container.prop, b.particle_container);
        Sys.apply(a.particle2_container.prop, b.particle2_container);
        Sys.apply(a.Burst_container.prop, b.Burst_container);
        Sys.apply(a.Wild_nospin.prop, b.Wild_nospin);
        Sys.apply(a.WildSym_firstspin.prop, b.WildSym_firstspin);
        Sys.apply(a.WildSym_secondspin.prop, b.WildSym_secondspin);
        f.playGlowFadeAnimation();
        a.Burst_container.play();
        a.Rainbow_container.play();
        a.Wild_nospin.play();
        f.fireEvent("view:playAudio", {
            id: "wildExpansionSnd",
            name: "wildExpansionSnd"
        })
    },
    triggerFirstSpinWild: function(c) {
        var b = this,
            a = this.AnimationItems[c];
        b.applyGlobalComposite(a.particle_container, "lighter");
        a.particle_container.play();
        a.WildSym_firstspin.play()
    },
    updateOperations: function(d, b) {
        var a, c, e;
        if (d.items.length > 0) {
            for (c = 0; c < d.items.length; c++) {
                if (d.items[c].prop.image === "Wild_Star") {
                    a = d.items[c].prop.operations.fade.length;
                    e = d.items[c].prop.operations.fade[a - 1];
                    e.value = b
                }
            }
        }
    },
    applyGlobalComposite: function(d, c, b) {
        var a;
        for (a = 0; a < d.items.length; a++) {
            d.items[a].prop.globalCompositeOperation = c;
            if (b) {
                d.items[a].prop.globalAlpha = b
            }
        }
    },
    skipWildAnimation: function() {
        var e = this,
            c = e.model.readData("animatingOnReels"),
            b = e.AnimationItems,
            a, d;
        if (c && c.length > 0) {
            e.skipGlowAnimation(true);
            Sys.each(c, function(f) {
                a = b[f];
                a.Wild_nospin.stop();
                a.WildSym_firstspin.stop();
                a.WildSym_secondspin.stop();
                a.Rainbow_container.stop();
                Sys.each(a.quickStopAnimList.items, function(g) {
                    if (g.prop.id === "rainbow") {
                        g.prop.operations = {};
                        g.prop.opacity = g.prop.ownOpacity = 1
                    }
                });
                a.quickStopAnimList.play();
                e.applyGlobalComposite(a.particle_container, "lighter");
                e.applyGlobalComposite(a.particle2_container, "lighter");
                a.particle_container.play();
                a.particle2_container.play();
                d = f
            });
            e.fireEvent("view:Wild_second_spinAnimationCompleted", d)
        }
    },
    triggerPrticle2Container: function(c) {
        var b = this,
            a = b.AnimationItems[c];
        b.applyGlobalComposite(a.particle2_container, "lighter");
        a.particle2_container.play()
    },
    initExpandingWildAnimations: function() {
        var c = this,
            a, b;
        Sys.iterate(c.AnimationItems, function(d, e) {
            c.addQuickStopAnimations(e, d);
            Sys.iterate(e, function(f, g) {
                switch (f) {
                    case "Rainbow_container":
                        g.prop.delay = c.InitialDelay;
                        c.tweakItemToAddNeverLastingFadeEffect(c.getAnimationItemFromListWithId(g, "Rainbow"));
                        break;
                    case "Burst_container":
                        g.prop.delay = c.InitialDelay;
                        b = c.getAnimationItemFromListWithId(g, "RainbowBurst");
                        c.tweakItemToAddNeverLastingFadeEffect(b);
                        break;
                    case "Wild_nospin":
                        g.prop.delay = c.InitialDelay;
                        a = c.getAnimationItemFromListWithId(g, "Wild_Star");
                        c.tweakItemToAddNeverLastingFadeEffect(a);
                        c.addFakeItemToRaiseEventAfterTime(g, 0, "view:triggerFirstSpinWild", d);
                        break;
                    case "WildSym_firstspin":
                        a = c.getAnimationItemFromListWithId(g, "WildSym");
                        c.tweakItemToAddNeverLastingFadeEffect(c.getAnimationItemFromListWithId(g, "WildSym"));
                        c.addFakeItemToRaiseEventAfterTime(g, 0, "view:triggerSecondSpinWild", d);
                        break;
                    case "WildSym_secondspin":
                        a = c.getAnimationItemFromListWithId(g, "WildSym");
                        c.tweakItemToAddNeverLastingFadeEffect(c.getAnimationItemFromListWithId(g, "WildSym"));
                        break;
                    case "particle_container":
                        c.addFakeItemToRaiseEventAfterTime(g, 0, "view:triggerParticle2_container", d);
                        break;
                    default:
                        break
                }
                Game.stage.view.addToRenderLoop(g);
                g.stop()
            })
        })
    },
    addQuickStopAnimations: function(b, f) {
        var h = this,
            i = new Animation.CanvasAnimationList({}),
            a = Platform.isDesktopDevice ? Resources.readData("desktopAnimationCfg") : Resources.readData("animationCfg"),
            g, d, e = h.getPositions(f);
        for (var c = 0; c < Resources.readData("config").reel.symbolRows; c++) {
            d = e[c];
            g = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.ExpandingWild.symbols,
                image: a.Wild_nospin.clips.Wild_Star.i
            });
            g.prop.width = d.width;
            g.prop.height = d.height;
            g.prop.top = d.top;
            g.prop.left = d.left;
            i.add(g)
        }
        i.add(new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.ExpandingWild.rainbow_container,
            image: a.Rainbow_container.clips.Rainbow.i,
            id: "rainbow",
            width: a.Rainbow_container.clips.Rainbow.w,
            height: a.Rainbow_container.clips.Rainbow.h,
            top: -200,
            left: d.left - 95,
            globalCompositeOperation: "lighter"
        }));
        Sys.apply(b.particle_container.prop, e.particle_container);
        Sys.apply(b.particle2_container.prop, e.particle2_container);
        b.quickStopAnimList = i
    },
    playGlowFadeAnimation: function() {
        var b = this,
            a = b.getAnimationItemFromListWithId(b.GlowAnimItem.BgGlow, "bg_2");
        if (b.model.isModeChanged() && !a.isRunning()) {
            if (b.model.readData("mode") === "basic") {
                b.restoreGlowAnimation();
                b.fireEvent("view:glowFadeInStart")
            } else {
                if (b.model.readData("mode") === "respin") {
                    b.fireEvent("view:glowFadeOutStart")
                }
            }
            b.GlowAnimItem.BgGlow.prop.delay = 0;
            b.applyGlobalComposite(b.GlowAnimItem.BgGlow, "lighten");
            b.GlowAnimItem.BgGlow.play();
            b.configTopRainbowFader(500);
            b.GlowAnimStoppedList.stop()
        }
    },
    configTopRainbowFader: function(d) {
        var c = this,
            b, a = 0,
            e = 0.8;
        if (c.model.readData("mode") === "basic" && c.model.readData("modeChanged")) {
            b = "wildRainbowFader"
        } else {
            if (c.model.readData("mode") === "respin" && c.model.readData("modeChanged")) {
                b = "mainRainbowFader"
            }
        }
        c.topFaderList.items[0].prop.operations.fade = [{
            time: 0,
            value: a
        }, {
            time: d,
            value: e
        }, {
            time: d + 1000,
            value: e,
            goTo: 1
        }];
        c.topFaderList.items[0].prop.image = b;
        c.topFaderList.restore()
    },
    getRainbowFader: function() {
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 1280,
            height: 77,
            depth: Layering.Game.Slots.ExpandingWild.topFader
        })
    }
};
SB.ExpandingWildDesktopView = Sys.extend(SB.ExpandingWildView, SB.ExpandingWildDesktopView, "SB.ExpandingWildDesktopView");
Sys.ns("SB");
SB.WinningSymbolsView = {
    WIN_SITUATION_ANIMATION_TIMES: {
        SYM0: 1000,
        SYM1: 1000
    },
    configureItemForAllWinningSymbolsDisplay: function(d, a) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.ALL_WINNING_SYMBOLS_ANIMATION_TIME;
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function() {},
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: e / 2,
                    value: 1
                }, {
                    time: e,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: b
                    }
                }]
            }
        });
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.restore()
    },
    configureItemForWinSituationToggling: function(d, a) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.WIN_SITUATION_ANIMATION_TIMES[a.symbol];
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function() {},
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: e / 2,
                    value: 1
                }, {
                    time: e,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: b
                    }
                }]
            }
        });
        d.restore()
    }
};
SB.WinningSymbolsView = Sys.extend(Game.Slots.WinningSymbolsView, SB.WinningSymbolsView, "SB.WinningSymbolsView");
Sys.ns("SB");
SB.WinningSymbolsDesktopView = {
    WIN_SITUATION_ANIMATION_TIMES: {
        SYM1: 2000,
        SYM3: 2000,
        SYM4: 2000,
        SYM5: 2000,
        SYM6: 2000,
        SYM7: 2000,
        SYM8: 2000,
        SYM9: 2000
    },
    configureItemForWinSituationToggling: function(d, a) {
        var b = this,
            c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        b.symbolGlowAnimation(d, a);
        d.restore()
    },
    symbolGlowAnimation: function(d, b) {
        var c = this,
            a = 1;
        Sys.applyProperties(d.prop, {
            image: b.symbol,
            depth: Layering.Game.Slots.WinningSymbols.animationItems + 5,
            globalCompositeOperation: "lighter",
            operations: {
                fade: [{
                    time: 0,
                    value: 0
                }, {
                    time: 200,
                    value: a / 4
                }, {
                    time: 400,
                    value: a / 2
                }, {
                    time: 1000,
                    value: a
                }, {
                    time: 2000,
                    value: 0,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: c
                    },
                    goTo: 0
                }]
            }
        })
    }
};
SB.WinningSymbolsDesktopView = Sys.extend(SB.WinningSymbolsView, SB.WinningSymbolsDesktopView, "SB.WinningSymbolsDesktopView");
Sys.ns("SB");
SB.WinningSymbolsModel = {
    SYMBOLS_TO_ANIMATE_ON_TOGGLE: (Platform.isDesktopDevice) ? ["SYM1", "SYM2", "SYM3", "SYM4", "SYM5", "SYM6", "SYM7", "SYM8", "SYM9"] : ["SYM0", "SYM1"]
};
SB.WinningSymbolsModel = Sys.extend(Game.Slots.WinningSymbolsModel, SB.WinningSymbolsModel, "SB.WinningSymbolsModel");
Sys.ns("SB");
SB.WinningSymbolsController = {
    setupEvents: function() {
        var a = this;
        SB.WinningSymbolsController.superclass.setupEvents.apply(a, arguments);
        if (Platform.isDesktopDevice) {
            a.on({
                "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
                "notify:stateHandler.enteringSpinningState": a.onLeavingIdleState,
                "request:dimmedSymbols.unDimNoWinSymbols": a.onLeavingIdleState
            })
        }
    },
    onLeavingIdleState: function() {
        var c = this,
            d = Game.stage.model.getCurrentReelGroupConfiguration(),
            a = d.symbolCols,
            b = d.symbolRows;
        if (c.view.animationList) {
            c.view.animationItems = Sys.utils.init2dMatrix(a, b);
            c.view.animationList.stop()
        }
    }
};
SB.WinningSymbolsController = Sys.extend(Game.Slots.WinningSymbolsController, SB.WinningSymbolsController, "SB.WinningSymbolsController");
Sys.ns("SB");
SB.WinAnimations = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.WinAnimationsModel,
            controller: SB.WinAnimationsController,
            view: Core.View
        }
    }
};
SB.WinAnimations = Sys.extend(Core.Module, SB.WinAnimations, "SB.WinAnimations");
Sys.ns("SB");
SB.WinAnimationsController = {
    setupEvents: function() {
        var a = this;
        a.counter = 0;
        a.on({
            "request:winAnimations.startAnimation": a.onStartAnimation,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:bendingBetlines.animationComplete": a.animateWinSituations,
            "notify:bigWin.animationAborted": a.abort,
            "notify:standardWinAnimations.animationAborted": a.abort,
            "notify:symbolFlyingAnimation.finish": a.onAnimationComplete
        })
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    abort: function() {
        var a = this;
        a.model.storeData("winSituations", []);
        a.onAnimationComplete();
        a.fireEvent("notify:winAnimations.animationAborted")
    },
    onStartAnimation: function() {
        var a = this;
        a.fireEvent("notify:winAnimations.showingWinAnimations", "notify:winAnimations.winAnimationsFinished");
        a.animateWinSituations()
    },
    animateWinSituations: function() {
        var h = this,
            e = h.model,
            a = e.readData("winSituations"),
            g = a.length;
        if (g > 0) {
            h.counter++;
            var k = a[0],
                l = [],
                d = k.positions,
                b, j, c = d.length;
            for (var i = 0; i < c; i++) {
                j = d[i];
                b = Game.stage.model.getSymbolConfiguration(j.reelIndex, j.symbolIndex);
                l.push({
                    top: b.top + b.height / 2,
                    left: b.left + b.width / 2
                })
            }
            var f = {
                winSituation: k,
                symbolConfig: e.SymbolConfig[k.sym],
                pathConfig: l,
                counter: h.counter,
                animationEndCallbackEvent: undefined,
                last: false
            };
            h.triggerBendingBetline(f, g);
            k.animated = true;
            a.splice(0, 1);
            e.storeData("winSituations", a)
        }
    },
    triggerBendingBetline: function(b, a) {
        var c = this,
            d;
        b.animationEndCallbackEvent = "notify:bendingBetlines.animationComplete";
        b.last = (a - 1) === 0;
        c.fireEvent("notify:winAnimations.showAnimation", b);
        if (c.counter === 2 || c.counter === 5 || c.counter === 9) {
            d = c.counter === 2 ? 0 : c.counter === 5 ? 1 : 2;
            c.fireEvent("request:comboAnimations.showComboAnimation", d)
        }
        if (c.counter === 1 && c.model.readData("winType") !== "bigWin") {
            c.fireEvent("request:symbolBurst.showBurst")
        }
    },
    onAnimationComplete: function() {
        var a = this;
        a.counter = 0;
        a.fireEvent("notify:winAnimations.winAnimationsFinished");
        if (a.model.readData("winType") === "bigWin") {
            a.fireEvent("notify:bigWin.AllAnimationsComplete")
        }
    }
};
SB.WinAnimationsController = Sys.extend(Core.Controller, SB.WinAnimationsController, "SB.WinAnimationsController");
Sys.ns("SB");
SB.WinAnimationsModel = {
    SymbolConfig: {
        SYM1: {
            fillColor: "#ffffff",
            strokeColor: "#ffd635",
            flashColor: "rgba(193,59,255,1)",
            shadowColor: "rgba(193,59,255,0.4)",
            betlineColor: "#fff1ba",
            betlineShadow: "#fff1ba",
            betlineFlash: "#fff1ba",
            lineWidth: 3
        },
        SYM3: {
            fillColor: "#ffffff",
            strokeColor: "#ffd635",
            flashColor: "rgba(193,59,255,1)",
            shadowColor: "rgba(193,59,255,0.4)",
            betlineColor: "rgba(245,174,12,0.8)",
            betlineFlash: "#fff9a1",
            lineWidth: 3
        },
        SYM4: {
            fillColor: "#ffffff",
            strokeColor: "#ffd635",
            flashColor: "rgba(193,59,255,1)",
            shadowColor: "rgba(193,59,255,0.4)",
            betlineColor: "rgba(40,200,255,0.8)",
            betlineFlash: "#d3edff",
            lineWidth: 3
        },
        SYM5: {
            fillColor: "#fecb00",
            strokeColor: "#000000",
            flashColor: "#FFFB00",
            shadowColor: "#FFFB00",
            betlineColor: "rgba(248,229,58,0.8)",
            betlineFlash: "#fefef3",
            lineWidth: 3
        },
        SYM6: {
            fillColor: "#ffffff",
            strokeColor: "#20fd13",
            flashColor: "#99FF1C",
            shadowColor: "#99FF1C",
            betlineColor: "rgba(145,204,6,0.8)",
            betlineFlash: "#fefef3",
            lineWidth: 3
        },
        SYM7: {
            fillColor: "#ffffff",
            strokeColor: "#fc7414",
            flashColor: "rgba(255,28,28,1)",
            shadowColor: "rgba(255,28,28,0.2)",
            betlineColor: "rgba(250,90,15,0.8)",
            betlineFlash: "#fefef3",
            lineWidth: 3
        },
        SYM8: {
            fillColor: "#ffffff",
            strokeColor: "#13cdfa",
            flashColor: "#005EFF",
            shadowColor: "#005EFF",
            betlineColor: "rgba(40,200,255,0.8)",
            betlineFlash: "#fefef3",
            lineWidth: 3
        },
        SYM9: {
            fillColor: "#ffffff",
            strokeColor: "#fa31fe",
            flashColor: "#DB50EB",
            shadowColor: "#DB50EB",
            betlineColor: "rgba(198,109,255,0.8)",
            betlineFlash: "#fefef3",
            lineWidth: 3
        }
    },
    processServerResponse: function(c) {
        var b = this,
            a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            if (Platform.isDesktopDevice) {
                a = SB.utils.serverResponse.randomizeWinSituations(c.wins.winSituations)
            } else {
                a = c.wins.winSituations.slice(0)
            }
        }
        b.storeData("winSituations", Sys.clone(a));
        if (c.wins.winType !== "bigWin") {
            Sys.each(b.readData("winSituations"), function(d) {
                if (d.positions.length === 5) {
                    d.fiveSymWin = true
                }
            })
        }
        b.storeData("winType", c.wins.winType)
    },
    isWinAnimations: function() {
        return this.readData("winSituations").length > 0
    }
};
SB.WinAnimationsModel = Sys.extend(Core.Model, SB.WinAnimationsModel, "SB.WinAnimationsModel");
Sys.ns("SB");
SB.BendingBetlines = {
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            controller: SB.BendingBetlinesController,
            view: SB.BendingBetlinesView
        }
    }
};
SB.BendingBetlines = Sys.extend(Core.Module, SB.BendingBetlines, "SB.BendingBetlines");
Sys.ns("SB");
SB.BendingBetlinesController = {
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:winAnimations.showAnimation": a.animate,
            "view:crossedOverSymbol": a.betlineDrawn,
            "notify:winAnimations.animationAborted": a.abort
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    animate: function(a) {
        this.fireEvent("request:audioPlayer.play", {
            name: "winSymbolMedSnd",
            id: "winSymbolMedSnd"
        });
        this.view.animate(a)
    },
    betlineDrawn: function(a) {
        var b = this;
        b.fireEvent("notify:bendingBetlines.crossedOverSymbol", a);
        if (a.betlineDrawnEvent) {
            b.view.stopAnimations();
            setTimeout(function() {
                b.fireEvent(a.betlineDrawnEvent)
            }, 10)
        }
    },
    abort: function() {
        this.view.stopAnimations()
    }
};
SB.BendingBetlinesController = Sys.extend(Core.Controller, SB.BendingBetlinesController, "SB.BendingBetlinesController");
Sys.ns("SB");
SB.BendingBetlinesView = {
    initAnimations: function() {
        var a = this;
        a.animationItem = new Animation.CanvasAnimationItem({
            width: 100,
            height: 100,
            top: 0,
            left: 0,
            depth: Layering.Game.Slots.WinSituationsDisplay.bendingBetlines,
            executeBefore: function(b) {
                var k = this,
                    f = this.customProps,
                    c = k.left,
                    i = k.top,
                    d = k.matrix,
                    e;
                b.save();
                e = k.tempMatrix;
                e.set(d);
                Animation.utils.multiplyMatrix(e, [1, 0, 0, 1, k.pivot.x - k.left, k.pivot.y - k.top], d);
                b.setTransform(d[0], d[1], d[2], d[3], d[4], d[5]);
                if (!f.redraw) {
                    f.lastPoints = [{
                        x: c,
                        y: i
                    }];
                    f.wid = 1;
                    f.swid = 1;
                    b.beginPath()
                }
                var h = f.lastPoints[0];
                f.redraw = true;
                b.moveTo(h.x, h.y);
                b.lineWidth = 25;
                b.lineJoin = b.lineCap = "round";
                b.shadowBlur = 25;
                b.strokeStyle = f.cfg.betlineColor;
                f.lastPoints.push({
                    x: k.left,
                    y: k.top
                });
                for (var g = 0; g < f.lastPoints.length; g++) {
                    var j = f.lastPoints[g];
                    b.lineTo(j.x, j.y)
                }
                b.stroke();
                b.strokeStyle = f.cfg.betlineFlash;
                b.shadowBlur = 20;
                b.lineWidth = 8;
                b.stroke();
                b.restore()
            }
        });
        a.animationList = new Animation.CanvasAnimationList();
        a.animationList.add(a.animationItem);
        Game.stage.view.addToRenderLoop(a.animationList);
        a.animationList.stop()
    },
    animate: function(c) {
        var g = this,
            f = g.animationItem,
            b = c.pathConfig,
            h = 170,
            e = [],
            d = f.prop.customProps;
        for (var a = 0; a < b.length; a++) {
            e.push({
                time: h * a,
                value: b[a],
                fireEvent: {
                    event: "view:crossedOverSymbol",
                    argument: {
                        position: b[a],
                        symbolConfig: {
                            sym: c.winSituation.sym,
                            pos: c.winSituation.positions[a],
                            color: c.symbolConfig
                        }
                    },
                    scope: g
                }
            })
        }
        if (Sys.isDefined(c.animationEndCallbackEvent)) {
            e[b.length - 1].fireEvent.argument.betlineDrawnEvent = c.animationEndCallbackEvent
        }
        f.restore();
        d.lastPoints = [];
        d.redraw = false;
        d.cfg = c.symbolConfig;
        f.prop.operations.translatePath = e;
        Animation.Operations.translatePath.applyDefaultValuesToOperation(f);
        g.animationList.play(g.animationItem)
    },
    stopAnimations: function() {
        var a = this;
        a.animationItem.stop();
        a.animationList.stop(a.animationItem)
    }
};
SB.BendingBetlinesView = Sys.extend(Core.View, SB.BendingBetlinesView, "SB.BendingBetlinesView");
Sys.ns("SB");
SB.BendingBetlinesDesktopView = {
    BETLINE_STREAK_IMG_CONFIG: {
        width: 961,
        height: 88,
        frames: 10
    },
    initAnimations: function() {
        var e = this,
            d = document.createElement("canvas"),
            f = Environment.getResolution(),
            c = d.getContext("2d"),
            b, a = new Image();
        d.width = f.width;
        d.height = f.height;
        b = c.createLinearGradient(0, 0, f.width, 0);
        b.addColorStop(0, "black");
        b.addColorStop(1, "transparent");
        c.fillStyle = b;
        c.fillRect(0, 0, f.width, f.height);
        a.src = d.toDataURL();
        e.animationItem = new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Slots.WinSituationsDisplay.bendingBetlines
        });
        e.animationList = new Animation.CanvasAnimationList();
        e.animationList.add(e.animationItem);
        Game.stage.view.addToRenderLoop(e.animationList);
        e.animationList.stop();
        e.bender = new BetLineBender(f);
        e.fadeCoverImage = a;
        e.inMemoryCanvas = d
    },
    animate: function(b) {
        var f = this,
            i = f.animationItem,
            a = 40,
            d = 22,
            g = Resources.readData("animationImages"),
            e = Environment.getResolution(),
            c = b.winSituation.positions,
            h;
        f.betlineImageRendered = false;
        i.stop();
        f.points = f.getBetlinePoints(b.winSituation);
        i.prop.operations = {
            value: [{
                time: 0,
                value: 0
            }, {
                time: d * f.points.length,
                value: f.BETLINE_STREAK_IMG_CONFIG.frames
            }, {
                time: d * f.points.length + 100,
                value: f.BETLINE_STREAK_IMG_CONFIG.frames,
                goTo: 1
            }],
            fade: [{
                time: 0,
                value: 1
            }, {
                time: (d * f.points.length) / 2,
                value: 1
            }, {
                time: d * f.points.length * 1.5,
                value: 1
            }, {
                time: (d * f.points.length * 1.5) + 1,
                value: 0.01
            }, {
                time: a * f.points.length * 1.5,
                value: 0,
                fireEvent: {
                    event: "view:crossedOverSymbol",
                    argument: {
                        betlineDrawnEvent: b.animationEndCallbackEvent
                    },
                    scope: f
                }
            }]
        };
        f.textureMap = f.bender.buildTextureMapCoordinates(f.bender.buildMesh(f.points, f.BETLINE_STREAK_IMG_CONFIG.width, f.BETLINE_STREAK_IMG_CONFIG.height, 10), f.BETLINE_STREAK_IMG_CONFIG.frames, 1, f.BETLINE_STREAK_IMG_CONFIG.width, f.BETLINE_STREAK_IMG_CONFIG.height);
        i.prop.executeBefore = function(l) {
            var n = this.localTime,
                p, k, j, o;
            if (!f.betlineImageRendered) {
                if (b.winSituation.fiveSymWin) {
                    o = {
                        reelIndex: c[c.length - 1].reelIndex,
                        symbolIndex: c[c.length - 1].symbolIndex
                    }
                }
                h = f.textureMap[Math.floor(this.value)] || f.textureMap[f.textureMap.length - 1];
                f.bender.renderFrame(l, h, g["streak" + b.winSituation.sym], o);
                if (this.value === f.BETLINE_STREAK_IMG_CONFIG.frames) {
                    f.betlineImageRendered = true
                }
            } else {
                k = f.inMemoryCanvas;
                j = k.getContext("2d");
                k.width = e.width;
                k.height = e.height;
                f.bender.renderMemCanvasOnContext(j);
                n = n - d * f.points.length;
                j.globalCompositeOperation = "destination-out";
                p = (n / (d * f.points.length * 0.5)) * e.width;
                p = e.width > p ? p : e.width;
                try {
                    if (b.winSituation.dir === "right" || b.winSituation.fiveSymWin) {
                        j.save();
                        j.scale(-1, 1);
                        j.drawImage(f.fadeCoverImage, e.width - p, 0, p, e.height, -e.width, 0, p, e.height);
                        j.restore()
                    } else {
                        j.drawImage(f.fadeCoverImage, e.width - p, 0, p, e.height, 0, 0, p, e.height)
                    }
                } catch (m) {}
                l.drawImage(k, 0, 0)
            }
        };
        i.restore();
        f.animationList.play(i)
    },
    getBetlinePoints: function(d) {
        var e = [],
            g, b = d.positions,
            a = b.length,
            f = 2,
            c;
        g = Game.stage.model.getSymbolConfiguration(b[0].reelIndex, b[0].symbolIndex);
        if (b[0].symbolIndex === b[1].symbolIndex) {
            f = 1
        } else {
            if (b[0].symbolIndex < b[1].symbolIndex) {
                f = 0
            }
        }
        if (d.dir === "left") {
            if (d.fiveSymWin) {
                e.push([g.left - g.width / 4, g.top + g.height / 2 * f])
            } else {
                e.push([g.left, g.top + g.height / 2 * f])
            }
        } else {
            e.push([g.left + g.width, g.top + g.height / 2 * f])
        }
        for (c = 0; c < b.length; c++) {
            g = Game.stage.model.getSymbolConfiguration(b[c].reelIndex, b[c].symbolIndex);
            e.push([g.left + g.width / 2, g.top + g.height / 2])
        }
        f = 0;
        if (b[a - 2].symbolIndex === b[a - 1].symbolIndex) {
            f = 1
        } else {
            if (b[a - 2].symbolIndex < b[a - 1].symbolIndex) {
                f = 2
            }
        }
        if (d.dir === "left") {
            if (d.fiveSymWin) {
                e.push([g.left + g.width, g.top + g.height / 2 * f])
            } else {
                e.push([g.left + g.width * 1.25, g.top + g.height / 2 * f])
            }
        } else {
            e.push([g.left - g.width / 4, g.top + g.height / 2 * f])
        }
        if (d.fiveSymWin) {
            e.reverse()
        }
        return e
    }
};
SB.BendingBetlinesDesktopView = Sys.extend(SB.BendingBetlinesView, SB.BendingBetlinesDesktopView, "SB.BendingBetlinesDesktopView");
var BetLineBender = function(b) {
    var a = document.createElement("canvas");
    a.width = b.width;
    a.height = b.height;
    this.size = b;
    this.inMemoryCanvas = a;
    this.inMemoryContext = a.getContext("2d");
    this.softness = 0.4
};
BetLineBender.prototype = {
    renderFrame: function(a, f, c, h) {
        var g = this,
            e = f.length,
            d, b, j = g.inMemoryContext;
        j.clearRect(0, 0, g.size.width, g.size.height);
        for (d = 0; d < e; d++) {
            g.renderSections(j, f[d], c)
        }
        if (h) {
            b = Game.stage.model.getSymbolConfiguration(h.reelIndex, h.symbolIndex);
            j.clearRect(b.left + b.width / 2, b.top, b.left + b.width, b.top + b.height)
        }
        g.renderMemCanvasOnContext(a)
    },
    renderMemCanvasOnContext: function(a) {
        a.save();
        a.globalCompositeOperation = "lighter";
        a.drawImage(this.inMemoryCanvas, 0, 0);
        a.restore()
    },
    buildTextureMapCoordinates: function(m, f, k, l, c) {
        var g = [],
            a, e, d, h, b;
        for (e = -1; ++e < f;) {
            a = [];
            h = l * (e % k);
            b = c * Math.floor(e / k);
            for (d = -1; ++d < m.length;) {
                a.push(this.getTextureMap(m[d], h, b))
            }
            g.push(a)
        }
        return g
    },
    buildMesh: function(c, b, q, e) {
        var o = this,
            j = bCurve.getStepsFromCurve(bCurve.getCurveFromPoints(c, this.softness), e),
            p = j.length,
            s = 2,
            r = Math.round(b / p),
            a = Math.round(q / s),
            l = q / s,
            f = bCurve.getStepsFromCurve(bCurve.getCurveFromPoints(o.getSupportPoints(c, 0, -l), this.softness), e),
            d = bCurve.getStepsFromCurve(bCurve.getCurveFromPoints(o.getSupportPoints(c, 0, l), this.softness), e),
            n = [],
            k = [],
            m, g;
        n.push({
            top: {
                x: j[0].x,
                y: j[0].y
            },
            bottom: {
                x: j[0].x,
                y: j[0].y
            }
        });
        for (g = 0; g < p - 2; g++) {
            n.push(o.calculateSupportPoints(l, j[g].x, j[g].y, j[g + 1].x, j[g + 1].y, false))
        }
        n.push({
            top: {
                x: j[p - 1].x,
                y: j[p - 1].y
            },
            bottom: {
                x: j[p - 1].x,
                y: j[p - 1].y
            }
        });
        for (g = 0; g < p - 1; g++) {
            m = [];
            m.push({
                x: f[g].x,
                y: f[g].y,
                u: g * r,
                v: 0
            });
            m.push({
                x: f[g + 1].x,
                y: f[g + 1].y,
                u: (g * r) + r,
                v: 0
            });
            m.push({
                x: j[g + 1].x,
                y: j[g + 1].y,
                u: (g * r) + r,
                v: a
            });
            m.push({
                x: j[g].x,
                y: j[g].y,
                u: (g * r),
                v: a
            });
            k.push(m)
        }
        for (g = 0; g < p - 1; g++) {
            m = [];
            m.push({
                x: j[g].x,
                y: j[g].y,
                u: g * r,
                v: a
            });
            m.push({
                x: j[g + 1].x,
                y: j[g + 1].y,
                u: (g * r) + r,
                v: a
            });
            m.push({
                x: d[g + 1].x,
                y: d[g + 1].y,
                u: (g * r) + r,
                v: a * 2
            });
            m.push({
                x: d[g].x,
                y: d[g].y,
                u: (g * r),
                v: a * 2
            });
            k.push(m)
        }
        return k
    },
    calculateSupportPoints: function(d, a, c) {
        var b = {};
        b.top = {
            x: a,
            y: c + d
        };
        b.bottom = {
            x: a,
            y: c - d
        };
        return b
    },
    buildCurveIndex: function(d, c) {
        var a = [],
            b;
        for (b = -1; ++b <= c;) {
            a.push({
                x: this.getInterpolationValue(d.x1, d.x2, d.xs, b / c),
                y: this.getInterpolationValue(d.y1, d.y2, d.ys, b / c)
            })
        }
        return a
    },
    getInterpolationValue: function(d, c, a, b) {
        return Math.pow((1 - b), 2) * d + 2 * b * (1 - b) * a + Math.pow(b, 2) * c
    },
    renderSections: function(a, f, e) {
        var b, d, c;
        for (c = -1; ++c < 2;) {
            d = f[c].points;
            b = f[c].matrix;
            a.save();
            a.beginPath();
            a.moveTo(d.x0, d.y0);
            a.lineTo(d.x1, d.y1);
            a.lineTo(d.x2, d.y2);
            a.closePath();
            a.clip();
            a.transform(b[0], b[1], b[2], b[3], b[4], b[5]);
            a.drawImage(e, 0, 0);
            a.restore()
        }
    },
    getTextureMap: function(q, A, m) {
        var o = [
                [0, 1, 2],
                [2, 3, 0]
            ],
            z = [],
            n;
        for (n = -1; ++n < 2;) {
            var p = o[n],
                x = q[p[0]].x,
                w = q[p[1]].x,
                u = q[p[2]].x,
                h = q[p[0]].y,
                f = q[p[1]].y,
                c = q[p[2]].y,
                v = q[p[0]].u + A,
                s = q[p[1]].u + A,
                r = q[p[2]].u + A,
                e = q[p[0]].v + m,
                b = q[p[1]].v + m,
                a = q[p[2]].v + m,
                y = v * b + e * r + s * a - b * r - e * s - v * a,
                l = x * b + e * u + w * a - b * u - e * w - x * a,
                k = v * w + x * r + s * u - w * r - x * s - v * u,
                j = v * b * u + e * w * r + x * s * a - x * b * r - e * s * u - v * w * a,
                i = h * b + e * c + f * a - b * c - e * f - h * a,
                g = v * f + h * r + s * c - f * r - h * s - v * c,
                d = v * b * c + e * f * r + h * s * a - h * b * r - e * s * c - v * f * a;
            z.push({
                points: {
                    x0: x,
                    y0: h,
                    x1: w,
                    y1: f,
                    x2: u,
                    y2: c
                },
                matrix: [l / y, i / y, k / y, g / y, j / y, d / y]
            })
        }
        return z
    },
    getCurveFromPoints: function(n, a) {
        var t = n.length,
            l = [],
            h = (a >= 0 || a <= 1) ? a : 1,
            o, e, r, q, d, g, f, k, j, b, m, p, c;
        if (t < 3) {
            return false
        }
        for (o = -1; ++o < t;) {
            e = n[o][0];
            d = n[o][1];
            if (o > 0 && o + 1 < t) {
                q = n[o - 1][0];
                f = n[o - 1][1];
                r = n[o + 1][0];
                g = n[o + 1][1];
                p = ((r - q) / 2) * h;
                c = ((g - f) / 2) * h;
                k = e - p;
                j = d - c;
                b = e + p;
                m = d + c
            } else {
                k = b = e;
                j = m = d
            }
            l.push({
                x: e,
                y: d,
                sx1: k,
                sy1: j,
                sx2: b,
                sy2: m
            })
        }
        return l
    },
    cInterpolate: function(e, d, b, a, c) {
        return Math.pow(1 - c, 3) * e + 3 * c * Math.pow(1 - c, 2) * b + 3 * Math.pow(c, 2) * (1 - c) * a + Math.pow(c, 3) * d
    },
    getSupportPoints: function(c, a, e) {
        var d = [],
            b;
        d.push([c[0][0] + a / 2, c[0][1] + e / 2]);
        for (b = 1; b < c.length - 1; b++) {
            d.push([c[b][0] + a, c[b][1] + e])
        }
        d.push([c[c.length - 1][0] + a / 2, c[c.length - 1][1] + e / 2]);
        return d
    }
};
Sys.ns("SB");
SB.ComboAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            controller: SB.ComboAnimationController,
            view: SB.ComboAnimationView
        }
    }
};
SB.ComboAnimation = Sys.extend(Core.Module, SB.ComboAnimation, "SB.ComboAnimation");
Sys.ns("SB");
SB.ComboAnimationController = {
    setupEvents: function() {
        var a = this;
        a.on({
            "request:comboAnimations.showComboAnimation": a.view.animateCombo.bind(a.view),
            "view:animationComplete": a.fireEvent.bind(a, "notify:comboAnimation.animationComplete"),
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:winAnimations.animationAborted": a.view.restoreAnimation.bind(a.view)
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    }
};
SB.ComboAnimationController = Sys.extend(Core.Controller, SB.ComboAnimationController, "SB.ComboAnimationController");
Sys.ns("SB");
SB.ComboAnimationView = {
    TEXT_OPERATIONS: [{
        offsetX: 2,
        offsetY: 2,
        lineWidth: 5,
        strokeStyle: "rgba( 0, 0, 0, 0.7 )",
        drawType: "stroke",
        lineJoin: "round"
    }, {
        lineJoin: "round",
        lineWidth: 6,
        strokeStyle: "#000000",
        drawType: "stroke"
    }, {
        lineWidth: 6,
        strokeStyle: "#f7f732",
        drawType: "stroke",
        lineJoin: "round"
    }, {
        fillStyle: "#fb0536",
        lineJoin: "round"
    }],
    FONT: "80px BauhausRegular",
    FONT_IN_OTHER_LANG: "80px SBMyroidProBold",
    TEXT_OFFSET: 20,
    TEXT_TOP: 80,
    TEXT_LEFT: undefined,
    WIN_TEXTS: ["specialWinCombo", "specialWinSuperCombo", "specialWinMegaCombo"],
    DURATION: 700,
    MEGA_COMBO_FONT: "90px BauhausRegular",
    SUPER_MEGA_COMBO_FONT: "100px BauhausRegular",
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.FONT = b.FONT_IN_OTHER_LANG;
            b.MEGA_COMBO_FONT = "90px SBMyroidProBold";
            b.SUPER_MEGA_COMBO_FONT = "100px SBMyroidProBold"
        }
        b.comboAnimationItems = [];
        b.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(b.animationList);
        b.animationList.stop()
    },
    createTextAnimation: function(c) {
        var h = this,
            i = 205,
            e, g = 15,
            b = "#94cbf9",
            l = "#0b4763",
            d = h.FONT,
            k = Services.languageManager.getText(h.WIN_TEXTS[c]),
            a, j, f;
        if (c === 1) {
            i = 230;
            d = h.MEGA_COMBO_FONT;
            g = 1;
            b = "#f5c347";
            l = "#730101"
        }
        if (c === 2) {
            i = 216;
            g = -15;
            d = h.SUPER_MEGA_COMBO_FONT;
            b = "#cafe70";
            l = "#1b3300"
        }
        h.TEXT_OPERATIONS[3].fillStyle = b;
        h.TEXT_OPERATIONS[2].strokeStyle = l;
        f = h.createText(k, d);
        a = f.width;
        j = f.height;
        e = (Environment.getStageResolution().width - f.width) / 2;
        return new Animation.CanvasAnimationItem({
            width: a,
            height: j,
            top: i,
            left: e,
            opacity: 1,
            depth: Layering.Game.Slots.WinningSymbols.comboAnimation,
            image: f,
            operations: {},
            text: k,
            angle: g
        })
    },
    createText: (function() {
        var a = {};
        return function(d, b) {
            var c = this;
            return a[d] || (a[d] = Animation.utils.text.createText(d, b, c.TEXT_OFFSET, c.TEXT_OPERATIONS))
        }
    }()),
    configureTextAnimation: function(b) {
        var a = this;
        b.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 1.3,
                scaleY: 1.3
            }
        }, {
            time: 100,
            value: {
                scaleX: 1,
                scaleY: 1
            }
        }, {
            time: a.DURATION,
            value: {
                scaleX: 1.2,
                scaleY: 1.2
            }
        }];
        b.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: 200,
            value: 0.9
        }, {
            time: a.DURATION,
            value: 0.5
        }];
        b.prop.operations.rotate = [{
            time: 0,
            value: b.prop.angle
        }, {
            time: a.DURATION,
            value: b.prop.angle
        }];
        b.restore()
    },
    animateCombo: function(c) {
        var b = this,
            a;
        if (Sys.isDefined(b.comboAnimationItems[c])) {
            a = b.comboAnimationItems[c]
        } else {
            a = b.createTextAnimation(c);
            b.animationList.add(a);
            b.comboAnimationItems[c] = a
        }
        b.configureTextAnimation(a);
        b.animationList.play(b.comboAnimationItems[c])
    },
    restoreAnimation: function() {
        var a = this;
        a.animationList.restore();
        a.animationList.stop()
    }
};
SB.ComboAnimationView = Sys.extend(Core.View, SB.ComboAnimationView, "SB.ComboAnimationView");
Sys.ns("SB");
SB.ComboAnimationDesktopView = {
    TEXT_OPERATIONS: [{
        offsetX: 2,
        offsetY: 2,
        lineWidth: 7,
        strokeStyle: "rgba( 0, 0, 0, 0.7 )",
        drawType: "stroke",
        lineJoin: "round"
    }, {
        lineJoin: "round",
        lineWidth: 7,
        strokeStyle: "#000000",
        drawType: "stroke"
    }, {
        lineWidth: 7,
        strokeStyle: "#f7f732",
        drawType: "stroke",
        lineJoin: "round"
    }, {
        fillStyle: "#fb0536",
        lineJoin: "round"
    }],
    FONT: "70px BauhausRegular",
    DURATION: 1000,
    MAX_SCALES: [],
    FONT_IN_OTHER_LANG: "70px SBMyroidProBold",
    MEGA_COMBO_FONT: "90px BauhausRegular",
    SUPER_MEGA_COMBO_FONT: "100px BauhausRegular",
    COLOR_STOP: {
        blue: [{
            pos: 0,
            rgb: "#cceeff"
        }, {
            pos: 0.25,
            rgb: "#cceeff"
        }, {
            pos: 1,
            rgb: "#0d85f2"
        }],
        green: [{
            pos: 0,
            rgb: "#ecfc9d"
        }, {
            pos: 0.3,
            rgb: "#ecfc9d"
        }, {
            pos: 1,
            rgb: "#82f60c"
        }],
        orange: [{
            pos: 0,
            rgb: "#fff499"
        }, {
            pos: 0.2,
            rgb: "#fff17d"
        }, {
            pos: 1,
            rgb: "#f1af28"
        }]
    },
    createTextAnimation: function(d) {
        var i = this,
            j = 140,
            f, h = 15,
            m = "#064792",
            e = i.FONT,
            l = Services.languageManager.getText(i.WIN_TEXTS[d]),
            b, c, k, g, a;
        i.TEXT_OPERATIONS[3].fillStyle = {
            type: "linearGradient",
            linearGradient: [0, 33, 0, 123],
            colorStop: i.COLOR_STOP.blue
        };
        if (d === 1) {
            j = 180;
            e = i.MEGA_COMBO_FONT;
            h = 5;
            m = "#1f3900";
            i.TEXT_OPERATIONS[3].fillStyle = {
                type: "linearGradient",
                linearGradient: [0, 33, 0, 123],
                colorStop: i.COLOR_STOP.green
            }
        }
        if (d === 2) {
            j = 150;
            h = -15;
            e = i.SUPER_MEGA_COMBO_FONT;
            m = "#850101";
            i.TEXT_OPERATIONS[3].fillStyle = {
                type: "linearGradient",
                linearGradient: [0, 33, 0, 123],
                colorStop: i.COLOR_STOP.orange
            }
        }
        i.TEXT_OPERATIONS[2].strokeStyle = m;
        b = Environment.getStageResolution();
        g = i.createText(l, e);
        c = g.width;
        k = g.height;
        if (c <= b.width / 3) {
            a = 3
        } else {
            if (c <= b.width / 2) {
                a = 2
            }
        }
        if ((b.width / 3) <= c && c <= (b.width / 2)) {
            a = 2.5
        } else {
            if ((b.width / 2) <= c && c <= (b.width)) {
                a = 2.5
            }
        }
        f = (Environment.getStageResolution().width - g.width) / 2;
        if (!i.MAX_SCALES[d]) {
            i.MAX_SCALES[d] = a
        }
        return new Animation.CanvasAnimationItem({
            width: c,
            height: k,
            top: j,
            left: f,
            opacity: 1,
            depth: Layering.Game.Slots.WinningSymbols.comboAnimation,
            image: g,
            operations: {},
            text: l,
            angle: h,
            comboType: d
        })
    },
    configureTextAnimation: function(b) {
        var a = this;
        if (b.prop.comboType === 2) {
            a.configureSuperMegaTextAnimation(b)
        } else {
            a.configureComboAndMegaTextAnimation(b)
        }
        b.restore()
    },
    configureComboAndMegaTextAnimation: function(b) {
        var a = this,
            c = a.MAX_SCALES[b.prop.comboType];
        b.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: c,
                scaleY: c
            }
        }, {
            time: 30,
            value: {
                scaleX: 2 * c / 3,
                scaleY: 2 * c / 3
            }
        }, {
            time: 90,
            value: {
                scaleX: c === 2.5 ? 0.5 : 1,
                scaleY: c === 2.5 ? 0.5 : 1
            }
        }, {
            time: 380,
            value: {
                scaleX: c === 2.5 ? 0.8 : 1.2,
                scaleY: c === 2.5 ? 0.8 : 1.2
            }
        }, {
            time: 680,
            value: {
                scaleX: c === 2.5 ? 1 : 1.4,
                scaleY: c === 2.5 ? 1 : 1.4
            }
        }, {
            time: a.DURATION,
            value: {
                scaleX: c === 2.5 ? 1.2 : 1.7,
                scaleY: c === 2.5 ? 1.2 : 1.7
            }
        }];
        b.prop.operations.fade = [{
            time: 0,
            value: 0.2
        }, {
            time: 30,
            value: 0.5
        }, {
            time: 90,
            value: 1
        }, {
            time: 380,
            value: 1
        }, {
            time: 680,
            value: 0.5
        }, {
            time: a.DURATION,
            value: 0
        }];
        b.prop.operations.rotate = [{
            time: 0,
            value: b.prop.angle
        }, {
            time: a.DURATION,
            value: b.prop.angle
        }]
    },
    configureSuperMegaTextAnimation: function(c) {
        var b = this,
            a = 200,
            d = b.MAX_SCALES[c.prop.comboType];
        c.prop.operations.scale = [{
            time: 0,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }, {
            time: a,
            value: {
                scaleX: d,
                scaleY: d
            }
        }, {
            time: 30 + a,
            value: {
                scaleX: 2 * d / 3,
                scaleY: 2 * d / 3
            }
        }, {
            time: 90 + a,
            value: {
                scaleX: d === 2.5 ? 0.5 : 1,
                scaleY: d === 2.5 ? 0.5 : 1
            }
        }, {
            time: 380 + a,
            value: {
                scaleX: d === 2.5 ? 0.8 : 1.2,
                scaleY: d === 2.5 ? 0.8 : 1.2
            }
        }, {
            time: 680 + a,
            value: {
                scaleX: d === 2.5 ? 1 : 1.4,
                scaleY: d === 2.5 ? 1 : 1.4
            }
        }, {
            time: b.DURATION + a,
            value: {
                scaleX: d === 2.5 ? 1.2 : 1.7,
                scaleY: d === 2.5 ? 1.2 : 1.7
            }
        }];
        c.prop.operations.fade = [{
            time: 0,
            value: 0
        }, {
            time: a - 1,
            value: 0
        }, {
            time: a,
            value: 0.2
        }, {
            time: 30 + a,
            value: 0.5
        }, {
            time: 90 + a,
            value: 1
        }, {
            time: 380 + a,
            value: 1
        }, {
            time: 680 + a,
            value: 0.5
        }, {
            time: b.DURATION + a,
            value: 0
        }];
        c.prop.operations.rotate = [{
            time: 0,
            value: c.prop.angle
        }, {
            time: b.DURATION + a,
            value: c.prop.angle
        }]
    }
};
SB.ComboAnimationDesktopView = Sys.extend(SB.ComboAnimationView, SB.ComboAnimationDesktopView, "SB.ComboAnimationDesktopView");
Sys.ns("SB");
SB.IdleSymbolAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.IdleSymbolAnimationModel,
            controller: SB.IdleSymbolAnimationController,
            view: SB.IdleSymbolAnimationView
        }
    }
};
SB.IdleSymbolAnimation = Sys.extend(Core.Module, SB.IdleSymbolAnimation, "SB.IdleSymbolAnimation");
Sys.ns("SB");
SB.IdleSymbolAnimationController = {
    IS_ANIMATING: false,
    setupEvents: function() {
        var a = this;
        SB.IdleSymbolAnimationController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:stateHandler.enteringIdleState": a.showTwinkleAnimations,
            "notify:spin.roundStart": a.stopAnimations,
            "view:animateSatellite": a.animateSatellite,
            "request:idleAnimation.animateAllSymbols": a.showTwinkleAnimationsInUndimSymbols
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    animateSatellite: function(a) {
        this.fireEvent("request:satelliteAnimation.animate", a)
    },
    showTwinkleAnimations: function() {
        var a = this;
        if (a.model.animateTwinkle()) {
            a.view.animateTwinkles()
        }
    },
    showTwinkleAnimationsInUndimSymbols: function() {
        var a = this;
        if (!a.IS_ANIMATING) {
            a.view.animateTwinkles();
            a.IS_ANIMATING = true
        }
    },
    stopAnimations: function() {
        var a = this;
        a.model.storeData("reelInfo", undefined);
        a.view.stop();
        a.IS_ANIMATING = false
    }
};
SB.IdleSymbolAnimationController = Sys.extend(Core.Controller, SB.IdleSymbolAnimationController, "SB.IdleSymbolAnimationController");
Sys.ns("SB");
SB.IdleSymbolAnimationView = {
    IMAGE_WIDTH: 69,
    IMAGE_HEIGHT: 67,
    TWINKLE_CONFIGURATION: {
        SYM3: {
            img: "bar_twinkle",
            bigTwinkle: {
                left: 89,
                top: 22
            }
        },
        SYM4: {
            img: "orange_twinkle",
            bigTwinkle: {
                left: 96,
                top: 21
            }
        },
        SYM5: {
            img: "yellow_twinkle",
            bigTwinkle: {
                left: 21,
                top: 8
            },
            smallTwinkle: {
                left: 58,
                top: 86
            }
        },
        SYM6: {
            img: "green_twinkle",
            bigTwinkle: {
                left: 96,
                top: 25
            },
            smallTwinkle: {
                left: 15,
                top: 71
            }
        },
        SYM7: {
            img: "red_twinkle",
            bigTwinkle: {
                left: 72,
                top: 13
            },
            smallTwinkle: {
                left: 24,
                top: 90
            }
        },
        SYM8: {
            img: "blue_twinkle",
            bigTwinkle: {
                left: 23,
                top: 16
            },
            smallTwinkle: {
                left: 96,
                top: 87
            }
        },
        SYM9: {
            img: "purple_twinkle",
            bigTwinkle: {
                left: 58,
                top: 3
            },
            smallTwinkle: {
                left: 12,
                top: 46
            }
        }
    },
    WILD_CONFIGURATION: {
        purpleTwinkle: {
            left: 65,
            top: 1
        },
        blueTwinkle: {
            left: 6,
            top: 45
        },
        orangeTwinkle: {
            left: 97,
            top: 86
        }
    },
    SATELLITE_ANIM_SYMS: ["SYM3", "SYM4"],
    configureTwinkleAnimation: function(e, c) {
        var i = this,
            b = Game.stage.model.getSymbolConfiguration(c.reelIndex, c.symbolIndex),
            f = i.TWINKLE_CONFIGURATION[c.sym],
            g = c.twinkleType === "bigTwinkle" ? 0 : Sys.Math.randomIntBetween(200, 800),
            h = c.twinkleType === "bigTwinkle" ? 0 : 0.5,
            d = 1 - h,
            a = 1.6 - h;
        g = g + Sys.Math.randomIntBetween(0, 50);
        e.prop = Sys.apply(e.prop, {
            image: f.img,
            operations: {
                fade: [{
                    value: 0,
                    time: g
                }, {
                    value: 1,
                    time: 800 + g
                }, {
                    value: 0,
                    time: 2000 + g
                }, {
                    value: 1,
                    time: 2800 + g
                }, {
                    value: 0,
                    time: 4000 + g,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: i,
                        argument: c
                    }
                }],
                scale: [{
                    time: g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }, {
                    time: 800 + g,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 2000 + g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }, {
                    time: 2800 + g,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 4000 + g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }]
            },
            top: b.top + f[c.twinkleType].top,
            left: b.left + f[c.twinkleType].left
        })
    },
    configureWildTwinkleAnimation: function(e, c) {
        var i = this,
            b = Game.stage.model.getSymbolConfiguration(c.reelIndex, c.symbolIndex),
            f = i.WILD_CONFIGURATION[c.twinkleType],
            g = c.twinkleType === "purpleTwinkle" ? 0 : Sys.Math.randomIntBetween(100, 500),
            h = c.twinkleType === "purpleTwinkle" ? 0.4 : 0.8,
            d = 1 - h,
            a = 1.6 - h;
        e.prop = Sys.apply(e.prop, {
            operations: {
                fade: [{
                    value: 0,
                    time: g
                }, {
                    value: 1,
                    time: 800 + g
                }, {
                    value: 0,
                    time: 2000 + g
                }, {
                    value: 1,
                    time: 2800 + g
                }, {
                    value: 0,
                    time: 4000 + g,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: i,
                        argument: c
                    }
                }],
                scale: [{
                    time: g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }, {
                    time: 800 + g,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 2000 + g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }, {
                    time: 2800 + g,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 4000 + g,
                    value: {
                        scaleX: d,
                        scaleY: d
                    }
                }]
            },
            top: b.top + f.top,
            left: b.left + f.left
        })
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "view:animationComplete": a.animationComplete
        })
    },
    initAnimations: function() {
        var e = this,
            f = Resources.readData("config").reel,
            b = f.symbolCols,
            c = f.symbolRows,
            g, d;
        e.animationList = new Animation.CanvasAnimationList();
        e.twinkleAnimationItems = Sys.utils.init2dMatrix(b, c);
        for (var a = 0; a < b; a++) {
            for (var h = 0; h < c; h++) {
                g = e.createTwinkleAnimationItem();
                d = e.createTwinkleAnimationItem();
                e.twinkleAnimationItems[a][h] = {
                    bigTwinkle: g,
                    smallTwinkle: d
                };
                e.animationList.add(g);
                e.animationList.add(d)
            }
        }
        Game.stage.view.addToRenderLoop(e.animationList);
        e.animationList.stop();
        e.wildAnimationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(e.wildAnimationList);
        e.wildAnimationList.stop()
    },
    createTwinkleAnimationItem: function() {
        var a = this,
            b;
        b = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.burstAnimation,
            width: a.IMAGE_WIDTH,
            height: a.IMAGE_HEIGHT
        });
        return b
    },
    createWildTwinkleAnimationItems: function() {
        var b = this,
            a = {};
        a.purpleTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.burstAnimation,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_purple_twinkle"
        });
        a.blueTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.burstAnimation,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_blue_twinkle"
        });
        a.orangeTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.burstAnimation,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_orange_twinkle"
        });
        return a
    },
    animateTwinkles: function() {
        var f = this,
            a = f.model.readData("reelInfo"),
            e, d = [],
            c, g;
        if (a) {
            for (var b = 0; b < 5; b++) {
                e = f.getNextTwinkle();
                c = a[e.reelIndex].symbols[e.symbolIndex];
                g = {
                    sym: c,
                    reelIndex: e.reelIndex,
                    symbolIndex: e.symbolIndex
                };
                if (c !== "SYM1") {
                    d.push(e.twinkleItems.bigTwinkle);
                    if (f.TWINKLE_CONFIGURATION[c].smallTwinkle) {
                        d.push(e.twinkleItems.smallTwinkle)
                    }
                } else {
                    f.animateWildTwinkles(g)
                }
                if (f.SATELLITE_ANIM_SYMS.contains(c)) {
                    f.fireEvent("view:animateSatellite", g)
                }
            }
        }
        f.animationList.play(d)
    },
    animateTwinkle: function() {
        var e = this,
            d, a = e.model.readData("reelInfo"),
            c = [],
            b, f;
        if (a) {
            d = e.getNextTwinkle();
            b = a[d.reelIndex].symbols[d.symbolIndex];
            f = {
                sym: b,
                reelIndex: d.reelIndex,
                symbolIndex: d.symbolIndex
            };
            if (b !== "SYM1") {
                c.push(d.twinkleItems.bigTwinkle);
                if (e.TWINKLE_CONFIGURATION[a[d.reelIndex].symbols[d.symbolIndex]].smallTwinkle) {
                    c.push(d.twinkleItems.smallTwinkle)
                }
                e.animationList.play(c)
            } else {
                e.animateWildTwinkles(f)
            }
            if (e.SATELLITE_ANIM_SYMS.contains(b)) {
                e.fireEvent("view:animateSatellite", f)
            }
        }
    },
    animateWildTwinkles: function(a) {
        var b = this;
        if (!Sys.isDefined(b.wildTwinkleAnimationItems)) {
            b.wildTwinkleAnimationItems = b.createWildTwinkleAnimationItems();
            Sys.iterate(b.wildTwinkleAnimationItems, function(c, d) {
                b.wildAnimationList.add(d)
            })
        }
        if (!b.model.readData("wildAnimating")) {
            b.model.storeData("wildAnimating", true);
            Sys.iterate(b.wildTwinkleAnimationItems, function(c, d) {
                a.twinkleType = c;
                b.configureWildTwinkleAnimation(d, a)
            });
            b.wildAnimationList.play()
        } else {
            b.twinkleAnimationItems[a.reelIndex][a.symbolIndex].animating = false
        }
    },
    getNextTwinkle: function() {
        var f = this,
            b = Sys.Math.randomIntBetween(0, 4),
            h = Sys.Math.randomIntBetween(0, 2),
            d = f.twinkleAnimationItems[b][h],
            a = f.model.readData("reelInfo"),
            g, e, c;
        if (d.animating) {
            return f.getNextTwinkle()
        } else {
            d.animating = true;
            c = a[b].symbols[h];
            if (c !== "SYM1") {
                g = {
                    sym: a[b].symbols[h],
                    reelIndex: b,
                    symbolIndex: h,
                    twinkleType: "bigTwinkle"
                };
                f.configureTwinkleAnimation(d.bigTwinkle, g);
                if (f.TWINKLE_CONFIGURATION[a[b].symbols[h]].smallTwinkle) {
                    e = {
                        sym: a[b].symbols[h],
                        reelIndex: b,
                        symbolIndex: h,
                        twinkleType: "smallTwinkle"
                    };
                    f.configureTwinkleAnimation(d.smallTwinkle, e)
                }
            }
            return {
                twinkleItems: d,
                reelIndex: b,
                symbolIndex: h
            }
        }
    },
    animationComplete: function(a) {
        var b = this;
        if (a.sym !== "SYM1") {
            if (b.TWINKLE_CONFIGURATION[a.sym].smallTwinkle) {
                if (a.twinkleType === "smallTwinkle") {
                    b.twinkleAnimationItems[a.reelIndex][a.symbolIndex].animating = false;
                    b.animateTwinkle()
                }
            } else {
                b.twinkleAnimationItems[a.reelIndex][a.symbolIndex].animating = false;
                b.animateTwinkle()
            }
        } else {
            if (a.twinkleType === "orangeTwinkle") {
                b.twinkleAnimationItems[a.reelIndex][a.symbolIndex].animating = false;
                b.model.storeData("wildAnimating", false);
                b.animateTwinkle()
            }
        }
    },
    stop: function() {
        var d = this,
            e = Resources.readData("config").reel,
            b = e.symbolCols,
            c = e.symbolRows;
        d.animationList.stop();
        d.wildAnimationList.stop();
        for (var a = 0; a < b; a++) {
            for (var f = 0; f < c; f++) {
                d.twinkleAnimationItems[a][f].animating = false
            }
        }
    }
};
SB.IdleSymbolAnimationView = Sys.extend(Core.View, SB.IdleSymbolAnimationView, "SB.IdleSymbolAnimationView");
Sys.ns("SB");
SB.IdleSymbolAnimationDesktopView = {
    SPECIAL_SYMS: ["SYM1", "SYM3", "SYM4"],
    STANDARD_SYM_DIM: {
        BIG: {
            W: 68,
            H: 68
        },
        SMALL: {
            W: 62,
            H: 62
        }
    },
    SYM_DIMENSION: {
        SYM1: {
            BIG: {
                W: 62,
                H: 62
            },
            SMALL: {
                W: 62,
                H: 62
            }
        },
        SYM3: {
            BIG: {
                W: 88,
                H: 88
            },
            SMALL: {
                W: 88,
                H: 88
            }
        },
        SYM4: {
            BIG: {
                H: 88,
                W: 88
            },
            SMALL: {
                W: 88,
                H: 88
            }
        }
    },
    setupEvents: function() {
        var a = this;
        SB.IdleSymbolAnimationDesktopView.superclass.setupEvents.apply(a, arguments);
        a.on({
            "view:startOrbitAnimation": a.animateOrbit
        })
    },
    TWINKLE_CONFIGURATION: {
        SYM3: {
            img: "bar_twinkle",
            bigTwinkle: {
                left: 82,
                top: 3
            }
        },
        SYM4: {
            img: "orange_twinkle",
            bigTwinkle: {
                left: 91,
                top: -1
            }
        },
        SYM5: {
            img: "yellow_twinkle",
            bigTwinkle: {
                left: 30,
                top: 12
            },
            smallTwinkle: {
                left: 66,
                top: 84
            }
        },
        SYM6: {
            img: "green_twinkle",
            bigTwinkle: {
                left: 100,
                top: 17
            },
            smallTwinkle: {
                left: 29,
                top: 61
            }
        },
        SYM7: {
            img: "red_twinkle",
            bigTwinkle: {
                left: 77,
                top: 3
            },
            smallTwinkle: {
                left: 36,
                top: 75
            }
        },
        SYM8: {
            img: "blue_twinkle",
            bigTwinkle: {
                left: 33,
                top: 8
            },
            smallTwinkle: {
                left: 102,
                top: 75
            }
        },
        SYM9: {
            img: "purple_twinkle",
            bigTwinkle: {
                left: 63,
                top: -3
            },
            smallTwinkle: {
                left: 23,
                top: 40
            }
        }
    },
    WILD_CONFIGURATION: {
        purpleTwinkle: {
            left: 72,
            top: -1
        },
        blueTwinkle: {
            left: 19,
            top: 38
        },
        orangeTwinkle: {
            left: 102,
            top: 72
        }
    },
    configureTwinkleAnimation: function(g, d) {
        var k = this,
            c = Game.stage.model.getSymbolConfiguration(d.reelIndex, d.symbolIndex),
            h = k.TWINKLE_CONFIGURATION[d.sym],
            i = d.twinkleType === "bigTwinkle" ? 0 : Sys.Math.randomIntBetween(200, 800),
            j = d.twinkleType === "bigTwinkle" ? 0 : 0.4,
            f = 1 - j,
            a = 1.3 - j,
            e, b;
        i = i + Sys.Math.randomIntBetween(0, 2000);
        if (d.twinkleType === "bigTwinkle") {
            e = k.STANDARD_SYM_DIM.BIG.W;
            b = k.STANDARD_SYM_DIM.BIG.H;
            if (k.SPECIAL_SYMS.contains(d.sym)) {
                e = k.SYM_DIMENSION[d.sym].BIG.W;
                b = k.SYM_DIMENSION[d.sym].BIG.H
            }
        } else {
            e = k.STANDARD_SYM_DIM.SMALL.W;
            b = k.STANDARD_SYM_DIM.SMALL.H;
            if (k.SPECIAL_SYMS.contains(d.sym)) {
                e = k.SYM_DIMENSION[d.sym].SMALL.W;
                b = k.SYM_DIMENSION[d.sym].SMALL.H
            }
        }
        g.prop = Sys.apply(g.prop, {
            image: h.img,
            operations: {
                fade: [{
                    value: 0,
                    time: i
                }, {
                    value: 1,
                    time: 700 + i
                }, {
                    value: 0,
                    time: 1500 + i,
                    fireEvent: {
                        event: "view:startOrbitAnimation",
                        scope: k,
                        argument: d
                    }
                }, {
                    value: 1,
                    time: 2500 + i
                }, {
                    value: 0,
                    time: 3500 + i,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: k,
                        argument: d
                    }
                }],
                scale: [{
                    time: i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }, {
                    time: 700 + i,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 1500 + i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }, {
                    time: 2500 + i,
                    value: {
                        scaleX: f + 0.1,
                        scaleY: f + 0.1
                    }
                }, {
                    time: 3500 + i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }],
                rotate: [{
                    time: 0,
                    value: 1
                }, {
                    time: 3500,
                    value: 1
                }]
            },
            top: c.top + h[d.twinkleType].top,
            left: c.left + h[d.twinkleType].left,
            width: e,
            height: b
        })
    },
    configureWildTwinkleAnimation: function(g, d) {
        var k = this,
            c = Game.stage.model.getSymbolConfiguration(d.reelIndex, d.symbolIndex),
            h = k.WILD_CONFIGURATION[d.twinkleType],
            i = d.twinkleType === "purpleTwinkle" ? 0 : Sys.Math.randomIntBetween(100, 500),
            j = d.twinkleType === "purpleTwinkle" ? 0.4 : 0.7,
            f = 1 - j,
            a = 1.3 - j,
            e, b;
        if (d.twinkleType === "bigTwinkle") {
            e = k.STANDARD_SYM_DIM.BIG.W;
            b = k.STANDARD_SYM_DIM.BIG.H;
            if (k.SPECIAL_SYMS.contains(d.sym)) {
                e = k.SYM_DIMENSION[d.sym].BIG.W;
                b = k.SYM_DIMENSION[d.sym].BIG.H
            }
        } else {
            e = k.STANDARD_SYM_DIM.SMALL.W;
            b = k.STANDARD_SYM_DIM.SMALL.H;
            if (k.SPECIAL_SYMS.contains(d.sym)) {
                e = k.SYM_DIMENSION[d.sym].SMALL.W;
                b = k.SYM_DIMENSION[d.sym].SMALL.H
            }
        }
        g.prop = Sys.apply(g.prop, {
            operations: {
                fade: [{
                    value: 0,
                    time: i
                }, {
                    value: 1,
                    time: 700 + i
                }, {
                    value: 0,
                    time: 1500 + i,
                    fireEvent: {
                        event: "view:startOrbitAnimation",
                        scope: k,
                        argument: d
                    }
                }, {
                    value: 1,
                    time: 2500 + i
                }, {
                    value: 0,
                    time: 3500 + i,
                    fireEvent: {
                        event: "view:animationComplete",
                        scope: k,
                        argument: d
                    }
                }],
                scale: [{
                    time: i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }, {
                    time: 700 + i,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 1500 + i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }, {
                    time: 2500 + i,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: 3500 + i,
                    value: {
                        scaleX: f,
                        scaleY: f
                    }
                }]
            },
            top: c.top + h.top,
            left: c.left + h.left,
            width: e,
            height: b
        })
    },
    animateOrbit: function() {
        var e = this,
            b = Sys.Math.randomIntBetween(0, 4),
            f = Sys.Math.randomIntBetween(0, 2),
            a = e.model.readData("reelInfo"),
            c = a[b].symbols[f],
            d = e.twinkleAnimationItems[b][f];
        if (e.SATELLITE_ANIM_SYMS.contains(c) && !d.animating) {
            e.fireEvent("view:animateSatellite", {
                reelIndex: b,
                symbolIndex: f,
                sym: c
            })
        }
    }
};
SB.IdleSymbolAnimationDesktopView = Sys.extend(SB.IdleSymbolAnimationView, SB.IdleSymbolAnimationDesktopView, "SB.IdleSymbolAnimationDesktopView");
Sys.ns("SB");
SB.IdleSymbolAnimationModel = {
    processServerResponse: function(d) {
        var c = this,
            a = [],
            b = [];
        if (!Sys.isDefined(d.wins) || !Sys.isDefined(d.wins.winSituations)) {
            c.storeData("hasWin", false)
        } else {
            c.storeData("hasWin", true)
        }
        Sys.each(d.reelInfo, function(f, e) {
            a = [];
            Sys.each(f.symbols, function(g, h) {
                a[h] = g
            });
            b[e] = {
                symbols: a
            }
        });
        c.storeData("reelInfo", b)
    },
    animateTwinkle: function() {
        var a = this;
        return !a.readData("hasWin") && Sys.isDefined(a.readData("reelInfo"))
    }
};
SB.IdleSymbolAnimationModel = Sys.extend(Core.Model, SB.IdleSymbolAnimationModel, "SB.IdleSymbolAnimationModel");
Sys.ns("SB");
SB.SatelliteAnimation = {
    getDefaultMVCClasses: function() {
        return {
            model: SB.SatelliteAnimationModel,
            controller: SB.SatelliteAnimationController,
            view: SB.SatelliteAnimationView
        }
    }
};
SB.SatelliteAnimation = Sys.extend(Core.Module, SB.SatelliteAnimation, "SB.SatelliteAnimation");
Sys.ns("SB");
SB.SatelliteAnimationController = {
    setupEvents: function() {
        var a = this;
        SB.SatelliteAnimationController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:stateHandler.enteringIdleState": a.showSatelliteAnimations,
            "notify:spin.roundStart": a.stopAnimations,
            "request:satelliteAnimation.storeBarSatelliteAnimation": a.storeBarSatelliteAnimation,
            "request:satelliteAnimation.storeSevenSatelliteAnimation": a.storeSevenSatelliteAnimation,
            "view:barSatelliteAnimations": a.barSatelliteAnimations,
            "view:sevenSatelliteAnimations": a.sevenSatelliteAnimations,
            "request:satelliteAnimation.animate": a.animateSatellite
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    barSatelliteAnimations: function(a) {
        var b = this.animationsToCreate("BarSatellite");
        b.makeNumberOfSets = a;
        this.fireEvent("request:cutOutAnimation.setupAnimation", {
            cfg: b,
            endEvent: "request:satelliteAnimation.storeBarSatelliteAnimation"
        })
    },
    animationsToCreate: function(b) {
        var a;
        switch (b) {
            case "SevenSatellite":
                a = {
                    name: "SevenSatelliteAnim",
                    depth: Layering.Game.Slots.BigWin.burst_container,
                    events: [{
                        onFrame: "end",
                        event: "view:sevenAnimationCompleted",
                        scope: this.view
                    }],
                    baseCfg: {
                        id: "SevenSatelliteAnim",
                        left: 0,
                        top: 0
                    }
                };
                break;
            case "BarSatellite":
                a = {
                    name: "BarSatelliteAnim",
                    depth: Layering.Game.Slots.BigWin.burst_container,
                    events: [{
                        onFrame: "end",
                        event: "view:barAnimationCompleted",
                        scope: this.view
                    }],
                    baseCfg: {
                        id: "BarSatelliteAnim",
                        left: 0,
                        top: 0
                    }
                };
                break;
            default:
                break
        }
        return a
    },
    sevenSatelliteAnimations: function(a) {
        var b = this.animationsToCreate("SevenSatellite");
        b.makeNumberOfSets = a;
        this.fireEvent("request:cutOutAnimation.setupAnimation", {
            cfg: b,
            endEvent: "request:satelliteAnimation.storeSevenSatelliteAnimation"
        })
    },
    storeBarSatelliteAnimation: function(a) {
        this.view.storeBarSatelliteItems(a)
    },
    storeSevenSatelliteAnimation: function(a) {
        this.view.storeSevenSatelliteItems(a)
    },
    showSatelliteAnimations: function() {
        var a = this;
        if (a.model.animateSatellite()) {
            a.view.animateSatellites()
        }
    },
    animateSatellite: function(b) {
        var a = this;
        a.view.animateSatellite(b)
    },
    stopAnimations: function() {
        var a = this;
        a.view.stop()
    }
};
SB.SatelliteAnimationController = Sys.extend(Core.Controller, SB.SatelliteAnimationController, "SB.SatelliteAnimationController");
Sys.ns("SB");
SB.SatelliteAnimationView = {
    configureAnimationItem: function(d, b, a) {
        var c = Game.stage.model.getSymbolConfiguration(b.reelIndex, b.symbolIndex);
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.delay = Sys.Math.randomIntBetween(0, 1000);
        Sys.each(d.items, function(e) {
            e.prop.globalCompositeOperation = "lighter";
            Sys.each(e.prop.operations.transformMatrix, function(f) {
                if (Sys.isDefined(f.events)) {
                    Sys.each(f.events, function(g) {
                        g.argument = a
                    })
                }
            })
        })
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "view:sevenAnimationCompleted": a.sevenAnimationCompleted,
            "view:barAnimationCompleted": a.barAnimationCompleted
        })
    },
    initAnimations: function() {
        var a = this;
        a.barSatelliteAnimationItems = [];
        a.sevenSatelliteAnimationItems = []
    },
    storeBarSatelliteItems: function(b) {
        var c = this,
            a;
        if (Sys.isDefined(b.BarSatelliteAnimMaster)) {
            a = b.BarSatelliteAnimMaster.items
        } else {
            a = [b.BarSatelliteAnim]
        }
        Sys.each(a, function(d) {
            Game.stage.view.addToRenderLoop(d);
            d.stop();
            c.barSatelliteAnimationItems.push({
                list: d,
                animating: false
            })
        })
    },
    storeSevenSatelliteItems: function(b) {
        var c = this,
            a;
        if (Sys.isDefined(b.SevenSatelliteAnimMaster)) {
            a = b.SevenSatelliteAnimMaster.items
        } else {
            a = [b.SevenSatelliteAnim]
        }
        Sys.each(a, function(d) {
            Game.stage.view.addToRenderLoop(d);
            d.stop();
            c.sevenSatelliteAnimationItems.push({
                list: d,
                animating: false
            })
        })
    },
    animateSatellites: function() {
        var b = this,
            a = b.model.readData("barSymConfigs"),
            c = b.model.readData("sevenSymConfigs");
        if (a.length > b.barSatelliteAnimationItems.length) {
            b.fireEvent("view:barSatelliteAnimations", a.length - b.barSatelliteAnimationItems.length)
        }
        if (c.length > b.sevenSatelliteAnimationItems.length) {
            b.fireEvent("view:sevenSatelliteAnimations", c.length - b.sevenSatelliteAnimationItems.length)
        }
    },
    animateSatellite: function(e) {
        var d = this,
            c, a, b;
        if (e.sym === "SYM3") {
            if (d.barSatelliteAnimationItems.length === 0) {
                d.animateSatellites()
            }
            c = d.getIdleAnimationList(d.barSatelliteAnimationItems, e);
            b = "barSatelliteAnimation"
        } else {
            if (e.sym === "SYM4") {
                if (d.sevenSatelliteAnimationItems.length === 0) {
                    d.animateSatellites()
                }
                c = d.getIdleAnimationList(d.sevenSatelliteAnimationItems, e);
                b = "barSatelliteAnimation"
            }
        }
        if (Sys.isDefined(c)) {
            a = {
                index: c.index,
                type: b
            };
            d.configureAnimationItem(c.list, e, a);
            c.list.play()
        }
    },
    getIdleAnimationList: function(g, b) {
        var h = this,
            c, f, k, d, a = Game.stage.model.getSymbolConfiguration(b.reelIndex, b.symbolIndex);
        if (!h.isAlreadyRunning(g, a)) {
            for (var e = 0; e < g.length; e++) {
                f = g[e].list;
                for (d = 0; d < f.items.length; d++) {
                    k = f.items[d];
                    if (!k.prop.running) {
                        c = g[e];
                        c.index = e;
                        break
                    }
                }
            }
        }
        return c
    },
    isAlreadyRunning: function(a, g) {
        var e = false,
            f, d, b;
        for (var c = 0; c < a.length; c++) {
            f = a[c].list;
            for (b = 0; b < f.items.length; b++) {
                d = f.items[b];
                if (d.prop.running && f.prop.top === g.top && f.prop.left === g.left) {
                    e = true;
                    break
                }
            }
        }
        return e
    },
    sevenAnimationCompleted: function() {},
    barAnimationCompleted: function() {},
    stop: function() {
        var a = this;
        Sys.each(a.barSatelliteAnimationItems, function(b) {
            b.list.stop()
        });
        Sys.each(a.sevenSatelliteAnimationItems, function(b) {
            b.list.stop()
        })
    }
};
SB.SatelliteAnimationView = Sys.extend(Core.View, SB.SatelliteAnimationView, "SB.SatelliteAnimationView");
Sys.ns("SB");
SB.SatelliteAnimationModel = {
    SYMBOLS_TO_ANIMATE: ["SYM3", "SYM4"],
    processServerResponse: function(d) {
        var b = this,
            a = [],
            c = [];
        if (!Sys.isDefined(d.wins) || !Sys.isDefined(d.wins.winSituations)) {
            b.storeData("hasWin", false)
        } else {
            b.storeData("hasWin", true)
        }
        Sys.each(d.reelInfo, function(f, e) {
            Sys.each(f.symbols, function(g, h) {
                if (g === "SYM3") {
                    a.push({
                        sym: g,
                        reelIndex: e,
                        symbolIndex: h
                    })
                } else {
                    if (g === "SYM4") {
                        c.push({
                            sym: g,
                            reelIndex: e,
                            symbolIndex: h
                        })
                    }
                }
            })
        });
        b.storeData("barSymConfigs", a);
        b.storeData("sevenSymConfigs", c)
    },
    animateSatellite: function() {
        var a = this;
        return !a.readData("hasWin") && (a.readData("barSymConfigs").length > 0 || a.readData("sevenSymConfigs").length > 0)
    }
};
SB.SatelliteAnimationModel = Sys.extend(Core.Model, SB.SatelliteAnimationModel, "SB.SatelliteAnimationModel");
Sys.ns("SB");
SB.BackgroundView = {
    TOP_DARKFADER_IMAGE: {
        image: "mainFaderTop",
        depth: Layering.Game.Slots.Background.fader,
        width: 1100,
        height: 51,
        left: 91,
        top: 85
    },
    BOTTOM_DARKFADER_IMAGE: {
        image: "mainFaderBottom",
        depth: Layering.Game.Slots.Background.fader,
        width: 1100,
        height: 83,
        left: 88,
        top: 540
    },
    TOP_FADER_IMAGE: {
        image: "topFader",
        width: 1100,
        height: 66,
        depth: Layering.Game.Slots.Background.fader,
        left: 91,
        top: 86
    },
    BOTTOM_FADER_IMAGE: {
        image: "bottomFader",
        width: 1101,
        height: 45,
        depth: Layering.Game.Slots.Background.fader,
        left: 91,
        top: 571
    },
    FADE_TIME: 1500,
    initAnimations: function() {
        SB.BackgroundView.superclass.initAnimations.apply(this, arguments);
        var b = this,
            a = new Animation.CanvasAnimationList({}),
            d = new Animation.CanvasAnimationItem(b.TOP_DARKFADER_IMAGE),
            c = new Animation.CanvasAnimationItem(b.BOTTOM_DARKFADER_IMAGE);
        a.add(d);
        a.add(c);
        b.faderList = a;
        b.topFaderItem = d;
        b.bottomFaderItem = c;
        Game.stage.view.addToRenderLoop(a)
    },
    changeFader: function(b) {
        var a = this;
        if (!Sys.isDefined(a.faderList)) {
            return
        }
        a.faderList.stop();
        if (b === "lightFader") {
            a.topFaderItem.prop = Sys.apply(a.topFaderItem.prop, a.TOP_FADER_IMAGE);
            a.bottomFaderItem.prop = Sys.apply(a.bottomFaderItem.prop, a.BOTTOM_FADER_IMAGE)
        } else {
            a.topFaderItem.prop = Sys.apply(a.topFaderItem.prop, a.TOP_DARKFADER_IMAGE);
            a.bottomFaderItem.prop = Sys.apply(a.bottomFaderItem.prop, a.BOTTOM_DARKFADER_IMAGE)
        }
        a.faderList.prop.delay = 10;
        a.faderList.restore();
        a.faderList.play()
    },
    hideFader: function() {
        this.faderList.stop()
    },
    showFader: function() {
        this.faderList.play()
    },
    enableGreyLayer: function() {},
    disableGreyLayer: function() {},
    refresh: function() {}
};
SB.BackgroundView = Sys.extend(Game.BackgroundView, SB.BackgroundView, "SB.BackgroundView");
Sys.ns("SB");
SB.BackgroundDesktopView = {
    MAIN_FADER: [{
        image: "mainFaderReel1",
        depth: Layering.Game.Slots.Background.fader,
        width: 179,
        height: 497,
        left: 161,
        top: 48
    }, {
        image: "mainFaderReel2",
        depth: Layering.Game.Slots.Background.fader,
        width: 190,
        height: 497,
        left: 348,
        top: 48
    }, {
        image: "mainFaderReel3",
        depth: Layering.Game.Slots.Background.fader,
        width: 190,
        height: 497,
        left: 546,
        top: 48
    }, {
        image: "mainFaderReel4",
        depth: Layering.Game.Slots.Background.fader,
        width: 190,
        height: 497,
        left: 744,
        top: 48
    }, {
        image: "mainFaderReel5",
        depth: Layering.Game.Slots.Background.fader,
        width: 180,
        height: 497,
        left: 942,
        top: 48
    }],
    WILD_FADER: [{
        image: "wildFaderReel1",
        depth: Layering.Game.Slots.Background.fader + 1,
        width: 179,
        height: 497,
        left: 161,
        top: 48
    }, {
        image: "wildFaderReel2",
        depth: Layering.Game.Slots.Background.fader + 1,
        width: 190,
        height: 497,
        left: 348,
        top: 48
    }, {
        image: "wildFaderReel3",
        depth: Layering.Game.Slots.Background.fader + 1,
        width: 190,
        height: 497,
        left: 546,
        top: 48
    }, {
        image: "wildFaderReel4",
        depth: Layering.Game.Slots.Background.fader + 1,
        width: 190,
        height: 497,
        left: 744,
        top: 48
    }, {
        image: "wildFaderReel5",
        depth: Layering.Game.Slots.Background.fader + 1,
        width: 180,
        height: 497,
        left: 942,
        top: 48
    }],
    DIVIDERS: {
        image: "dividers",
        depth: Layering.Game.Slots.Background.dividers,
        width: 1058,
        height: 538,
        left: 117,
        top: 49
    },
    FIREFLY_POS: ["LT", "LC", "LB", "RT", "RC", "RB"],
    TOP_FLYES: {
        topLeft: [],
        centerLeft: [],
        bottomLeft: [],
        topRight: [],
        centerRight: [],
        bottomRight: []
    },
    FLY_WIDTH: 64,
    FLY_HEIGHT: 64,
    FLY_IMAGE: "fireFly",
    CURRENT_FADER: undefined,
    setupEvents: function() {
        var a = this;
        SB.BackgroundDesktopView.superclass.setupEvents.apply(this, arguments);
        a.on({
            "view:fireflyComplete": a.configurefirefly
        })
    },
    initAnimations: function() {
        SB.BackgroundDesktopView.superclass.initAnimations.apply(this, arguments);
        var c = this,
            e = new Animation.CanvasAnimationItem(c.DIVIDERS),
            d = new Animation.CanvasAnimationList({}),
            a, b = new Animation.CanvasAnimationList({});
        for (a = 0; a < c.MAIN_FADER.length; a++) {
            d.add(new Animation.CanvasAnimationItem(c.MAIN_FADER[a]));
            b.add(new Animation.CanvasAnimationItem(c.WILD_FADER[a]))
        }
        c.mainFaderItemList = d;
        c.wildFaderItemList = b;
        c.greyLayer = c.createGreyLayer();
        c.list.add(c.greyLayer);
        c.list.add(e);
        c.list.add(c.betlineNumbers());
        c.greyLayer.stop();
        c.list.add(c.createNetEntProdLabelItem());
        Game.stage.view.addToRenderLoop(c.list);
        Game.stage.view.addToRenderLoop(d);
        Game.stage.view.addToRenderLoop(b);
        Game.stage.view.addToRenderLoop(c.createFireFly(3))
    },
    createNetEntProdLabelItem: function() {
        var b = "A NETENT PRODUCTION",
            a = "13px SBMyroidProRegular",
            c = Animation.utils.text.createText(b, a, 0, [{
                fillStyle: "#ffffff"
            }]);
        return new Animation.Item({
            left: 15,
            top: 8,
            width: c.width,
            height: c.height,
            depth: Layering.Game.Slots.Background.netEntProd,
            image: c
        })
    },
    changeFader: function(b) {
        var a = this;
        if (!Sys.isDefined(a.mainFaderItemList) && !Sys.isDefined(a.wildFaderItemList)) {
            return
        }
        if (a.CURRENT_FADER !== b) {
            if (b === "lightFader" && Sys.isDefined(a.CURRENT_FADER)) {
                a.mainFaderItemList.prop.operations = {
                    fade: [{
                        time: 0,
                        value: 1
                    }, {
                        time: 1200,
                        value: 1
                    }]
                };
                a.mainFaderItemList.restore();
                a.wildFaderItemList.prop.operations = {
                    fade: [{
                        time: 0,
                        value: 0
                    }, {
                        time: 1500,
                        value: 1
                    }, {
                        time: 10000,
                        value: 1,
                        gotTo: 1
                    }]
                };
                a.wildFaderItemList.restore()
            } else {
                if (b === "lightFader" && !Sys.isDefined(a.CURRENT_FADER)) {
                    a.mainFaderItemList.stop();
                    a.wildFaderItemList.prop.operations = {
                        fade: [{
                            time: 0,
                            value: 1
                        }, {
                            time: 1500,
                            value: 1,
                            goTo: 0
                        }]
                    };
                    a.wildFaderItemList.restore()
                } else {
                    a.wildFaderItemList.stop();
                    a.mainFaderItemList.prop.operations = {
                        fade: [{
                            time: 0,
                            value: 1
                        }, {
                            time: 10000,
                            value: 1,
                            gotTo: 0
                        }]
                    };
                    a.mainFaderItemList.restore()
                }
            }
        } else {
            if (b === "lightFader") {
                a.mainFaderItemList.prop.operations = {
                    fade: [{
                        time: 0,
                        value: 0
                    }, {
                        time: 100,
                        value: 0
                    }]
                };
                a.mainFaderItemList.restore();
                a.wildFaderItemList.prop.operations = {
                    fade: [{
                        time: 0,
                        value: 1
                    }, {
                        time: 10000,
                        value: 1,
                        gotTo: 0
                    }]
                };
                a.wildFaderItemList.restore()
            }
        }
        a.CURRENT_FADER = b
    },
    hideFader: function() {
        var a = this;
        a.wildFaderItemList.stop();
        a.mainFaderItemList.stop()
    },
    showFader: function() {
        var a = this;
        if (a.CURRENT_FADER === "lightFader") {
            a.wildFaderItemList.play();
            a.mainFaderItemList.stop()
        } else {
            a.wildFaderItemList.stop();
            a.mainFaderItemList.play()
        }
    },
    createFireFly: function(c) {
        var b = new Animation.CanvasAnimationList({}),
            a = this;
        a.createLeftTopFlies(b, c);
        a.createLeftCenterFlies(b, c);
        a.createLeftBottomFlies(b, c);
        a.createRightTopFlies(b, c);
        a.createRightCenterFlies(b, c);
        a.createRightBottomFlies(b, c);
        b.prop.globalCompositeOperation = "screen";
        return b
    },
    configurefirefly: function(a) {
        var c = this,
            b;
        switch (a.pos) {
            case c.FIREFLY_POS[0]:
                b = c.TOP_FLYES.topLeft[a.index];
                c.configTopLeftFly(b, a);
                break;
            case c.FIREFLY_POS[1]:
                b = c.TOP_FLYES.centerLeft[a.index];
                c.configCenterLeftFly(b, a);
                break;
            case c.FIREFLY_POS[2]:
                b = c.TOP_FLYES.bottomLeft[a.index];
                c.configBottomLeftFly(b, a);
                break;
            case c.FIREFLY_POS[3]:
                b = c.TOP_FLYES.topRight[a.index];
                c.configTopRightFly(b, a);
                break;
            case c.FIREFLY_POS[4]:
                b = c.TOP_FLYES.centerRight[a.index];
                c.configCenterRightFly(b, a);
                break;
            case c.FIREFLY_POS[5]:
                b = c.TOP_FLYES.bottomRight[a.index];
                c.configBottomRightFly(b, a);
                break;
            default:
                break
        }
    },
    configTopLeftFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
        c = Math.floor(Math.random() * (150 - 5 + 1)) + 5;
        d = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c + 50,
                left: d + g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c + 80,
                left: d + 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    configCenterLeftFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
        c = Math.floor(Math.random() * (350 - 200 + 1)) + 200;
        d = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c + 10,
                left: d + g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c + 20,
                left: d + 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    configBottomLeftFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
        c = Math.floor(Math.random() * (520 - 300 + 1)) + 300;
        d = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c - 100,
                left: d + g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c - 50,
                left: d + 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    configTopRightFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (8000 - 1000 + 1)) + 1000;
        c = Math.floor(Math.random() * (150 - 5 + 1)) + 5;
        d = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c + 50,
                left: d - g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c + 80,
                left: d - 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    configCenterRightFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
        c = Math.floor(Math.random() * (350 - 200 + 1)) + 200;
        d = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c + 10,
                left: d - g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c + 20,
                left: d - 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    configBottomRightFly: function(f, a) {
        var e = this,
            c = 0,
            d = 0,
            b, g;
        b = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
        c = Math.floor(Math.random() * (520 - 400 + 1)) + 400;
        d = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
        g = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
        f.prop.operations.translate = [{
            time: b,
            value: {
                top: c,
                left: d
            },
            support: {
                top: c - 100,
                left: d - g
            }
        }, {
            time: 15000 + b,
            value: {
                top: c - 50,
                left: d - 70
            }
        }];
        f.prop.operations.scale = e.configureFliesScaleOperation(1, b);
        f.prop.operations.fade = e.configureFliesFadeOperation(1, b, a);
        f.restore()
    },
    createLeftTopFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
            b = Math.floor(Math.random() * (150 - 5 + 1)) + 5;
            a = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b + 50,
                            left: a + j
                        }
                    }, {
                        time: 15000 + (e * f),
                        value: {
                            top: b + 80,
                            left: a + 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[0],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.topLeft[e] = d
        }
    },
    configureFliesScaleOperation: function(c, a) {
        var d = Number((Math.random() * (0.5 - 0.1 + 0.1) + 0.1).toFixed(1)),
            b;
        b = [{
            time: c * a,
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }, {
            time: 3000 + (c * a),
            value: {
                scaleX: d,
                scaleY: d
            }
        }, {
            time: 9000 + (c * a),
            value: {
                scaleX: d,
                scaleY: d
            }
        }, {
            time: 12000 + (c * a),
            value: {
                scaleX: 0.3,
                scaleY: 0.3
            }
        }, {
            time: 15000 + (c * a),
            value: {
                scaleX: 0,
                scaleY: 0
            }
        }];
        return b
    },
    configureFliesFadeOperation: function(c, b, a) {
        var e, d = this;
        e = [{
            time: c * b,
            value: 0
        }, {
            time: 3000 + (c * b),
            value: 0.8
        }, {
            time: 9000 + (c * b),
            value: 0.8
        }, {
            time: 12000 + (c * b),
            value: 0.8
        }, {
            time: 15000 + (c * b),
            value: 0,
            fireEvent: {
                event: "view:fireflyComplete",
                scope: d,
                argument: a
            }
        }];
        return e
    },
    createLeftCenterFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
            b = Math.floor(Math.random() * (350 - 200 + 1)) + 200;
            a = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b + 10,
                            left: a + j
                        }
                    }, {
                        time: 15000 + (e * f),
                        value: {
                            top: b + 20,
                            left: a + 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[1],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.centerLeft[e] = d
        }
    },
    createLeftBottomFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
            b = Math.floor(Math.random() * (520 - 300 + 1)) + 300;
            a = Math.floor(Math.random() * (95 - 5 + 1)) + 5;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b - 100,
                            left: a + j
                        }
                    }, {
                        time: 15000 + (e * f),
                        value: {
                            top: b - 50,
                            left: a + 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[2],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.bottomLeft[e] = d
        }
    },
    createRightTopFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (8000 - 1000 + 1)) + 1000;
            b = Math.floor(Math.random() * (200 - 5 + 1)) + 5;
            a = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b + 50,
                            left: a - j
                        }
                    }, {
                        time: 15000 + (e * f),
                        value: {
                            top: b + 80,
                            left: a - 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[3],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.topRight[e] = d
        }
    },
    createRightCenterFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
            b = Math.floor(Math.random() * (350 - 200 + 1)) + 200;
            a = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b + 10,
                            left: a - j
                        }
                    }, {
                        time: 15000 + (e * f),
                        value: {
                            top: b + 20,
                            left: a - 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[4],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.centerRight[e] = d
        }
    },
    createRightBottomFlies: function(h, c) {
        var g = this,
            e = 0,
            b = 0,
            a = 0,
            d, f, j;
        for (; e < c; e++) {
            f = Math.floor(Math.random() * (10000 - 2000 + 1)) + 2000;
            b = Math.floor(Math.random() * (520 - 400 + 1)) + 400;
            a = Math.floor(Math.random() * (1250 - 1160 + 1)) + 1160;
            j = Math.floor(Math.random() * (170 - 90 + 1)) + 90;
            d = new Animation.CanvasAnimationItem({
                depth: Layering.Game.Slots.Background.movingFireFly,
                width: g.FLY_WIDTH,
                height: g.FLY_HEIGHT,
                image: g.FLY_IMAGE,
                pivot: {
                    x: 0,
                    y: 0
                },
                operations: {
                    translate: [{
                        time: e * f,
                        value: {
                            top: b,
                            left: a
                        },
                        support: {
                            top: b - 100,
                            left: a - j
                        }
                    }, {
                        time: 20000 + (e * f),
                        value: {
                            top: b - 50,
                            left: a - 70
                        }
                    }],
                    scale: g.configureFliesScaleOperation(e, f),
                    fade: g.configureFliesFadeOperation(e, f, {
                        pos: g.FIREFLY_POS[5],
                        index: e
                    })
                }
            });
            h.add(d);
            g.TOP_FLYES.bottomRight[e] = d
        }
    },
    createGreyLayer: function() {
        var b = document.createElement("canvas"),
            a;
        b.width = 100;
        b.height = 100;
        a = b.getContext("2d");
        a.save();
        a.fillStyle = "rgba(0,0,0,0.7)";
        a.fillRect(0, 0, 100, 100);
        a.restore();
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Slots.Background.greyLayer,
            image: b
        })
    },
    enableGreyLayer: function() {
        var a = this;
        a.list.play(a.greyLayer)
    },
    disableGreyLayer: function() {
        var a = this;
        a.greyLayer.stop()
    },
    hideFaderOnReel: function(b) {
        var a = this;
        a.wildFaderItemList.items[b].stop();
        a.mainFaderItemList.items[b].stop()
    },
    betlineNumbers: function() {
        var a = new Animation.CanvasAnimationItem({
            width: 1203,
            height: 462,
            image: "betline_numbers",
            top: 75,
            left: 39,
            depth: Layering.Game.Slots.Background.betlineNumbers
        });
        return a
    },
    refresh: function() {}
};
SB.BackgroundDesktopView = Sys.extend(Game.BackgroundView, SB.BackgroundDesktopView, "SB.BackgroundDesktopView");
Sys.ns("SB");
SB.BackgroundController = {
    WINDOWS_TO_GREYOUT: ["paytable", "gameRules"],
    setupEvents: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.on({
                "request:background.changeFader": a.view.changeFader.bind(a.view),
                "request:background.hideFader": a.view.hideFader.bind(a.view),
                "request:settingsWindow.openChild": a.checkEnableGreyArea,
                "request:settingsWindow.closeChild": a.checkDisableGreyArea,
                "request:settingsWindow.close": a.disableGreyAreaAndButton,
                "notify:responseParser.responseParsed": a.onServerResponse,
                "notify:animationManager.allImagesLoaded": a.initAnimations,
                "notify:spin.reelStoppedSpinning": a.hideFaderOnReel,
                "notify:stateHandler.enteringBigWinState": a.view.hideFader.bind(a.view),
                "notify:stateHandler.leavingBigWinState": a.view.showFader.bind(a.view),
                "notify:settingsWindowCloseButton.click": a.disableGreyAreaAndButton,
                "notify:stateHandler.enteringIdleState": a.view.hideFader.bind(a.view),
                "notify:stateHandler.enteringSpinningState": a.startReelSpinning
            })
        } else {
            a.on({
                "request:background.changeFader": a.view.changeFader.bind(a.view),
                "request:background.hideFader": a.view.hideFader.bind(a.view),
                "notify:animationManager.allImagesLoaded": a.initAnimations,
                "notify:responseParser.responseParsed": a.onServerResponse,
                "notify:stateHandler.enteringBigWinState": a.view.hideFader.bind(a.view),
                "notify:stateHandler.leavingBigWinState": a.view.showFader.bind(a.view)
            })
        }
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    isWindowToGreyout: function(a) {
        return this.WINDOWS_TO_GREYOUT.indexOf(a) > -1 ? true : false
    },
    checkEnableGreyArea: function(a) {
        var b = this;
        if (Platform.isDesktopDevice && b.isWindowToGreyout(a)) {
            b.enableGreyArea()
        }
    },
    checkDisableGreyArea: function(a) {
        var b = this;
        if (Platform.isDesktopDevice && b.isWindowToGreyout(a)) {
            b.disableGreyArea()
        }
    },
    enableGreyArea: function() {
        var a = this;
        a.fireEvent("request:disableKeypad", this.MODULE_NAME);
        a.view.enableGreyLayer()
    },
    disableGreyArea: function() {
        var a = this;
        a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
        a.view.disableGreyLayer()
    },
    disableGreyAreaAndButton: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.disableGreyArea()
        }
    },
    hideFaderOnReel: function(b) {
        var a = this;
        a.view.hideFaderOnReel(b)
    },
    startReelSpinning: function() {
        var a = this;
        if (a.model.readData("nextaction") === "respin") {
            a.view.changeFader("lightFader")
        } else {
            a.view.changeFader("darkFader")
        }
        a.view.showFader()
    }
};
SB.BackgroundController = Sys.extend(Core.Controller, SB.BackgroundController, "SB.BackgroundController");
Sys.ns("SB");
SB.BackgroundModel = {
    processServerResponse: function(b) {
        var a = this;
        a.storeData("nextaction", b.nextaction)
    }
};
SB.BackgroundModel = Sys.extend(Core.Model, SB.BackgroundModel, "SB.BackgroundModel");
Sys.ns("SB");
SB.FeatureSplash = {
    getMixinDependencies: function() {
        return [{
            userInput: {
                inputEvents: ["start", "end", "cancel", "move", "hover", "scroll"]
            }
        }]
    },
    getStateChanges: function() {
        return {
            featureSplash: {
                state: {
                    name: "FeatureSplash",
                    execute: function() {},
                    waitEvents: {
                        "notify:featureSplash.closed": false
                    }
                }
            },
            beforeLoaderClose: {
                queue: [function(a) {
                    a.stateHandler.pushState(a.states.featureSplash)
                }],
                waitEvents: []
            }
        }
    },
    getDefaultMVCClasses: function() {
        return {
            model: SB.FeatureSplashModel,
            controller: SB.FeatureSplashController,
            view: SB.FeatureSplashView
        }
    }
};
SB.FeatureSplash = Sys.extend(Core.Module, SB.FeatureSplash, "SB.FeatureSplash");
Sys.ns("SB");
SB.FeatureSplashController = {
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:animationManager.allImagesLoaded": a.initAnimations,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.start,
            "request:featureSplash.close": a.close,
            "view:closed": a.onClosed
        })
    },
    initAnimations: function() {
        this.view.initAnimations()
    },
    onServerResponse: function(a) {
        this.model.processServerResponse(a)
    },
    onFeatureSplashState: function() {
        var a = this;
        if (a.model.readData("animationRequested") && a.model.readData("showNextTime")) {
            a.view.startAllAnimations();
            a.show()
        } else {
            a.close()
        }
    },
    start: function() {
        var a = this;
        if (a.model.readData("animationRequested") && a.model.readData("showNextTime")) {
            a.model.storeData("currentSlideIndex", -1);
            a.startListeningToUserInput();
            a.onFeatureSplashState()
        } else {
            a.onClosed()
        }
    },
    show: function() {
        var a = this;
        a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
        a.fireEvent("request:spinButton.hide", a.MODULE_NAME);
        a.fireEvent("notify:featureSplash.showing");
        a.featureScreenTimer = setTimeout(function() {
            a.close()
        }, 40000)
    },
    close: function() {
        var a = this;
        a.view.close()
    },
    onClosed: function() {
        var a = this;
        clearTimeout(a.featureScreenTimer);
        a.stopListeningToUserInput();
        a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
        a.fireEvent("request:spinButton.show", a.MODULE_NAME);
        a.fireEvent("notify:featureSplash.closed")
    },
    onUserInputEnd: function(c) {
        var b = this,
            a = b.view.inputTargetsButton(c);
        if (a === "checkBox") {
            b.updateShowNextTime()
        }
        if (a === "continueButton") {
            b.view.close()
        }
    },
    onUserInputStart: function(c) {
        var b = this,
            a = b.view.inputTargetsButton(c);
        if (a === "continueButton") {
            b.view.updateContinueButton("click")
        }
    },
    onUserInputHover: function(c) {
        var b = this,
            a = b.view.inputTargetsButton(c);
        if (a === "checkBox" || a === "continueButton") {
            if (a === "checkBox") {
                document.body.style.cursor = "pointer";
                b.view.updateCheckboxFirefly("hover")
            }
            if (a === "continueButton") {
                b.view.updateContinueButton("hover")
            }
        } else {
            document.body.style.cursor = "auto";
            b.view.updateContinueButton("basic");
            b.view.updateCheckboxFirefly("hoverout")
        }
    },
    updateShowNextTime: function() {
        var a = this,
            b = !a.model.readData("showNextTime");
        a.model.storeData("showNextTime", b);
        a.view.updateCheckBox(b);
        a.fireEvent("request:settingsManager.storeData", "showFeatureSplash", b, true)
    },
    onLeavingIdleState: function() {
        this.close()
    }
};
SB.FeatureSplashController = Sys.extend(Core.Controller, SB.FeatureSplashController, "SB.FeatureSplashController");
Sys.ns("SB");
SB.FeatureSplashModel = {
    processServerResponse: function(b) {
        var a = this;
        if (b.gamestate.current === "basic" && b.clientaction === "init" && b.restore === false) {
            a.storeData("animationRequested", true)
        } else {
            a.storeData("animationRequested", false)
        }
        a.storeData("restore", b.restore)
    },
    setupData: function() {
        var a = this,
            b = !(Services.localStorageManager.hasData("showFeatureSplash") && Services.localStorageManager.readData("showFeatureSplash") === "false");
        a.storeData("showNextTime", b);
        a.storeData("autoClose", true)
    }
};
SB.FeatureSplashModel = Sys.extend(Core.Model, SB.FeatureSplashModel, "SB.FeatureSplashModel");
Sys.ns("SB");
SB.FeatureSplashView = {
    BACKGROUND_IMAGE: "splashScreenBG",
    STARBURST_TM_WILD: {
        left: 416,
        top: 304,
        image: "startburstTmWild",
        width: 390,
        height: 71
    },
    WIN_BOTH_WAYS: {
        left: 863,
        top: 302,
        textOperation: [{
            shadowColor: "#fd9435",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 15
        }, {
            shadowColor: "#fd9435",
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 18
        }, {
            fillStyle: "#fffab3"
        }],
        fontSize: "46",
        fontFamily: "BauhausRegular"
    },
    CHECKBOX: {
        width: 30,
        height: 30,
        left: 1217,
        top: 646,
        offsetx: 10
    },
    CHECKBOX_FIREFLY: {
        width: 32,
        height: 32
    },
    DONT_SHOW: {
        textOperation: [{
            textAlign: "medium",
            fillStyle: "#ffffff"
        }],
        font: "16px Arial"
    },
    CONTINUE: {
        left: 635,
        top: 642,
        fontSize: "58",
        fontFamily: "BauhausRegular",
        textOperation: {
            basic: [{
                fillStyle: "#fffab2"
            }, {
                strokeStyle: "#ffd01f",
                lineWidth: 1,
                drawType: "stroke"
            }, {
                shadowColor: "#be571f",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 30
            }, {
                shadowColor: "#be571f",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 30
            }],
            hover: [{
                fillStyle: "#fcffce"
            }, {
                strokeStyle: "#ffd01f",
                lineWidth: 1,
                drawType: "stroke"
            }, {
                shadowColor: "#c26249",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 20
            }, {
                shadowColor: "#c26249",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 20
            }],
            click: [{
                shadowColor: "#fd9435",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 20
            }, {
                shadowColor: "#fd9435",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 20
            }, {
                shadowColor: "#c83813",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 13
            }, {
                strokeStyle: "#ffd01f",
                lineWidth: 1,
                drawType: "stroke"
            }, {
                fillStyle: "#fefef1"
            }]
        }
    },
    CONTINUE_BOX: {
        left: 464,
        top: 603,
        width: 349,
        height: 75
    },
    IMAGE_WIDTH: 67,
    IMAGE_HEIGHT: 67,
    WILD_SYMBOL: {
        left: 310,
        top: 340
    },
    WILD_CONFIGURATION: {
        purpleTwinkle: {
            left: 81,
            top: 13
        },
        blueTwinkle: {
            left: 31,
            top: 48
        },
        orangeTwinkle: {
            left: 112,
            top: 82
        }
    },
    configureWildTwinkleAnimation: function(d, b) {
        var i = this,
            e = i.WILD_CONFIGURATION[b.twinkleType],
            c, a, h = 1200,
            g = 2500,
            f = 3900;
        if (b.twinkleType === "purpleTwinkle") {
            c = 0.6;
            a = 1;
            h = 1200;
            delay = 0
        } else {
            if (b.twinkleType === "blueTwinkle") {
                c = 0.4;
                a = 0.8;
                h = 1000;
                delay = 500
            } else {
                if (b.twinkleType === "orangeTwinkle") {
                    c = 0.4;
                    a = 0.8;
                    h = 700;
                    delay = 1000
                }
            }
        }
        d.prop = Sys.apply(d.prop, {
            operations: {
                fade: [{
                    value: 1,
                    time: delay
                }, {
                    value: 1,
                    time: h + delay
                }, {
                    value: 1,
                    time: g + delay
                }, {
                    value: 1,
                    time: f + delay,
                    goTo: 0
                }],
                scale: [{
                    time: delay,
                    value: {
                        scaleX: c,
                        scaleY: c
                    }
                }, {
                    time: h + delay,
                    value: {
                        scaleX: a,
                        scaleY: a
                    }
                }, {
                    time: g + delay,
                    value: {
                        scaleX: c,
                        scaleY: c
                    }
                }, {
                    time: f + delay,
                    value: {
                        scaleX: c,
                        scaleY: c
                    }
                }, {
                    time: f + h + delay,
                    value: {
                        scaleX: a + 0.05,
                        scaleY: a + 0.05
                    }
                }, {
                    time: f + g + delay,
                    value: {
                        scaleX: c + 0.05,
                        scaleY: c + 0.05
                    }
                }, {
                    time: f + f + delay,
                    value: {
                        scaleX: c + 0.05,
                        scaleY: c + 0.05
                    },
                    goTo: 0
                }]
            },
            top: i.WILD_SYMBOL.top + e.top,
            left: i.WILD_SYMBOL.left + e.left
        })
    },
    createWildTwinkleAnimationItems: function() {
        var b = this,
            a = {};
        a.purpleTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.IntroOutro.text,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_purple_twinkle"
        });
        a.blueTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.IntroOutro.text,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_blue_twinkle"
        });
        a.orangeTwinkle = new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.IntroOutro.text,
            width: b.IMAGE_WIDTH,
            height: b.IMAGE_HEIGHT,
            image: "wild_orange_twinkle"
        });
        return a
    },
    animateWildTwinkles: function() {
        var b = this,
            a = {};
        b.wildTwinkleAnimationItems = b.createWildTwinkleAnimationItems();
        Sys.iterate(b.wildTwinkleAnimationItems, function(c, d) {
            a.twinkleType = c;
            b.configureWildTwinkleAnimation(d, a);
            b.wildAnimationList.add(d)
        });
        b.wildAnimationList.play()
    },
    initAnimations: function() {
        var b = this,
            c = Resources.readData("language").lang,
            a = ["bg", "el", "iw", "ru", "tr", "ro", "sk", "et", "pl", "hr", "cs"];
        if (a.indexOf(c) > -1) {
            b.CONTINUE.fontFamily = "SBMyroidProBold";
            b.WIN_BOTH_WAYS.fontFamily = "SBMyroidProBold"
        }
        if (b.model.readData("restore") || !b.model.readData("showNextTime")) {
            return
        }
        b.inMemCanvas = document.createElement("canvas");
        b.inMemContext = b.inMemCanvas.getContext("2d");
        b.createTextStrings();
        b.animationList = new Animation.CanvasAnimationList({});
        b.animationList.add(b.createBackgroundItem());
        b.wildAnimationList = new Animation.CanvasAnimationList();
        b.wildText = b.createStarburstTmWild();
        b.winBothWays = b.createWinBothWays(b.strWinBothWays, b.WIN_BOTH_WAYS);
        b.continueButton = b.createContinueButton();
        b.checkboxMsg = b.createDontShowNextTimeText(b.strCheckBox, b.DONT_SHOW);
        b.continueBackground = b.createContinueBackground();
        b.checkboxFirefly = b.createCheckBoxFireFly();
        b.animationList.addItems([b.wildText, b.winBothWays, b.continueButton, b.continueBackground, b.checkboxFirefly, b.checkboxMsg]);
        Game.stage.view.addToRenderLoop(b.animationList);
        Game.stage.view.addToRenderLoop(b.wildAnimationList);
        b.animationList.stop();
        b.wildAnimationList.stop()
    },
    inputTargetsButton: function(d) {
        var a = this,
            c = document.getElementById("canvasAnimationManager"),
            b = Sys.UserInputUtils.getCoordinatesRelativeToElement(d, c);
        if (Sys.UserInputUtils.isUserInputInSegment(b, a.model.readData("checkboxDimension"))) {
            return "checkBox"
        }
        if (Sys.UserInputUtils.isUserInputInSegment(b, a.model.readData("continueDimension"))) {
            return "continueButton"
        }
        return false
    },
    startAllAnimations: function() {
        var a = this;
        a.animationList.play();
        a.animateWildTwinkles();
        a.continueBackground.stop()
    },
    close: function() {
        var a = this;
        if (a.animationList) {
            a.animationList.stop();
            a.wildAnimationList.stop();
            a.fireEvent("view:closed")
        }
    },
    updateCheckBox: function(b) {
        var a = this;
        if (b === false) {
            a.checkboxFirefly.prop.image = "checkboxClickLight"
        } else {
            a.checkboxFirefly.prop.image = "checkboxHover"
        }
    },
    createBackgroundItem: function() {
        var a = this,
            b = Layering.Game.Slots.IntroOutro.background;
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            canvasIndex: 1,
            depth: b,
            image: a.BACKGROUND_IMAGE
        })
    },
    createDontShowNextTimeText: function(e, a) {
        var c = this,
            d = Animation.utils.text.createText(e, a.font, 0, a.textOperation);
        var b = c.CHECKBOX;
        return new Animation.CanvasAnimationItem({
            left: b.left - d.width - b.offsetx,
            top: b.top + d.height / 2 - 2,
            width: d.width,
            height: d.height,
            depth: Layering.Game.Slots.IntroOutro.text,
            image: d
        })
    },
    createCheckBoxFireFly: function() {
        var b = this;
        var a = b.CHECKBOX;
        b.model.storeData("checkboxDimension", [{
            x: a.left,
            y: a.top,
            width: a.width,
            height: a.height
        }]);
        return new Animation.CanvasAnimationItem({
            left: a.left + a.width / 2 - b.CHECKBOX_FIREFLY.width / 2,
            top: a.top + a.height / 2 - b.CHECKBOX_FIREFLY.height / 2,
            width: b.CHECKBOX_FIREFLY.width,
            height: b.CHECKBOX_FIREFLY.height,
            depth: Layering.Game.Slots.IntroOutro.text,
            image: "checkboxBlank"
        })
    },
    createTextStrings: function() {
        var a = this;
        a.strStartGame = Services.languageManager.getText(Language.Keys.continue_uc);
        a.strCheckBox = Services.languageManager.getText("dontShowNextTime");
        a.strWinBothWays = Services.languageManager.getText("winBothWaysRev")
    },
    createContinueButton: function() {
        var c = this,
            d, b, a;
        a = Platform.isIEBrowser ? 9 : 0;
        d = c.strStartGame;
        b = c.CONTINUE;
        c.continueBasic = Animation.utils.text.drawText(d, b.fontSize, b.fontFamily, 15, 349, b.textOperation.basic);
        c.continueHover = Animation.utils.text.drawText(d, b.fontSize, b.fontFamily, 15, 349, b.textOperation.hover);
        c.continueClick = Animation.utils.text.drawText(d, b.fontSize, b.fontFamily, 15, 349, b.textOperation.click);
        c.model.storeData("continueDimension", [{
            x: c.CONTINUE_BOX.left,
            y: c.CONTINUE_BOX.top,
            width: c.CONTINUE_BOX.width,
            height: c.CONTINUE_BOX.height
        }]);
        return new Animation.CanvasAnimationItem({
            left: b.left - c.continueBasic.width / 2,
            top: b.top - c.continueBasic.height / 2 + a,
            width: c.continueBasic.width,
            height: c.continueBasic.height,
            depth: Layering.Game.Slots.IntroOutro.text,
            image: c.continueBasic
        })
    },
    createContinueBackground: function() {
        var a = this;
        return new Animation.CanvasAnimationItem({
            left: a.CONTINUE_BOX.left,
            top: a.CONTINUE_BOX.top,
            width: a.CONTINUE_BOX.width,
            height: a.CONTINUE_BOX.height,
            depth: Layering.Game.Slots.IntroOutro.overlay,
            image: "continueOverlay"
        })
    },
    updateContinueButton: function(b) {
        var a = this;
        switch (b) {
            case "hover":
                a.continueButton.prop.image = a.continueHover;
                break;
            case "click":
                document.body.style.cursor = "auto";
                a.continueButton.prop.image = a.continueClick;
                a.continueBackground.play();
                break;
            case "basic":
                a.continueButton.prop.image = a.continueBasic;
                break;
            default:
                break
        }
    },
    updateCheckboxFirefly: function(b) {
        var a = this,
            c = a.model.readData("showNextTime");
        switch (b) {
            case "hover":
                if (c === true && a.checkboxFirefly.prop.image !== "checkboxHover") {
                    a.checkboxFirefly.prop.image = "checkboxHover"
                } else {
                    if (c === false && a.checkboxFirefly.prop.image === "checkboxClick") {
                        a.checkboxFirefly.prop.image = "checkboxClickLight"
                    }
                }
                break;
            case "hoverout":
                if (c === true && a.checkboxFirefly.prop.image !== "checkboxBlank") {
                    a.checkboxFirefly.prop.image = "checkboxBlank"
                } else {
                    if (c === false && a.checkboxFirefly.prop.image === "checkboxClickLight") {
                        a.checkboxFirefly.prop.image = "checkboxClick"
                    }
                }
                break;
            default:
                break
        }
    },
    createWinBothWays: function(d, a) {
        var c = Animation.utils.text.drawText(d, a.fontSize, a.fontFamily, 15, 500, a.textOperation),
            b;
        if (Environment.browser === "firefox") {
            b = a.top - c.height / 2 + 2
        } else {
            if (Platform.isIEBrowser) {
                b = a.top - c.height / 2 + 8
            } else {
                b = a.top - c.height / 2
            }
        }
        return new Animation.CanvasAnimationItem({
            left: a.left - c.width / 2,
            top: b,
            width: c.width,
            height: c.height,
            depth: Layering.Game.Slots.IntroOutro.text,
            image: c
        })
    },
    createStarburstTmWild: function() {
        var b = this,
            a = b.STARBURST_TM_WILD;
        return new Animation.CanvasAnimationItem({
            left: a.left - a.width / 2,
            top: a.top - a.height / 2,
            width: a.width,
            height: a.height,
            depth: Layering.Game.Slots.IntroOutro.text,
            image: a.image
        })
    }
};
SB.FeatureSplashView = Sys.extend(Core.View, SB.FeatureSplashView, "SB.FeatureSplashView");
Sys.ns("SB");
SB.GameRulesDesktopView = {
    SETTINGS_WINDOW_CSS: "interface-settingsWindow_base interface-gameSettings-gamerule-background-uri interface-settingsWindow_landscape_desktop",
    SCROLL_BAR_CSS: "interface-settingsSection_scrollBar sb-settingsSection-scrollBar",
    BASE_CSS: "tab interface-gameRules_base sb-gameRules-base",
    WRAPPER_CSS: "tab interface-settingsWindow_content sb-settingsWindow_content",
    RULES_WRAPPER_CSS: "interface-gameRules_rulesWrapper sb-gameRules_rulesWrapper",
    setUpContent: function() {
        this.model.storeData("activetArea", [{
            x: 130,
            y: 57,
            width: 1022,
            height: 485
        }, {
            x: 0,
            y: 695,
            width: 1280,
            height: 200
        }, {
            x: 142,
            y: 724,
            width: 10,
            height: 17
        }, {
            x: 513,
            y: 0,
            width: 280,
            height: 60
        }, {
            x: 37,
            y: 624,
            width: 52,
            height: 52
        }]);
        SB.GameRulesDesktopView.superclass.setUpContent.apply(this, arguments)
    },
    show: function() {
        document.getElementById("settingsWindow").className = this.SETTINGS_WINDOW_CSS;
        this.containerWrapper.el.style.display = "block";
        Interface.GameRulesDesktopView.superclass.show.apply(this, arguments)
    },
    onGreyAreaClick: function(c) {
        var b = document.getElementById("canvasAnimationManager"),
            a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, b);
        return Sys.UserInputUtils.isUserInputInSegment(a, this.model.readData("activetArea"))
    },
    onDisableBasicGamePanel: function() {
        this.disable("disableBasicGamePanel")
    },
    onEnableBasicGamePanel: function() {
        this.enable("disableBasicGamePanel")
    }
};
SB.GameRulesDesktopView = Sys.extend(Interface.GameRulesDesktopView, SB.GameRulesDesktopView, "SB.GameRulesDesktopView");
Sys.ns("SB");
SB.GameRulesController = {
    onDisableBasicGamePanel: function(b) {
        var a = this;
        if (b === "background") {} else {
            if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
                a.view.onDisableBasicGamePanel(b)
            }
        }
    },
    onUserInputStart: function(a) {
        if (Platform.isDesktopDevice && !this.checkSettingsMenu(a) && !this.view.onGreyAreaClick(a)) {
            this.onHideRequest()
        }
        this.view.onUserInputStart.apply(this.view, arguments)
    },
    onShowRequest: function(a) {
        var b = this;
        Interface.GameRulesController.superclass.onShowRequest.apply(b, arguments);
        if (Platform.isDesktopDevice) {
            b.fireEvent("request:logo.hide")
        }
    },
    onHideRequest: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.fireEvent("request:logo.show")
        }
        Interface.GameRulesController.superclass.onHideRequest.apply(a, arguments)
    },
    checkSettingsMenu: function(d) {
        var c = Sys.UserInputUtils.getDOMElementFromCoordinates(d);
        var a = document.getElementById("autoplaySettings");
        var b = document.getElementById("gameSettings");
        return Sys.UserInputUtils.isParentAndChildElements(a, c) || Sys.UserInputUtils.isParentAndChildElements(b, c)
    }
};
SB.GameRulesController = Sys.extend(Interface.GameRulesController, SB.GameRulesController, "SB.GameRulesController");
Sys.ns("SB");
SB.DimmedSymbolsModel = {
    processServerResponse: function(h) {
        var e = h.reelInfo,
            d = Resources.readData("config").reel,
            i = d.symbolRows,
            a = d.symbolCols,
            c, b, j, g = [],
            f;
        if (Sys.isDefined(e) && Sys.isDefined(h.wins) && Sys.isArray(h.wins.winSituations)) {
            j = Sys.utils.init2dMatrix(a, i, false);
            Sys.each(h.wins.winSituations, function(k) {
                Sys.each(k.positions, function(l) {
                    j[l.reelIndex][l.symbolIndex] = true
                })
            });
            for (c = 0; c < a; c++) {
                for (b = 0; b < e[c].symbols.length; b++) {
                    if (!j[c][b]) {
                        if (e[c].overlaySymbols[b]) {
                            f = e[c].overlaySymbols[b]
                        } else {
                            f = e[c].symbols[b]
                        }
                        g.push({
                            x: c,
                            y: b,
                            symbol: f
                        })
                    }
                }
            }
        }
        this.storeData("symbolsToDim", g)
    }
};
SB.DimmedSymbolsModel = Sys.extend(Core.Model, SB.DimmedSymbolsModel, "SB.DimmedSymbolsModel");
Sys.ns("SB");
SB.DimmedSymbolsController = {
    setupEvents: function() {
        var a = this;
        SB.DimmedSymbolsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:dimmedSymbols.unDimNoWinSymbols": a.unDimNoWinSymbols
        })
    },
    unDimNoWinSymbols: function(a) {
        if (this.model.isState("animateSymbols")) {
            this.model.setState("idle");
            this.view.unDimNoWinSymbols(a)
        }
    }
};
SB.DimmedSymbolsController = Sys.extend(Game.Slots.DimmedSymbolsController, SB.DimmedSymbolsController, "SB.DimmedSymbolsController");
Sys.ns("SB");
SB.DimmedSymbolsDesktopView = {
    unDimNoWinSymbols: function(a) {
        var b = this;
        b.undimSymbols(0, a)
    },
    undimSymbols: function(h, i) {
        var g = this,
            d = [{}, {}, {}, {}, {}],
            c = g.model.readData("unDimSymbolConfig"),
            e = Object.keys(c),
            a = e.length,
            f = e[h],
            b;
        if (i === false) {
            b = 0
        } else {
            b = 80
        }
        d[f] = c[f];
        g.fireEvent("view:setReelSymbols", d);
        h++;
        if (h < a) {
            setTimeout(function() {
                g.undimSymbols(h, i)
            }, b)
        }
    }
};
SB.DimmedSymbolsDesktopView = Sys.extend(Game.Slots.DimmedSymbolsView, SB.DimmedSymbolsDesktopView, "SB.DimmedSymbolsDesktopView");
Sys.ns("SB");
SB.Spin = {
    constructor: function() {
        SB.Spin.superclass.constructor.apply(this, arguments)
    },
    getStateChanges: function() {
        var b = SB.Spin.superclass.getStateChanges.apply(this, arguments);
        var a = this.model;
        b.handleServerError = {
            state: {
                name: "HandleServerError",
                execute: function() {},
                waitEvents: {
                    "notify:spin:serverErrorHandled": false
                }
            }
        };
        b.validateSpin = {
            state: {
                name: "ValidateSpin",
                execute: function(c) {
                    if (a.readData("isValidServerResponse")) {
                        c.stateHandler.pushState(c.states.stopped);
                        c.stateHandler.pushState(c.states.stopping);
                        c.stateHandler.pushState(c.states.beforeStopping)
                    } else {
                        c.stateHandler.pushState(c.states.idle);
                        c.stateHandler.pushState(c.states.handleServerError)
                    }
                },
                waitEvents: {
                    "notify:spin:serverResponseReceived": false
                }
            }
        };
        return b
    }
};
SB.Spin = Sys.extend(Core.Slots.Spin, SB.Spin, "SB.Spin");
Sys.ns("SB");
SB.SpinController = {
    setupEvents: function() {
        var a = this;
        SB.SpinController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:spin.setReelsVisibility": a.setReelsVisibility,
            "notify:stateHandler.enteringIdleState": a.restoreReelVisibility,
            "notify:stateHandler.enteringHandleServerErrorState": a.onHandleServerError,
            "notify:dialogWindow.closeForMaxBetAndPlayerLimit": a.abortReelSpinning
        })
    },
    abortReelSpinning: function() {
        var a = this;
        if (Sys.isDefined(a.model.readData("currentReelset"))) {
            a.fireEvent("request:reelStopAnimations.abort");
            a.abortSpinWithoutReelHide()
        }
    },
    abortSpinWithoutReelHide: function() {
        var a = this;
        a.model.setSpinType("quickStop");
        a.model.storeData("hasFinishedStartSequence", true);
        a.stopSpin(a.model.getNoWinOutcome());
        a.fireEvent("notify:spin.spinAborted");
        a.aborted = true
    },
    errorResponse: function(b) {
        var c = this,
            d = Sys.utils.getErrorCode(b),
            a = [11, 13, 14];
        c.model.storeData("isValidServerResponse", false);
        if (Sys.utils.httpRequestIsOK(b) && c.model.readData("currentReelset") === "basic") {
            c.fireEvent("notify:spin:serverResponseReceived")
        }
        if (Sys.isDefined(c.model.readData("currentReelset")) && (a.indexOf(d) === -1)) {
            c.fireEvent("request:reelStopAnimations.abort");
            c.abortSpin()
        }
    },
    onHandleServerError: function() {
        if (!this.aborted) {
            this.moveOutofHandleErrorState()
        }
    },
    activateDefaultOutcome: function() {
        SB.SpinController.superclass.activateDefaultOutcome.apply(this, arguments);
        if (this.aborted) {
            this.moveOutofHandleErrorState()
        }
    },
    setReelsVisibility: function(b) {
        var c = this;
        var a = c.model.readData("reelsetHidden") || [];
        Sys.each(b.reels, function(d) {
            if (!Sys.contains(a, d)) {
                a.push(d)
            }
        });
        c.model.storeData("reelsetHidden", a);
        c.view.setReelVisibility(b)
    },
    restoreReelVisibility: function() {
        var a = this;
        a.view.setReelVisibility({
            reels: a.model.readData("reelsetHidden"),
            opacity: 1,
            time: 0
        });
        a.model.storeData("reelsetHidden", [])
    },
    activateReelset: function(c, b) {
        var a = this,
            d = a.model.readData("reelsetHidden");
        SB.SpinController.superclass.activateReelset.apply(a, arguments);
        if (Sys.isDefined(d) && d.length > 0) {
            a.view.setReelVisibility({
                reels: d,
                opacity: 0,
                time: 0
            })
        }
    },
    cancelSpin: function() {
        var a = this;
        a.restoreReelVisibility();
        SB.SpinController.superclass.cancelSpin.apply(a, arguments)
    },
    announceSpinComplete: function() {
        var a = this;
        if (a.aborted) {
            if (a.dialogClosed) {
                a.view.show();
                a.moveOutofHandleErrorState()
            }
        }
        a.allReelsHaveStopped = true;
        this.fireEvent("notify:spin.spinAnimationComplete");
        this.fireEvent("notify:spin.AllIsStopped")
    },
    moveOutofHandleErrorState: function() {
        this.fireEvent("notify:spin:serverErrorHandled")
    }
};
SB.SpinController = Sys.extend(Core.Slots.SpinController, SB.SpinController, "SB.SpinController");
Sys.ns("SB");
SB.SpinView = {
    SPIN_SOUNDS: {
        basic: {
            spinStart: {
                id: (Platform.isIEBrowser) ? "spinStart2" : "spinStart",
                name: (Platform.isIEBrowser) ? "spinStart2" : "spinStart"
            },
            reelSpin: {
                id: "reelSpin",
                name: "reelSpin",
                loop: true
            },
            reelStop: {
                id: "reelStop",
                name: "reelStop"
            },
            reelBounce: {
                id: "reelBounce",
                name: "reelBounce"
            }
        },
        respin: {
            spinStart: {
                id: (Platform.isIEBrowser) ? "spinStart2" : "spinStart",
                name: (Platform.isIEBrowser) ? "spinStart2" : "spinStart"
            },
            reelSpin: {
                id: (Platform.isIEBrowser) ? "respinStart" : "reSpin",
                name: (Platform.isIEBrowser) ? "respinStart" : "reSpin",
                loop: true
            },
            reelStop: {
                id: "reelStop",
                name: "reelStop"
            },
            reelBounce: {
                id: "reelBounce",
                name: "reelBounce"
            }
        }
    },
    setupReelListsForReelset: function(g, f) {
        var t = this,
            o, s, a = Resources.readData("config").reel,
            p = a.symbolRows,
            q = a.symbolCols,
            d = a.orientation,
            c = a.reelAreaTop,
            k = a.reelAreaLeft,
            j = a.reelSpacing,
            l = d === "horizontal" ? p : q,
            r = d === "horizontal" ? q : p,
            b = a.reelDepthModifiers || Sys.utils.initArray(l, 0),
            m = f.reels,
            n = f.reelLists,
            u = Layering.Game.Slots.Spin.symbols,
            h, e;
        for (o = 0; o < l; o++) {
            if (d === "horizontal") {
                h = k;
                e = c + o * (a.symbolHeight + j)
            } else {
                h = k + o * (a.symbolWidth + j);
                e = c
            }
            s = new SB.ReelList({
                id: g + "_" + o,
                symbolWidths: a.symbolWidths,
                symbolHeights: a.symbolHeights,
                blurredSymbolWidths: a.blurredSymbolWidths,
                blurredSymbolHeights: a.blurredSymbolHeights,
                symbolCenterToCenter: a.symbolCenterToCenter,
                baseDepth: u + b[o],
                depthDistribution: a.depthDistribution,
                symbolSpecificDepthModifiers: a.symbolSpecificDepthModifiers,
                numberOfOutcomeSymbols: r,
                x: h,
                y: e,
                orientation: d,
                visibleLength: a.visibleLength,
                outcomeOffset: a.outcomeOffset,
                spinDirection: a.spinDirection,
                reelStrip: m[o],
                timeToMoveOneSlot: a.timeToMoveOneSlot,
                startBounceSupportPointOffset: a.startBounceSupportPointOffset,
                endBounceSupportPointOffsets: a.endBounceSupportPointOffsets,
                endBounceDurations: a.endBounceDurations,
                startSpinCompleteCallback: t.startSpinComplete.bind(t),
                bounceStartCallback: t.reelStartedBouncing.bind(t),
                reelStoppedCallback: t.reelStopped.bind(t)
            });
            n.push(s)
        }
    },
    setReelVisibility: function(d) {
        if (Sys.isDefined(d) && Sys.isDefined(d.reels)) {
            var g = this,
                k = g.model.readData("reelsets"),
                j, b = d.reels.length,
                e = d.opacity,
                f, h, c = d.time || 10,
                i, a;
            Sys.iterate(k, function(l, m) {
                j = m.reelLists;
                for (i = 0; i < b; i++) {
                    f = j[d.reels[i]].animationItems;
                    h = f.length;
                    for (a = 0; a < h; a++) {
                        f[a].prop.operations.fade = [{
                            time: 0,
                            value: 1 - e
                        }, {
                            time: c,
                            value: e
                        }, {
                            time: c + 1,
                            value: e,
                            goTo: 1
                        }];
                        f[a].restore();
                        f[a].play()
                    }
                }
            })
        }
    },
    reelStartedBouncing: function() {
        var b = this,
            a = b.model.readData("reelsetHidden") || [];
        if (!Sys.contains(a, b.reelStoppedCount)) {
            b.activeSpinSounds.reelBounce.id = "reelBounce" + b.reelStoppedCount;
            b.fireEvent("view:playAudio", b.activeSpinSounds.reelBounce)
        }
    },
    hide: function() {
        var a = this;
        a.setReelVisibility({
            reels: [1, 2, 3],
            opacity: 1
        });
        this.model.storeData("reelsetHidden", []);
        SB.SpinView.superclass.hide.apply(a, arguments)
    },
    startSpin: function() {
        var f = this,
            e, d = f.model.readData("reelsets"),
            c = d[f.model.readData("currentReelset")].reelLists,
            g = Resources.readData("config").reel,
            b = g.timeToMoveOneSlotInStart,
            a = c.length;
        f.fireEvent("view:playAudio", f.activeSpinSounds.spinStart);
        if (Platform.isDesktopDevice) {
            f.fireEvent("view:playAudio", f.activeSpinSounds.reelSpin)
        }
        f.spinStartTimePerReel = [];
        f.isStopSequenceResuming = false;
        f.numReelsStarted = 0;
        f.reelStoppedCount = 0;
        for (e = 0; e < a; e++) {
            c[e].startSpin(e);
            if (Sys.isDefined(b)) {
                c[e].model.timeToMoveOneSlot = b
            }
        }
    },
    startSpinComplete: function() {
        var a = this;
        a.fireEvent("view:startSpinComplete", a.numReelsStarted);
        if (Platform.isDesktopDevice) {
            a.spinStartTimePerReel[a.numReelsStarted] = Date.now();
            a.model.storeData("spinStartTimePerReel", a.spinStartTimePerReel)
        }
        if (!Platform.isDesktopDevice && a.numReelsStarted === 0) {
            a.fireEvent("view:playAudio", a.activeSpinSounds.reelSpin)
        }
        a.numReelsStarted++
    },
    setActiveSpinSound: function(a) {
        var b = this;
        switch (a) {
            case "freespin":
                if (Sys.isDefined(b.SPIN_SOUNDS.freeSpins)) {
                    b.activeSpinSounds = b.SPIN_SOUNDS.freeSpins
                } else {
                    b.activeSpinSounds = b.SPIN_SOUNDS.basic
                }
                break;
            case "respin":
                if (Sys.isDefined(b.SPIN_SOUNDS.respin)) {
                    b.activeSpinSounds = b.SPIN_SOUNDS.respin
                } else {
                    b.activeSpinSounds = b.SPIN_SOUNDS.basic
                }
                break;
            default:
                if (a.contains("wild") && Sys.isDefined(b.SPIN_SOUNDS.respin)) {
                    b.activeSpinSounds = b.SPIN_SOUNDS.respin
                } else {
                    b.activeSpinSounds = b.SPIN_SOUNDS.basic
                }
                break
        }
    },
    checkIfTimeToStop: function(f) {
        var k = this,
            g, h = k.model.readData("reelsets"),
            n = h[k.model.readData("currentReelset")].reelLists,
            b = n.length,
            d, e = Resources.readData("config").reel,
            c = e.symbolRows,
            m = e.timeToMoveOneSlot,
            l = e.timeToMoveOneSlotInStart,
            j = e.timeToMoveOneSlotInStop,
            a = k.getNumberOfExtraRows();
        clearTimeout(k.checkTimeout);
        for (g = 0; g < b; g++) {
            d = n[g];
            if (Sys.isDefined(l) && !d.isStopping() && k.model.timeToIncreaseSpeed(g) && !k.isStopSequencePaused()) {
                n[g].model.timeToMoveOneSlot = m
            }
            if (Sys.isDefined(j) && !d.isStopping() && k.model.timeToDecreaseSpeed(g) && !k.isStopSequencePaused()) {
                n[g].model.timeToMoveOneSlot = j
            }
            if (!d.isStopping() && k.model.timeToStop(g) && !k.isStopSequencePaused()) {
                d.model.numberOfOutcomeSymbols = c + a + k.getNumberOfExtraRowsAbove();
                k.fireEvent("view:reelStopStarted", g);
                if (f) {
                    d.stopSpin(f[g])
                }
                if (k.model.isUsingStackedSymbols()) {
                    k.model.insertRandomSymbolsInReel(g, k.getNumberOfExtraRowsAbove(), a, c)
                }
                k.stopped++
            }
        }
        if (k.stopped < b) {
            k.checkTimeout = setTimeout(function() {
                k.checkIfTimeToStop(f)
            }, 40)
        }
    }
};
SB.SpinView = Sys.extend(Core.Slots.SpinView, SB.SpinView, "SB.SpinView");
Sys.ns("SB");
SB.SpinModel = {
    timeToDecreaseSpeed: function(e) {
        var f = this,
            b = Date.now(),
            a = f.readData("spinStartTime"),
            c = f.readData("minimumSpinTime"),
            g = f.readData("hasFinishedStartSequence"),
            h = (b - a) >= c,
            d = f.spinType === "quickSpin",
            i = f.spinType === "quickStop";
        if ((h || d || i) && g) {
            return b >= f.getSpeedDownTime(e)
        } else {
            return false
        }
    },
    getSpeedDownTime: function(g) {
        var e = this,
            a = e.readData("stopSequenceStartTime"),
            c = e.readData("nearwinEnabled"),
            d, b, f = e.readData("spinTimes"),
            h = e.readData("currentReelset");
        if (e.spinType === "quickStop" || e.spinType === "quickSpin") {
            b = f[e.spinType]
        } else {
            if (h === "freeSpin" || h === "respin") {
                b = f[h]
            } else {
                b = f.standard
            }
        }
        d = a + e.getReelStopDelay(g) - b.stopSpinSpeedDownDuration;
        if (c && e.spinType !== "quickStop") {
            d += e.getNearWinDelay(g)
        }
        return d
    },
    timeToIncreaseSpeed: function(e) {
        var f = this,
            b = Date.now(),
            a = f.readData("spinStartTime"),
            c = f.readData("minimumSpinTime"),
            g = f.readData("hasFinishedStartSequence"),
            h = (b - a) >= c,
            d = f.spinType === "quickSpin",
            i = f.spinType === "quickStop";
        if ((h || d || i) && g) {
            if (f.getSpeedUpTime(e)) {
                return b >= f.getSpeedUpTime(e)
            } else {
                return false
            }
        } else {
            return false
        }
    },
    getSpeedUpTime: function(e) {
        var d = this,
            a = d.readData("spinStartTimePerReel"),
            c, b = d.readData("nearwinEnabled");
        if (Sys.isDefined(a) && Sys.isDefined(a[e])) {
            c = a[e] + d.getReelSpeedUpDelay(e)
        } else {
            return false
        }
        if (b && d.spinType !== "quickStop") {
            c += d.getNearWinDelay(e)
        }
        return c
    },
    getReelSpeedUpDelay: function(d) {
        var b = this,
            e = b.readData("currentReelset"),
            c = b.readData("spinTimes"),
            a;
        if (b.spinType === "quickStop" || b.spinType === "quickSpin") {
            a = c[b.spinType]
        } else {
            if (e === "freeSpin" || e === "respin") {
                a = c[e]
            } else {
                a = c.standard
            }
        }
        return a.reelStopDelays[d] + a.startSpinSpeedUpDuration
    }
};
SB.SpinModel = Sys.extend(Core.Slots.SpinModel, SB.SpinModel, "SB.SpinModel");
Sys.ns("SB");
SB.SpinButtonDisable = {
    constructor: function() {
        SB.SpinButtonDisable.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            controller: SB.SpinButtonDisableController,
            model: Core.Model
        }
    }
};
SB.SpinButtonDisable = Sys.extend(Core.Module, SB.SpinButtonDisable, "SB.SpinButtonDisable");
Sys.ns("SB");
SB.SpinButtonDisableController = {
    constructor: function() {
        SB.SpinButtonDisableController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        a.on({
            "notify:stateHandler.leavingBigWinState": a.requestSpinButtonEnable,
            "notify:stateHandler.leavingStandardWinPresentationState": a.requestSpinButtonEnable,
            "notify:stateHandler.leavingNoWinPresentationState": a.requestSpinButtonEnable,
            "notify:freeRounds.started": a.requestSpinButtonEnable,
            "notify:responseParser.responseParsed": a.handleFreeRounds
        })
    },
    requestSpinButtonEnable: function() {
        this.fireEvent("request:spinButton.enable", this.MODULE_NAME);
        this.fireEvent("notify:spinButtonDisable.complete")
    },
    requestSpinButtonDisable: function() {
        this.fireEvent("request:spinButton.disable", this.MODULE_NAME)
    },
    handleFreeRounds: function(a) {
        var b;
        if (Sys.isNumber(a.freeRoundsLeft)) {
            this.model.storeData("freeRoundsLeft", a.freeRoundsLeft);
            b = this.model.readData("freeRoundsLeft");
            if (Sys.isDefined(b) && b === 0) {
                this.requestSpinButtonDisable();
                this.fireEvent("notify:spinButtonDisable.start")
            }
        } else {
            this.model.removeData("freeRoundsLeft")
        }
    }
};
SB.SpinButtonDisableController = Sys.extend(Core.Controller, SB.SpinButtonDisableController, "SB.SpinButtonDisableController");
Sys.ns("SB");
SB.QuickStopperController = {
    spinStopped: function() {
        var a = this;
        SB.QuickStopperController.superclass.spinStopped.apply(a, arguments);
        if (Game.moduleLoader.stateHandler.currentState.name === "Idle") {
            a.fireEvent("notify:quickStopper.enableSpinButton")
        }
    }
};
SB.QuickStopperController = Sys.extend(Game.Slots.QuickStopperController, SB.QuickStopperController, "SB.QuickStopperController");
Sys.ns("SB");
SB.QuickStopperDesktopView = {
    initAnimations: function() {},
    quickStop: function() {}
};
SB.QuickStopperDesktopView = Sys.extend(Game.Slots.QuickStopperView, SB.QuickStopperDesktopView, "SB.QuickStopperDesktopView");
Sys.ns("Animation");
var existingProto = Animation.ReelModel.prototype;
Animation.ReelModel = function(a) {
    var b = this;
    Sys.applyProperties(b, a);
    b.slotLength = b.symbolLength + b.symbolSpacing;
    b.outcomeWindowLength = b.numberOfOutcomeSymbols * b.slotLength;
    b.reelStripLength = b.slotLength * b.reelStrip.length;
    b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
    b.leadingSymbolsCount = b.getNumberOfNeededLeadingSymbols();
    b.visibleSymbolsCount += b.leadingSymbolsCount;
    b.outcomeSymbols = [];
    b.setWindowPosition(-b.outcomeOffset);
    b.firstOutcomeSymbolReelStripIndex = 0;
    b.currentTime = 0;
    b.targetOffset = 0;
    b.startTime = 0;
    b.startBlurDuration = Resources.readData("config").reel.startBlurDuration;
    b.stopBlurDuration = Resources.readData("config").reel.stopBlurDuration;
    if (Sys.isDefined(Resources.readData("config").reel.startBounceDuration)) {
        b.startDuration = Resources.readData("config").reel.startBounceDuration
    } else {
        b.startDuration = b.timeToMoveOneSlot * ((b.visibleWindowLength + Math.abs(b.startBounceSupportPointOffset) * 2) / b.slotLength)
    }
    if (Sys.isDefined(Resources.readData("config").reel.startBounceUpDuration)) {
        b.startBounceUpDuration = Resources.readData("config").reel.startBounceUpDuration
    }
    if (Sys.isDefined(Resources.readData("config").reel.startBounceDownDuration)) {
        b.startBounceDownDuration = Resources.readData("config").reel.startBounceDownDuration
    }
    b.stopTime = 0;
    b.stopDuration = 0;
    b.currentBounce = b.endBounceSupportPointOffsets.length;
    b.accumulatedBounceTime = 0;
    b.hasCompletedSpin = true;
    b.hasCompletedBounce = true;
    b.state = "stopping"
};
existingProto.start = function(b) {
    var c = this,
        a = Resources.readData("config").reel.startBounceStartDurations;
    if (Sys.isDefined(a)) {
        c.startTime = c.currentTime + a[b]
    } else {
        c.startTime = c.currentTime
    }
    c.targetOffset = c.visibleWindowLength + c.slotLength * c.leadingSymbolsCount;
    c.state = "starting";
    c.hasCompletedSpin = false;
    c.hasCompletedBounce = false
};
existingProto.getStartingDistance = function(f) {
    var e = this,
        d, b, a, c;
    if (Platform.isDesktopDevice) {
        if (!Sys.isDefined(e.reelStartDuration)) {
            e.reelStartDuration = e.startBounceUpDuration
        }
        d = Math.min(1, (e.currentTime - e.startTime) / e.reelStartDuration);
        b = Animation.utils.getInterpolationValue(0, e.targetOffset, d, {
            type: "bezier",
            support: e.startBounceSupportPointOffset
        });
        a = Math.min(1, (e.currentTime - e.startTime + f) / e.reelStartDuration);
        c = Animation.utils.getInterpolationValue(0, e.targetOffset, a, {
            type: "bezier",
            support: e.startBounceSupportPointOffset
        });
        if (c - b > 0) {
            e.reelStartDuration = e.startBounceDownDuration
        }
    } else {
        d = Math.min(1, (e.currentTime - e.startTime) / e.startDuration);
        b = Animation.utils.getInterpolationValue(0, e.targetOffset, d, {
            type: "bezier",
            support: e.startBounceSupportPointOffset
        });
        a = Math.min(1, (e.currentTime - e.startTime + f) / e.startDuration);
        c = Animation.utils.getInterpolationValue(0, e.targetOffset, a, {
            type: "bezier",
            support: e.startBounceSupportPointOffset
        })
    }
    return c - b
};
existingProto.stop = function() {
    var a = this,
        c = a.getIndexForFirstVisibleSymbol(),
        d = a.getNumberOfRowsAbove() + a.getNumberOfRowsBelow(),
        b = c - a.numberOfOutcomeSymbols + d;
    a.reelStartDuration = undefined;
    a.targetPosition = b * a.slotLength - a.outcomeOffset;
    a.targetOffset = a.windowPosition - a.targetPosition;
    a.stopDuration = Math.round(a.timeToMoveOneSlot * (a.targetOffset / a.slotLength));
    a.outcomeSymbols = a.nextOutcomeSymbols;
    a.stopTime = a.currentTime;
    a.currentBounce = 0;
    a.accumulatedBounceTime = 0;
    a.state = "stopping";
    a.stopKey = Date.now();
    a.stoppingStartTime = new Date().getTime();
    a.firstOutcomeSymbolReelStripIndex = (b - a.getNumberOfRowsAbove()) < 0 ? b + a.reelStrip.length - a.getNumberOfRowsAbove() : b - a.getNumberOfRowsAbove()
};
Animation.ReelModel.prototype = existingProto;
Sys.ns("SB");
SB.ReelList = {
    startSpin: function(a) {
        var b = this;
        b.model.stopTime = null;
        b.model.start(a)
    },
    shouldUseMotionBlur: function() {
        var b = this;
        if (b.model.state !== "stopping") {
            if (Sys.isDefined(b.model.startBlurDuration) && Sys.isDefined(b.model.startTime)) {
                return (b.model.currentTime > b.model.startTime + b.model.startBlurDuration && !b.model.isStopping())
            } else {
                return b.model.isSpinning()
            }
        } else {
            if (Sys.isDefined(b.model.stopBlurDuration) && Sys.isDefined(b.model.stoppingStartTime)) {
                var a = (new Date().getTime() > b.model.stoppingStartTime + b.model.stopBlurDuration);
                return !a
            } else {
                return b.model.isSpinning()
            }
        }
    }
};
SB.ReelList = Sys.extend(Animation.ReelList, SB.ReelList, "SB.ReelList");
Sys.ns("SB");
SB.SettingsWindowExtendedView = {
    BASE_CSS: "interface-settingsWindow_base interface-gameSettings-paytable-background-uri",
    CLOSE_BUTTON_CSS: "sb-settingsWindow_desktop_closeButton interface-settingsWindow_closeButton_uri",
    CONTENT_CSS: "interface-settingsWindow_content sb-settingsWindow_content",
    showChild: function() {
        if (Environment.orientation() === "portrait") {
            this.open()
        }
    },
    setupDOMStructure: function() {
        var a = this;
        a.container = new Sys.Element({
            id: "settingsWindow",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET
        });
        a.content = a.container.add(new Sys.Element({
            id: "settingsWindowContent",
            tag: "div",
            cls: a.CONTENT_CSS
        }));
        a.closeButton = new Interface.utils.DOMButton({
            id: "settingsWindowCloseButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:close"),
            enabled: false
        });
        a.closeButton.SOUND_CLICK = "paytableButtonClick";
        a.container.add(a.closeButton.getContainer())
    }
};
SB.SettingsWindowExtendedView = Sys.extend(Interface.SettingsWindowBaseView, SB.SettingsWindowExtendedView, "SB.SettingsWindowExtendedView");
Sys.ns("SB");
SB.SettingsWindowController = {
    onCloseRequest: function() {
        var a = this;
        if (a.model.readData("open")) {
            if (Platform.isDesktopDevice) {
                a.fireEvent("request:logo.show")
            }
            a.close()
        }
    }
};
SB.SettingsWindowController = Sys.extend(Interface.SettingsWindowController, SB.SettingsWindowController, "SB.SettingsWindowController");
Sys.ns("SB");
SB.VideoItem = {
    play: function() {
        var a = this;
        if (!a.isRunning()) {
            a.restore();
            a.videoEl.load()
        }
        a.prop.paused = false;
        a.videoEl.style.display = "block";
        a.videoEl.play()
    },
    setupVideo: function(c) {
        var e = this,
            b = document.createElement("video"),
            d = Resources.readData("videos"),
            a = Resources.readData("animationImages");
        b.src = d[c.src];
        b.preload = "auto";
        b.loop = Sys.isDefined(c.loop) ? c.loop : true;
        b.autoplay = Sys.isDefined(c.autoplay) ? c.autoplay : true;
        b.type = Sys.isDefined(c.type) ? c.type : undefined;
        b.width = Sys.isDefined(c.width) ? c.width : undefined;
        b.height = Sys.isDefined(c.height) ? c.height : undefined;
        b.poster = Sys.isDefined(c.poster) ? a[c.poster].src : undefined;
        b.style.position = Sys.isDefined(c.position) ? c.position : undefined;
        b.style.top = Sys.isDefined(c.top) ? c.top : undefined;
        b.style.left = Sys.isDefined(c.left) ? c.left : undefined;
        b.style.zIndex = Sys.isDefined(c.zIndex) ? c.zIndex : undefined;
        b.style.display = "none";
        if (c.container !== undefined) {
            c.container.addChildren([b])
        } else {
            document.body.appendChild(b)
        }
        e.videoEl = b
    },
    stop: function() {
        var a = this;
        Animation.VideoItem.superclass.stop.apply(a, arguments);
        a.videoEl.pause();
        if (a.videoEl.currentTime > 0) {
            a.videoEl.currentTime = 0
        }
        a.videoEl.style.display = "none"
    }
};
SB.VideoItem = Sys.extend(Animation.VideoItem, SB.VideoItem, "SB.VideoItem");
Sys.ns("SB");
SB.PaytableController = {
    onDisableBasicGamePanel: function(b) {
        var a = this;
        if (b === "background") {} else {
            if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
                a.view.onDisableBasicGamePanel(b)
            }
        }
    },
    onShowRequest: function(a) {
        var b = this;
        Interface.PaytableController.superclass.onShowRequest.apply(b, arguments);
        if (Platform.isDesktopDevice) {
            b.fireEvent("request:logo.hide")
        }
    },
    onHideRequest: function() {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.fireEvent("request:logo.show")
        }
        Interface.PaytableController.superclass.onHideRequest.apply(a, arguments)
    },
    onUserInputStart: function(a) {
        if (Platform.isDesktopDevice && !this.checkSettingsMenu(a) && !this.view.onGreyAreaClick(a)) {
            this.onHideRequest()
        }
        this.view.onUserInputStart.apply(this.view, arguments)
    },
    checkSettingsMenu: function(d) {
        var c = Sys.UserInputUtils.getDOMElementFromCoordinates(d);
        var a = document.getElementById("autoplaySettings");
        var b = document.getElementById("gameSettings");
        return Sys.UserInputUtils.isParentAndChildElements(a, c) || Sys.UserInputUtils.isParentAndChildElements(b, c)
    }
};
SB.PaytableController = Sys.extend(Interface.PaytableController, SB.PaytableController, "SB.PaytableController");
Sys.ns("SB");
SB.CardNavigation = {
    CSS: {
        ARROWS: "interface-cardNavigation_arrows sb-cardNavigation_arrows clearfix trim",
        ARROWS_PREVIOUS: "interface-cardNavigation_arrows_previous sb-cardNavigation_arrows_previous",
        ARROWS_CLOSE: "interface-cardNavigation_arrows_close sb-cardNavigation_arrows_close",
        ARROWS_NEXT: "interface-cardNavigation_arrows_next sb-cardNavigation_arrows_next",
        INDICATORS: "interface-cardNavigation_indicators sb-cardNavigation_indicators clearfix utils_horizontal_center trim",
        INDICATORS_CHILD: "interface-cardNavigation_indicator",
        INDICATORS_SELECTED: "interface-cardNavigation_selectedIndicator",
        DISABLED: "interface-cardNavigation_disabled"
    },
    setupArrows: function(c) {
        var b = this,
            a = Sys.isObj(c);
        b.arrowContainer = new Sys.Element({
            id: b.id + "_arrows",
            tag: "ul",
            cls: b.CSS.ARROWS
        });
        b.previousArrow = new Interface.utils.DOMButton({
            id: "paytablePrevious",
            tag: "li",
            baseCSS: b.CSS.ARROWS_PREVIOUS,
            textContent: (a && Sys.isDefined(c.previous)) ? c.previous : "",
            clickCallback: b.previous.bind(b)
        });
        b.previousArrow.SOUND_CLICK = "paytableButtonClick";
        b.arrowContainer.add(b.previousArrow.getContainer());
        b.subComponents.push(b.previousArrow);
        if (b.hasCloseButton) {
            b.closeArrow = new Interface.utils.DOMButton({
                id: "paytableClose",
                tag: "li",
                baseCSS: b.CSS.ARROWS_CLOSE,
                textContent: (a && Sys.isDefined(c.close)) ? c.close : "",
                clickCallback: b.close.bind(b)
            });
            b.closeArrow.SOUND_CLICK = "paytableButtonClick";
            b.arrowContainer.add(b.closeArrow.getContainer());
            b.subComponents.push(b.closeArrow)
        }
        b.nextArrow = new Interface.utils.DOMButton({
            id: "paytableNext",
            tag: "li",
            baseCSS: b.CSS.ARROWS_NEXT,
            textContent: (a && Sys.isDefined(c.next)) ? c.next : "",
            clickCallback: b.next.bind(b)
        });
        b.nextArrow.SOUND_CLICK = "paytableButtonClick";
        b.arrowContainer.add(b.nextArrow.getContainer());
        b.subComponents.push(b.nextArrow)
    },
    setupIndicators: function() {
        var c = this,
            d = new Sys.Element({
                id: c.id + "indicators",
                tag: "ul",
                cls: c.CSS.INDICATORS
            }),
            b = [],
            e, a;
        for (a = -1; ++a < c.numCards;) {
            e = new Interface.utils.DOMButton({
                id: "paytableIndicator_" + a,
                tag: "li",
                baseCSS: c.CSS.INDICATORS_CHILD,
                clickCallback: c.selectCard.bind(c, a)
            });
            e.SOUND_CLICK = "paytableButtonClick";
            b.push(d.add(e.getContainer()));
            c.subComponents.push(e)
        }
        c.indicatorContainer = d;
        c.indicatorChildren = b
    }
};
SB.CardNavigation = Sys.extend(Interface.utils.CardNavigation, SB.CardNavigation, "SB.CardNavigation");
Sys.ns("SB");
SB.KeyboardManagerController = {
    SPACE_BAR_ENABLED: true,
    constructor: function() {
        Core.KeyboardManagerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        var a = this;
        SB.KeyboardManagerController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:spinButtonDisable.complete": a.enableSpaceBar,
            "notify:spinButtonDisable.start": a.disableSpaceBar
        })
    },
    enableSpaceBar: function() {
        this.SPACE_BAR_ENABLED = true
    },
    disableSpaceBar: function() {
        this.SPACE_BAR_ENABLED = false
    },
    onSpaceBarPressed: function(b) {
        var a = this;
        if (!Services.settingsManager.getSetting("spacebarToSpin")) {
            return
        }
        if (a.SPACE_BAR_ENABLED) {
            if (b === "up") {
                a.fireEvent("request:spinButton.released");
                a.fireEvent("request:abortPresentation");
                if (a.model.readData("quickStopAvailable")) {
                    a.fireEvent("request:quickStopper.quickStop")
                }
            } else {
                if (b === "down") {
                    window.onkeydown = function(c) {
                        return c.keyCode !== 32
                    };
                    a.fireEvent("notify:wildExpanding.stopAnimation");
                    a.fireEvent("request:spinButton.pressed")
                }
            }
        } else {
            a.fireEvent("request:abortPresentation")
        }
    }
};
SB.KeyboardManagerController = Sys.extend(Core.KeyboardManagerController, SB.KeyboardManagerController, "SB.KeyboardManagerController");
Sys.ns("SB");
SB.DialogWindowController = {
    onDialogShown: function(a) {
        var b = this;
        if (b.model.hasQueuedDialog()) {
            b.view.showNextDialog()
        } else {
            if (a.errorCode === 13 || a.errorCode === 11) {
                b.fireEvent("notify:dialogWindow.closeForMaxBetAndPlayerLimit")
            }
            b.fireEvent("request:quickSettingsMenu.externalActivate", b.MODULE_NAME);
            b.fireEvent("request:enableBasicGamePanel", b.MODULE_NAME);
            b.fireEvent("notify:dialogWindow.allDialogsClosed")
        }
        b.fireEvent("notify:dialogWindow.dialogShown", a.id)
    }
};
SB.DialogWindowController = Sys.extend(Core.DialogWindowController, SB.DialogWindowController, "SB.DialogWindowController");
Sys.ns("SB.utils");
SB.utils.serverResponse = {
    winSituationsAlreadyRandomised: false,
    randomWinSituations: [],
    winSituationsToToggle: [],
    randomizeWinSituations: function(c) {
        var k = this,
            e, f = [],
            g, j, b = [],
            l = [],
            m = [],
            h;
        h = Sys.clone(c);
        if (k.winSituationsAlreadyRandomised) {
            return k.randomWinSituations
        }
        Sys.each(h, function(n, i) {
            m.push(i)
        });
        e = m.length;
        if (h) {
            var d = {
                coins: h[0].wins.coins,
                count: 1
            };
            for (g = 1; g < e; g++) {
                if (d.coins === h[g].wins.coins) {
                    d.count++
                } else {
                    l.push(d);
                    d = {
                        coins: h[g].wins.coins,
                        count: 1
                    }
                }
            }
            l.push(d);
            var a = 0;
            Sys.each(l, function(p) {
                var n = m.splice(0, p.count);
                var o = [],
                    q, i = n.length;
                for (j = 0; j < i; j++) {
                    q = Math.floor(Math.random() * ((n.length - 1) - 0 + 1));
                    o[j] = n[q];
                    n.splice(q, 1)
                }
                for (j = 0; j < o.length; j++) {
                    f.push(o[j])
                }
                a = a + p.count
            });
            k.winSituationsToToggle = f;
            Sys.each(f, function(i) {
                b.push(h[i])
            });
            k.winSituationsAlreadyRandomised = true;
            k.randomWinSituations = b;
            return b
        }
    },
    getRandomWinSituationsToToggle: function() {
        return this.winSituationsToToggle
    }
};
Sys.ns("Core");
Core.BonusMessage = {
    constructor: function() {
        Core.BonusMessage.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Core.Model,
            controller: Core.BonusMessageController
        }
    }
};
Core.BonusMessage = Sys.extend(Core.Module, Core.BonusMessage, "Core.BonusMessage");
Sys.ns("Core");
Core.BonusMessageController = {
    constructor: function() {
        Core.BonusMessageController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:stateHandler.enteringIdleState": this.showBonusMessageDialog
        })
    },
    onServerResponse: function(a) {
        var b;
        if (Sys.isNumber(a.bonusAwarded)) {
            b = a.bonusAwarded.toFixed(2)
        }
        this.model.storeData("bonusAwarded", b)
    },
    showBonusMessageDialog: function() {
        var a = this.model.readData("bonusAwarded");
        if (Sys.isDefined(a)) {
            this.requestDialog(a);
            this.model.setState("dialogOpen")
        }
    },
    requestDialog: function(a) {
        this.fireEvent("request:dialogWindow.showDialog", this.getDialog(a))
    },
    getDialog: function(b) {
        var a = this;
        return {
            title: Services.languageManager.getText(Language.Keys.bonusAwardedTitle),
            text: Services.languageManager.getText(Language.Keys.bonusAwardedCongrats, [b]),
            buttons: [{
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                action: function() {
                    a.fireEvent("notify:dialogBoxClosed", {
                        name: "bonusMessage",
                        button: "continue"
                    })
                }
            }]
        }
    }
};
Core.BonusMessageController = Sys.extend(Core.Controller, Core.BonusMessageController, "Core.BonusMessageController");
Sys.ns("SB");
SB.ErrorManagerController = {
    revertSpin: function() {
        var a = this;
        SB.ErrorManagerController.superclass.revertSpin.apply(a, arguments);
        a.fireEvent("request:audioPlayer.stop", "reelSpin")
    }
};
SB.ErrorManagerController = Sys.extend(Core.ErrorManagerController, SB.ErrorManagerController, "SB.ErrorManagerController");
Sys.ns("SB");
SB.MoneyManagerController = {
    onSettingChanged: function(b, d) {
        var c = this,
            a = c.model;
        if (b === "betLevel" || b === "denomination" || b === "betLines") {
            if (b === "betLevel") {
                if (a.setBetLevel(d)) {
                    c.notifyBetChange(false)
                }
            } else {
                if (b === "denomination" && a.setDenomination(d)) {
                    c.notifyBetChange(false)
                }
            }
        }
    },
    notifyBetChange: function(a) {
        var c = this,
            b = this.model;
        c.fireEvent("notify:moneyManager.betChanged", {
            playerBetCoins: b.readData("playerBetCoins"),
            playerBetCents: b.readData("playerBetCents"),
            playerBetFormatted: c.formatMoneyCurrencySign(b.readData("playerBetCents")),
            doAnimate: a
        })
    }
};
SB.MoneyManagerController = Sys.extend(Core.MoneyManagerController, SB.MoneyManagerController, "SB.MoneyManagerController");
Sys.ns("SB");
SB.SpinButtonController = {
    setupEvents: function() {
        var a = this;
        SB.SpinButtonController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "request:disableKeypad": a.disable,
            "notify:stateHandler.enteringBigWinState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingBigWinState": a.model.storeData.bind(a.model, "inWinState", false),
            "notify:stateHandler.enteringStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", false)
        })
    },
    onPressedRequest: function() {
        var b = this,
            a = b.model.isAutoPlayMode();
        if (Platform.isDesktopDevice) {
            if ((b.model.readData("inIdleState") || b.model.readData("inWinState")) && a === false) {
                b.view.onPressedRequest()
            }
        } else {
            if (b.model.readData("inIdleState")) {
                b.view.onPressedRequest()
            }
        }
    },
    onReleasedRequest: function() {
        var b = this,
            a = b.model.isAutoPlayMode();
        if (Platform.isDesktopDevice) {
            if ((b.model.readData("inIdleState") || b.model.readData("inWinState")) && a === false) {
                b.view.onReleasedRequest()
            }
        } else {
            if (b.model.readData("inIdleState")) {
                b.view.onReleasedRequest()
            }
        }
    },
    onClick: function() {
        var b = this,
            a = b.model;
        if (a.hasProperty("hidden")) {
            if (b.view.canInteractWhileHidden()) {
                b.fireEvent("notify:spinButton.clickedWhileHidden")
            }
        } else {
            b.fireEvent("request:audioPlayer.play", {
                name: "spinButtonClick"
            });
            b.fireEvent("notify:spinButton.clicked", {
                skip: a.readData("noStopOnSpin")
            });
            if (a.readData("inIdleState") || (Platform.isDesktopDevice && a.readData("inWinState") && !a.hasProperty("disabled"))) {
                if (a.hasDisplayType("autoPlay")) {
                    b.fireEvent(b.AUTOPLAY_START_EVENT)
                } else {
                    b.fireEvent(b.ROUND_START_EVENT)
                }
            }
        }
    }
};
SB.SpinButtonController = Sys.extend(Interface.Slots.SpinButtonController, SB.SpinButtonController, "SB.SpinButtonController");
Sys.ns("SB");
SB.SpinButtonModel = {
    isAutoPlayMode: function() {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"),
            b = Sys.isDefined(a) && a > 0;
        return b
    }
};
SB.SpinButtonModel = Sys.extend(Interface.Slots.SpinButtonModel, SB.SpinButtonModel, "SB.SpinButtonModel");
Sys.ns("Game");
Game.BonusProgramWidget = {
    constructor: function() {
        Game.BonusProgramWidget.superclass.constructor.apply(this, arguments)
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getDefaultMVCClasses: function() {
        return {
            model: Game.BonusProgramWidgetModel,
            controller: Game.BonusProgramWidgetController,
            view: Game.BonusProgramWidgetView
        }
    },
    getStateChanges: function() {
        var b = this.model,
            c = b.readData("widgetUrl"),
            a = b.readData("nextAction");
        return {
            beforeLoaderClose: {
                queue: [function(d) {
                    if (b.bonusProgramWidgetEnabled() && c && a === "spin") {
                        d.stateHandler.pushState(d.states.bonusProgramWidget)
                    }
                }]
            },
            checkForAdditionalFreeRounds: {
                waitEvents: ["notify:bonusProgramWidget.closed"]
            },
            bonusProgramWidget: {
                state: {
                    name: "BonusProgramWidget",
                    execute: function() {},
                    waitEvents: {
                        "notify:bonusProgramWidget.closed": false,
                        "notify:responseParser.gameConfigurationParsed": false
                    }
                }
            }
        }
    }
};
Game.BonusProgramWidget = Sys.extend(Core.Module, Game.BonusProgramWidget, "Game.BonusProgramWidget");
Sys.ns("Game");
Game.BonusProgramWidgetModel = {
    constructor: function() {
        Game.BonusProgramWidgetModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function() {
        var a = Resources.readData("gameServerInitResponse") || {};
        this.storeData("widgetUrl", "../../");
        this.storeData("slowServerRequestTimeLimit", 5000);
        this.setBonusProgramData(a)
    },
    setBonusProgramData: function(a) {
        this.storeData("bonusProgramWidgetEnabled", Boolean(a.freeRoundWidgetEnabled));
        this.storeData("bonusProgramWidgetGameId", a.freeRoundWidgetGameId);
        this.storeData("bonusProgramWidgetSections", a.freeRoundWidgetSections);
        this.storeData("nextAction", a.nextaction)
    },
    bonusProgramWidgetEnabled: function() {
        return Boolean(this.readData("bonusProgramWidgetEnabled"))
    }
};
Game.BonusProgramWidgetModel = Sys.extend(Core.Model, Game.BonusProgramWidgetModel, "Game.BonusProgramWidgetModel");
Sys.ns("Game");
Game.BonusProgramWidgetController = {
    constructor: function() {
        Game.BonusProgramWidgetController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringBonusProgramWidgetState": this.initBonusProgramWidget,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:bonusProgramWidget.notification": this.notificationHandler,
            "notify:bonusProgramWidget.close": this.closeBonusProgramWidget,
            "notify:responseParser.gameConfigurationParsed": this.checkForAdditionalFreeRounds,
            "notify:responseParser.bonusProgramWidgetValuesParsed": this.onBonusProgramWidgetValuesParsed,
            "notify:bonusProgramWidget.reInit": this.reInit,
            "notify:settingsManager.settingChanged": this.onSettingChanged,
            "view:orientationChanged": this.notifyOrientation
        })
    },
    initBonusProgramWidget: function() {
        var c = this,
            f = this.model.readData("widgetUrl"),
            b = this.model.readData("bonusProgramWidgetGameId"),
            a = Resources.readData("queryData").gameId,
            d = this.model.readData("slowServerRequestTimeLimit"),
            e;
        this.view.initViewData();
        if (b.indexOf("##") !== -1) {
            e = b.split("##")[1];
            b = b.split("##")[0];
            this.model.storeData("bonusProgramWidgetTheme", e)
        }
        this.fetchWidgetVariants(f, b, d, function(h) {
            var g;
            if (!h) {
                c.closeBonusProgramWidget();
                return
            }
            g = c.parseVariantsResponse(h, f, b, e, a);
            c.startBonusProgramWidget(g)
        })
    },
    fetchWidgetVariants: function(g, e, f, b) {
        var c = this.getWidgetLocationByWidgetID(e),
            d = Sys.utils.httpGet({
                url: g + c + "/variants.json"
            }),
            a = setTimeout(function() {
                b(false)
            }, f);
        d.done(function(h) {
            b(h)
        }).fail(function(h) {
            b(false)
        }).always(function() {
            clearTimeout(a)
        })
    },
    getWidgetLocationByWidgetID: function(a) {
        return a === "default_w" || a === "game_branded_w" ? "free_rounds_widget" : a
    },
    parseVariantsResponse: function(b, i, d, h, c) {
        var a, g;
        try {
            a = JSON.parse(b.response);
            g = h ? a[h] : a[c];
            return i + this.getWidgetLocationByWidgetID(d) + (g || a["default"])
        } catch (f) {
            return false
        }
    },
    startBonusProgramWidget: function(a) {
        if (a) {
            this.view.loadIframePage(a);
            this.disableSettingsButton();
            Resources.storeData("bonusProgramWidgetActive", true)
        } else {
            this.closeBonusProgramWidget()
        }
    },
    reInit: function(a) {
        this.model.setBonusProgramData(a);
        if (this.model.bonusProgramWidgetEnabled()) {
            this.initBonusProgramWidget()
        }
    },
    sendMessage: function(d, c, a) {
        var b = document.getElementById("bonusProgramWidgetIframe");
        if (b) {
            b.contentWindow.postMessage({
                moduleId: "bonusProgramWidget",
                action: d,
                data: c || null,
                dataRoute: a || null
            }, "*")
        }
    },
    notificationHandler: function(c) {
        var d, a, b;
        switch (c.action) {
            case "widgetReady":
                this.notifyOrientation(Utils.Platform.getOrientation());
                d = Resources.readData("language");
                b = Resources.readData("queryData");
                a = d.lang || d.defaultLang;
                this.notifyLanguage(a);
                this.sendMessage("soundSettingChange", Services.settingsManager.getSetting("volume"));
                this.sendMessage("defaultValues", {
                    operatorId: b.operatorId,
                    gameId: b.gameId,
                    theme: this.model.readData("bonusProgramWidgetTheme")
                });
                break;
            case "getTextStrings":
                this.getTextStrings(c.data, c.dataRoute);
                break;
            case "roundStarted":
                this.roundStarted();
                break;
            case "resumeNormalGameplay":
                this.resumeNormalGameplay();
                break;
            case "playFreeRoundsNow":
                this.playFreeRoundsNow();
                break;
            case "getSectionValues":
                this.sendMessage("populateSectionValues", this.model.readData("bonusProgramWidgetSections"));
                break;
            default:
                this.sendMessage("actionNotSupported")
        }
    },
    getTextStrings: function(a, b) {
        var d, c = {};
        Sys.iterate(a, function(f, e) {
            if (Sys.isArray(e) && e.length > 0) {
                d = Services.languageManager.getText(f, e)
            } else {
                d = Services.languageManager.getText(f)
            }
            if (d) {
                c[f] = d
            }
        });
        this.sendMessage("populateTextStrings", c, b)
    },
    roundStarted: function() {
        this.requestWidgetAction()
    },
    requestWidgetAction: function() {
        this.fireEvent("request:serverManager.sendAction", "widgetspin", "notify:responseParser.bonusProgramWidgetValuesParsed")
    },
    checkForAdditionalFreeRounds: function(a) {
        if (!a.freeRoundWidgetEnabled) {
            this.fireEvent("notify:bonusProgramWidget.closed")
        }
    },
    onBonusProgramWidgetValuesParsed: function(a) {
        this.sendMessage("processRoundOutcome", {
            indexToShow: a.indexToShow
        })
    },
    resumeNormalGameplay: function() {
        this.closeBonusProgramWidget()
    },
    playFreeRoundsNow: function() {
        this.closeBonusProgramWidget();
        this.fireEvent("request:freeRounds.requestGameConfiguration")
    },
    closeBonusProgramWidget: function() {
        this.view.closeIframePage();
        this.fireEvent("notify:bonusProgramWidget.closed");
        this.enableSettingsButton()
    },
    enableSettingsButton: function() {
        this.fireEvent("request:settingsButton.enable")
    },
    disableSettingsButton: function() {
        this.fireEvent("request:settingsButton.disable")
    },
    notifyOrientation: function(a) {
        this.sendMessage("updateOrientation", {
            orientation: a
        })
    },
    notifyLanguage: function(a) {
        this.sendMessage("updateLanguage", {
            lang: a
        })
    },
    onGameSizeChanged: function() {
        if (typeof this.view.refresh === "function") {
            this.model.storeData("gameSizeChangedTriggered", true);
            this.view.refresh();
            this.notifyOrientation(Utils.Platform.getOrientation())
        }
    },
    onSettingChanged: function(a, b) {
        if (a === "volume") {
            this.sendMessage("soundSettingChange", b)
        }
    }
};
Game.BonusProgramWidgetController = Sys.extend(Core.Controller, Game.BonusProgramWidgetController, "Game.BonusProgramWidgetController");
Sys.ns("Game");
Game.BonusProgramWidgetView = {
    PARENT_CONTAINER_ID: "viewport",
    viewElements: {},
    bonusProgramWidgetIframeId: "bonusProgramWidgetIframe",
    constructor: function() {
        Game.BonusProgramWidgetView.superclass.constructor.apply(this, arguments)
    },
    initViewData: function() {
        var c, a, b;
        a = document.createElement("div");
        b = document.createElement("div");
        a.appendChild(b);
        c = document.getElementById(this.PARENT_CONTAINER_ID);
        a.setAttribute("id", "bonusProgramWidgetContainer");
        b.setAttribute("id", "bonusProgramWidgetOverlay");
        c.appendChild(a);
        this.viewElements = {
            mainContainer: a,
            overlay: b
        };
        this.refresh()
    },
    adaptToOrientation: function(a) {
        if (!this.model.readData("gameSizeChangedTriggered")) {
            this.fireEvent("view:orientationChanged", a);
            this.refresh()
        }
    },
    refresh: function() {
        if (typeof this.viewElements.mainContainer !== "undefined" && Environment.getCurrentPlatform() === "mobile") {
            this.setIframeContainerHeight()
        }
        if (this.viewElements.iframe) {
            this.viewElements.iframe.style.width = "100%";
            this.viewElements.iframe.style.height = "100%"
        }
    },
    setIframeContainerHeight: function() {
        var a = Sys.utils.toInt(Environment.determineResolution().resolution.height + (Platform.isTabletDevice ? 0 : Environment.getSpaceBelowGame()));
        this.viewElements.mainContainer.style.height = a + "px"
    },
    loadIframePage: function(a) {
        this.removeIframeInstance();
        this.createIframeInstance(a)
    },
    createIframeInstance: function(b) {
        var a = document.createElement("iframe");
        a.setAttribute("id", this.bonusProgramWidgetIframeId);
        a.setAttribute("scrolling", "no");
        a.setAttribute("allowtransparency", "true");
        a.setAttribute("src", b);
        a.setAttribute("style", "width: 100%; height: 100%");
        a.onload = this.refresh.bind(this);
        this.viewElements.mainContainer.appendChild(a);
        this.viewElements.iframe = a
    },
    removeIframeInstance: function() {
        var a = document.getElementById(this.bonusProgramWidgetIframeId);
        if (a) {
            a.parentNode.removeChild(a);
            this.viewElements.iframe = null
        }
    },
    closeIframePage: function() {
        var a = this.viewElements.mainContainer;
        a.parentNode.removeChild(a)
    }
};
Game.BonusProgramWidgetView = Sys.extend(Core.View, Game.BonusProgramWidgetView, "Game.BonusProgramWidgetView");
Sys.ns("Integration");
Integration.Disclaimer = {
    constructor: function() {
        Integration.Disclaimer.superclass.constructor.apply(this, arguments)
    },
    getDefaultMVCClasses: function() {
        return {
            model: Integration.DisclaimerModel,
            controller: Integration.DisclaimerController,
            view: Integration.DisclaimerView
        }
    },
    getMixinDependencies: function() {
        return ["orientation"]
    },
    getStateChanges: function() {
        var a = this.model;
        return {
            beforeLoaderClose: {
                queue: [function(b) {
                    if (a.disclaimerEnabled()) {
                        b.stateHandler.pushState(b.states.disclaimer)
                    }
                }]
            },
            disclaimer: {
                state: {
                    name: "Disclaimer",
                    execute: function() {},
                    waitEvents: {
                        "notify:disclaimer.dialogClosed": false
                    }
                }
            }
        }
    }
};
Integration.Disclaimer = Sys.extend(Core.Module, Integration.Disclaimer, "Integration.Disclaimer");
Sys.ns("Integration");
Integration.DisclaimerModel = {
    constructor: function() {
        Integration.DisclaimerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function(d) {
        var b = d || Resources.readData("gameServerInitResponse") || {},
            a = Resources.readData("queryData") || {},
            c = Resources.readData("language") || {};
        this.storeData("disclaimerEnabled", Boolean(b.iframeEnabled));
        this.storeData("language", c.lang);
        this.storeData("disclaimerExtUrl", "/ext.html");
        this.storeData("gameId", a.gameId);
        this.storeData("operatorId", a.operatorId)
    },
    disclaimerEnabled: function() {
        return Boolean(this.readData("disclaimerEnabled"))
    }
};
Integration.DisclaimerModel = Sys.extend(Core.Model, Integration.DisclaimerModel, "Integration.DisclaimerModel");
Sys.ns("Integration");
Integration.DisclaimerController = {
    COOKIE_POLICY_URL: "https://www.netent.com/en/cookie-policy/",
    constructor: function() {
        Integration.DisclaimerController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function() {
        this.on({
            "notify:stateHandler.enteringDisclaimerState": this.showDisclaimerDialog,
            "view:declineCookieDialog": this.declineCookieDialog.bind(this),
            "view:acceptCookieDialog": this.acceptCookieDialog.bind(this),
            "view:openCookiePolicyLink": this.openCookiePolicyLink.bind(this)
        })
    },
    showDisclaimerDialog: function() {
        var a = this.cookieDialogRequired();
        if (a) {
            this.requestDialog()
        } else {
            this.fireEvent("notify:disclaimer.dialogClosed")
        }
    },
    cookieDialogRequired: function() {
        var c = this.getStoredCookieDialogChoice(),
            f, b, a, d, e;
        if (c) {
            c = JSON.parse(c);
            f = c.cookieAccepted;
            if (f) {
                this.loadDisclaimerIframe();
                return false
            }
            a = new Date();
            b = new Date(c.date);
            d = Math.abs(a.getTime() - b.getTime());
            e = Math.ceil(d / (1000 * 3600 * 24));
            if (e < 90) {
                return false
            }
        }
        return true
    },
    declineCookieDialog: function() {
        this.storeCookieDialogChoice(false);
        this.closeDisclaimerDialog()
    },
    acceptCookieDialog: function() {
        this.storeCookieDialogChoice(true);
        this.closeDisclaimerDialog();
        this.loadDisclaimerIframe()
    },
    storeCookieDialogChoice: function(b) {
        var a = {
            cookieAccepted: b,
            date: new Date()
        };
        localStorage.setItem("netEntCookieDisclaimer", JSON.stringify(a))
    },
    getStoredCookieDialogChoice: function() {
        return localStorage.getItem("netEntCookieDisclaimer")
    },
    loadDisclaimerIframe: function() {
        this.view.initViewData()
    },
    closeDisclaimerDialog: function() {
        this.view.closeDialog();
        this.fireEvent("request:quickSettingsMenu.externalActivate", this.MODULE_NAME);
        this.fireEvent("request:enableBasicGamePanel", this.MODULE_NAME);
        this.fireEvent("notify:disclaimer.dialogClosed")
    },
    requestDialog: function() {
        this.fireEvent("request:quickSettingsMenu.externalDeactivate", this.MODULE_NAME);
        this.fireEvent("request:disableBasicGamePanel", this.MODULE_NAME);
        this.view.showDialog()
    },
    openCookiePolicyLink: function() {
        var b = this.model.readData("language"),
            a = this.COOKIE_POLICY_URL + b;
        Sys.utils.openURL(a)
    }
};
Integration.DisclaimerController = Sys.extend(Core.Controller, Integration.DisclaimerController, "Integration.DisclaimerController");
Sys.ns("Integration");
Integration.DisclaimerView = {
    PARENT_CONTAINER_ID: "viewport",
    constructor: function() {
        Integration.DisclaimerView.superclass.constructor.apply(this, arguments);
        this.parent = document.querySelector(".viewport-wrapper")
    },
    initViewData: function() {
        var a = this.createIFrame();
        this.addNoReferrerMetaTag();
        document.getElementById(this.PARENT_CONTAINER_ID).appendChild(a);
        this.viewElements = {
            iframe: a
        };
        this.loadIframePage()
    },
    create: function() {
        var a = document.createElement("div"),
            d = document.createElement("div"),
            b = this.createLeftButton(),
            c = this.createRightButton(),
            e = this.createLink(),
            f = this.createText(e);
        this.disclaimerElement = document.createElement("div");
        this.disclaimerElement.setAttribute("id", "disclaimer");
        this.disclaimerElement.classList.add("disclaimer");
        a.classList.add("disclaimer__container");
        d.classList.add("disclaimer__container__buttons");
        d.appendChild(b.getContainer().getEl());
        d.appendChild(c.getContainer().getEl());
        a.appendChild(d);
        a.appendChild(f);
        this.disclaimerElement.appendChild(a);
        this.parent.appendChild(this.disclaimerElement)
    },
    createIFrame: function() {
        var a = document.createElement("iframe");
        a.setAttribute("id", "disclaimer-iframe");
        a.setAttribute("scrolling", "no");
        a.setAttribute("allowtransparency", "true");
        a.setAttribute("sandbox", "allow-scripts allow-same-origin");
        a.style.width = "1px";
        a.style.height = "1px";
        a.style.display = "none";
        return a
    },
    destroy: function() {
        this.parent.removeChild(this.disclaimerElement)
    },
    addNoReferrerMetaTag: function() {
        var a = document.createElement("meta");
        a.name = "referrer";
        a.content = "no-referrer";
        document.getElementsByTagName("head")[0].appendChild(a)
    },
    loadIframePage: function() {
        var b = window.location.hostname,
            d = this.model.readData("disclaimerExtUrl"),
            c = this.model.readData("gameId"),
            a = encodeURIComponent(b);
        this.viewElements.iframe.src = d + "?id=" + c + "&m=" + a
    },
    createLeftButton: function() {
        var a = this;
        return new Interface.utils.Button({
            CSS: {
                base: "button disclaimer__button disclaimer__button--left"
            },
            label: Services.languageManager.getText(Language.Keys.btn_no),
            enabled: true,
            clickCallback: function() {
                a.fireEvent("view:declineCookieDialog")
            }
        })
    },
    createRightButton: function() {
        var a = this;
        return new Interface.utils.Button({
            CSS: {
                base: "button disclaimer__button disclaimer__button--right"
            },
            label: Services.languageManager.getText(Language.Keys.btn_yes),
            enabled: true,
            clickCallback: function() {
                a.fireEvent("view:acceptCookieDialog")
            }
        })
    },
    createLink: function() {
        var a = this;
        return new Interface.utils.Button({
            CSS: {
                base: "disclaimer__link"
            },
            label: Services.languageManager.getText(Language.Keys.cookiePolicyPart2),
            enabled: true,
            clickCallback: function() {
                a.fireEvent("view:openCookiePolicyLink")
            }
        })
    },
    createText: function(b) {
        var a = Services.languageManager.getText(Language.Keys.cookiePolicy) + " ",
            c = document.createElement("p"),
            d = document.createElement("div");
        d.classList.add("disclaimer__text");
        c.appendChild(document.createTextNode(a));
        c.appendChild(b.getContainer().getEl());
        d.appendChild(c);
        return d
    },
    showDialog: function() {
        this.create()
    },
    closeDialog: function() {
        this.destroy()
    }
};
Integration.DisclaimerView = Sys.extend(Core.View, Integration.DisclaimerView, "Integration.DisclaimerView");
Sys.override(Interface.GameSettingsDesktopView, {
    SETTINGS_CONTROLS: [{
        id: "quickSpin",
        label: Language.Keys.setting_quickSpinGame,
        type: "checkbox"
    }, {
        id: "showFeatureSplash",
        label: Language.Keys.setting_introScreeGame,
        type: "checkbox"
    }, {
        id: "spacebarToSpin",
        label: Language.Keys.setting_spaceSpin,
        type: "checkbox"
    }]
});
Sys.override(Interface.SpinSettingsView, {
    ADVANCED_AUTOPLAY_SETTINGS: {
        stopAutoplayTitle: {
            labelOCTKey: Language.Keys.autoplay_setting_stopAutoPlay,
            type: "settingGroupTitle"
        },
        stopAutoplayIfBalanceDecreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            infoOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesByInfoTouch,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfWinExceeds: {
            labelOCTKey: Language.Keys.autoplay_setting_ifWinExeeds,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfBalanceIncreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashIncreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        }
    },
    update: function() {
        var c = this,
            b = c.model.readData.bind(c.model),
            a = !b("disabled"),
            d = b("autoPlayNrSpins");
        c.nrAutoPlaySpins.setValue(d);
        c.stopIfAutoplayingBonusGameWon.toggle(b("stopAutoplayIfAutoplayingBonusGameWon"));
        c.quickSpin.toggle(b("quickSpin"));
        if (c.spinButtonPosition) {
            c.spinButtonPosition.toggle(b("leftHandMode"))
        }
        if (d === c.model.getAutoplaySpinsArray()[0]) {
            c.stopIfAutoplayingBonusGameWon.toggle(false);
            c.stopIfAutoplayingBonusGameWon.disable();
            Sys.iterate(c.ADVANCED_AUTOPLAY_SETTINGS, function(f, e) {
                c.advancedSettings[f].setValue(e.defaultValue)
            })
        } else {
            if (a && !c.stopIfAutoplayingBonusGameWon.isEnabled()) {
                c.stopIfAutoplayingBonusGameWon.enable()
            }
        }
    }
});
Sys.apply(Sys.utils, {
    numberToFixedDigits: function(a, b) {
        if (Math.abs(a) < 1) {
            return a.toFixed(b - 1)
        }
        if (a >= 1000) {
            return a.toString()
        }
        return a.toPrecision(b)
    },
});
Sys.override(Interface.BetSettingsDesktopView, {
    update: function() {
        var b = this,
            a = b.model;
        if (this.COINVALUE_FIX.MAX_WIDTH && a.readData("updatableCoinValues") && this.coinValueValueItem) {
            Interface.BetSettingsDesktopView.updateCoinValueStyle(b.model.readData("coinValue"), this)
        }
        if (Sys.isDefined(b.selectors) && this.enabled) {
            if (a.readData("updatableBetLevels")) {
                b.selectors.betLevelSelector.update(b.model.readData("betLevel"));
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.selectors.coinValueSelector.update(b.model.readData("coinValue"));
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
        if (Sys.isDefined(b.coinValueValueItem && b.betLevelValueItem)) {
            if (a.readData("updatableBetLevels")) {
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
    },
});
Sys.apply(Interface.BetSettingsDesktopView, {
    updateCoinValueStyle: function(c, i) {
        var f = i,
            a = f.coinValueValueItem.prop,
            k = a.customProps.inMemCanvas.ctx,
            l = Number(f.COINVALUE_FIX.FONT.split("px")[0]),
            g = f.COINVALUE_FIX.FONT.split(" ")[1],
            b = c,
            d, j = f.COINVALUE_FIX.MAX_WIDTH,
            h = f.COINVALUE_FIX.POSITION.y,
            e;
        d = Animation.utils.text.shrinkFont(b.toString(), l, g, 0, j, k).font;
        e = (Animation.utils.text.getHeightOfFont(f.COINVALUE_FIX.FONT) - Animation.utils.text.getHeightOfFont(d)) * 0.75;
        f.selectors.coinValueSelector.basePosition.y = h + e;
        f.selectors.coinValueSelector.fontValue = d;
        f.selectors.coinValueSelector.FONT_VALUE = d
    }
});
Sys.ns("Integration.OpenBet");
Integration.OpenBet.ResponseParserControllerOverride = {
    doIntegrationSpecificResponseHandling: function(c) {
        var b, a;
        if (!Sys.isDefined(c) || (c.clientaction === "rcinfo" || c.clientaction === "rcreset")) {
            return c
        }
        b = c.credit + c.openbet.freebets;
        a = c.openbet.rgitoken;
        if (!isNaN(b)) {
            c.credit = b
        }
        if (Sys.isDefined(a)) {
            Resources.readData("extraParams")["openbet.rgitoken"] = encodeURIComponent(a)
        }
        return c
    }
};
Integration.OpenBet.ServerManagerModelOverride = {
    doIntegrationSpecificRequestUrlUpdates: function(a) {
        var c = Resources.readData("extraParams"),
            b = a;
        Sys.iterate(c, function(e, d) {
            if (e.match(/openbet\.\w+/)) {
                b += "&" + e + "=" + d
            }
        });
        return b
    }
};
Integration.OpenBet.ErrorManagerControllerOverride = {
    handleIntegrationSpecificErrors: function(b) {
        var c = this,
            d = Sys.utils.getErrorCode(b),
            a = Sys.utils.getResponseParameter("errordata", b);
        if (!Sys.isDefined(d) || d < 997 || d > 1000) {
            return false
        }
        if (Sys.isDefined(a)) {
            a = decodeURIComponent(a);
            a = a.replace(/\+/g, " ")
        }
        return {
            title: "Error (" + d + ")",
            text: a,
            buttons: c.getButtons([{
                type: "casino",
                reason: 3
            }]),
            fatal: true
        }
    }
};
Integration.OpenBet.GameHistoryOverride = function() {
    var a = Game.getHistoryTab;
    Game.getHistoryTab = function(c, d, b) {
        if (b) {
            a(c, d, b)
        }
    }
};
Integration.OpenBet.applyOverrides = function() {
    var a;
    Sys.override(Core.ResponseParserController, Integration.OpenBet.ResponseParserControllerOverride);
    Sys.override(Core.ServerManagerModel, Integration.OpenBet.ServerManagerModelOverride);
    Sys.override(Core.ErrorManagerController, Integration.OpenBet.ErrorManagerControllerOverride);
    a = Integration.OpenBet.GameHistoryOverride;
    a()
};
if (Sys.openBetMode) {
    Integration.OpenBet.applyOverrides()
}
Sys.ns("Integration.GCM");
Integration.GCM.ErrorManagerModel = {
    setupDialogConfig: function() {
        var a = {},
            b;
        Sys.each([11, 13], function(c) {
            b = Services.languageManager.getText(String(c));
            a[c] = {
                category: "RECOVERABLE_ERROR",
                severity: "INFO",
                errorCode: "LIMIT_EXCEEDED",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.playLimit),
                    originalMessage: b
                },
                revert: true
            }
        });
        b = Services.languageManager.getText(Language.Keys.freeRounds_expired);
        a[12] = {
            category: "RECOVERABLE_ERROR",
            severity: "INFO",
            errorCode: "FREEROUNDS_EXPIRED",
            message: b,
            extraParameters: {
                originalError: 12,
                originalTitle: Services.languageManager.getText(Language.Keys.freeRounds_expired)
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.returnToLobby);
        a[20] = {
            category: "CONNECTION_ERROR",
            severity: "ERROR",
            errorCode: "SESSION_TIMEOUT",
            message: b,
            extraParameters: {
                originalError: 20,
                originalTitle: Services.languageManager.getText(Language.Keys.btn_sessionTimeOut),
                originalMessage: b,
                reason: 3
            },
            revert: false
        };
        Sys.each([10, 15, 51, 100, 101, 102], function(c) {
            b = Services.languageManager.getText(Language.Keys.deposit);
            a[c] = {
                category: "INSUFFICIENT_FUNDS",
                severity: "INFO",
                errorCode: "CLIENT_INSUFFICIENT_FUNDS",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
                    originalMessage: b,
                    reason: 5
                },
                revert: true
            }
        });
        Sys.each([0, 53, 56, 58], function(c) {
            b = Services.languageManager.getText(Language.Keys.gameUnavailable);
            a[c] = {
                category: "CONNECTION_ERROR",
                severity: "ERROR",
                errorCode: "CANNOT_CONNECT_TO_SERVER",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.gameUnavailable),
                    reason: 9
                },
                revert: false
            }
        });
        b = Services.languageManager.getText(Language.Keys.accountUnavailable);
        a[70] = {
            category: "LOGIN_ERROR",
            severity: "ERROR",
            errorCode: "ACCOUNT_UNAVAILABLE",
            message: b,
            extraParameters: {
                originalError: 70,
                originalTitle: Services.languageManager.getText(Language.Keys.accountUnavailable)
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.reload);
        a.http = {
            category: "CONNECTION_ERROR",
            severity: "ERROR",
            errorCode: "CANNOT_CONNECT_TO_SERVER",
            message: b,
            extraParameters: {
                originalError: "httpError",
                originalTitle: Services.languageManager.getText(Language.Keys.connectionLost),
                originalMessage: b,
                reason: 9
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.deposit);
        a.clientOutOfMoney = {
            category: "INSUFFICIENT_FUNDS",
            severity: "INFO",
            errorCode: "CLIENT_INSUFFICIENT_FUNDS",
            message: b,
            extraParameters: {
                originalError: "clientOutOfMoney",
                originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
                reason: 9
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.returnToLobby);
        a.generic = {
            category: "NON_RECOVERABLE_ERROR",
            severity: "ERROR",
            errorCode: "CLIENTERROR",
            message: b,
            extraParameters: {
                originalError: "generic",
                originalTitle: Services.languageManager.getText(Language.Keys.error),
                originalMessage: b,
                reason: 9
            },
            revert: false
        };
        return a
    }
};
Integration.GCM.ErrorManagerDesktopModel = {
    setupDialogConfig: function() {
        return Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments)
    }
};
Integration.GCM.ErrorManagerController = {
    showDialog: function(a) {
        var b = (a.errorCode === "http") ? 0 : a.errorCode;
        this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
        this.fireEvent("request:gcmProxy.handleError", a)
    },
    handleIntegrationSpecificErrors: function(b) {
        var a = Sys.utils.getResponseParameter("openbet.error.xml", b),
            c;
        if (Sys.isDefined(a)) {
            c = {
                RGIError: true,
                RGIXML: a.replace(/\+/g, " ")
            }
        }
        return c
    },
    getDialogConfig: function(a) {
        return this.model.getDialogConfig(a)
    },
    handleClientOutOfMoneyError: function() {
        this.showDialogForErrorCode("clientOutOfMoney")
    }
};
Integration.GCM.DialogWindowController = {
    onShowDialogRequest: function(b) {
        var c = this,
            e = b.severity === "stopped",
            d = {
                category: "MULTI_CHOICE_DIALOG",
                severity: e ? "ERROR" : "INFO",
                message: Sys.isDefined(b.text) ? b.text : b.title,
                errorCode: "ERROR",
                actions: [],
                revert: false,
                extraParameters: {}
            },
            a = [];
        Sys.each(b.buttons, function(f) {
            a.push(f.text);
            d.actions.push(f.action)
        });
        d.extraParameters.options = a;
        c.fireEvent("request:gcmProxy.handleError", d);
        c.model.storeData("currentDialogConfig", b);
        c.model.setState("showing")
    }
};
Integration.GCM.SlowRequestAnimationController = {
    onShowDialog: function() {}
};
(function() {
    if (Sys.isGcmEnabled) {
        Sys.override(Core.ErrorManagerModel, Integration.GCM.ErrorManagerModel);
        Sys.override(Core.ErrorManagerController, Integration.GCM.ErrorManagerController);
        Sys.override(Core.DialogWindowController, Integration.GCM.DialogWindowController);
        Sys.override(Core.SlowRequestAnimationController, Integration.GCM.SlowRequestAnimationController);
        if (Sys.isDefined(Core.ErrorManagerDesktopModel)) {
            Sys.override(Core.ErrorManagerDesktopModel, Integration.GCM.ErrorManagerDesktopModel)
        }
    }
}());
var bCurve = {
    getCurveFromPoints: function(n, a) {
        var t = n.length,
            l = [],
            h = (a >= 0 || a <= 1) ? a : 1,
            o, e, r, q, d, g, f, k, j, b, m, p, c;
        if (t < 3) {
            return false
        }
        for (o = -1; ++o < t;) {
            e = n[o][0];
            d = n[o][1];
            if (o > 0 && o + 1 < t) {
                q = n[o - 1][0];
                f = n[o - 1][1];
                r = n[o + 1][0];
                g = n[o + 1][1];
                p = ((r - q) / 2) * h;
                c = ((g - f) / 2) * h;
                k = e - p;
                j = d - c;
                b = e + p;
                m = d + c
            } else {
                k = b = e;
                j = m = d
            }
            l.push({
                x: e,
                y: d,
                sx1: k,
                sy1: j,
                sx2: b,
                sy2: m
            })
        }
        return l
    },
    getStepsFromCurve: function(d, f) {
        var l = d.length,
            m = [],
            o, n, h, g, p, b, c, e, k = [],
            a = 0;
        for (h = -1; ++h < (l - 1);) {
            o = d[h];
            n = d[h + 1];
            b = Math.sqrt(Math.pow((o.x - n.x), 2) + Math.pow((o.y - n.y), 2));
            if (b > a) {
                a = b
            }
            k.push(b)
        }
        e = f / a;
        for (h = -1; ++h < (l - 1);) {
            o = d[h];
            n = d[h + 1];
            c = Math.ceil(k[h] * e);
            for (g = -1; ++g < c;) {
                p = g / c;
                m.push({
                    x: bCurve.cInterpolate(o.x, n.x, o.sx2, n.sx1, p),
                    y: bCurve.cInterpolate(o.y, n.y, o.sy2, n.sy1, p)
                })
            }
        }
        return m
    },
    cInterpolate: function(e, d, b, a, c) {
        return Math.pow(1 - c, 3) * e + 3 * c * Math.pow(1 - c, 2) * b + 3 * Math.pow(c, 2) * (1 - c) * a + Math.pow(c, 3) * d
    }
};
Sys.ns("Game");
if (Sys.isDefined(window.injectWeinre)) {
    injectWeinre()
}(function() {
    var b = new Core.StateHandler();
    Game.moduleLoader = new Core.Slots.ModuleLoader({
        stateHandler: b
    });
    var a = new Core.Heart();
    b.initStateHandler();
    if (Sys.isDefined(Integration) && Sys.isDefined(Integration.GCM)) {
        Integration.GCM.availableOptions = ["MUTE", "GAME_PREFERENCES", "PAYTABLE", "ABOUT", "TURBO"]
    }
}());